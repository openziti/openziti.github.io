{
  "api/clang.html": {
    "href": "api/clang.html",
    "title": "| Ziti",
    "keywords": "This is the c# sdk"
  },
  "api/clang/index.html": {
    "href": "api/clang/index.html",
    "title": "C SDK | Ziti",
    "keywords": "C SDK This is the c sdk landing page - you should be redirected to the API doc immediately. If not click here"
  },
  "api/csharp.html": {
    "href": "api/csharp.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "api/csharp/NetFoundry.html": {
    "href": "api/csharp/NetFoundry.html",
    "title": "Namespace NetFoundry | Ziti",
    "keywords": "Namespace NetFoundry Classes Ziti A collection of static helper methods and properties for Ziti. ZitiConnection Represents a connection through the Ziti network. Supports both use-cases as well as callback-based. ZitiException Represents a Ziti-specific exception ZitiIdentity Represents an enrolled identity ZitiStream A representation of a standard which utilizes the NetFoundry network Enums ZitiStatus An enum representing the outcome of the given Ziti operation. Delegates ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a (callback based Ziti)"
  },
  "api/csharp/NetFoundry.Ziti.html": {
    "href": "api/csharp/NetFoundry.Ziti.html",
    "title": "Class Ziti | Ziti",
    "keywords": "Class Ziti A collection of static helper methods and properties for Ziti. Inheritance System.Object Ziti Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class Ziti : object Properties | Improve this Doc View Source OutputDebugInformation A property which controls whether or not output is sent to the output stream. This is a global flag - when toggled all debug messages will show across any connection. Declaration public static bool OutputDebugInformation { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source Debug(String) A helper method to output messages helpful during debugging Ziti-related issues. Declaration public static void Debug(string msg) Parameters Type Name Description System.String msg"
  },
  "api/csharp/NetFoundry.ZitiConnection.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.html",
    "title": "Class ZitiConnection | Ziti",
    "keywords": "Class ZitiConnection Represents a connection through the Ziti network. Supports both use-cases as well as callback-based. Inheritance System.Object ZitiConnection Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiConnection : IDisposable Methods | Improve this Doc View Source Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) Establishes the necessary connecctivity and callbacks to send data through the NetFoundry network Declaration public void Dial(ZitiConnection.OnConnected onConnected, ZitiConnection.OnDataReceived onDataReceived) Parameters Type Name Description ZitiConnection.OnConnected onConnected Once the connection is established this callback is called ZitiConnection.OnDataReceived onDataReceived Called each time data is received over the NetFoundry network | Improve this Doc View Source Dispose() Closes the ZitiConnection and cleans up as needed Declaration public void Dispose() | Improve this Doc View Source Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) Writes the provided data over the NetFoundry network Declaration public void Write(byte[] data, int count, ZitiConnection.OnDataWritten onDataWritten, object context) Parameters Type Name Description System.Byte [] data A buffer holding the information to be sent over the NetFoundry network System.Int32 count How many bytes of the buffer (starting at position 0) to write ZitiConnection.OnDataWritten onDataWritten A callback to be invoked after the data is written to the NetFoundry network System.Object context Any object, provided back to the caller of this functionin the onDataWritten callback"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnConnected.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnConnected.html",
    "title": "Delegate ZitiConnection.OnConnected | Ziti",
    "keywords": "Delegate ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnConnected(ZitiConnection zitiConnection, ZitiStatus status); Parameters Type Name Description ZitiConnection zitiConnection The ZitiConnection which as passed to the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) method ZitiStatus status The ZitiStatus representing the outcome of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived)"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html",
    "title": "Delegate ZitiConnection.OnDataReceived | Ziti",
    "keywords": "Delegate ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataReceived(ZitiStatus status, byte[] data, int count); Parameters Type Name Description ZitiStatus status The ZitiStatus representing the outcome of the write operation. System.Byte [] data A buffer representing the data that was received over the Ziti network. Data will always start at postiion 0. System.Int32 count The number of bytes received in this interation. Data will always start at postiion 0."
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html",
    "title": "Delegate ZitiConnection.OnDataWritten | Ziti",
    "keywords": "Delegate ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a (callback based Ziti) Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataWritten(ZitiStatus status, int bytesWritten, object context); Parameters Type Name Description ZitiStatus status A ZitiStatus that represents the state of the connection which initiated this callback. If NOT OK appropriate actions should be taken System.Int32 bytesWritten A count of how many bytes were able to be written. System.Object context The context that was supplied during the Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) invocation"
  },
  "api/csharp/NetFoundry.ZitiException.html": {
    "href": "api/csharp/NetFoundry.ZitiException.html",
    "title": "Class ZitiException | Ziti",
    "keywords": "Class ZitiException Represents a Ziti-specific exception Inheritance System.Object ZitiException Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiException : Exception Constructors | Improve this Doc View Source ZitiException(String) The basic constructor for creating a ZitiException Declaration public ZitiException(string message) Parameters Type Name Description System.String message The message"
  },
  "api/csharp/NetFoundry.ZitiIdentity.html": {
    "href": "api/csharp/NetFoundry.ZitiIdentity.html",
    "title": "Class ZitiIdentity | Ziti",
    "keywords": "Class ZitiIdentity Represents an enrolled identity Inheritance System.Object ZitiIdentity Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiIdentity : object Constructors | Improve this Doc View Source ZitiIdentity(String) Creates a new ZitiIdentity using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path) Parameters Type Name Description System.String path The path to the enrolled Ziti identity | Improve this Doc View Source ZitiIdentity(String, Int32) Creates a new ZitiIdentity with the provided timeout (ms) using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path, int timeOutInMillis) Parameters Type Name Description System.String path The path to the enrolled ziti identity System.Int32 timeOutInMillis timeout in milliseconds Properties | Improve this Doc View Source PathToConfigFile The path to the enrolled identity Declaration public string PathToConfigFile { get; } Property Value Type Description System.String Methods | Improve this Doc View Source Dump() Dumps debug information to standard out. Only used when debugging Declaration public void Dump() | Improve this Doc View Source InitializeAndRun() Initializes this identity with the NetFoundry network Declaration public void InitializeAndRun() | Improve this Doc View Source NewConnection(String) Creates a new ZitiConnection for this identity Declaration public ZitiConnection NewConnection(string serviceName) Parameters Type Name Description System.String serviceName The service name to create a ZitiConnection for Returns Type Description ZitiConnection A ZitiConnection that is ready to be Dialed or converted to a stream via AsStream() Exceptions Type Condition ZitiException Thrown when the serviceName provided does not exist | Improve this Doc View Source ServiceAvailable(String) Determines if the provided serviceName is available for this identity Declaration public bool ServiceAvailable(string serviceName) Parameters Type Name Description System.String serviceName The service name to verify Returns Type Description System.Boolean If the service exists - true, false if not | Improve this Doc View Source Shutdown() instructs this identity to disconnect from the NetFoundry network Declaration public void Shutdown()"
  },
  "api/csharp/NetFoundry.ZitiStatus.html": {
    "href": "api/csharp/NetFoundry.ZitiStatus.html",
    "title": "Enum ZitiStatus | Ziti",
    "keywords": "Enum ZitiStatus An enum representing the outcome of the given Ziti operation. Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public enum ZitiStatus : int Fields Name Description CONFIG_NOT_FOUND A user error indicating the provided configuration file was not found. CONNABORT An exceptional situation indicating the connection between the client and the Ziti Network Gateway was interrupted CONTROLLER_UNAVAILABLE A network error indicating the Ziti Network Controller was not able to be contacted. EOF A normal status indicating the connection is closed. GATEWAY_UNAVAILABLE A network error indicating the Ziti Network Gateway was not able to be contacted. NOT_AUTHORIZED A user error indicating the identity from the provided configuration file is not authorized to perform the action. OK Indicates a successful outcome SERVICE_UNAVALABLE A user error indicating the service name provided was not available. Either it does not exist or the provided identity does not have sufficient rights to the service. TIMEOUT An exceptional status indicating the operation did not complete within the specified timeout"
  },
  "api/csharp/NetFoundry.ZitiStream.html": {
    "href": "api/csharp/NetFoundry.ZitiStream.html",
    "title": "Class ZitiStream | Ziti",
    "keywords": "Class ZitiStream A representation of a standard which utilizes the NetFoundry network Inheritance System.Object ZitiStream Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiStream : Stream Constructors | Improve this Doc View Source ZitiStream(ZitiConnection) Creates a ZitiStream from the provided ZitiConnection Declaration public ZitiStream(ZitiConnection conn) Parameters Type Name Description ZitiConnection conn The ZitiConnection to create a ZitiStream from Properties | Improve this Doc View Source CanRead Indicates if the stream can be read from Declaration public override bool CanRead { get; } Property Value Type Description System.Boolean | Improve this Doc View Source CanSeek Seeking is not supported Declaration public override bool CanSeek { get; } Property Value Type Description System.Boolean | Improve this Doc View Source CanWrite indicates if the stream is ready for writing Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean | Improve this Doc View Source Length unsupported - always returns 0 Declaration public override long Length { get; } Property Value Type Description System.Int64 | Improve this Doc View Source Position unsupported - always returns 0 Declaration public override long Position { get; set; } Property Value Type Description System.Int64 Methods | Improve this Doc View Source Dispose(Boolean) Disposes of the ZitiStream , cleaning up any retained resources Declaration protected override void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing | Improve this Doc View Source Flush() Flushes bytes Declaration public override void Flush() | Improve this Doc View Source PumpAsync(Stream) Asynchronously pumps this ZitiStream to/from the destination Declaration public Task PumpAsync(Stream destination) Parameters Type Name Description Stream destination Returns Type Description Task | Improve this Doc View Source PumpAsync(Stream, Stream) Asynchronously pumps data between the input and destination Declaration public static Task PumpAsync(Stream input, Stream destination) Parameters Type Name Description Stream input The input stream Stream destination The destination stream Returns Type Description Task A which is awaitable | Improve this Doc View Source Read(Byte[], Int32, Int32) Reads data into the provided buffer Declaration public override int Read(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer to read data into System.Int32 offset The position in the bufer to begin appending data System.Int32 count The number of bytes to append Returns Type Description System.Int32 Returns the number of bytes read | Improve this Doc View Source Seek(Int64, SeekOrigin) unsupported Declaration public override long Seek(long offset, SeekOrigin origin) Parameters Type Name Description System.Int64 offset SeekOrigin origin Returns Type Description System.Int64 | Improve this Doc View Source SetLength(Int64) unsupported Declaration public override void SetLength(long value) Parameters Type Name Description System.Int64 value | Improve this Doc View Source Write(Byte[], Int32, Int32) Writes the provided buffer over the ZitiNetwork Declaration public override void Write(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer containing data to write System.Int32 offset The position in the buffer to read from System.Int32 count The number of bytes to write from the buffer"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "| Ziti",
    "keywords": "Here you will find the information necessary to successfully use a Ziti SDK to create an application. If there is a term which is not familiar please refer to the glossary . Each SDK has certain syntax unique to the particular language the SDK is targetting. Each SDK presents an api which is as idomatic as possible to present a consistent look and feel for the language or runtime being used."
  },
  "api/rest/create-ca-json.html": {
    "href": "api/rest/create-ca-json.html",
    "title": "| Ziti",
    "keywords": "Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" }"
  },
  "api/rest/create-service-rest.html": {
    "href": "api/rest/create-service-rest.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "api/rest/index.html": {
    "href": "api/rest/index.html",
    "title": "Ziti controlller REST API | Ziti",
    "keywords": "Ziti controlller REST API The API version and Swagger definition for a particular controller may be fetched and there are relatively good documents available as well, also served directly from the controller. There are two main endpoints Client API The client api services are used by endpoints to interact with the Ziti Network . These services are necessary to authenticate, enroll, return services and fetch other information related to the endpoint's participating in the network. Download the Client API Spec The client api spec can be downloaded from your controller at the following url (replace \"${CONTROLLER_URL}\" accordingly) https://${CONTROLLER_URL}/edge/client/v1/docs . Management API The management api is used to configure, manage, and maintain the Ziti Network . Download the Management API Spec The client api spec can be downloaded from your controller at the following url (replace \"${CONTROLLER_URL}\" accordingly) https://${CONTROLLER_URL}/edge/management/v1/docs . Example Find the controller version Here's one of many examples you'll find linked in the docs GET / { \"data\": { \"apiVersions\": { \"edge\": { \"v1\": { \"path\": \"/edge/v1\" } } }, \"buildDate\": \"2021-04-23 18:09:47\", \"revision\": \"fe826ed2ec0c\", \"runtimeVersion\": \"go1.16.3\", \"version\": \"v0.19.12\" }, \"meta\": {} }"
  },
  "api/swift/index.html": {
    "href": "api/swift/index.html",
    "title": "Swift (with Objective-C interoperability) | Ziti",
    "keywords": "Swift (with Objective-C interoperability) empty index to be replaced by the unzipped docs fetched from s3 during build"
  },
  "articles/bootstrapping-trust/part-01.encryption-everywhere.html": {
    "href": "articles/bootstrapping-trust/part-01.encryption-everywhere.html",
    "title": "Bootstrapping Trust | Ziti",
    "keywords": "Bootstrapping Trust Part 1: Encryption Everywhere Whether you are an encryption expert or a newcomer, welcome! This series is for you! It assumes you know nothing and takes you from soup to nuts on how to bootstrap trust with the intent to power a Zero Trust security model. The process and thinking described in this series are the direct output of developing the same system for the Ziti open source project. Ziti can be found on the GitHub project page for OpenZiti . The series starts with the basics and dovetails into Ziti's Enrollment system. The parts are as follows. Part 1: Encryption Everywhere Part 2: A Primer On Public-Key Cryptography Part 3: Certificates Part 4: Certificate Authorities & Chains Of Trust Part 5: Bootstrapping Trust Zero Trust This entire series assumes some familiarity with Zero Trust. If you do not have a strong background in it, that is fine. This section should give the reader enough context to make use of the entire series. If a more in-depth understanding is desired, please consider reading Zero Trust Networks: Building Secure Systems in Untrusted Networks by Evan Gilman. Zero Trust is a security model that requires strict identity authentication and access verification on every connection at all times. It sets the tone for a system's security to say, \"this system shall never assume the identity or access of any connection.\" Before the Zero Trust security models, IT infrastructures were set up as a series of security perimeters. Think of as a castle with walls and moats. The castle would have a set number of entry points with guards. Once past the guards and inside the castle, any visitors were trusted and had access to the castle. In the real world, passing the guards is analogous to authenticating with a machine or, at worst, connect the office network via WiFi or ethernet cable. Zero Trust does away with the concept of having a central castle that assumes anyone inside is trusted. It assumes that the castle has already been breached. That is to say, we expect attackers to already be inside the network and for it to be a hostile environment. Any resources inside the network should be treated as being publicly available on the internet and must be defended. To accomplish this defense, a series of Zero Trust pillars are defined: Never Trust, Verify - the virtue of a connection should not grant access Authenticate Before Connect - authentication should happen before resources are connected to Least Privileged Access - access should only grant connectivity to the minimum number of resources Implementing those pillars is not a simple tweak to existing infrastructure. The first point alone will have much of this series dedicated to it. Ziti & Zero Trust In a Zero Trust model, there needs to exist mechanisms to verify identities such that trust can be granted. Zero Trust does not mean there is no trust. Zero Trust means that trust is given only after verification. Even then, that trust is limited to accessing the minimum network resources necessary. To accomplish this, we need a network that can force all connections through the following process. Authenticate Request Access To A Resource Connect To The Requested Resource This process is not the typical connection order on a network. Most connections on a network are done in the reverse order. At first, this may seem counter-intuitive. To help make Zero Trust and bootstrapping trust a bit clearer, it helps to have a concrete system to use an example. It just so happens that the Ziti software system makes a great example! In Ziti, all of the above steps require interacting with a Ziti Controller. The Ziti Controller manages the Ziti overlay network by maintaining a list of known network services, SDK clients, routers, enrollments, policies, and much more! All of these pieces working together to create a Ziti Network. A Ziti Network is an overlay network - meaning it creates a virtual network on top of a concrete network. The concrete network may be the internet, a university network, or your own home network. Whatever it is, it is referred to as the underlay network. In the Ziti Network, all network resources are modeled as services in the Ziti Controller. All services on a Ziti Network should only be accessible via the Ziti Network for maximum effect. Network services can be made available via a Ziti Network in a variety of manners. The preferred method is embedding the Ziti SDK inside of applications and servers as it provides the highest degree of Zero Trust security. However, it is also possible to configure various overlay-to-underlay connections to existing network services via \"router termination\" or a particular type of application with the Ziti SDK embedded in it that specifically deals with underlay-to-overlay translations (i.e. Ziti Desktop Edge/Mobile Edge). The Ziti Controller also knows about one or more Ziti Routers that form a mesh network that can create dynamic circuits amongst themselves. Routers use circuits to move data across the Ziti Network. Routers can be configured to allow data to enter and exit the mesh. The most common entry/exit points are Ziti SDKs acting as clients or servers. Network clients wishing to attach to the network use the Ziti SDK to first authenticate with the Ziti Controller. During authentication, the Ziti SDK client and Ziti Controller will verify each other. Upon successful authentication, the Ziti Controller can provide a list of available services to dial (connect) or to bind (host) for the authenticated SDK Client. The client can then request to dial or bind a service. If fulfilled, a session is associated with the client and service. This new session is propagated to the necessary Ziti Routers, and the required circuits are created. The client is returned a list of Ziti Routers which can be connected to in order to complete the last mile of communication between the Ziti overlay network and the SDK client. This set of steps covers the pillars of the Zero Trust model! The Ziti Controller and SDK Clients verify each other. The client cannot connect to network resources or services until it authenticates. After authentication, a client is given the least privilege access allowed by only being told about and only being able to dial/bind the authenticated identity's assigned services. It is a Zero Trust overlay network! How did this system come into existence? How do the Ziti SDK client and Ziti Controller verify each other? How do the routers and controller know to validate each other? How is this managed at scale with hundreds of Ziti Routers and thousands of Ziti SDK clients? It seems that this is a recursive problem. To terminate the recursion, we have to start our system with a well-defined and carefully controlled seed of trust. Trust In software systems that require network connectivity, there are at least two parties in the system. Generally, there are more, and in the case of a Ziti network, there could be thousands. Between two parties, each time a connection is made, a trust decision is made. Should this connection be allowed? Mechanisms must be put into place to verify the identity of the connecting party if that question is to be answered. One mechanism that might jump out at the reader is a password or secret. In Ziti, it would be possible to configure the Controller, Routers, and SDK Clients with a secret. Software is easy to deploy with a secret. Throw it into a configuration file, point the software at, and off you go! It is also fundamentally weak as there is only one secret in the system necessary to compromise the entire system. In Ziti, this would mean giving the secret to network clients that may or may not be owned by the network operator. Also, shared secrets do not individually identify each component, nor do they define how secrets will power other security concerns, like encryption. The solution can be improved. Secrets could be generated per software component. The controller, each router, and each SDK client could have a unique secret. This secret would then individually identity each component! It is a significant improvement, but how does each component verify connections? Do they challenge for the incoming connections secret and compare it to a list? That means that a pair of systems that need to connect must have each other's secrets. Secret sharing will not do! We can not be copying secrets between every machine. One machine that is compromised would mean that many secrets are revealed! This solution can be evolved and improved, but we do not have to do that hard work! If we did, we would end up recreating an existing technology. That technology is (public-key cryptography)[ https://en.wikipedia.org/wiki/Public-key_cryptography ], and it provides everything we need. Public-key cryptography allows each device to have a unique, secret, private key that proves its unique identity. That private key is mathematically tied to a public key. The public key can be used to encrypt messages that only the private key holder can decrypt. Also, the public key cannot be used to derive the original private key. This functionality fits perfectly with what our distributed system needs! Alas, public-key cryptography introduces complex behaviors, setup, and management. In the next article, we will dive a little deeper into this topic. For now, let us take it on faith that it will serve our needs well. Setting It Up So we have decided that public-key cryptography is the answer. What does that mean? What do I have to do? Let us explore what would need to be done by a human or a piece of software automating this process. Don't worry if you don't get all of this; the gist is all you need for now. Later articles will expand upon this terminology. In fact, after reading the later articles, consider revisiting this part. Consider the following diagram of a \"mesh\" distributed system. This mesh could be any type of system such as a mesh of Ziti Routers, or maybe it is a system of sensors on an airplane. What they do does not matter. What matters is that this system has multiple pieces of software connecting amongst themselves. Consider what it means to accomplish this using public-key cryptography. In the diagram above, each system needs: a key pair for client and server connections to have the public keys of each system it is connecting to So what do we need to do? Drop into a CLI and start generating keys on each machine. Do that by using these commands: openssl ecparam -name secp256k1-genkey -param_enc explicit -out private-key.pem openssl req -new -x509 -key private-key.pem -out server.pem -days 360 Voila - you now have a self-signed certificate! What is a self-signed certificate? For now, let us understand it means that no other system has expressed trust in your public certificate. In Part 4: Certificate Authorities & Chains Of Trust we will cover them in more detail. You can repeat the above process for every piece of software in your mesh network. Preferably, you log into each machine and generate the private key there. Moving private keys on and off devices is a security risk and frowned upon. For maximum security, hardware, such as Hardware Security Modules (HSMs) and Trusted Platform Modules (TPMs) , can be used to store the private keys in a manner that does not make them directly accessible. Then you will need to copy each public certificate to every other machine and configure your software so that it trusts that certificate. The system will need to repeat this process any time the system adds a piece of software. If a machine is compromised, the analogous public certificate will need to be untrusted on every node in the mesh. Adding or removing trust in a public certificate involves configuring software or operating systems. There are many ways it can be implemented, including configuration files, files stored in specific directories, and even via configuration tools such as Windows Certificate Manager snap-in. This is a log of careful work to get a simple system running. Consider what this means when adding or removing many nodes? Visiting each machine and reconfiguring them each time is quite a bit of overhead. There is a solution to these woes. While it is elegant on its own, it does add complexity. Let us see how Certificate Authorities (CAs) can help! In the next section, we will hit the highlights of CAs. For more detail, look forward to Part 4: Certificate Authorities & Chains Of Trust . CAs & Adding Complexity A CA enables trust deferral from multiple individual certificates to a single certificate which means that instead of trusting each certificate, each piece of software will trust the CA. The CA will be used to sign every public certificate our software pieces need to use. How does \"signing\" work? We will cover that in part three and why it matters part in four . For now, the basics will be provided. Here are the high-level steps of using a CA: create a CA configuration via OpenSSL CNF files create the CA use the CA's public key to sign all of the public certificates distribute the CA's certificate to every machine configure the machines certificate store or configure the software For items one and two, the process can be a bit mystical. There is a multitude of options involved in managing a CA. To perform number three, you will need to go through the processing of creating certificate signing requests (CSRs, see parts three for more detail) on behalf of the piece of software, and someone or something will have to play the role of the CA and resolve the CSRs. The last two steps will depend on the operating system and software being used. All of these actions can be done via a CLI or programmatically. You will have to spend time and energy, making sure the options are correctly set and learning about all the different capabilities and extensions. Mistakes will inevitably occur. It is time-consuming to debug why a specific public certificate is not working as intended. The tools and systems that use the certificates are purposely vague in error messages as not to reveal too much information to attackers. The payoff for using CAs is having the ability to create chains of trust. Chains of trust allow distributed systems to scale without having to reconfigure each node every time the system grows or shrinks. With a little more upfront cost and bookkeeping to run a CA, the system will greatly decrease the amount of configuration required on each device. Further Concerns Once configured, there are still other concerns that need to be taken into account. Consider the following list of events that may happen to a CA, and it's certificates: What happens when a certificate expires? How does a system know not to trust a certificate anymore? What happens when private keys need to regenerate? CAs do not automatically handle the propagation of these types of events. CAs are files on a storage device or HSM. Issuing or revoking certificates does not generate any kind of event without additional software. There is also the issue of certificates expiring. That \"-days 360\", used in the example above, puts a lifetime on each certificate. The lifetime can be extended far into the future, but this is a bad practice. Limiting the life span of a certificate reduces attack windows and can be used as a trigger to adopt strong encryption. Even if we ignore all of those concerns, who did we trust to get this system setup? What was the seed of trust used to bootstrap trust? So far, you could have imagined that a human was doing all of this work. In that case, a human operator is trusted to properly configure all of the systems - trusting them with access to all of the private keys. The seed of trust is in that human. If this is a software system performing these actions, that means that the system has to be trusted and most likely have access to every other system coming online. That is workable, but what happens when your system can have external systems request to be added to the network? How can that be handled? How do you trust that system in the first place? Using a secret password creates a single, exploitable, weak point. Public-key cryptography could be put in place, but then we are in a chicken-and-egg scenario. We are putting public-key cryptography in place to automate public-key cryptography. There are many caveats to bootstrapping trust. In a dynamic distributed system where pieces of software can come and go at the whim of network operators, the issues become a mountain of concerns. Thankfully in Ziti, a mechanism is provided that abstracts all of these issues. To understand how Ziti accomplishes this, we have a few more topics to discuss. In part two , we will chip away at those topics by covering public-key cryptography in more detail to understand its powers and applications. Written By: Andrew Martinez June 2020"
  },
  "articles/bootstrapping-trust/part-02.a-primer-on-public-key-cryptography.html": {
    "href": "articles/bootstrapping-trust/part-02.a-primer-on-public-key-cryptography.html",
    "title": "Bootstrapping Trust | Ziti",
    "keywords": "Bootstrapping Trust Part 2: A Primer On Public-Key Cryptography If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series: Part 1: Encryption Everywhere Part 2: A Primer On Public-Key Cryptography Part 3: Certificates Part 4: Certificate Authorities & Chains Of Trust Part 5: Bootstrapping Trust It isn't easy to talk about bootstrapping trust without covering the basics of public-key cryptography. The reader may skip this article if the concepts of encryption, signing, and public/private keys are familiar. However, if not, I implore that you bear the brunt of this article as later parts will heavily rely on it. If you wish, you can dive into the mathematics behind it to prove it to yourself, but I promise, no math here. When necessary, I will wave my hands at it, point into the distance, and let the reader journey out. Keys Keys are blobs of data containing rather large numbers. They can be stored anywhere data can be stored, but are commonly stored as files. A set of public and private keys is referred to as a \"key set\" or \"key pair.\" Within a key pair, there is only one private key and one public key. The two keys are mathematically entangled, given a particular function and its parameters. Today, those functions and parameters are generally elliptical curves and are the basis of a \"trapdoor function.\" Trapdoor functions are attractive to the cryptographically inclined for two main reasons: they make it easy to encrypt with one key of a key pair and decrypt with the other. one key cannot be derived from the other Of the two keys, the private key is the most important. It must be kept tucked away from prying eyes and attackers. Some secure environments store the private key in hardware such as Hardware Security Modules (HSMs) or Trusted Platform Modules (TPMs) . Mobile devices, such as laptops and smartphones, use hardware technology similar to TPMs. Apple has its Secure Enclave, and Android has its Keymaster Hardware Abstraction Layer. The goal of all of these pieces of hardware is to keep sensitive secrets (e.g., private keys) safe. The fact that an entire industry of embedded hardware has been developed to keep private keys safe should tip the reader off to how important they are. As stated above, these two keys have some impressive capabilities. It is not possible to derive one from the other. This allows the public key to be handed out freely without compromising the private key. Also, both keys can generate encrypted data that only the other key can decrypt. More clearly: Anyone with the public key can encrypt data only the private key holder can decrypt Anyone with the public key can decrypt data from the private key holder Number one can succinctly be called \"Public Key Encryption\" and number two \"Private Key Encryption.\" This article explores the merits of both. Public Key Encryption From the list above, number one is what most people think of as \"encryption.\" It is \"secure\" as it allows anyone with the widely available public key to send messages only the private key holder can read. This property ensures that communication from the public key holder to the private key holder is being read exclusively by the intended target. There is quite a bit of pressure to keep the private key extremely safe. Whoever holds the private key, has a guaranteed identity that is tied to and verifiable by the public key. It is verifiable because if one can use the public key to encrypt data, only the private key holder can decrypt it. This fact means that data can be encrypted and sent that coordinates on an additional secret. Since only the private key holder can decrypt the data to see this second level secret, future communication can use the new secret to encrypted and verify traffic in both directions. This additional exchange is roughly how part of the TLS negotiation works for HTTPs. TLS, and by proxy HTTPS, use other technologies and strategies to provide an incredible security proposition. Private Key Encryption For private key encryption, the same principles apply as with public key encryption with the roles reversed. The private key encrypts data only the public key can decrypt. On the surface, this seems absurd. When the server encrypts data with its private key, the public key can decrypt it. The public key is not protected and expected to be widely available. It seems as if private key encryption is nearly useless as everyone can read it! Except it isn't. Private key encryption verifies the identity of the private key holder. The public key cannot interact with anyone else. Additionally, this property allows us to generate encrypted data that could only have come from the private key holder. If that data happens to be small and describe another document, we call that a \"digital signature\" or \"signature\" for short. Digital Signatures Digital signatures are similar to handwritten ones used to sign legal documents and checkbooks, but with a significant advantage. They validate that a document has not been altered since it was signed. With today's computer's graphical abilities, the nefarious can forge images and handwritten signatures. That puts handwritten signatures at a significant disadvantage. So how does this work? The data that will be signed can be anything. What it represents is not important. It can be text, JSON, an image, a PDF, or anything at all! That data is processed by a one-way cryptographic hashing algorithm , such as SHA-256. This process is idempotent, meaning running it repeatedly on the same data, parameters, and hashing algorithm gives the same result. The output of this process is a hash, a string of characters that uniquely identifies the input data. With sufficiently large input data, the hash is much shorter than the input data as the hash size is usually fixed length. For example, here is the Ziti logo: This logo's file can be hashed using SHA-256 via the sha256sum command commonly found on Linux. $> sha256sum ziti.png c3a6681cc81f9c0fa44b3e2921495882c55f0a86c54cd60ee0fdc7d200ad26db ziti.png That long string \"c3a....6db\" is the hash of that file! The string is 64 characters long and is comprised of hex characters (a base 16 numbering system of 0-9 and a-f). Each character takes four bits to represent (4^2 = 16). Since there are 64 characters at 4 bits each we have: 64 x 4 = 256. This is where SHA-256 gets its name. SHA-256 is a fixed-length cryptographic hashing algorithm who's output is 256 bits in length. The hash itself is not encryption. It is \"hashing.\" Hashing of this nature is not reversible while encryption is. For cryptographic hashing, it is impracticable to have two similar sets of data that have the same function that produces the same hash. In essence, the hash uniquely represents the data: all of it! Changing even a single character would generate a different hash. After hashing a data or document, the private key holder can encrypt the hash to generate a signature. This process provides the following truths when working with the signature: the private key is the only key capable of producing its signature of the data's hash the public key can validate the signature given the data and hashing algorithm used Verifying a signature a straightforward process: Use the public key to decrypt the signature to reveal the original hash Use the hashing algorithm that was used initially on the data, recreate the hash independently Compare the two hashes, and if they are the same the signature is valid Signing data is incredibly powerful. It allows a private key holder to state that data was approved by them and not altered. It is also publicly verifiable to anyone with the document, signature, and public key. This allows many decentralized approaches to sharing data that can have its source and content verified. Bearer tokens are an example of the power of signatures. Bearer tokens are a document that is signed by a trusted authentication system and contain data that provides information about the client presenting the token. Signing the token ensures that the content of the token has not been changed and has been endorsed by a trusted system. An example of a bearer token is a JSON Web Token (JWT) A JWT specifies the format of the bearer token as a header, payload, and signature using JSON. A client can then present a JWT to any system which can then verify that the contents are valid and from a trusted identity. As long as the signature is valid, the JWT can grant access to the client presenting it based on whatever information is inside the JWT. Closing This article should have shed light on public-key cryptography by explaining the roles of the public and private keys. It should have also provided a glimpse at the power of encryption and digital signatures. In part three we will see how key pairs can be combined with certificates! Written By: Andrew Martinez June 2020"
  },
  "articles/bootstrapping-trust/part-03.certificates.html": {
    "href": "articles/bootstrapping-trust/part-03.certificates.html",
    "title": "Bootstrapping Trust | Ziti",
    "keywords": "Bootstrapping Trust Part 3: Certificates If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series: Part 1: Encryption Everywhere Part 2: A Primer On Public-Key Cryptography Part 3: Certificates Part 4: Certificate Authorities & Chains Of Trust Part 5: Bootstrapping Trust In the series, we have covered public-key cryptography, where we learned about public keys, private keys, and their uses for encryption and signing. Using keys to sign data will play an essential role in this article. It is vital that the reader understand that signatures verify both the content of the data and its source. For a refresher, see part two of this series. This article covers how certificates and certificate authorities (CAs) work as \"trust anchors.\" When a CA is a trust anchor, it means that a system can trust the CA to sign certificates that it can, in turn, trust. Throughout this entire article, \"trusting certificates\" is mentioned. Trusting a certificate (CA or otherwise) is a software or operating system configuration process. This configuration tells the system that the specified certificates are trustworthy in the eyes of the operator. Certificates Part two of this series covered keys, both public and private, but did not mention certificates. It is common to hear \"certificate\" used interchangeably with \"public key\" and, sometimes, \"private key.\" A certificate must have the public key inside of it. Some storage formats allow certificates to be stored along with the matching private key. One example of this is PFX files. PFX files, which are PKCS#12 archives, are also sometimes generically referred to as a \"certificates\". In this article \"certificate\" will always mean an x509 certificate that contains only the public key. Certificates are a simple concept, but years of expansions and extensions have added to them and can be daunting uninitiated when you get into the nitty-gritty details. This article will strive to sit above that detail. If you venture into the realm of generating certificates, using OpenSSL and its configuration files, it can be a cumbersome experience to wade through. There are many great articles and tutorials available to get you started. For this article, the word \"certificate\" will mean an \"x509 Certificate\". x509 is a public standard and is the de-facto standard for software systems dealing with public-key cryptography. There are other formats, but they are usually environment-specific, such as Card Verifiable Certificates. x509 good enough for general purpose use on most systems. So, what is a certificate? It is yet another blob of data that is specially formatted. It can be stored anywhere data can be stored but is usually a file. For this conversation, we will focus on the following subset of information that a certificate contains: Subject information A public key Distinguished Name Issuer Information Validity Period Usage/Extensions Signatures Subject Information Certificates contain more than keys. The Distinguished Name (DN) are text fields. They are useful mainly to humans to know what/who owns a certificate. It is sometimes used by software as display information or for comparison checks. Since humans provide the DN values or configure software with values, it is not always distinguishing. DN values have an alternate name: relatively distinguished names. Related to the Subject DN is the Issuer Information. The Issuer Information is the subject of the certificate that issued the certificate. Because of this, both the issuer information has similar values to the subject DN. Both can include the following information: CN - common name - a name SN - surname SERIALNUMBER - a number that is usually unique per certificate issuer, but not always C - country L - locality name ST or S - state or province STREET - street address O - organization name OU - organizational unit T - title G or GN - given name E - email address UID - user id DC - domain component Do not worry about memorizing that list. Simply knowing they exist and that they may or may not matter is good enough for now. If the reader is wondering when they might matter, well, that is generally when the system you are using complains about them. Validity Period The Validity Period specifies two points in time from when the certificate is valid. Before and after this window of time, the certificate is invalid and should not be trusted. Validity periods should be as small as possible to fit their use case. Shorter periods reduce the window of time that compromised private key can remain useful for an attack. The cost of this is overhead reissuing certificates as they reach the end of their validity period. Usage/Extensions Usage/Extension Data is interesting because it can limit what roles a certificate fulfills. Depending on the system, this may be adhered to or not. Some examples of usage that are common to see: key usage: client authentication, server authentication, signatures, etc. Subject Alternate Names (SANs) Limits what IP address, email address, domain name, etc. the certificate can be associated with Certificate Authority (CA) flag and more This series will not dive into the details of these usages. However, it is essential to be aware of them and that they can affect the roles a certificate can fulfill. Signatures The signature section of a certificate is a list of signatures from other entities that trust this certificate. A certificate that signs itself is a \"self-signed certificate.\" Self-signed certificates must be individually trusted as no other certificate has expressed trust in it by signing it. Self-signed certificates are sometimes used for testing purposes as they are easy to create. They are also used as Root Certificate Authorities (root CAs). Each signature on a certificate is the result of taking the contents of the certificate (without signatures), one-way hashing it, and then encrypting the hash with the signator's private key. The result is appended to the end of the signature list. During this process, the public certificate moves between systems to be signed. The movement of the public certificate between systems is facilitated by Certificate Signing Requests (CSRs). CSRs can be transmitted electronically as files or as a data stream to the signer. CSRs contain only the public information of a certificate and a signature from the certificate's private key. Since CSRs only contain public information, they are not considered sensitive. The signature in a CSR allows the signer to verify that the CSR is from the subject specified in the CSR. If the signature is valid, the signator processes the CSR, and the result is a newly minted certificate with an additional signature. Conclusion Certificates are keys, usually public ones, with additional metadata that adds conventions and restrictions around certificate usages. They provide a place for signatures to resides and, through CSRs, provide a vehicle to request additional signatures. Certificates are useful because they package all of these concerns into a neat single file. In part four , we will explore how to create a formidable chain of trust by linking multiple certificates together. Written By: Andrew Martinez June 2020"
  },
  "articles/bootstrapping-trust/part-04.certificate-authorities-and-chains-of-trust.html": {
    "href": "articles/bootstrapping-trust/part-04.certificate-authorities-and-chains-of-trust.html",
    "title": "Bootstrapping Trust | Ziti",
    "keywords": "Bootstrapping Trust Part 4: Certificate Authorities & Chains of Trust If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series: Part 1: Encryption Everywhere Part 2: A Primer On Public-Key Cryptography Part 3: Certificates Part 4: Certificate Authorities & Chains Of Trust Part 5: Bootstrapping Trust This article makes implicit heavy use of part 2 and part 3 of this series. Root & Intermediate Certificate Authorities (CAs) Not all certificates are the same! Certificates have different capabilities depending on their usage attributes and extensions. The previous article in this series mentioned a few of those attributes and extensions. Two of those were clientAuth , for client certificates, and serverAuth , for server certificates, which play an essential role in how a certificate is used during network authentication negotiations. These roles are crucial, as they are a contract for what attributes and extensions should be included in the certificate to make it useful. For example, a server certificate usually finds it useful to include Subject Alternate Names (SANs). A SAN can be used to tie a certificate to a specific domain name (like ziti.dev). However, a client certificate will not have use for those same fields. The roles of certificates and the attributes/extensions they have are not always strictly followed. Some systems, such as web browsers, require SANs on a server certificate. That wasn't always the case. Before that, the Common Name field in the subject information contained the domain name. Some systems still rely on that convention. Another type of certificate is a Certificate Authority (CA) certificate. A CA is a key pair with a certificate that has a unique purpose: to sign other certificates. CA certificates have a special CA flag set to \"true.\" This flag alone does not grant the CA certificate any power, but if a system trusts that CA, it then allows that system to trust any certificate that CA has signed. As mentioned in previous parts of this series, trusting a CA is a software or operating system configuration process. This process can be done in multiple ways depending on the system: adding it to a store, a specific folder, or adding lines to a configuration file. Your operating system, right now, has its own set of trusted CAs. Most operating systems come with a default list installed and maintained by your OS developer. Over time this list is added to and removed from as trust is granted or withdrawn. Some pieces of software come with a list of CAs that are used instead of or in addition to the OS's CAs. The power of a CA comes not by its creation but by it being trusted. CAs come in two flavors: Root CAs and Intermediate CAs. Root CAs are the egg or the chicken (depending on your viewpoint) of the CA trust chicken-and-egg problem. Trust for CAs has to start somewhere. With CAs, it is the Root CA. A Root CA can sign certificates that are themselves CAs as well. Those certificates represent Intermediate CAs. Layers of CAs starting with a root and adding intermediates along the way allows the private key for the Root CAs to be kept in a highly secure environment, which is not convenient to use for signing. This security means that the Root CA has a far less likely chance of having its private key compromised. Intermediate CAs are put into less secure environments and, if compromised, can be revoked. Trust is usually put into the Root CA, and since it was not compromised can remain trusted. Compromised intermediate CAs can be blacklisted. Running a public CA is serious business if you wish to be publicly trusted. The organizations running a CA have to have strict protocols that verify the security and safe handling of the CAs private keys. If the private key is compromised, it can be used to sign other certificates for malicious intents. Any system that trusted the compromised CA will now trust any maliciously signed certificates. This will compromise all certificates signed by that CA. Public CAs are maintained by organizations such as DigiCert, Let's Encrypt, and others. Anyone can create private CAs. The only difference is that the number of systems that trust a private CA is much smaller than that of a public one. CAs are a cornerstone of bootstrapping trust. Trusting the proper CAs can grant trust to a large number of systems. Chains of Trust & PKIs Part three of this series introduced that certificates self-sign or sign another certificate. Certificates are usually signed via Certificate Signing Requests (CSRs). A certificate signing itself is called a \"self-signed certificate\" and is an indicator of it being a root CA if the CA flag is also set to true. A root CA can sign other certificates that also have the CA flag set to true. Those types of certificates are intermediate CAs. Any CA, root or intermediate, that fulfills a CSR and signs the enclosed certificate will generate a non-CA certificate as long as the CA flag is false. These certificates are \"leaf certificates.\" The term Public Key Infrastructure (PKI) is used to describe all of the outputs that are generated when a CA is created. That includes the root, intermediates, and leaf certificates. It also optionally includes all of the systems, processes, procedures, and data used to manage them. For the purpose of this article, and simplicity, let us stick to the certificates only. Consider the following PKI setup: Two root CAs: Root A Root B The root CAs each sign an intermediate CA via CSR: Intermediate A Intermediate B A server wishes to have a certificate to have Root A's trust extended to it. A key pair is generated A CSR is created and submitted to Intermediate A to sign The CSR is fulfilled. Server Cert A is created and signed by Intermediate A Visually this would appear as follows: This PKI has two chains of trust: Chain A and Chain B. They are called chains because the signatures link the certificates together. Root A has signed Intermediate A's certificate and Intermediate A has signed Server A's certificate. Programmatically we can traverse these signatures and verify them using the public certificates of each signatory. Trusting Root A will trust Server A. The second chain, Chain B, does not sign any of the certificates on Chain A. As expected, Trusting either of the CAs from Chain B does not grant any trust to the certificates on Chain A. Chain B highlights the fact that any system may have multiple chains of trust that do not interact in any fashion. Returning to Chain A, trusting Intermediate A designates it as a \"trust anchor.\" Any certificate can be a trust anchor. The certificate used as a trust anchor determines which certificates will additionally be trusted. A leaf certificate as a trust anchor only trusts that one certificate. Trusting a CA trusts all certificates that it has signed itself or any of its intermediates. In the diagram above, trust only flow downward. Trusting Server Cert A will only trust that one server certificate Trusting Intermediate A will trust Server Cert A and any other certificate it signs Trust Root A will trust Intermediate A and Server Cert A and any other certificate Root A signs (intermediate CA or not) and in turn, any of the certificates they sign Trusting a CA that has signed many certificates allows public certificate trust to scale. This is how trust scales for web traffic. Companies like DigiCert, IdenTrust, GoDaddy, etc. have their root CA or one of their large intermediate CAs trusted. Those CAs sign certificates for websites. All of our devices trust those website certificates because the CA has signed them. Distributed Systems & CAs The goal for any private distributed system should be to have certificates verified on both sides: clients verify servers and vice versa. This behavior is a tenant of Zero Trust - do not trust, verify. Verification should be done on every connection before any data exchange. Over TLS, which secures HTTPS, this would be \"mutual TLS\" or \"mTLS.\" Most public websites do not require mTLS. Instead, they use TLS with the client validating the server. For public web traffic, the server wishes to be trusted widely. The reverse is not necessary. If it is, websites use an additional form of authentications, like usernames and passwords, to verify the client's identity. Public key cryptography is a stronger authentication mechanism, but it is also difficult for the general public to set up, manage, and maintain. The same is true for distributed systems. Most don't secure anything at all or only verify servers. It is inherently insecure and can cause issues depending on the setup of the system. Ziti is a distributed system that abstracts away this security setup for both its internal routers and client SDKs. This setup allows application-specific networking with strong identity verification, powerful policy management, flexible mesh routing, and more. The goal of this series is to focus on bootstrapping trust. So in the last article we will come full circle and see how all of this relates to bootstrapping trust for Zero Trust networks. Written By: Andrew Martinez June 2020"
  },
  "articles/bootstrapping-trust/part-05.bootstrapping-trust.html": {
    "href": "articles/bootstrapping-trust/part-05.bootstrapping-trust.html",
    "title": "Bootstrapping Trust | Ziti",
    "keywords": "Bootstrapping Trust Part 5 Bootstrapping Trust If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series: Part 1: Encryption Everywhere Part 2: A Primer On Public-Key Cryptography Part 3: Certificates Part 4: Certificate Authorities & Chains Of Trust Part 5: Bootstrapping Trust Ziti In this series of articles, we are exploring bootstrapping trust, what that means, and how it enables Zero Trust security methodologies. Ziti provides a method to bootstrap trust via its enrollment process. For Ziti, the enrollment process is bootstrapping trust. This trust must be in place as all connections in Ziti require verification. All identities in Ziti have a key pair that identifies that individual. The enrollment process abstracts the steps of setting up keys, certificates, CSRs, CAs, and deploying them to the proper locations. In addition, the Ziti SDKs can be embedded within any application and enroll with a Ziti network in the exact same fashion to bootstrap trust as part of Ziti's Zero Trust model. Ziti has a concept called the \"Edge.\" The Edge is a set of software features that sit on top of the \"Fabric.\" The Fabric is the core of each Ziti component, and it provides long haul mesh routing while the Edge focuses on enrolling Ziti components, managing access via policies, and maintaining the trust necessary to provide the foundation of a Zero Trust network without the hassle of setting it up yourself. Together they are a powerful combination of optimized long haul routing and trust management. A small scale example Ziti system appears as follows: Ziti Edge has the concepts of identities for endpoint SDKs and routers. Both require certificates signed by a trusted CA. Ziti can generate the PKI necessary to manage that trust. The PKI and its CAs will form the backbone of the trust system that Ziti will deploy for you. In the system diagram above, the Ziti Controller will manage an intermediate CA and a secure enrollment process that will bootstrap trust for each router and SDK. After bootstrapping trust, the controller will maintain data to manage the entire life cycle of the certificates it generates. This life cycle encompasses all the concerns from part one of this series, including bootstrapping, revoking, renewing, and rotating keys. So let us review the components a Ziti Controller must have to function: A CA (intermediate preferred) A server certificate generated for the Controller's IP/hostname/etc. Signed by the CA or a public CA A Ziti Controller configured and ready to run This article series has touched on items one and two, but not three. For information on how to configure a Ziti Controller refer to the Ziti documentation repository on Github. You will also find details on how to use the Ziti CLI to generate the PKI necessary to start a Ziti network. However, here is a simple command that will help get the controller started. ziti pki create ca test1 ziti pki create server --dns myserver.com Enrollment Once a Ziti Controller is up and running, it is possible to create a new identity and enroll it. Behind the scenes, many things happen, but for now, let us focus on what an administrator would have to perform. Authenticate via the Ziti CLI, Ziti Admin Console (ZAC), or Edge REST API Issue a request to create a new identity for an SDK or router Receive an enrollment JWT Use the JWT on the enrolling device/server to enroll In those steps, we have performed many complex interactions. The enrolling identity: validated the enrollment JWT cryptographically validated the Ziti Controller as a suitable trust anchor cryptographically bootstrapped its trust pool of CAs as additional trust anchors over a secure connection generated a key pair generated a CSR The controller has: asserted its identity cryptographically asserted the validity of the enrolling identity provided a CA store of trust anchors fulfilled the CSR request for the identity All of these items are performed making no assumptions and securely verifying each step. This process does not suffer from man-in-the-middle attacks. It provides many benefits! Below is a detailed image of each step of the enrollment process. Let's break those steps down: Via the Ziti CLI, ZAC, or Edge REST API the admin authenticates and requests to create an identity The admin receives a JWT that is signed by the controller and is cryptographically verifiable. The JWT contains all the information for the enrolling device/server to contact the controller and verify its identity. It also includes a secret enrollment token. The JWT is given to the enrolling device The device parses the JWT, verifies all the information is present to enroll The device retrieves the public certificate from the controller at the address specified in the JWT The device confirms that the server is, in fact, the owner of the private key for that certificate The device uses the retrieved certificate to verify the signature on the JWT Verifies content has not changed Verifies the issuing server is the server it is communicating with Makes a secure connection to the server and requests the CAs to trust The enrolling identity generates a key pair, if necessary, and a CSR. The CSR is submitted in a request with the JWT's enrollment token. The controller verifies the CSR, verifies the enrollment token, verifies the client connection, and then returns the necessary signed certificates. At the end of the process, which took four simple human steps, but numerous cryptographically secure software steps, the controller now has a record of the certificates issued to a specific identity. That identity now has certificates that can be used to make connections to other enrolled Ziti components. All components in the system can verify the identity of any other Ziti component. At every step, every link is verified. No individual piece of software blindly trusts any other for inbound or outbound connections. Trust has been successfully bootstrapped! Now we enter a maintenance window where trust has to be verified continuously and maintained. The enrolled identity can now interact with the Ziti Controller to either function as a Ziti Router or as Zero Trust network client. Conclusion Thank you for reading this far! If you completed the entire series, I hope it has been helpful. Zero Trust is a complicated topic, and it requires a serious foundation in bootstrapping trust to get right. Hopefully, this series starts you on your way. If you have time, please checkout (Ziti)[https://github.com/openziti]! It is the Zero Trust network overlay solution that I have personally worked on and was the inspiration for this series. Written By: Andrew Martinez June 2020"
  },
  "articles/c-sdk-on-beaglebone.html": {
    "href": "articles/c-sdk-on-beaglebone.html",
    "title": "Building the Ziti C SDK and Sample Apps for arm (BeagleBone) | Ziti",
    "keywords": "Building the Ziti C SDK and Sample Apps for arm (BeagleBone) This article walks you through building the Ziti C SDK for Linux-arm and running the wttr sample application on a BeagleBone SanCloud . Configure the Host System This article uses an Ubuntu 19.10 virtual machine as a development host because it's relatively easy to install a functional toolchain that targets arm-linux. devbox$ sudo apt-get install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf \\ binutils-arm-linux-gnueabihf gdb-multiarch cmake git Build the SDK and Sample Applications devbox$ git clone --recurse-submodules https://github.com/netfoundry/ziti-sdk-c.git Cloning into 'ziti-sdk-c'... remote: Enumerating objects: 77, done. remote: Counting objects: 100% (77/77), done. remote: Compressing objects: 100% (50/50), done. remote: Total 1287 (delta 35), reused 51 (delta 24), pack-reused 1210 Receiving objects: 100% (1287/1287), 475.44 KiB | 4.85 MiB/s, done. ... devbox$ cd ziti-sdk-c devbox$ mkdir build-Linux-arm devbox$ cd build-Linux-arm devbox$ cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/Linux-arm.cmake .. project version: 0.9.2.1 (derived from git) -- The C compiler identification is GNU 9.2.1 -- The CXX compiler identification is GNU 9.2.1 -- Check for working C compiler: /usr/bin/arm-linux-gnueabihf-gcc ... $ make [ 1%] Building C object deps/uv-mbed/deps/libuv/CMakeFiles/uv_a.dir/src/fs-poll.c.o [ 1%] Building C object deps/uv-mbed/deps/libuv/CMakeFiles/uv_a.dir/src/idna.c.o [ 2%] Building C object deps/uv-mbed/deps/libuv/CMakeFiles/uv_a.dir/src/inet.c.o [ 2%] Building C object deps/uv-mbed/deps/libuv/CMakeFiles/uv_a.dir/src/random.c.o ... [ 99%] Building C object programs/sample_wttr/CMakeFiles/sample_wttr.dir/sample_wttr.c.o [ 99%] Linking C executable sample_wttr [ 99%] Built target sample_wttr [100%] Built target sample-host When make completes, you'll have statically linked binaries for the SDK's sample applications. Set up a Ziti Network For this article we'll use a Ziti Edge Developer Edition to run our network. Follow the Ziti Network Quickstart . Create the \"demo-weather\" Service The sample_wttr application accesses a service named \"demo-weather\", so we'll create that service now. Log in to your Ziti Edge Developer Edition web UI and follow the steps: On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"demo-weather\" Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = wttr.in port = 80 Click save Upload the Artifacts to Your BeagleBone At this point we have created all of the artifacts that are needed for running the sample application: The \"sample_wttr\" executable The Ziti identity json file (e.g. \"NewUser.json\") Now we need to upload these artifacts to the BeagleBone. The scp command shown here assumes that: You are in the build-Linux-arm subdirectory where the make command was executed above. Your BeagleBone is running sshd and has an IP address of 192.168.2.2 which can be reached from your development host The Ziti identity json file that was created when you followed the Ziti Network Quickstart was downloaded to your ~/Downloads directory. devbox$ scp ./programs/sample_wttr/sample_wttr root@192.168.2.2:. $ scp ~/Downloads/NewUser.json ./programs/sample_wttr/sample_wttr debian@192.168.2.2:. NewUser.json 100% 6204 2.5MB/s 00:00 sample_wttr 100% 2434KB 5.4MB/s 00:00 Run the Application Now we're ready to log into the BeagleBone and run the sample application. Let's go! ubuntu@beaglebone:~$ ./sample_wttr ./NewUser.json [ 0.000] INFO library/ziti.c:173 NF_init(): ZitiSDK version 0.9.2.1-local @de37e6f(wttr-sample-shutdown-cleanup) starting at (2019-09-05T22:35:12.259) [ 0.000] INFO library/ziti.c:195 NF_init_with_tls(): ZitiSDK version 0.9.2.1-local @de37e6f(wttr-sample-shutdown-cleanup) /home/scarey/repos/github.com/netfoundry/ziti-sdk-c/deps/uv-mbed/src/http.c:315 ERR TLS handshake error /home/scarey/repos/github.com/netfoundry/ziti-sdk-c/deps/uv-mbed/src/http.c:153 WARN received -103 (software caused connection abort) [ 0.210] ERROR library/ziti.c:433 version_cb(): failed to get controller version from ec2-54-164-120-24.compute-1.amazonaws.com:1280 CONTROLLER_UNAVAILABLE(software caused connection abort) [ 0.210] WARN library/ziti_ctrl.c:49 code_to_error(): unmapped error code: CONTROLLER_UNAVAILABLE [ 0.210] ERROR library/ziti.c:419 session_cb(): failed to login: CONTROLLER_UNAVAILABLE[-11](software caused connection abort) ERROR: status => WTF: programming error ubuntu@beaglebone:~# Oops. Actually The Ziti SDK verifies the certificate from the Ziti Edge Controller, so we need to set the clock on the BeagleBone to a time/date that is within the valid range of the certificate. Might as well set the clock to the current time: ubuntu@beaglebone:~# sudo rdate time.nist.gov Wed Mar 18 15:46:56 2020 And now we are ready to run the application: ubuntu@beaglebone:~$ ./sample_wttr ./NewUser.json [ 0.000] INFO library/ziti.c:173 NF_init(): ZitiSDK version 0.9.2.1-local @de37e6f(wttr-sample-shutdown-cleanup) starting at (2020-03-18T15:46:57.536) [ 0.000] INFO library/ziti.c:195 NF_init_with_tls(): ZitiSDK version 0.9.2.1-local @de37e6f(wttr-sample-shutdown-cleanup) [ 0.554] INFO library/ziti.c:438 version_cb(): connected to controller ec2-54-164-120-24.compute-1.amazonaws.com:1280 version v0.9.0(ea556fc18740 2020-02-11 16:09:08) [ 0.696] INFO library/connect.c:180 connect_get_service_cb(): got service[demo-weather] id[cc90410f-1017-4d23-977a-3695cb58f4e8] [ 0.810] INFO library/connect.c:209 connect_get_net_session_cb(): got session[d89bfdd8-c7e5-42ff-a39f-63056eeb3a82] for service[demo-weather] [ 0.810] INFO library/channel.c:148 ziti_channel_connect(): opening new channel for ingress[tls://ec2-54-164-120-24.compute-1.amazonaws.com:3022] ch[0] sending HTTP request request success: 99 bytes sent HTTP/1.1 200 OK Server: nginx/1.10.3 Date: Wed, 18 Mar 2020 15:47:00 GMT Content-Type: text/plain; charset=utf-8 Content-Length: 8662 Connection: close Weather report: Rochester \\ / Sunny .-. 39 F  ( )   0 mph `- 9 mi / \\ 0.0 in   Wed 18 Mar   Morning  Noon  Evening  Night    Overcast  Overcast  Cloudy  Overcast   .--. 32..35 F  .--. 35..41 F  .--. 39..44 F  .--. 37..42 F   .-( ).  3-4 mph  .-( ).  6-8 mph  .-( ).  9-16 mph  .-( ).  9-17 mph   (___.__)__) 6 mi  (___.__)__) 6 mi  (___.__)__) 6 mi  (___.__)__) 6 mi   0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%     Thu 19 Mar   Morning  Noon  Evening  Night    \\ / Partly cloudy  Cloudy  \\ / Partly cloudy  _`/\"\".-. Patchy light d  _ /\"\".-. 41..44 F  .--. 50 F  _ /\"\".-. 53..55 F  ,\\_( ). 50..53 F   \\_( ).  4-7 mph  .-( ).  4-6 mph  \\_( ).  6-11 mph  /(___(__)  10-19 mph   /(___(__) 3 mi  (___.__)__) 6 mi  /(___(__) 6 mi      4 mi   0.0 in | 0%  0.0 in | 0%  0.0 in | 0%      0.0 in | 20%     Fri 20 Mar   Morning  Noon  Evening  Night    _`/\"\".-. Light rain sho \\ / Partly cloudy  \\ / Partly cloudy  Cloudy   ,\\_( ). 62 F  _ /\"\".-. 66 F  _ /\"\".-. 48..51 F  .--. 46 F   /(___(__)  14-27 mph  \\_( ).  26-41 mph  \\_( ).  24-36 mph  .-( ).  22-30 mph       6 mi  /(___(__) 6 mi  /(___(__) 6 mi  (___.__)__) 6 mi       0.0 in | 29%  0.0 in | 59%  0.0 in | 41%  0.0 in | 0%   Location: Rochester, Monroe County, New York, United States of America [43.157285,-77.6152139] Follow @igor_chubin for wttr.in updates request completed: Connection closed [ 3.714] INFO library/ziti.c:238 NF_shutdown(): Ziti is shutting down ========================"
  },
  "articles/golang-aha/article.html": {
    "href": "articles/golang-aha/article.html",
    "title": "Golang Aha! Moments | Ziti",
    "keywords": "Golang Aha! Moments Introduction As we (the OpenZiti team) progressed on our Go journey, we've stumbed on various obstacles, settled on some best practices and hopefully gotten better at writing Go code. This document is meant to share some of the 'Aha!' moments where we overcame stumbling blocks and found solutions that sparked joy. This is intended both for new team members and for anyone in the go community who might be interested. We'd be very happy to hear from others about their own 'aha' moments and also how the solutions presented strike your sensibilities. Channels Channels are a core feature of go. As is typical of go, the channel API is small and simple, but provides a lot of power. If you haven't read it yet, Dave Cheney's Channel Axioms is worth a look. Closing Channels Closing channels can be complicated. On the reader side things are generally uncomplicated. A closed channel read will return immediately with the zero value and flag indicating that it is closed. func main() { ch := make(chan interface{}, 1) ch <- \"hello\" val, ok := <- ch fmt.Printf(\"%v, %v\\n\", val, ok) // prints hello, true close(ch) val, ok = <- ch fmt.Printf(\"%v, %v\\n\", val, ok) // prints <nil>, false } On the writer side, things can be more complicated. If you only have a single writer, it can be responsible for closing the channel. This notifies any blocker readers that the channel is closed. However, if there are multiple writers, this won't work. Writing to a closed channel will cause a panic. Closing an already closed channel will also cause a panic. So, what do we do? The main thing is to realize that we don't have to close the channel. We only have to make sure the readers and writers are safely notified that they should stop trying to use the channel. For this, we can use a second channel. package main import ( \"github.com/openziti/foundation/util/concurrenz\" \"github.com/pkg/errors\" ) type Queue struct { ch chan int closeNotify chan struct{} closed concurrenz.AtomicBoolean } func (self *Queue) Push(val int) error { select { case self.ch <- val: return nil case <-self.closeNotify: return errors.New(\"queue closed\") } } func (self *Queue) Pop() (int, error) { select { case val := <-self.ch: return val, nil case <-self.closeNotify: return 0, errors.New(\"queue closed\") } } func (self *Queue) Close() { if self.closed.CompareAndSwap(false, true) { close(self.closeNotify) } } If there are several entities which all need to shutdown together, they can even share a closeNotify channel. A variation on this would let readers drain the channel once it's closed. Because select case evaluation is random, we may not read a val from the channel once the close notify channel is closed. We can ensure that we return a value if it's available by modifying Pop() as follows: func (self *Queue) Pop() (int, error) { select { case val := <-self.ch: return val, nil case <-self.closeNotify: select { case val := <-self.ch: return val, nil default: return 0, errors.New(\"queue closed\") } } } Places used: https://github.com/openziti/channel/blob/main/impl.go (see rxer, txer) Other Channel Uses Let's look at how we can use channels in a few other ways. Semaphores and Pools Because channels have a sized buffer and have well defined blocking behavior, creating a semaphore implementation is very straightforward. We can create a channel with a buffer of the size we want our semaphore to have. We can then read and write from the channel to acquire and release the semaphore. package concurrenz import \"time\" type Semaphore interface { Acquire() AcquireWithTimeout(t time.Duration) bool TryAcquire() bool Release() bool } func NewSemaphore(size int) Semaphore { result := &semaphoreImpl{ c: make(chan struct{}, size), } for result.Release() { } return result } type semaphoreImpl struct { c chan struct{} } func (self *semaphoreImpl) Acquire() { <-self.c } func (self *semaphoreImpl) AcquireWithTimeout(t time.Duration) bool { select { case <-self.c: return true case <-time.After(t): return false } } func (self *semaphoreImpl) TryAcquire() bool { select { case <-self.c: return true default: return false } } func (self *semaphoreImpl) Release() bool { select { case self.c <- struct{}{}: return true default: return false } } We could use mostly the same implementation for a resource pool. Instead of a channel of struct{}, we could have a channel of connections or buffers that are acquired and released. Signal We can use channels as signals. In this example we have something running periodically, but we want to be able to trigger it to run sooner. With a single element channel, we can notify a goroutine. By using select with default , we can ensure that signalling code doesn't block and that the receiving side only gets a single signal per loop. package main import ( \"fmt\" \"github.com/openziti/foundation/util/concurrenz\" \"time\" ) func NewWorker() *Worker { w := &Worker{ signal: make(chan struct{}, 1), } go w.run() return w } type Worker struct { signal chan struct{} stopped concurrenz.AtomicBoolean } func (self *Worker) run() { ticker := time.NewTicker(time.Minute) defer ticker.Stop() for !self.stopped.Get() { select { case <-ticker.C: self.work() case <-self.signal: self.work() } } } func (self *Worker) work() { if !self.stopped.Get() { fmt.Println(\"working hard\") } } func (self *Worker) RunNow() { select { case self.signal <- struct{}{}: default: } } Channel Loops and Event Handler We often have a loop which is processing inputs from one or channel. Often we have a set of data we want to keep local to a single goroutine, so we don't have to use any synchronization or worry about cpu cache effects. We use channels to feed data to the goroutine and/or to trigger different kinds of processing. A for with select loop can handle channels of different types. YOu can have a channel per type of work, or per type of data. Sometimes it can be convenient to consolidate things on a single channel, using an event API. Here's a simple example where the processor is maintaining some cached data which can be updated externally. Presumably the processor would be doing something with the cached data, but we've left that out to focus on the pattern itself. type Event interface { // events are passed the processor so they don't each have to include it Handle(*Processor) } type Processor struct { ch chan Event closeNotify chan struct{} cache map[string]string } func (self *Processor) run() { for { select { case event := <-self.ch: event.Handle(self) case <-self.closeNotify: return } } } func (self *Processor) queueEvent(evt Event) { select { case self.ch <- evt: case <-self.closeNotify: return } } func (self *Processor) UpdateCache(k, v string) { self.queueEvent(&updateCache{key: k, value: v}) } func (self *Processor) Invalidate(k string) { self.queueEvent(invalidate(k)) } type updateCache struct { key string value string } func (self *updateCache) Handle(p *Processor) { p.cache[self.key] = self.value } type invalidate string func (self invalidate) Handle(p *Processor) { delete(p.cache, string(self)) } Type Aliases As we demonstrated in the previous example we can alias a type and add functions to it, usually to satify some interface. type invalidate string func (self invalidate) Handle(p *Processor) { delete(p.cache, string(self)) } This can be useful if we only have a single piece of data. Rather than wrapping it in a struct, we can just alias it and add our own funcs. The main downside to this approach is that you have to unalias the data inside your functions which can lead to code that is less clear. See for example this method from an AtomicBoolean implementation: type AtomicBoolean int32 func (ab *AtomicBoolean) Set(val bool) { atomic.StoreInt32((*int32)(ab), boolToInt(val)) } Function Type Aliases A go feature which can surprise developers is the ability to add function definitions to funcs. The Event API in the Processor example above could be extended as follows: type Event interface { Handle(*Processor) } type EventF func(*Processor) func (self EventF) Handle(p *Processor) { self(p) } The Invalidate code could now be written as: func (self *Processor) Invalidate(k string) { self.queueEvent(EventF(func(processor *Processor) { delete(processor.cache, k) })) } The need for an EventF cast could be removed by adding a helper function. func (self *Processor) queueEventF(evt EventF) { self.queueEvent(evt) } func (self *Processor) UpdateCache(k, v string) { self.queueEventF(func(processor *Processor) { processor.cache[k] = v }) } I first encountered this style in the go http library where handlers can be defined as structs implementing Handler or as functions matching HandlerFunc . This is most useful when you may have both heavy implementations which carry a lot of state as well as very simple implementations which make more sense as a function. The processor event channel could also be implemented in terms of pure functions, if all event implementations are lightweight. Interfaces A golang limitation that often trips people up is that packages cannot have circular dependencies. There are a few ways to work around this, but the most common is to introduce interfaces in the more independent of the packages. Errors In some situations, go's error handling can be excessively verbose. Especially in cases where you're doing a series of I/O operations, your code can look something like: func WriteExample(w io.Writer) error { if _, err := w.Write([]byte(\"one\")); err != nil { return err } if _, err := w.Write([]byte(\"two\")); err != nil { return err } if _, err := w.Write([]byte(\"three\")); err != nil { return err } if _, err := w.Write([]byte(\"four\")); err != nil { return err } return nil } One way to clean this up is to wrap the error in the operation and only check it at the end. type WriterErr struct { err error w io.Writer } func (self *WriterErr) Write(s string) { if self.err == nil { _, self.err = self.w.Write([]byte(s)) } } func (self *WriterErr) Error() error { return self.err } func WriteExample2(w io.Writer) error { writer := &WriterErr{w: w} writer.Write(\"one\") writer.Write(\"two\") writer.Write(\"three\") writer.Write(\"four\") return writer.Error() } See also: https://go.dev/blog/errors-are-values https://dave.cheney.net/2019/01/27/eliminate-error-handling-by-eliminating-errors Note: This pattern is could be viewed as an error monad implementation Gotchas Loop Variables[^cam] Like many other languages, it's possible to get into trouble when capturing loop variables, both via pointer references and via closures. The following snippet will print out world world since the loop variable remains constant throughout loop iteration. func main() { var list []*string for _, v := range []string {\"hello\", \"world\"} { list = append(list, &v) } for _, v := range list { fmt.Printf(\"%v \", *v) } fmt.Println() } Similarly, the following will output second second : func main() { for _, v := range []string {\"first\", \"second\"} { go func() { time.Sleep(100 * time.Millisecond) fmt.Printf(\"%v \", v) }() } time.Sleep(200 *time.Millisecond) fmt.Println() } Common Deadlock Causes Non-reentrant Mutexes Unlike in some other languages, the mutexes provide in the sync package are non-reentrant. So if your code grabs a lock and ends up calling back into something which gets the same lock, the goroutine will deadlock. Typically, if you have to call back in, you'd either need an indicator that the lock is already acquired, or do the work in a new go-routine, depending on how independent the second access was. Channel Deadlocks If you have a goroutine processing events from a channel, if the event submits an event back onto the channel, that can cause a deadlock, if the channel is not buffered, or if the buffer is full. Fixes include: Running the next event in-line, if you can detect that you're already in the event processing context Ensure the channel is buffer is big enough that it will never block Handing the new event submission off to a new go-routine One benefit to keeping your channel buffers at zero, is that you will detect these deadlocks very quickly. If you have a small buffer, then the deadlock may not be caught until the system is under load. [^cam]: Suggested by Cameron Otts"
  },
  "articles/index.html": {
    "href": "articles/index.html",
    "title": "Articles | Ziti",
    "keywords": "Articles Here you'll find articles that cover various topics related to developing applications with Ziti. Topics Ziti Up and Running on BeagleBone Bootstrapping Trust Zitifications A Zitification is any open-source project that has been modified to use the OpenZiti Edge SDK for client or server connectivity, or both. Zitified apps are bound to an identity instead of an address. Prometheus Kubernetes SSH SCP"
  },
  "articles/wildcard-dns/cheatsheet.html": {
    "href": "articles/wildcard-dns/cheatsheet.html",
    "title": "------------- start docker | Ziti",
    "keywords": "------------- start docker docker-compose up access the docker controller to create the necessary overlay docker exec -it docker_ziti-controller_1 bash ------------- log into the ziti cli zitiLogin ------------- make at least one router to be public ziti edge update edge-router ziti-edge-router -a \"public\" ------------- allow all identities to use any edge router with the attribute \"public\" ziti edge delete edge-router-policy all-endpoints-public-routers ziti edge create edge-router-policy all-endpoints-public-routers --edge-router-roles \"#public\" --identity-roles \"#all\" ------------- allows all edge-routers to access all services ziti edge delete service-edge-router-policy all-routers-all-services ziti edge create service-edge-router-policy all-routers-all-services --edge-router-roles \"#all\" --service-roles \"#all\" ziti edge delete identity zititunneller-blue ziti edge create identity device zititunneller-blue -o blue.jwt ziti edge enroll blue.jwt ------------- create a client - probably won't commit ziti edge create identity device zdewclint -o zdewclint.jwt from outside docker: docker cp docker_ziti-controller_1:/openziti/zdewclint.jwt /mnt/v/temp/ attach a wholly different docker container with NET_ADMIN priv so we can make a tun and provide access to the blue network docker run --cap-add=NET_ADMIN --device /dev/net/tun --name ziti-tunneler-blue --user root --network docker_zitiblue -v docker_ziti-fs:/openziti --rm -it openziti/quickstart /bin/bash ------------- zititunneller-blue apt install wget unzip wget https://github.com/openziti/ziti-tunnel-sdk-c/releases/latest/download/ziti-edge-tunnel-Linux_x86_64.zip unzip ziti-edge-tunnel-Linux_x86_64.zip clear ./ziti-edge-tunnel run -i blue.json ziti edge delete config \"basic.dial\" ziti edge create config \"basic.dial\" intercept.v1 '{\"protocols\":[\"tcp\"],\"addresses\":[\"simple.web.test\"], \"portRanges\":[{\"low\":80, \"high\":80}]}' ziti edge delete config \"basic.bind\" ziti edge create config \"basic.bind\" host.v1 '{\"protocol\":\"tcp\", \"address\":\"web-test-blue\",\"port\":8000}' ziti edge delete service \"basic.web.test.service\" ziti edge create service \"basic.web.test.service\" --configs \"basic.bind,basic.dial\" ziti edge delete service-policy basic.web.test.service.bind.blue ziti edge create service-policy basic.web.test.service.bind.blue Bind --service-roles \"@basic.web.test.service\" --identity-roles \"@zititunneller-blue\" ziti edge delete service-policy basic.web.test.service.dial.zdew ziti edge create service-policy basic.web.test.service.dial.zdew Dial --service-roles \"@basic.web.test.service\" --identity-roles \"@zdewclint\" ziti edge delete config \"wildcard.dial\" ziti edge create config \"wildcard.dial\" intercept.v1 '{\"protocols\":[\"tcp\"],\"addresses\":[\"*.blue\"], \"portRanges\":[{\"low\":8000, \"high\":8000}]}' ziti edge delete config \"wildcard.bind\" ziti edge create config \"wildcard.bind\" host.v1 '{\"forwardProtocol\":true, \"allowedProtocols\":[\"tcp\",\"udp\"], \"forwardAddress\":true, \"allowedAddresses\":[\"*.blue\"], \"forwardPort\":true, \"allowedPortRanges\":[ {\"low\":1,\"high\":32768}] }' ziti edge delete service \"wildcard.web.test.service\" ziti edge create service \"wildcard.web.test.service\" --configs \"wildcard.bind,wildcard.dial\" ziti edge delete service-policy wildcard.web.test.service.bind.blue ziti edge create service-policy wildcard.web.test.service.bind.blue Bind --service-roles \"@wildcard.web.test.service\" --identity-roles \"@zititunneller-blue\" ziti edge delete service-policy wildcard.web.test.service.dial.zdew ziti edge create service-policy wildcard.web.test.service.dial.zdew Dial --service-roles \"@wildcard.web.test.service\" --identity-roles \"@zdewclint\""
  },
  "articles/zitification/index.contents.html": {
    "href": "articles/zitification/index.contents.html",
    "title": "| Ziti",
    "keywords": "\"Zitification\" or \"zitifying\" is the act of taking an application and incorporating a Ziti SDK into that application. Once an application has a Ziti SDK incorporated into it, that application can now access network resources securely from anywhere in the world provided that the computer has internet access: NO VPN NEEDED, NO ADDITIONAL SOFTWARE NEEDED. Integrating a Ziti SDK into your application and enrolling the application itself into a Ziti Network provides you with * tremendous* additional security. An application using a Ziti Network configured with a truly zero-trust mindset will be IMMUNE to the \"expand/multiply\" phases of classic ransomware attacks . As recent events have shown, it's probably not a case of if your application will be attacked, but when. In these posts we're going to explore how common applications can be \"zitified\". The first application we are going to focus on will be ssh and it's corollary scp . At first, you might think, \"why even bother\" zitifying (of all things) ssh and scp ? These applications are vital to system administration, and we have been using ssh and scp \"safely\" on the internet for years. Hopefully you're now interested enough to find out in the first post: zitifying ssh If you'd prefer to read about other zitifications, a running list of zitified apps will be updated below: ssh->zssh scp->zscp Kubernetes cluster manager - kubectl"
  },
  "articles/zitification/index.html": {
    "href": "articles/zitification/index.html",
    "title": "Zitification | Ziti",
    "keywords": "Zitification \"Zitification\" or \"zitifying\" is the act of taking an application and incorporating a Ziti SDK into that application. Once an application has a Ziti SDK incorporated into it, that application can now access network resources securely from anywhere in the world provided that the computer has internet access: NO VPN NEEDED, NO ADDITIONAL SOFTWARE NEEDED. Integrating a Ziti SDK into your application and enrolling the application itself into a Ziti Network provides you with * tremendous* additional security. An application using a Ziti Network configured with a truly zero-trust mindset will be IMMUNE to the \"expand/multiply\" phases of classic ransomware attacks . As recent events have shown, it's probably not a case of if your application will be attacked, but when. In these posts we're going to explore how common applications can be \"zitified\". The first application we are going to focus on will be ssh and it's corollary scp . At first, you might think, \"why even bother\" zitifying (of all things) ssh and scp ? These applications are vital to system administration, and we have been using ssh and scp \"safely\" on the internet for years. Hopefully you're now interested enough to find out in the first post: zitifying ssh If you'd prefer to read about other zitifications, a running list of zitified apps will be updated below: ssh->zssh scp->zscp Kubernetes cluster manager - kubectl"
  },
  "articles/zitification/kubernetes/index.html": {
    "href": "articles/zitification/kubernetes/index.html",
    "title": "Zitifying Kubectl | Ziti",
    "keywords": "Zitifying Kubectl The previous post showed how to use a zero trust overlay like Ziti for transferring files by zitifying scp . Next up in the list of zitifications is kubectl . Kubernetes is a container orchestration system. Its purpose is to deploy, scale, and manage the deployment containers. Containers are self-contained, pre-built images of software generally with a singular purpose. Developers often like using containers for various reasons . One major reason developers like containers is because it simplifies the deployment of the solutions they are developing. This is where Kubernetes starts to come into focus. In this article we'll use a cloud provider to create a Kubernetes cluster to use. I'm using Oracle OKE in this article but there are numerous Kubernetes providers and any of them will work but clearly the commands I'm running here are Oracle specific. Once created we will then access the cluster three ways: Via the public Kubernetes API secured via mTLS. This is the default, out-of-the-box mechanism provided by Kubernetes. Via a tunneling app. I run Windows, so I'll use the Ziti Desktop Edge for Windows. Via a zitified kubectl . Here's where we'll get to see the power of a truly zitified application. We'll be able to access our cluster extremely securely using the Ziti overlay network without installing an additional agent. Once access to the cluster comes entirely from the Ziti Network , we will be able to turn public access to the Kubernetes management API off entirely! About Kubernetes If you are not already familiar with Kubernetes then it's probably best for you to stop reading and learn a little about it first. Though this article only expects you to understand the most rudimentary of commands, it won't teach you enough about Kubernetes to understand the what's and why's. Lots of documentation on this topic already exist and are just a search away in your search engine of choice. Kubernetes itself is not a container engine, it's an orchestrator. This means that Kubernetes knows how to interface with container engines to perform deployments and management of workloads on the behalf of operators. This provides people with a common abstraction to use when doing this management and deployment. Interacting with the Kubernetes API is made easy by using the command-line tool: kubectl . kubectl provides numerous commands and utilities to interact with your Kubernetes cluster. It does this by creating REST requests to a well-known endpoint. This endpoint is a highly-valuable target as it is the entry-point to the cluster. Plenty of blogs exist already on the internet addressing how to secure this endpoint but in this post we'll take it one step further than ever before by removing the Kubernetes control plane from the internet entirely. Following that we will even go one step further by replacing the existing kubectl command with a zero-trust implementation leveraging the ziti golang sdk. If you'd prefer to watch a video that goes over the same content contained in the rest of this article you can go ahead and click here to watch. Setup Below is an overview of the Ziti Network I created for this article. On the left you can see that the client, my computer, runs Windows 10. Inside Windows 10 I run linux and bash using Ubuntu via Windows Subsystem For Linux (WSL) . If you run Windows and don't have WSL installed I would encourage you to install and learn it! In my bash shell I have downloaded the linux version of kubectl created by combining the Ziti Golang SDK into it. You can grab it from this link if you like or go check out the code on GitHub and build it yourself! :) Solution Overview Basic Ziti Setup To accomplish our stated goals, we will need not only an existing Ziti Network but we'll also have to configure that network accordingly. Here's a list of the components necessary to deliver Kubernetes with our zero-trust network: A configuration for the Bind side of the service. This informs the identity within Kubernetes where to send traffic and how. A configuration for the Dial side of the service. This is strictly only necessary for tunneling apps. In this example, for the Ziti Desktop Edge for Windows and specifies what host and port will be intercepted on the machine running the stock kubectl . for Windows. The service itself which ties our polices mentioned above together. A Bind service-policy which specifies which identities are allowed to act as a \"host\" for the service (meaning an identity to send traffic to which knows where and how to offload that traffic). In our example this will be the ziti-edge-tunnel running in a Kubernetes pod. A Dial service-policy which specifies the identities allowed to access the service. This will be the identity using kubectl . Create two identities - one for the Bind side of the service (deployed within the Kubernetes cluster) and one for the Dial or client side. Here are some example commands using the ziti cli which illustrate how to create these services. Some things of note worth mentioning. I'm setting a variable to make my configuration easier. I reuse these code blocks a lot and by extracting some variables it makes it easy for me to delete/recreate services. First I set the service_name variable. I use this variable in all the names of the Ziti objects I create just to make it more clear and obvious if I have to look back at my configuration again. Since I'm going to be accessing my Kubernetes API which I've deployed using the Oracle cloud I chose to use k8s.oci as my service name. When deployed by a cloud provider, the Kubernetes API is generated or updated with numerous SANS and IP address I can choose from to represent the Dial side which will be intercepted by the Ziti Desktop Edge for Windows. The Oracle cloud console informs me that the private IP of 10.0.0.6 was assigned to my cluster when I click on the 'Access Cluster' button which is why I chose to use that value below. I could have choosen to use any of the DNS names provided by OKE. There are at least five I could choose from, all visible as SANS on the cert that the server returns: kubernetes , kubernetes.default , kubernetes.default.svc , kubernetes.default.svc.cluster , kubernetes.default.svc.cluster.local . I chose the IP since it's pretty obvious that it's an internal IP, not on my local network. Also worth pointing out is that I'm mapping the port as well, changing it from the port that the server provides, 6443, to the common HTTPS port of 443 for the local intercept. With zitified kubectl we don't even need these intercepts, but we'll keep it here so that we can use the unmodified kubectl as well. Finally, these commands are all executed inside a bash shell since I'm using WSL. Example Ziti CLI commands # the name of the service service_name=k8s.oci # the name of the identity you'd like to see on the kubectl client the_user_identity=\"${service_name}\".client # the name of the identity deployed into the kubernetes cluster the_kubernetes_identity=\"${service_name}\".private ziti edge create config \"${service_name}\"-host.v1 host.v1 \\ '{\"protocol\":\"tcp\", \"address\":\"10.0.0.6\",\"port\":6443 }' ziti edge create config \"${service_name}\"-client-config intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"10.0.0.6\",\"kubernetes\"], \"portRanges\":[{\"low\":443, \"high\":443}]}' ziti edge create service \\ \"${service_name}\" \\ --configs \"${service_name}\"-client-config,\"${service_name}\"-host.v1 ziti edge create service-policy \"${service_name}\"-binding Bind \\ --service-roles '@'\"${service_name}\" \\ --identity-roles '#'\"${service_name}\"'ServerEndpoints' ziti edge create service-policy \"${service_name}\"-dialing Dial \\ --service-roles '@'\"${service_name}\" \\ --identity-roles '#'\"${service_name}\"'ClientEndpoints' ziti edge create identity device \"${the_kubernetes_identity}\" \\ -a \"${service_name}\"ServerEndpoints \\ -o \"${the_kubernetes_identity}\".jwt ziti edge create identity device \"${the_user_identity}\" \\ -a \"${service_name}\"ClientEndpoints \\ -o \"${the_user_identity}\".jwt Kubernetes Config Files Once we have established the pieces of the Ziti Network , we'll want to get the Kubernetes config files from OKE so that we can test access, make sure the cluster works etc. Oracle provides a CLI command which makes it pretty easy to get those config files called oci . As of this writing - the guide from Oracle is here . Once oci is installed and configured the Oracle cloud gives you very easy commands to run which will generate two files. One file will be for accessing the Kubernetes API through the public endpoint. The other will get you the file for private access. We're going to want both since we're on a journey here from \"public API endpoint\" to tunneling-app-based access, to the final stage of app-embedded zero-trust directly into kubeztl . Getting the Kubernetes Config Files Notice that we are changing the file location output by these commands and they are being output as two separate Kubernetes config files. If you prefer to merge them all into one big config file and change contexts - feel free. I left them as separate files here because it provides a very clear separation as to which config is being used or modified. # Get this value directly from Oracle oci_cluster_id=\"put-your-cluster-id-here\" oci ce cluster create-kubeconfig \\ --cluster-id ${oci_cluster_id} \\ --file /tmp/oci/config.oci.public \\ --region us-ashburn-1 \\ --token-version 2.0.0 \\ --kube-endpoint PUBLIC_ENDPOINT chmod 600 /tmp/oci/config.oci.public oci ce cluster create-kubeconfig \\ --cluster-id ${oci_cluster_id} \\ --file /tmp/oci/config.oci.private \\ --region us-ashburn-1 \\ --token-version 2.0.0 \\ --kube-endpoint PRIVATE_ENDPOINT chmod 600 /tmp/oci/config.oci.private Connecting the Pieces At this point we should have all the pieces in place so that we can start putting them together to test the overall solution. In this section we'll access our public Kubernetes api to make sure it works. Then we'll install Ziti into the Kubernetes cluster and verify private access works. Finally we'll disable public access entirely and use the zitified kubeztl command to access the cluster with true, app-embedded zero-trust binary. Testing the Public API This step is very straight-forward for anyone who's used Kubernetes before. Issue the following commands, making sure the path is correct for your public Kubernetes config file, and verify Kubernetes works as expected. export KUBECONFIG=/tmp/oci/config.oci.public kubectl get pods -v6 --request-timeout='5s' I1019 13:57:31.910962 3211 loader.go:372] Config loaded from file: /tmp/oci/config.oci.public I1019 13:57:33.676047 3211 round_trippers.go:454] GET https://150.230.150.0:6443/api/v1/namespaces/default/pods?limit=500&timeout=5s 200 OK in 1752 milliseconds NAME READY STATUS RESTARTS AGE If your output looks something similar to the above (with or without the pods you expect to see) then great! That means your Kubernetes cluster is indeed up and running. Let's move on! Deploying Ziti to Kubernetes Next we'll grab a few lines from the excellent guide NetFoundry put out for integrating with Kubernetes. There's a section in that guide for installing Ziti with Helm . This comes down to just these steps: install the helm CLI tool using this guide add the NetFoundry helm repo: helm repo add netfoundry https://netfoundry.github.io/charts/ locate the jwt file for the Kubernetes identity. If you followed the steps above the file will be named: \"${the_kubernetes_identity}\".jwt (make sure you replace the variable with the correct value) use the jwt to add Ziti: helm install ziti-host netfoundry/ziti-host --set-file enrollmentToken=\"${the_kubernetes_identity}\".jwt (again make sure you replace the variable name) If you need to, make sure you create a persistent volume. The ziti pod requires storage to store a secret. ```bash apiVersion: v1 kind: PersistentVolume metadata: name: ziti-host-pv labels: type: local spec: storageClassName: oci capacity: storage: 100Mi accessModes: ReadWriteMany hostPath: path: \"/netfoundry\" ``` Add/Enroll the Client Identity Now consume the one time token (the jwt file) to enroll and create a client-side identity using the Ziti Desktop Edge for Windows (or MacOS or via the ziti-edge-tunnel if you prefer). Once you can see the identity in your tunneling app, you should be able to use the private kubernetes config file to access the same exact cluster. Remember though, we have mapped the port on the client side to use 443. That means you'll need to update your config file and change 6443 --> 443. Now when you run get pods you'll see the ziti-host pod deployed: export KUBECONFIG=/tmp/oci/config.oci.private kubectl get pods NAME READY STATUS RESTARTS AGE ziti-host-976b84c66-kr4bc 1/1 Running 0 90m The Big Finale - Zitified kubectl If you have made it this far, you've seen us access the Kubernetes API via the public IP. We've even accessed it via the private IP (which btw - is pretty cool in my opinion!). Now we're going to download the zitified kubectl command, turn off the public IP and even turn off the locally running tunneling app and still access the API! Disable the cluster's public IP address in OKE (go to the cluster in Oracle Cloud, click Edit and remove the public IP and click save) Turn off the Ziti Desktop Edge for Windows Download kubeztl (you don't need to call the executable kubeztl - you can keep it named kubectl if you want) bash curl -L -o kubeztl https://github.com/openziti-incubator/kubectl/releases/download/v0.0.4/kubectl-linux-amd64 Use kubeztl to get pods! bash ./kubeztl get pods -c id.json -S k8s.oci NAME READY STATUS RESTARTS AGE ziti-host-976b84c66-kr4bc 1/1 Running 0 101m ### Modifying KUBECONFIG The kubeztl command has also been modified to allow you to add the service name and config file directly into the file itself. This is convenient since you will not need to supply the ziti identity file, nor will you need to specify which service to use. Modifying the file is straight-forward. Open the config file, find the context listed under the contexts root and add two rows as shown here. contexts - context: cluster: cluster-cjw4arxuolq user: user-cjw4arxuolq zConfig: /tmp/oci/k8s.id.json service: k8s.oci Once done - you can now simply use the context the same way you have always - kubeztl get pods !!! ./kubeztl get pods NAME READY STATUS RESTARTS AGE ziti-host-976b84c66-kr4bc 1/1 Running 0 114m Conclusion We've seen in this post how you can not only secure your Kubernetes API with the normal Kubernetes mechanisms. You can also take your Kubernetes API off the internet ENTIRELY . No need to deploy and maintain a special bastian node. Now by having a secure, zero-trust overlay in place you can safely and securely access your Kubernetes API without the fear of that public, high-value API getting attacked. Once you've deployed Ziti into the Kubernetes cluster you're not done there. Now you can also use Ziti to span cloud networks. You can use it to easily link private data centers or other private Kubernetes clusters all into one secure, zero-trust overlay network! Use Ziti to expose workloads that are TRULY private! In future articles we might explore how we can bring Ziti to bear on these topics, stay tuned!"
  },
  "articles/zitification/kubernetes/kubernetes-oci.html": {
    "href": "articles/zitification/kubernetes/kubernetes-oci.html",
    "title": "Kubernetes Cheatsheet | Ziti",
    "keywords": "Kubernetes Cheatsheet This page exists as the set of commands which were used in the video Secure Kubernetes Cluster using Ziti establish some variables just to make commands easier: service_name=k8s.oci the_user_identity=\"${service_name}\".client the_kubernetes_identity=\"${service_name}\".private oci_cluster_id=\"put-your-cluster-id-here\" clean up commands - if needed: rm /tmp/oci/config.oci.public rm /tmp/oci/config.oci.private ziti edge delete identity \"${the_kubernetes_identity}\" ziti edge delete identity \"${the_user_identity}\" work done ahead of time - takes time to establish a cluster: previously setup kubernetes in OKE simple cluster standard quick create cluster public endpoint Shape: VM.Standard2.2 1 node pasted my public key for access exposed the cluster with public ip already installed oci as well as helm already deployed a ziti environment using https://openziti.github.io/ziti/quickstarts/network/hosted.html create kubernetes config files - public and private: oci ce cluster create-kubeconfig \\ --cluster-id ${oci_cluster_id} \\ --file /tmp/oci/config.oci.public \\ --region us-ashburn-1 \\ --token-version 2.0.0 \\ --kube-endpoint PUBLIC_ENDPOINT chmod 600 /tmp/oci/config.oci.public oci ce cluster create-kubeconfig \\ --cluster-id ${oci_cluster_id} \\ --file /tmp/oci/config.oci.private \\ --region us-ashburn-1 \\ --token-version 2.0.0 \\ --kube-endpoint PRIVATE_ENDPOINT chmod 600 /tmp/oci/config.oci.private delete any resources if needed: export KUBECONFIG=/tmp/oci/config.oci.public helm uninstall ziti-host kubectl delete persistentvolume ziti-host-pv show it working via public ip from wsl: wsl: export KUBECONFIG=/tmp/oci/config.oci.public kubectl get pods -v7 --request-timeout='5s' show it failing via private ip from wsl: export KUBECONFIG=/tmp/oci/config.oci.private kubectl get pods -v7 --request-timeout='2s' let's install ziti in the cluster: make a new identity: ziti edge create identity device \"${the_kubernetes_identity}\" -a \"${service_name}\"ServerEndpoints -o \"${the_kubernetes_identity}\".jwt ziti edge create identity device \"${the_user_identity}\" -a \"${service_name}\"ClientEndpoints -o \"${the_user_identity}\".jwt add the identity to the cluster (using the public ip): helm repo add netfoundry https://netfoundry.github.io/charts/ create the config file to apply apiVersion: v1 kind: PersistentVolume metadata: name: ziti-host labels: type: local spec: storageClassName: oci capacity: storage: 100Mi accessModes: - ReadWriteOnce hostPath: path: \"/netfoundry\" kubectl apply the config: export KUBECONFIG=/tmp/oci/config.oci.public kubectl apply -f add-persistent-claims.yaml helm install ziti-host netfoundry/ziti-host --set-file enrollmentToken=\"${the_kubernetes_identity}\".jwt verify the ziti identity was bootstrapped by using kubectl logs kubectl logs ziti-host<tab><enter> now go disable the public ip so private access ONLY works... this takes \"a minute or two or three\"... let's setup the ziti bits we need setup ziti to access the private server address... set environment variables to make it easier to reference: export KUBECONFIG=/tmp/oci/config.oci.private k8s_private_host_and_port=$(kubectl config view | grep server | cut -d \"/\" -f3) k8s_private_host=$(echo ${k8s_private_host_and_port} | cut -d \":\" -f1) k8s_private_port=$(echo ${k8s_private_host_and_port} | cut -d \":\" -f2) echo \"Private URL: ${k8s_private_host_and_port}, Host: ${k8s_private_host}, Port: ${k8s_private_port}\" ziti setup: k8s_private_dns=kubernetes ziti edge delete config \"${service_name}\"-host.v1 ziti edge delete config \"${service_name}\"-client-config ziti edge delete service \"${service_name}\" ziti edge delete service-policy \"${service_name}\"-binding ziti edge delete service-policy \"${service_name}\"-dialing ziti edge create config \"${service_name}\"-host.v1 host.v1 '{\"protocol\":\"tcp\", \"address\":\"'${k8s_private_host}'\",\"port\":'${k8s_private_port}' }' ziti edge create config \"${service_name}\"-client-config intercept.v1 '{\"protocols\":[\"tcp\"],\"addresses\":[\"'${k8s_private_host}'\",\"'${k8s_private_dns}'\"], \"portRanges\":[{\"low\":443, \"high\":443}]}' ziti edge create service \"${service_name}\" --configs \"${service_name}\"-client-config,\"${service_name}\"-host.v1 ziti edge create service-policy \"${service_name}\"-binding Bind --service-roles '@'\"${service_name}\" --identity-roles '#'\"${service_name}\"'ServerEndpoints' ziti edge create service-policy \"${service_name}\"-dialing Dial --service-roles '@'\"${service_name}\" --identity-roles '#'\"${service_name}\"'ClientEndpoints' verify windows can access the kubernetes api (using cmd.exe from wsl): cmd.exe /c curl -k \"https://${k8s_private_dns}\" cmd.exe /c curl -k \"https://${k8s_private_host}\" at this point from wsl kubectl will work using the ip address - but not dns #enroll the identity ziti edge enroll \"${the_user_identity}\".jwt # use the identity to get pods: ./kubeztl --zConfig \"${the_user_identity}\".json --service k8s.oci get pods # update your config to make it so you don't need to supply --zConfig or --service # replace \"${the_user_identity}\" accordingly: zConfig: /mnt/v/temp/oci/\"${the_user_identity}\".json service: k8s.oci use \"kubeztl\": download from github: curl -L -o kubeztl https://github.com/openziti-incubator/kubectl/releases/download/v0.0.4/kubectl-linux-amd64 ./kubeztl get pods -c ./id.json -S \"${service_name}\" modify config if you want... find your context, add two lines: zConfig: /mnt/v/temp/oci/oci.json service: k8s.oci useful if you need to update either of the identities... ziti edge update identity \"${the_user_identity}\" -a \"${service_name}\"ClientEndpoints ziti edge update identity \"${the_kubernetes_identity}\" -a \"${service_name}\"ServerEndpoints"
  },
  "articles/zitification/kubernetes/zitifying-kubectl.contents.html": {
    "href": "articles/zitification/kubernetes/zitifying-kubectl.contents.html",
    "title": "About Kubernetes | Ziti",
    "keywords": "The previous post showed how to use a zero trust overlay like Ziti for transferring files by zitifying scp . Next up in the list of zitifications is kubectl . Kubernetes is a container orchestration system. Its purpose is to deploy, scale, and manage the deployment containers. Containers are self-contained, pre-built images of software generally with a singular purpose. Developers often like using containers for various reasons . One major reason developers like containers is because it simplifies the deployment of the solutions they are developing. This is where Kubernetes starts to come into focus. In this article we'll use a cloud provider to create a Kubernetes cluster to use. I'm using Oracle OKE in this article but there are numerous Kubernetes providers and any of them will work but clearly the commands I'm running here are Oracle specific. Once created we will then access the cluster three ways: Via the public Kubernetes API secured via mTLS. This is the default, out-of-the-box mechanism provided by Kubernetes. Via a tunneling app. I run Windows, so I'll use the Ziti Desktop Edge for Windows. Via a zitified kubectl . Here's where we'll get to see the power of a truly zitified application. We'll be able to access our cluster extremely securely using the Ziti overlay network without installing an additional agent. Once access to the cluster comes entirely from the Ziti Network , we will be able to turn public access to the Kubernetes management API off entirely! About Kubernetes If you are not already familiar with Kubernetes then it's probably best for you to stop reading and learn a little about it first. Though this article only expects you to understand the most rudimentary of commands, it won't teach you enough about Kubernetes to understand the what's and why's. Lots of documentation on this topic already exist and are just a search away in your search engine of choice. Kubernetes itself is not a container engine, it's an orchestrator. This means that Kubernetes knows how to interface with container engines to perform deployments and management of workloads on the behalf of operators. This provides people with a common abstraction to use when doing this management and deployment. Interacting with the Kubernetes API is made easy by using the command-line tool: kubectl . kubectl provides numerous commands and utilities to interact with your Kubernetes cluster. It does this by creating REST requests to a well-known endpoint. This endpoint is a highly-valuable target as it is the entry-point to the cluster. Plenty of blogs exist already on the internet addressing how to secure this endpoint but in this post we'll take it one step further than ever before by removing the Kubernetes control plane from the internet entirely. Following that we will even go one step further by replacing the existing kubectl command with a zero-trust implementation leveraging the ziti golang sdk. If you'd prefer to watch a video that goes over the same content contained in the rest of this article you can go ahead and click here to watch. Setup Below is an overview of the Ziti Network I created for this article. On the left you can see that the client, my computer, runs Windows 10. Inside Windows 10 I run linux and bash using Ubuntu via Windows Subsystem For Linux (WSL) . If you run Windows and don't have WSL installed I would encourage you to install and learn it! In my bash shell I have downloaded the linux version of kubectl created by combining the Ziti Golang SDK into it. You can grab it from this link if you like or go check out the code on GitHub and build it yourself! :) Solution Overview Basic Ziti Setup To accomplish our stated goals, we will need not only an existing Ziti Network but we'll also have to configure that network accordingly. Here's a list of the components necessary to deliver Kubernetes with our zero-trust network: A configuration for the Bind side of the service. This informs the identity within Kubernetes where to send traffic and how. A configuration for the Dial side of the service. This is strictly only necessary for tunneling apps. In this example, for the Ziti Desktop Edge for Windows and specifies what host and port will be intercepted on the machine running the stock kubectl . for Windows. The service itself which ties our polices mentioned above together. A Bind service-policy which specifies which identities are allowed to act as a \"host\" for the service (meaning an identity to send traffic to which knows where and how to offload that traffic). In our example this will be the ziti-edge-tunnel running in a Kubernetes pod. A Dial service-policy which specifies the identities allowed to access the service. This will be the identity using kubectl . Create two identities - one for the Bind side of the service (deployed within the Kubernetes cluster) and one for the Dial or client side. Here are some example commands using the ziti cli which illustrate how to create these services. Some things of note worth mentioning. I'm setting a variable to make my configuration easier. I reuse these code blocks a lot and by extracting some variables it makes it easy for me to delete/recreate services. First I set the service_name variable. I use this variable in all the names of the Ziti objects I create just to make it more clear and obvious if I have to look back at my configuration again. Since I'm going to be accessing my Kubernetes API which I've deployed using the Oracle cloud I chose to use k8s.oci as my service name. When deployed by a cloud provider, the Kubernetes API is generated or updated with numerous SANS and IP address I can choose from to represent the Dial side which will be intercepted by the Ziti Desktop Edge for Windows. The Oracle cloud console informs me that the private IP of 10.0.0.6 was assigned to my cluster when I click on the 'Access Cluster' button which is why I chose to use that value below. I could have choosen to use any of the DNS names provided by OKE. There are at least five I could choose from, all visible as SANS on the cert that the server returns: kubernetes , kubernetes.default , kubernetes.default.svc , kubernetes.default.svc.cluster , kubernetes.default.svc.cluster.local . I chose the IP since it's pretty obvious that it's an internal IP, not on my local network. Also worth pointing out is that I'm mapping the port as well, changing it from the port that the server provides, 6443, to the common HTTPS port of 443 for the local intercept. With zitified kubectl we don't even need these intercepts, but we'll keep it here so that we can use the unmodified kubectl as well. Finally, these commands are all executed inside a bash shell since I'm using WSL. Example Ziti CLI commands # the name of the service service_name=k8s.oci # the name of the identity you'd like to see on the kubectl client the_user_identity=\"${service_name}\".client # the name of the identity deployed into the kubernetes cluster the_kubernetes_identity=\"${service_name}\".private ziti edge create config \"${service_name}\"-host.v1 host.v1 \\ '{\"protocol\":\"tcp\", \"address\":\"10.0.0.6\",\"port\":6443 }' ziti edge create config \"${service_name}\"-client-config intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"10.0.0.6\",\"kubernetes\"], \"portRanges\":[{\"low\":443, \"high\":443}]}' ziti edge create service \\ \"${service_name}\" \\ --configs \"${service_name}\"-client-config,\"${service_name}\"-host.v1 ziti edge create service-policy \"${service_name}\"-binding Bind \\ --service-roles '@'\"${service_name}\" \\ --identity-roles '#'\"${service_name}\"'ServerEndpoints' ziti edge create service-policy \"${service_name}\"-dialing Dial \\ --service-roles '@'\"${service_name}\" \\ --identity-roles '#'\"${service_name}\"'ClientEndpoints' ziti edge create identity device \"${the_kubernetes_identity}\" \\ -a \"${service_name}\"ServerEndpoints \\ -o \"${the_kubernetes_identity}\".jwt ziti edge create identity device \"${the_user_identity}\" \\ -a \"${service_name}\"ClientEndpoints \\ -o \"${the_user_identity}\".jwt Kubernetes Config Files Once we have established the pieces of the Ziti Network , we'll want to get the Kubernetes config files from OKE so that we can test access, make sure the cluster works etc. Oracle provides a CLI command which makes it pretty easy to get those config files called oci . As of this writing - the guide from Oracle is here . Once oci is installed and configured the Oracle cloud gives you very easy commands to run which will generate two files. One file will be for accessing the Kubernetes API through the public endpoint. The other will get you the file for private access. We're going to want both since we're on a journey here from \"public API endpoint\" to tunneling-app-based access, to the final stage of app-embedded zero-trust directly into kubeztl . Getting the Kubernetes Config Files Notice that we are changing the file location output by these commands and they are being output as two separate Kubernetes config files. If you prefer to merge them all into one big config file and change contexts - feel free. I left them as separate files here because it provides a very clear separation as to which config is being used or modified. # Get this value directly from Oracle oci_cluster_id=\"put-your-cluster-id-here\" oci ce cluster create-kubeconfig \\ --cluster-id ${oci_cluster_id} \\ --file /tmp/oci/config.oci.public \\ --region us-ashburn-1 \\ --token-version 2.0.0 \\ --kube-endpoint PUBLIC_ENDPOINT chmod 600 /tmp/oci/config.oci.public oci ce cluster create-kubeconfig \\ --cluster-id ${oci_cluster_id} \\ --file /tmp/oci/config.oci.private \\ --region us-ashburn-1 \\ --token-version 2.0.0 \\ --kube-endpoint PRIVATE_ENDPOINT chmod 600 /tmp/oci/config.oci.private Connecting the Pieces At this point we should have all the pieces in place so that we can start putting them together to test the overall solution. In this section we'll access our public Kubernetes api to make sure it works. Then we'll install Ziti into the Kubernetes cluster and verify private access works. Finally we'll disable public access entirely and use the zitified kubeztl command to access the cluster with true, app-embedded zero-trust binary. Testing the Public API This step is very straight-forward for anyone who's used Kubernetes before. Issue the following commands, making sure the path is correct for your public Kubernetes config file, and verify Kubernetes works as expected. export KUBECONFIG=/tmp/oci/config.oci.public kubectl get pods -v6 --request-timeout='5s' I1019 13:57:31.910962 3211 loader.go:372] Config loaded from file: /tmp/oci/config.oci.public I1019 13:57:33.676047 3211 round_trippers.go:454] GET https://150.230.150.0:6443/api/v1/namespaces/default/pods?limit=500&timeout=5s 200 OK in 1752 milliseconds NAME READY STATUS RESTARTS AGE If your output looks something similar to the above (with or without the pods you expect to see) then great! That means your Kubernetes cluster is indeed up and running. Let's move on! Deploying Ziti to Kubernetes Next we'll grab a few lines from the excellent guide NetFoundry put out for integrating with Kubernetes. There's a section in that guide for installing Ziti with Helm . This comes down to just these steps: install the helm CLI tool using this guide add the NetFoundry helm repo: helm repo add netfoundry https://netfoundry.github.io/charts/ locate the jwt file for the Kubernetes identity. If you followed the steps above the file will be named: \"${the_kubernetes_identity}\".jwt (make sure you replace the variable with the correct value) use the jwt to add Ziti: helm install ziti-host netfoundry/ziti-host --set-file enrollmentToken=\"${the_kubernetes_identity}\".jwt (again make sure you replace the variable name) If you need to, make sure you create a persistent volume. The ziti pod requires storage to store a secret. ```bash apiVersion: v1 kind: PersistentVolume metadata: name: ziti-host-pv labels: type: local spec: storageClassName: oci capacity: storage: 100Mi accessModes: ReadWriteMany hostPath: path: \"/netfoundry\" ``` Add/Enroll the Client Identity Now consume the one time token (the jwt file) to enroll and create a client-side identity using the Ziti Desktop Edge for Windows (or MacOS or via the ziti-edge-tunnel if you prefer). Once you can see the identity in your tunneling app, you should be able to use the private kubernetes config file to access the same exact cluster. Remember though, we have mapped the port on the client side to use 443. That means you'll need to update your config file and change 6443 --> 443. Now when you run get pods you'll see the ziti-host pod deployed: export KUBECONFIG=/tmp/oci/config.oci.private kubectl get pods NAME READY STATUS RESTARTS AGE ziti-host-976b84c66-kr4bc 1/1 Running 0 90m The Big Finale - Zitified kubectl If you have made it this far, you've seen us access the Kubernetes API via the public IP. We've even accessed it via the private IP (which btw - is pretty cool in my opinion!). Now we're going to download the zitified kubectl command, turn off the public IP and even turn off the locally running tunneling app and still access the API! Disable the cluster's public IP address in OKE (go to the cluster in Oracle Cloud, click Edit and remove the public IP and click save) Turn off the Ziti Desktop Edge for Windows Download kubeztl (you don't need to call the executable kubeztl - you can keep it named kubectl if you want) bash curl -L -o kubeztl https://github.com/openziti-incubator/kubectl/releases/download/v0.0.4/kubectl-linux-amd64 Use kubeztl to get pods! bash ./kubeztl get pods -c id.json -S k8s.oci NAME READY STATUS RESTARTS AGE ziti-host-976b84c66-kr4bc 1/1 Running 0 101m ### Modifying KUBECONFIG The kubeztl command has also been modified to allow you to add the service name and config file directly into the file itself. This is convenient since you will not need to supply the ziti identity file, nor will you need to specify which service to use. Modifying the file is straight-forward. Open the config file, find the context listed under the contexts root and add two rows as shown here. contexts - context: cluster: cluster-cjw4arxuolq user: user-cjw4arxuolq zConfig: /tmp/oci/k8s.id.json service: k8s.oci Once done - you can now simply use the context the same way you have always - kubeztl get pods !!! ./kubeztl get pods NAME READY STATUS RESTARTS AGE ziti-host-976b84c66-kr4bc 1/1 Running 0 114m Conclusion We've seen in this post how you can not only secure your Kubernetes API with the normal Kubernetes mechanisms. You can also take your Kubernetes API off the internet ENTIRELY . No need to deploy and maintain a special bastian node. Now by having a secure, zero-trust overlay in place you can safely and securely access your Kubernetes API without the fear of that public, high-value API getting attacked. Once you've deployed Ziti into the Kubernetes cluster you're not done there. Now you can also use Ziti to span cloud networks. You can use it to easily link private data centers or other private Kubernetes clusters all into one secure, zero-trust overlay network! Use Ziti to expose workloads that are TRULY private! In future articles we might explore how we can bring Ziti to bear on these topics, stay tuned!"
  },
  "articles/zitification/prometheus/part1.html": {
    "href": "articles/zitification/prometheus/part1.html",
    "title": "Enable Prometheus to Scrape Anything from Anywhere | Ziti",
    "keywords": "Enable Prometheus to Scrape Anything from Anywhere This is part one of a three-part article. This article provides the necessary background and rationale of the series. The next article will be a detailed explanation of the actual steps necessary to implement the solution. In the final article , we will explore what we have just created and understand what was just created The Problem With Pulling Prometheus is a server which wants to reach out and pull data from \"scrape targets\". It will generally do this using http requests. One problem with this design is that these targets are often inaccessible, hidden from Prometheus behind a firewall. If not hidden, it means some port was exposed on some network, thereby giving Prometheus the ability to pull the data it needs. Exposing that port on a \"trusted\" network is a possible attack vector for bad actors. Exposing that port on the open internet (as is often the case) is an open invitation for attack. It's much better to keep these servers totally dark to all networks. OpenZiti solves this problem of reach elegantly and natively while also keeping your service dark to all networks. This gives an OpenZiti-enabled Prometheus the ability to literally scrape any target, anywhere. As long as the target is participates on an OpenZiti overlay network, and as long as the proper polices are in place allowing the traffic to flow, Prometheus will be able to reach out and pull the data it needs from anything, anywhere. It doesn't matter if the target is in some private cloud data center, some private data center protected by a corporate firewall, or heck even running inside my local docker environment! As long as the target participates on that OpenZiti Prometheus can scrape it! That sort of reach is impossible with classic networks. Prometheus Prometheus is an incredibly popular CNCF project which has graduated the gauntlet of progressions to emerge as a \"graduated\" CNCF project. If you're familiar with Prometheus, there are probably a couple of reasons people mainly choose to deploy it: metrics collection and visualization and alerting. Prometheus is also tremendously flexible. It has numerous available plugins and supports integrating with a wide number of systems. According to this CNCF survey , Prometheus leads the pack when it comes to the project people go to for observability. Its popularity is probably because Prometheus is a CNCF project and is often considered the \"default\" solution to deploy on another wildly popular CNCF project called Kubernetes . One interesting aspect of Prometheus is that it generally favors a poll-based approach to metrics collection instead of a push-based model. Poll-based? I don't know about you, but historically when I've thought about a metrics collection agent, I tend to think of an agent that reads a log file or some library that pushes rows into a giant data lake in the cloud. I don't generally think about a solution that implements poll-based metrics. Often, this is because the target of a poll-based collecting agent will probably be behind a firewall. As you would expect, firewalls make it exceptionally difficult to implement a poll-based solution as firewalls have been known to make a habit of preventing external actors from accessing random http servers behind it! After all, that is their primary function! The Prometheus project makes strong arguments explaining the benefits of a poll-based solution. They also realize that firewalls are important in creating a safe network and understand the challenges firewalls create for such a solution. To deal with these situations, the project also provides a PushGateway . This allows solutions to push their data to a location outbound of the firewall. Pushing data out of the firewall allows metrics and alerting to function without the worry (and maintenance heartache) of an open, inbound firewall hole. Acceptable Risk Prometheus is often deployed into Kubernetes clusters, but it can be deployed anywhere. Taking the operational differences out of the equation, there is little difference between deploying Prometheus in a Kubernetes cluster and deploying it in one's data center. Once deployed, the needs will be the same. Prometheus will need to be authorized to reach out and scrape the targets it needs to scrape. All too often, this is done with relatively open network permissions. Even though we all know it's not the most secure way of authorizing Prometheus, this is often considered \"safe enough\" because we deployed Prometheus into a zone considered \"safe\". Managing firewall rules to all the computers Prometheus needs access to, feels like an impossible feat. There are just too many. To add to our acceptable risk, we will need to be able to access the Prometheus server in some way. We'll want to get at the UI, see the charts and graphs and data it provides and use the server to its fullest. For that, we'll of course need a hole in our firewall, or in the case of Kubernetes we will probably deploy some form of Kubernetes Ingress Controller to provide users access the service. What we need are better and richer controls over our network. We need a better way of authorizing Prometheus without the hassle of maintaining firewall rules on individual machines. We also need a way to do this across multiple clouds, multiple Kubernetes clusters and multiple data centers. Let's see how OpenZiti can solve this problem while also enhancing our overall security. OpenZiti The OpenZiti project allows us to solve all the problems outlined above. It is a fully-featured, zero trust overlay network and enables zero trust networking principles to be applied anywhere. This includes bringing those zero trust principles directly into your application through one of the many SDKs provided by the project. Let's look at an example and see what a setup might look like before and after applying OpenZiti. Overview Let's imagine that we have already deployed a solution using two Kubernetes clusters, ClusterA and ClusterB. It doesn't matter where the clusters are deployed. We are trying to illustrate a real-world situation where we have two separate Kubernetes clusters that we want to manage. The clusters could be deployed in the same cloud provider, in a private data center, in different cloud providers, it really does not matter. What is important, is that these clusters are available over the network. To enable access to the workloads inside the clusters, some form of Kubernetes ingress controller will be required on both clusters. In our example, we will have a workload deployed which exposes a prometheus scrape target we want Prometheus to monitor. Figure 1 - Before OpenZiti Taking a Closer Look Looking at the diagram above with a discerning eye towards security, there are some immediate observations one can make. Listening Ports One observation we have already accepted from the overview, is that these clusters must be exposed via the internet. At first that doesn't seem like a big deal, we expose workloads like this to the internet all the time. This is a perfectly normal action, it's likely done every day somewhere in the world. It's so common, we almost don't even think about it until the time comes when we need to think about it. This ends up in an exposed port, listening somewhere in the world. There might be a firewall with complex rules to protect this port, but it's just as likely that this isn't the case. People might need to access the resources inside these clusters from anywhere. Kubernetes API Exposed Another observation is that the Kubernetes API is fully exposed to the internet. This API is a very high-value target and should be secured as strongly as possible. That probably means yet another complex firewall rule to maintain. \"Trusted\" Intra-cluster Traffic The final point to note is that the traffic within the cluster is considered safe. As mentioned above, the Prometheus server needs to be able to scrape the target workloads. That traffic is necessary to be considered safe. Also, notice that the pod for Prometheus contains a container named \"configmap-reload\" which is used to trigger a webhook on the Prometheus server when the Kubernetes config map changes. This is necessary when changing the Prometheus config, adding new scrape configs etc. Applying Zero Trust Networking Principles Using OpenZiti Now that we understand the basic setup and understand some possible problems, let's see if OpenZiti can address one or more of these issues. When applying OpenZiti, the goal will be to strengthen our security posture for each of the above items. Figure 2 - After OpenZiti Taking a Closer Look After OpenZiti No External Listening Ports With a classic deployment as shown in the initial design, we know there will be ports exposed to the open internet. In an ideal scenario, there would be absolutely no ports exposed on the open internet nor in the \"trusted networking zone\". It's immediately obvious after applying a solution using OpenZiti that those listening ports exposed by the Kubernetes ingress controller are no longer deployed and thus are no longer exposed to the internet. That's one attack vector eliminated. OpenZiti will initiate outbound mTLS connections among all the constituent pieces of the overlay network. This means connections will begin inside the trusted network zone and only create outbound links. Once established, those connections can be used to safely transfer data between any participating edge node. This capability really can't be emphasized enough. With OpenZiti and with applications that use an OpenZiti SDK, such as the ones shown, there are no open ports to attack. This network is nearly impervious to the classical \"land and expand\" technique so many bad actors look to exploit. Kubernetes API no Longer Exposed Another significant benefit provided by OpenZiti is starting to come into focus. By having access to our clusters provided through OpenZiti, we can stop exposing the Kubernetes APIs for both clusters to the open internet. Prometheus will still be able to monitor each Kubernetes cluster through the private Kubernetes network. Accessing Prometheus will be provided via OpenZiti, instead of using a Kubernetes ingress controller. Later, we can ues the built-in capability Prometheus already provides to federate information from the clusters to a centralized, zitified Prometheus server. Once no longer exposed to the open internet, to maintain our Kubernetes cluster we could then turn to zitified tools. The OpenZiti project provides zitified versions of kubectl - kubeztl and helm - helmz . Each of these tools have an OpenZiti SDK embedded inside them. This allows both tools to connect to the private Kubernetes API over the OpenZiti overlay network. To use them, you will need a strong, OpenZiti identity as well as be authorized to access the service. Also note that we're also not replacing the existing security constraints the Kubernetes ecosystem already provides. You can (and should) still secure your Kubernetes clusters using namespaces, roles, etc. We'll explore kubeztl and helmz in future articles. \"Trusted\" Intra-cluster Traffic Lastly, let's turn our eyes toward the traffic running inside the Kubernetes cluster. Pay attention to the lines in orange and the lines in dark blue. Orange lines represent \"private\" traffic, traffic that needs to traverse the private network space. At this point we cannot send traffic to the Kubernetes API via the overlay network. The Kubernetes API doesn't have an OpenZiti SDK embedded within it. That means when we deploy Prometheus into ClusterA and ClusterB to monitor the cluster, Prometheus will be forced to connect to a port exposed on the cluster's underlay network. Still, while not ideal, we have greatly improved the overall security posture of the cluster. We're no longer able to access the Kubernetes API without first gaining access to the zero trust overlay network. Accessing the Kubernetes API will also require the identity to be properly authorized to access the service attaching to the Kubernetes API. Let's now focus on ClusterA. It contains a Prometheus server that decided against listening on the OpenZiti overlay. This means it will need to expose ports to the Kubernetes underlay network. The container inside the Prometheus pod will watch for configmap changes. To trigger the webhook, it will be forced to send unauthenticated webhook traffic to the Prometheus server on the underlay network in order to trigger the config to reload. Still, accessing this cluster and the listening Prometheus server will require being on the OpenZiti overlay. Also, this Prometheus server does have an OpenZiti SDK built into it. We also deployed the \"reflectz\" workload with an OpenZiti SDK built into it as well. That means the Prometheus server must scrape the \"reflectz\" workload exclusively over the OpenZiti overlay. Only authorized identities can access that scrape data. Contrast ClusterA with ClusterB. ClusterB deployed a Prometheus server with an embedded OpenZiti SDK and chose to provide its services exclusively on the OpenZiti overlay. We've also deployed a zitified \"reflectz\" workload here. Notice how little traffic traverses the Kubernetes cluster underlay network. The only traffic which needs to traverse the cluster's underlay network in ClusterB is the traffic which monitors the Kubernetes API. All other traffic in the cluster is now secured by the OpenZiti overlay network. You will need a strong identity, and you will need to be authorized on the overlay before even being allowed to connect to the target service. OpenZiti-Enabled Prometheus We are now coming to the final piece of the puzzle. We have protected both Kubernetes clusters using OpenZiti. Now we want to bring all this data back to a centralized Prometheus server to make it easier on our user base. To do this, we'll again deploy an OpenZiti-enabled Prometheus server. This time we don't care where it is deployed except that we know we are not deploying it into either of the Kubernetes clusters we are already using. Since the Prometheus servers are all now accessible via the overlay network, we can literally deploy our server anywhere in the world. It could be on development server, it could be deployed in some other cloud, it could be deployed in our private data center. Because it's part of the overlay network, it no longer matters where we deploy the server. Wherever deployed, all it will need is outbound internet access, a strong identity, and access and authorization to services defined in the OpenZiti overlay network. Once that's done, OpenZiti will take care of the rest. If you have made it this far you're might want to try all this for yourself. The next article will go into the details necessary to implement this solution. When complete you'll be able to deploy a zitified version of Prometheus and give Prometheus the power to scrape anything from anywhere using OpenZiti."
  },
  "articles/zitification/prometheus/part2.html": {
    "href": "articles/zitification/prometheus/part2.html",
    "title": "Configuring OpenZiti to Enable Prometheus | Ziti",
    "keywords": "Configuring OpenZiti to Enable Prometheus .leftdiv { width: 110px; height: 150px; object-fit: cover; display: block; margin-left: auto; margin-right: auto; float: left; } .leftdiv img { height: 220px; width: 210px; margin-top: -35px; } .rightdiv { width: 110px; height: 150px; object-fit: cover; display: block; margin-left: auto; margin-right: auto; float: right; } .rightdiv img { height: 220px; width: 210px; margin-top: -35px; } .flr { float: right; } This is part two of a three-part article. This article provides the technical deep dive into the steps necessary to implement the vision outlined in part one . This article will be heavy on OpenZiti CLI commands, explaining what we are doing to configure the overlay network, and why. In the final article , we will explore what we have just created and understand what was just created Goals Incredibly easy to deploy Prometheus servers No ports exposed to the internet Prometheus servers can be deployed listening on the overlay, not on the underlay Private Kubernetes API Zitified Prometheus As described in the previous article , Prometheus really prefers to be able to gather metrics from the targets it is monitoring. When the target is behind a firewall, you will be left with two choices. You can choose to open a hole in the firewall granting access (a generally bad idea), or you can use a PushGateway. Even if you choose to use the PushGateway, Prometheus will still need to be able to access and pull from the PushGateway so you'll still need some port open and listening for Prometheus to collect data. What we really want is to enable Prometheus to scrape data from targets without needing to expose any ports to the internet. It would be ** even better** if we didn't have to expose any ports at all, even to the local \"trusted\" network. This capability is something that is unique to an OpenZiti-enabled application. You can take an OpenZiti SDK and embed it into your application, and give your app zero trust superpowers! If we take an OpenZiti SDK and embed it into Prometheus, we can give Prometheus the superpower of invisibility and addressability. Embedding an OpenZiti SDK produces a zitified version of Prometheus. With an OpenZiti-powered Prometheus, no ports need to be open. The OpenZiti project has done the work to produce an OpenZiti-enabled version of Prometheus. It's also entirely open source. Check it out from the OpenZiti Test Kitchen hosted on GitHub https://github.com/openziti-test-kitchen/prometheus . Solution Overview As you'll recall from part1 , we are trying to use Prometheus to monitor workloads in two different Kubernetes clusters. We are going to deploy one cluster which will represent a first step of an OpenZiti solution. It will use a Prometheus sever which is OpenZiti-enabled, but it will still listen on the underlay network and be available to local devices on an ip:port. This Prometheus server will use OpenZiti to scrape targets which are available anywhere on the OpenZiti overlay network and we'll refer to this as \"ClusterA\". We'll also deploy a second OpenZiti-enabled Prometheus server, in a totally separate Kubernetes cluster. This Prometheus server will not listen on an ip:port. Instead, it will listen exclusively on the OpenZiti overlay. This Prometheus server will have no ports available to attack and will only be accessible via a properly authorized and authenticated OpenZiti client. This will be our \"ClusterB\" Finally, we'll stand up a third Prometheus server and use it to federate metrics back to a \"central\" Prometheus server. This emulates what one might do to provide a central location for humans to go to in order to visualize data or use the Prometheus server. We won't care where this is deployed, we'll actually deploy it in locally and then move it to a private server in AWS just to show how easy it that is. This is what the solution we'll build looks like: Digging In Let's get to work and build this solution. We'll need some legwork done first. Note It's going to get deep in this article with CLI commands. You'll see what the OpenZiti objects are that get created and learn why. You might not want to replicate the solution on your own and instead are looking for \"the big reveal\". If that describes you, just skim this article lightly and get on to part3 . In part 3 we'll explore the deployed solution and see what makes it so interesting and cool. Prerequisites You have an OpenZiti overlay network available. If not, for this scenario you will want to use \"host your own\" . You'll also want to have the ziti cli tool on your path Two Kubernetes clusters provisioned Necessary tooling installed and available on the path kubectl helm bash/zsh shell - tested in bash and some commands will use variables. If you use another shell, change accordingly a machine with docker installed to run the final Prometheus sever on (your local machine is fine) Ziti Desktop Edge installed on the development machine. I use Ziti Desktop Edge for Windows . A temporary folder exists to house files as we need them: /tmp/prometheus ClusterA - Using ziti-host We start with an empty OpenZiti network, and two empty Kubernetes clusters. Let's start by populating ClusterA. We will deploy three pods into this Kubernetes cluster. When done, the Kubernetes cluster will look similar to the image to the right. Pod 1. ziti-host . This pod will provide what is effectively the equivalent of a Kubernetes ingress controller. We'll install this using helm from a NetFoundry provided chart Pod 2. prometheuz . This pod will be our Prometheus server with OpenZiti embedded in it. We won't use OpenZiti to listen on the overlay network. Instead, we will follow a more traditional model of listening on the underlay at a known ip:port combination. We'll install this pod using a chart from the OpenZiti charts repository. Pod 3. reflectz . This pod represents the workload which we want to monitor. This is another chart provided by the OpenZiti chart repository and will also be installed with hlem. If you are interested in viewing the source code for this project you can find it on GitHub here Note Running the ziti cli commands shown below as shown will expect you to have the ziti binary on your path. Also it is expected that all the comands run will run from the same \"development\" machine with the expected tools available. Reach out on discourse if you get stuck. Pod 1 - ziti-host We will start off deploying Pod 1, ziti-host, to provide access to Kubernetes ClusterA. The ziti-host pod will require a single identity to be provisioned. We will use a shortened name for the cluster and we'll embed that name into the identity to make it easier for us to understand what identity we provisioned and why, should we ever need to reference these identities later. We'll refer to ClusterA as simply \"kubeA\". Let's make the identity now. Notice we are also passing the \"-a\" attribute during creation to add a role attribute to the identity of kubeA.services . This will be used later when setting up policies. Create the Identity ziti edge create identity device kubeA.ziti.id -o /tmp/prometheus/kubeA.ziti.id.jwt -a \"kubeA.services\" You should see confirmation output such as: New identity kubeA.ziti.id created with id: BeyyFUZFDR Enrollment expires at 2022-04-22T01:18:53.402Z Deploy ziti-host into ClusterA Once created, we can use helm to install the ziti-host pod. The jwt is a one-use token and will be useless after being consumed by ziti-host . As this is probably your first time running this helm chart, you will need to install it. The command is idempotent to running it over and over is of no concern. Run the following: helm repo add netfoundry https://netfoundry.github.io/charts/ helm repo update helm install ziti-host netfoundry/ziti-host --set-file enrollmentToken=\"/tmp/prometheus/kubeA.ziti.id.jwt\" You will see the confirmation output from helm. Now when you look at your Kubernetes cluster with kubectl , you will see a pod deployed: kubectl get pods NAME READY STATUS RESTARTS AGE ziti-host-db55b5c4b-rpc7f 1/1 Running 0 2m40s Awesome, we have our first deployed pod. It's useless at the moment as we have defined no services, nor authorized any services. Right now there's nothing to connect to, so we can simply move on and install the next pod, reflectz . Pod 2 - reflectz The first pod we want to have access to is the reflectz pod. It is a workload we will deploy that will do two things. First, it will listen on the OpenZiti overlay network for connections. When a connection is made, and when bytes are sent, the workload sill simply return back to the caller whatever was sent to it adding \"you sent me: \" to the payload. It's not much, but it's a demo after all. The second service provided is a scrape target for Prometheus. There is one metric exposed by reflectz we will care about, the total number of connections established to this workload. This pod also needs an identity provisioned, and this time around we will also provision some services. We will also use the ziti cli to enroll this identity. This helm chart wants you to provide an enrolled identity as part of the helm command. Let's do all this now. Create and Enroll the Identity ziti edge create identity user kubeA.reflect.id -o /tmp/prometheus/kubeA.reflect.id.jwt ziti edge enroll /tmp/prometheus/kubeA.reflect.id.jwt -o /tmp/prometheus/kubeA.reflect.id.json Create Configs and Services (including Tunneling-based Access) The reflectz chart also needs two services to be declared and specified at the time of the helm chart installation. We will want to be able to test the service to ensure they work. To enable testing the services, we will create two configs of type intercept.v1 . This will allow identities using tunneling apps to be able to access the services, this is how we'll verify the services work. Make the configs and services now. # create intercept configs for the two services ziti edge create config kubeA.reflect.svc-intercept.v1 intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"kubeA.reflect.svc.ziti\"],\"portRanges\":[{\"low\":80, \"high\":80}]}' ziti edge create config \"kubeA.reflect.svc-intercept.v1.scrape\" intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"kubeA.reflect.scrape.svc.ziti\"], \"portRanges\":[{\"low\":80, \"high\":80}], \"dialOptions\":{\"identity\":\"kubeA.reflect.id\"}}' # create the two services ziti edge create service \"kubeA.reflect.svc\" --configs \"kubeA.reflect.svc-intercept.v1\" -a \"kubeA.reflect.svc.services\" ziti edge create service \"kubeA.reflect.scrape.svc\" --configs \"kubeA.reflect.svc-intercept.v1.scrape\" Authorize the Workload and Clients Services are not valuable if there are no identities which can use the services. The identity used in the helm installation will also need to be authorized to bind these services. Tunneling apps will need to be authorized to dial these services but also remember Prometheus servers will need to be able to dial these services too. We will now create service-policies to authorize the tunneling clients, Prometheus scrapes, and the reflectz server to bind the service. # create the bind service policies and authorize the reflect id to bind these services ziti edge create service-policy \"kubeA.reflect.svc.bind\" Bind \\ --service-roles \"@kubeA.reflect.svc\" --identity-roles \"@kubeA.reflect.id\" ziti edge create service-policy \"kubeA.reflect.scrape.svc.bind\" Bind \\ --service-roles \"@kubeA.reflect.scrape.svc\" --identity-roles \"@kubeA.reflect.id\" # create the dial service policies and authorize the reflect id to bind these services ziti edge create service-policy \"kubeA.reflect.svc.dial\" Dial \\ --service-roles \"@kubeA.reflect.svc\" --identity-roles \"#reflectz-clients\" ziti edge create service-policy \"kubeA.reflect.svc.dial.scrape\" Dial \\ --service-roles \"@kubeA.reflect.scrape.svc\" --identity-roles \"#reflectz-clients\" Deploy reflectz With the identity enrolled, we can now install the helm chart from openziti, and install our demonstraction workload: reflectz . Notice that to deploy reflectz we need to supply an identity to the workload using --set-file reflectIdentity . This identity will be used to 'Bind' the services the workload exposes. We also need to define what the service names are we want to allow that identity to bind. We do this using the --set serviceName and --set prometheusServiceName flags. helm repo add openziti-test-kitchen https://openziti-test-kitchen.github.io/helm-charts/ helm repo update helm install reflectz openziti-test-kitchen/reflect \\ --set-file reflectIdentity=\"/tmp/prometheus/kubeA.reflect.id.json\" \\ --set serviceName=\"kubeA.reflect.svc\" \\ --set prometheusServiceName=\"kubeA.reflect.scrape.svc\" After running helm, pod 2 should be up and running. Let's take a look using kubectl kubectl get pods NAME READY STATUS RESTARTS AGE reflectz-775bd45d86-4sjwh 1/1 Running 0 7s ziti-host-db55b5c4b-rpc7f 1/1 Running 0 4m Pod 3 - Prometheuz Overlay Work - Setting Up OpenZiti Now we have access to the cluster and a workload to monitor. Now we want to deploy Prometheus and monitor this workload. Remember that the workload only exposes a scrape target over the OpenZiti overlay. For Prometheus to be able to scrape the workload, even when resident inside the Kubernetes cluster (!), Prometheus will need to be OpenZiti-enabled. That will require a few things. We'll need a new identity for Prometheus, we'll need to authorize Prometheus to access the workload's target, and we'll need to configure Prometheus to scrape that workload. When we create this identity we'll assign two attributes. The reflectz-clients attribute gives this identity the ability to dial the two services defined above. The prometheus-clients attribute is currently unused. We'll put that to use later, but we can define it now. Create and Enroll the Identity # create and enroll the identity. ziti edge create identity user kubeA.prometheus.id -o /tmp/prometheus/kubeA.prometheus.id.jwt -a \"reflectz-clients\",\"prometheus-clients\" ziti edge enroll /tmp/prometheus/kubeA.prometheus.id.jwt -o /tmp/prometheus/kubeA.prometheus.id.json Create Configs and Services (including Tunneling-based Access) # create the config and service for the kubeA prometheus server ziti edge create config \"kubeA.prometheus.svc-intercept.v1\" intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"kubeA.prometheus.svc\"],\"portRanges\":[{\"low\":80, \"high\":80}]}' ziti edge create config \"kubeA.prometheus.svc-host.v1\" host.v1 \\ '{\"protocol\":\"tcp\", \"address\":\"prometheuz-prometheus-server\",\"port\":80}' ziti edge create service \"kubeA.prometheus.svc\" \\ --configs \"kubeA.prometheus.svc-intercept.v1\",\"kubeA.prometheus.svc-host.v1\" Authorize the Workload and Clients # grant the prometheus clients the ability to dial the service and the kubeA.prometheus.id the ability to bind ziti edge create service-policy \"kubeA.prometheus.svc.dial\" Dial \\ --service-roles \"@kubeA.prometheus.svc\" \\ --identity-roles \"#prometheus-clients\" ziti edge create service-policy \"kubeA.prometheus.svc.bind\" Bind \\ --service-roles \"@kubeA.prometheus.svc\" \\ --identity-roles \"@kubeA.ziti.id\" Deploying Prometheuz With our services, configs and service-policies in place we are now ready to start our Prometheus server. Remember this server will not listen on a the OpenZiti overlay. It's going to listen exclusively on the underlay. We are still exploring OpenZiti, and we are not yet comfortable deploying our Prometheus server dark. We'll change this soon, don't worry. For now, we'll imagine that we're still evaluating the tech and chose to deploy it on the underlay, not on the overlay. Although Prometheus is listening on the underlay, we have deployed our workload listening on the overlay network. It won't be available on the underlay at all. The workload has no listening ports . This means that we'll still need an OpenZiti-enabled Prometheus to access and scrape that workload. To do this we'll use helm, and use a chart provided by the OpenZiti charts repo. Some interesting things to notice below in the helm install command. Notice that we are passing helm two --set parameters. These parameters are informing the helm chart that the Prometheus server is not \"zitified\", meaning it will be accessible via the underlay network. We're also passing one --set-file parameter to tell Prometheus what identity we want to be stored in the pod (as a secret). This secret will be used when we configure Prometheus to scrape the workload. Go ahead and run this command now and run kubectl get pods until all the containers are running. helm repo add openziti-test-kitchen https://openziti-test-kitchen.github.io/helm-charts/ helm repo update helm install prometheuz openziti-test-kitchen/prometheus \\ --set server.ziti.enabled=\"false\" \\ --set-file server.scrape.id.contents=\"/tmp/prometheus/kubeA.prometheus.id.json\" ClusterB - Fully Dark Now that we have deployed our first Kubernetes cluster, it's now time to deploy the second Kubernetes cluster. This time, we are going to keep our entire deployment fully dark ! There will be no listening ports, not even local to the Kubernetes cluster itself. To get any traffic to this Prometheus server, you will need a strong identity and need to be authorized on the OpenZiti overlay. When complete, ClusterB will look like the image to the right. This time, \"Pod1\" will be the reflectz workload. Since this is a fully dark deployment, listening entirely on the OpenZiti overlay, we won't need a ziti-host pod. Remember, in ClusterA ziti-host is used to provide internal access to the Kubernetes cluster via the OpenZiti overlay. It's similar in role to an ingress controller, but doesn't require you to expose your workloads to the internet. While that's pretty good we want to go fully dark this time. We'll have no ziti-host . We'll only need to deploy two pods: reflectz and prometheuz . The good news is that the same commands you've run for ClusterA, will mostly be used for ClusterB. You will want to beware that where you used \"kubeA\" before, make sure you change those to \"kubeB\". There will be small other changes we'll make along the way too, we'll see those changes and explain them below. Pod1 - reflectz The relectz workload we'll deploy for ClusterB will be nearly identical to the ClusterA workload. We will create a service for the actual 'reflect' service. We will make a service for Prometheus to scrape the workload. We'll also need another identity, so we'll create that identity, authorize it to bind the services, and authorize clients to access the workload. Since this process is very similar to what we did for ClusterA, there's not much to explain. Setup ClusterB's reflectz now. Create the Identity ziti edge create identity user kubeB.reflect.id -o /tmp/prometheus/kubeB.reflect.id.jwt ziti edge enroll /tmp/prometheus/kubeB.reflect.id.jwt -o /tmp/prometheus/kubeB.reflect.id.json Create Configs and Services (including Tunneling-based Access) # create intercept configs for the two services ziti edge create config kubeB.reflect.svc-intercept.v1 intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"kubeB.reflect.svc.ziti\"],\"portRanges\":[{\"low\":80, \"high\":80}]}' ziti edge create config \"kubeB.reflect.svc-intercept.v1.scrape\" intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"kubeB.reflect.scrape.svc.ziti\"], \"portRanges\":[{\"low\":80, \"high\":80}], \"dialOptions\":{\"identity\":\"kubeB.reflect.id\"}}' # create the two services ziti edge create service \"kubeB.reflect.svc\" --configs \"kubeB.reflect.svc-intercept.v1\" -a \"kubeB.reflect.svc.services\" ziti edge create service \"kubeB.reflect.scrape.svc\" --configs \"kubeB.reflect.svc-intercept.v1.scrape\" Authorize the Workload to Bind the Services # create the bind service policies and authorize the reflect id to bind these services ziti edge create service-policy \"kubeB.reflect.svc.bind\" Bind \\ --service-roles \"@kubeB.reflect.svc\" --identity-roles \"@kubeB.reflect.id\" ziti edge create service-policy \"kubeB.reflect.scrape.svc.bind\" Bind \\ --service-roles \"@kubeB.reflect.scrape.svc\" --identity-roles \"@kubeB.reflect.id\" Authorize Clients to Access the Services # create the dial service policies and authorize the reflect id to bind these services ziti edge create service-policy \"kubeB.reflect.svc.dial\" Dial \\ --service-roles \"@kubeB.reflect.svc\" --identity-roles \"#reflectz-clients\" ziti edge create service-policy \"kubeB.reflect.svc.dial.scrape\" Dial \\ --service-roles \"@kubeB.reflect.scrape.svc\" --identity-roles \"#reflectz-clients\" Deploy reflectz helm repo add openziti-test-kitchen https://openziti-test-kitchen.github.io/helm-charts/ helm repo update helm install reflectz openziti-test-kitchen/reflect \\ --set-file reflectIdentity=\"/tmp/prometheus/kubeB.reflect.id.json\" \\ --set serviceName=\"kubeB.reflect.svc\" \\ --set prometheusServiceName=\"kubeB.reflect.scrape.svc\" Pod 2 - Prometheuz For ClusterB we want Prometheuz to be totally dark . It will exclusively listen on the OpenZiti overlay and there will be no listening ports on the underlay. We will need another identity, of course, and most of the configuration and commands appear the same on the surface with very subtle differences. We'll explore these differences as we go. In this section we'll be making an identity, one config (a difference from the ClusterA install), a service, and two service-policies. Let's get to it. Create the Identity ziti edge create identity user kubeB.prometheus.id -o /tmp/prometheus/kubeB.prometheus.id.jwt -a \"reflectz-clients\",\"prometheus-clients\" ziti edge enroll /tmp/prometheus/kubeB.prometheus.id.jwt -o /tmp/prometheus/kubeB.prometheus.id.json Create One Config and Service Here's a difference from ClusterA. Since we are going to listen on the OpenZiti overlay, we are not installing ziti-host . That means we don't need to create a host.v1 config. A host.v1 config is necessary for services which have a 'Bind' configuration and are being bound by a tunneling application. We're not doing that, here Prometheus will 'Bind' this service, thus we don't need that host.v1 config. # create the config and service for the kubeB prometheus server ziti edge create config \"kubeB.prometheus.svc-intercept.v1\" intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"kubeB.prometheus.svc\"],\"portRanges\":[{\"low\":80, \"high\":80}], \"dialOptions\": {\"identity\":\"kubeB.prometheus.id\"}}' # no need for the host.v1 config ziti edge create service \"kubeB.prometheus.svc\" \\ --configs \"kubeB.prometheus.svc-intercept.v1\" Authorize Clients and Prometheus to Bind the Service At first, these commands appear identical. You need to look very closely to notice the difference between these command and the ones we ran for ClusterA, other than the obvious changes from \"kubeA\" to \"kubeB\". Pay close attention to the supplied --identity-roles for the bind policy specified below. With ClusterA, we did not have Prometheus listen on the overlay and we allowed Prometheus to listen on the underlay. That meant we needed to deploy ziti-host into that cluster to provide access to the service, and that means the service had to be bound by the ziti-host identity. Here we are flipping that script. We are allowing Prometheus to bind this service! That means we'll need to authorize the kubeB.prometheus.id to be able to bind the service. # grant the prometheus clients the ability to dial the service and the kubeB.prometheus.id the ability to bind ziti edge create service-policy \"kubeB.prometheus.svc.dial\" Dial \\ --service-roles \"@kubeB.prometheus.svc\" \\ --identity-roles \"#prometheus-clients\" ziti edge create service-policy \"kubeB.prometheus.svc.bind\" Bind \\ --service-roles \"@kubeB.prometheus.svc\" \\ --identity-roles \"@kubeB.prometheus.id\" Deploying Prometheuz At this point we have the OpenZiti overlay all configured. What's left, is to deploy Prometheus into ClusterB. This command is substantially different from what we ran while deploying Prometheus into ClusterA. You'll see that we need to supply two other identities for this installation. Remember, Prometheus will be entirely dark once deployed into ClusterB, listening only on the OpenZiti overlay. The container in the pod which monitors configmap changes won't be able to trigger a webhook using the underlay! This configmap-reloadz is a second \"zitification\" we didn't realize we were deploying in ClusterA, because we did not need it. We need it for ClusterB. You'll see for configmapReload we need to supply the identity which the container will use to hit the Prometheus webhook. We do that by passing --set-file configmapReload.ziti.id.contents=\"/tmp/prometheus/kubeB.prometheus.id.json\" . Then we'll supply the service which configmap-reloadz will dial, and we'll also specify what identity we expect to be hosting the service. Next you'll see we need to supply the identity to the Prometheus server we want to allow to listen on the OpenZiti overlay ( -set-file server.ziti.id.contents ). Similar to configmap-reloadz we will also specify the service and identity name to bind. Finally, to allow the server to scrape targets we need to supply a final identity which will be used when scraping targets with --set-file server.scrape.id.contents . You'll notice for simplicities sake, we are using the same identity for all three needs which is perfectly fine. If you wanted to use a different identity, you could. That choice is up to you. To keep it simple we just authorized this identity for all these purposes. # install prometheus helm repo add openziti-test-kitchen https://openziti-test-kitchen.github.io/helm-charts/ helm repo update helm install prometheuz openziti-test-kitchen/prometheus \\ --set-file configmapReload.ziti.id.contents=\"/tmp/prometheus/kubeB.prometheus.id.json\" \\ --set configmapReload.ziti.targetService=\"kubeB.prometheus.svc\" \\ --set configmapReload.ziti.targetIdentity=\"kubeB.prometheus.id\" \\ --set-file server.ziti.id.contents=\"/tmp/prometheus/kubeB.prometheus.id.json\" \\ --set server.ziti.service=\"kubeB.prometheus.svc\" \\ --set server.ziti.identity=\"kubeB.prometheus.id\" \\ --set-file server.scrape.id.contents=\"/tmp/prometheus/kubeB.prometheus.id.json\" What's Next In this article we've done a lot of OpenZiti CLI work, run some kubectl and helm commands but we still haven't explored what it is we are building and why it's so cool. We'll do that in the last, and final article. Hopefully, the payoff for you will be as rewarding as it was for me while building this article series. Addendum - a Quicker Start All the commands above are also available in github as .sh scripts. If you would prefer, you can clone the ziti-doc repository and access the scripts from the path mentioned below. \"Cleanup\" scripts are provided if desired. ${checkout_root}/docfx_project/articles/zitification/prometheus/scripts"
  },
  "articles/zitification/prometheus/part3.html": {
    "href": "articles/zitification/prometheus/part3.html",
    "title": "Scraping Anything, Anywhere in Action | Ziti",
    "keywords": "Scraping Anything, Anywhere in Action .flr { float: right; } This is part three of a three-part article. This article builds on the previous two articles. Here we will take a look at what we built and use it to explore the power of a zitified Prometheus. See part one for the necessary background about the series. See part two for detailed instructions covering how to setup the environment you're about to explore The Payoff Ok. Here it is. We are at the end of the series and here is where we'll put it all together and really start to understand the sort of innovations you can create when you zitify an application. As a reminder, we are working with Prometheus , a CNCF project which we will use to monitor a workload deployed in two separate Kubernetes clusters. To save you from flipping back to a previous article, here is what that solution looks like. Now we are ready to start using our Prometheus servers. We'll use our OpenZiti overlay network to connect to a workload which will generate a metric we want to display in Prometheus. We'll then configure Prometheus to scrape the workload and put it on a graph to prove it works. Once that's complete, we'll play around with the setup and see if we really can scrape anything, anywhere. Let's begin. Developer Access In the previous article , we established our entire solution using the OpenZiti overlay, kubectl and helm . We saw everything get installed and it all \"seems to work\". But how do we know it works? Let's provision an identity for yourself now and let's enroll it in your local tunneling app and find out. Go out and get a tunneling client running locally. Once you have that installed, provision an identity and enroll it with your tunneling client. ziti edge create identity user dev.client -a \"prometheus-clients\",\"reflectz-clients\" You should have access to six total services when this identity is enrolled: Service Name: kubeA.prometheus.svc Intercept: kubeA.prometheus.svc:80 Service Name: kubeA.reflect.svc Intercept: kubeA.reflect.svc.ziti:80 Service Name: kubeA.reflect.scrape.svc Intercept: kubeA.reflect.scrape.svc.ziti:80 Service Name: kubeB.prometheus.svc Intercept: kubeB.prometheus.svc:80 Service Name: kubeB.reflect.svc Intercept: kubeB.reflect.svc.ziti:80 Service Name: kubeB.reflect.scrape.svc Intercept: kubeB.reflect.scrape.svc.ziti:80 ClusterA With your developer access you should be able to navigate your browser to http://kubea.prometheus.svc/targets . Note We won't dwell on this for long in this article but notice that this is showing off another superpower of OpenZiti, private DNS. Notice that you were able to browse to a totally fictious domain name: kubea.prometheus.svc. \".svc\" is not a legitimate top level domain. Look at the full list of top level domains starting with S . You won't find \".svc\" on that list at this time You should see the following. You might have noticed that the chart deployed has a few other containers we have not discussed yet. We'll not go into those containers in this article. What's important is that this Prometheus server has a few targets already for us to access. Neat, but this isn't what we want to actually monitor. What we really want to monitor is the workload we deployed: reflectz . We can do this by editing the Prometheus configmap using kubectl . Let's go ahead and do this now: kubectl edit cm prometheuz-prometheus-server This will open an editor in your terminal and allow you to update the config map for the pod. Once the editor is open, find the section labeled \"scrape_config\" and add the following entry: - job_name: 'kubeA.reflectz' scrape_interval: 5s honor_labels: true scheme: 'ziti' params: 'match[]': - '{job!=\"\"}' 'ziti-config': - '/etc/prometheus/scrape.json' static_configs: - targets: - 'kubeA.reflect.scrape.svc-kubeA.reflect.id' This is yaml and yaml is sensitive to spaces. The block above is properly indented for the config that the helm chart installs. You should be able to simply copy it and add it under the scrape_config. Remember, there is a configmap-reload container in the pod which monitors the configmap. On successful edit, this container will notice and will issue a web hook to the prometheus-server container. The trigger is not immediate, don't worry if it takes a while. It can take around a minute for the trigger to fire. While we wait for the trigger, let's explain what this is doing. This is informing the Prometheus server to monitor a workload which can be found at the provided target of kubeA.reflect.scrape.svc-kubeA.reflect.id . Notice that no port is included in this target, and also notice that this is a very strange looking FQDN. That's because this is a zitified version of Prometheus. We have extended Prometheus to understand a \"scheme\" of ziti . When we configure this job with a scheme of ziti, we can then supply targets to the job which represent an OpenZiti service. We need to supply the ziti-config node with the path to the identity we want Prometheus to use to issue the scrape. This will always be /etc/prometheus/scrape.json at this time. Should the community desire it, we can look into changing the location of the identity. If you would like to tail the configmap-reloadz container, you can issue this one liner. This will instruct kubectl to tail the logs from configmap-reloadz . pod=$(kubectl get pods | grep server | cut -d \" \" -f1); echo POD: $pod; kubectl logs -f \"$pod\" prometheus-server-configmap-reload When the trigger happens for ClusterA you will see a message like the one below. Notice that configmap-reloadz is using the underlay network: http://127.0.0.1:9090/-/reload 2022/04/23 20:01:23 config map updated 2022/04/23 20:01:23 performing webhook request (1/1/http://127.0.0.1:9090/-/reload) 2022/04/23 20:01:23 successfully triggered reload Config Reloaded Once you've correctly updated the configmap, and configmap-reloadz detected the change and told Prometheus to reload. You'll see a new target has been reported by Prometheus at http://kubea.prometheus.svc/targets . You should now see \"kubeA.reflectz (1/1 up)\" showing. Congratulations! You have just successfully scraped a target from zitified Prometheus! Remember this workload does not listen on the Kubernetes underlay network. It's only accessible from the OpenZiti overlay. Let's Graph It! Cool, we have a target. The target can be scraped by Prometheus over the OpenZiti overlay. We're also able to securely access the Prometheus UI over the same OpenZiti overlay. Let's use the Prometheus UI to graph the data point we want to see, the reflect_total_connections metric. Navigate to http://kubea.prometheus.svc/graph enter reflect_total_connections click Graph (notice I changed my time to '10s', located just under Graph) click Execute Notice there are no connections (0) Generate Some Data Now let's change that graph of reflect_total_connections from 0 to 1 (or more). One of the services you will have access to will intercept kubeA.reflect.svc.ziti:80 . Note If you are using Windows and Windows Subsystem for Linux (WSL) as I am, you might need to understand how get WSL to use your Ziti Desktop Edge for Windows as your DNS resolver when inside WSL. Generally speaking this is as easy as editing /etc/resolv.conf and adding the IP as the first nameserver: nameserver 100.64.0.1 (or whatever the DNS IP is). Try it first, depending on how you setup WSL it might 'just work' for you. You can also just use cygwin or any other netcat tool from Windows (not WSL) too. Now we can use netcat to open a connection through this intercept a few times. The metric tracks the total number of connections to the reflect service. Connect, send some text, the use ctrl-c to disconnect. Do that a few times then click 'execute' again on the graph page. You can see I did this over a minute and moved my total count on kubeA to 8, shown below. /tmp/prometheus$ nc kubeA.reflect.svc.ziti 80 kubeA reflect test you sent me: kubeA reflect test ^C /tmp/prometheus$ nc kubeA.reflect.svc.ziti 80 another reflect test you sent me: another reflect test ^C /tmp/prometheus$ nc kubeA.reflect.svc.ziti 80 another reflect test you sent me: another reflect test ^C Scrape Something Else Hopefully you agree with me that this is pretty neat. Well what if we take it to the next level? What if we tried to scrape the workload we deployed to ClusterB? Could we get that to work? Recall from above how we enabled the job named 'kubeA.reflectz'. What if we simply copied/pasted that into the configmap changing kubeA --> kubeB. Would it work? Let's see. # edit the configmap on ClusterA: kubectl edit cm prometheuz-prometheus-server #add the job - and wait for the configmap to reload - job_name: 'kubeB.reflectz' scrape_interval: 5s honor_labels: true scheme: 'ziti' params: 'match[]': - '{job!=\"\"}' 'ziti-config': - '/etc/prometheus/scrape.json' static_configs: - targets: - 'kubeB.reflect.scrape.svc-kubeB.reflect.id' After watching the logs from configmap-reloadz on ClusterA and seeing the webhook trigger. Just go back to the Prometheus server in the browser. You should be at the 'graph' url but if not navigate back and execute another graph for reflect_total_connections . When we do that it probably doesn't look much different but... Wait a second? In the legend? Can it be? That's right. From Kubernetes ClusterA, we have just scraped a workload from Kubernetes ClusterB, entirely over the OpenZiti overlay. Generate some data like you did before by running a few netcat connection/disconnects and click 'Execute' again. Don't forget to send the connection request to kubeB though! nc kubeB.reflect.svc.ziti 80 this is kubeb you sent me: this is kubeb ^C nc kubeB.reflect.svc.ziti 80 another to kube b you sent me: another to kube b ^C nc kubeB.reflect.svc.ziti 80 one more for fun and profit you sent me: one more for fun and profit ^C Scraping All the Things! By now, you are probably starting to get the idea just how powerful this is for Prometheus. A zitified Prometheus can scrape things easily and natively by just deploying a Prometheuz instance into the location you want to scrape. Or, you can just enable a scrape target using a tunneling app, or in Kubernetes using the ziti-host helm chart. Let's complete our vision now and stand up a Prometheus server on our local workstation using Docker. When we run Prometheuz locally using docker we'll need a config file to give to docker using a volume mount. We also provide the identity used to connect to the OpenZiti overlay in the same fashion. Let's start up a docker container locally and see if we can grab data from our two Prometheus instances using a locally deployed Prometheuz via docker. GitHub has a sample Prometheus file you can download . Below, I used curl to download it and put it into the expected location. curl -s https://raw.githubusercontent.com/openziti/ziti-doc/main/docfx_project/articles/zitification/prometheus/scripts/local.prometheus.yml > /tmp/prometheus/prometheus.config.yml ziti edge create identity user local.prometheus.id -o /tmp/prometheus/local.prometheus.id.jwt -a \"reflectz-clients\",\"prometheus-clients\" ziti edge enroll /tmp/prometheus/local.prometheus.id.jwt -o /tmp/prometheus/local.prometheus.id.json docker run \\ -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.id.json \\ -v /tmp/prometheus/prometheus.config.yml:/etc/prometheus/prometheus.yml \\ -p 9090:9090 \\ openziti/prometheuz Look at what we've just done. We have started a Prometheus instance locally, and used it to connect to four Prometheus targets via scrape configurations when all four targets are hidden entirely from my local computer (and any computer) unless the computer has an OpenZiti identity. I personally think that is incredibly cool! Taking it to 11 But wait, I'm not done. That docker instance is listening on an underlay network. It's exposed to attack by anything on my local network. I want to fix that too. Let's start this docker container up listening only on the OpenZiti overlay. Just like in part 2 we will make a config, a service and two policies to enable identities on the OpenZiti overlay. curl -s https://raw.githubusercontent.com/openziti/ziti-doc/main/docfx_project/articles/zitification/prometheus/scripts/local.prometheus.yml > /tmp/prometheus/prometheus.config.yml # create the config and service for the local prometheus server ziti edge create config \"local.prometheus.svc-intercept.v1\" intercept.v1 \\ '{\"protocols\":[\"tcp\"],\"addresses\":[\"local.prometheus.svc\"],\"portRanges\":[{\"low\":80, \"high\":80}], \"dialOptions\": {\"identity\":\"local.prometheus.id\"}}' ziti edge create service \"local.prometheus.svc\" \\ --configs \"local.prometheus.svc-intercept.v1\" # grant the prometheus clients the ability to dial the service and the local.prometheus.id the ability to bind ziti edge create service-policy \"local.prometheus.svc.dial\" Dial \\ --service-roles \"@local.prometheus.svc\" \\ --identity-roles \"#prometheus-clients\" ziti edge create service-policy \"local.prometheus.svc.bind\" Bind \\ --service-roles \"@local.prometheus.svc\" \\ --identity-roles \"@local.prometheus.id\" Once that's done - let's see if we can start the docker container. The helm charts are configured to translate the --set flags provided into \"container friendly\" settings like environment variables, volumes and mounts etc. In docker we need to provide those. If you're familiar with docker these will probably all make sense. The most important part of the command below is the lack of a -p flag. The -p flag is used to expose a port from inside docker, outside docker. Look at the previous docker sample and you'll find we were mapping local underlay port 9090 to port 9090 in the docker container. In this example, we will do no such thing ! :) docker run \\ -e ZITI_LISTENER_SERVICE_NAME=local.prometheus.svc \\ -e ZITI_LISTENER_IDENTITY_FILE=/etc/prometheus/ziti.server.json \\ -e ZITI_LISTENER_IDENTITY_NAME=local.prometheus.id \\ -v /tmp/prometheus/prometheus.config.yml:/etc/prometheus/prometheus.yml \\ -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.id.json \\ -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.server.json \\ openziti/prometheuz But - Does It Work? After configuring the OpenZiti overlay, we just need to open a browser and navigate to http://local.prometheus.svc/targets . SUCCESS! SUCCESS! Wrap Up This was quite the journey and a lot of fun. We have taken a wildly popular open source project and brought OpenZiti to it with really not much code at all. Then using OpenZiti we were able to give Prometheus superpowers and enable it to scrape any target regardless of where that target is or what network it is on. Think of the possibilities here. Are you a cloud provider looking to monitor your client's services which are deployed on-prem? That's so easy with OpenZiti and without sacrificing security at all . In fact, using OpenZiti like this provides amazing reach while strengthening the security posture of the solution because you're now using the concepts of zero trust networking principles and applying them to your alerting and monitoring solution. What do you think? Was this series interesting? Do you think OpenZiti is cool and you are looking to try it out? What are you going to zitify? Tell us on twitter or on discourse! Both links are included in this page. Let us know what you think! Go star the openziti/ziti repo and help us spread the word of OpenZiti to the world!"
  },
  "articles/zitification/zitifying-scp/index.html": {
    "href": "articles/zitification/zitifying-scp/index.html",
    "title": "Zitifying SCP | Ziti",
    "keywords": "Zitifying SCP In the previous post we talked about how we could take a well-known application and improve its security by zitifying it, producing zssh . The logical next step after zitifying ssh would be to extend the functionality of zssh to cover moving files securely as well, enter zscp . A zitified scp effectively creates a more secure command line tool for sending and receiving files between ziti-empowered devices. Once zitified, we can use zscp using ziti identity names just like we did in zitifying ssh . I recommend reading the previous article ) if you haven't to learn more about the benefits of zitifying tools like ssh and scp . First Things First zscp functions with the same prerequisites as zssh : Establish a Ziti Network Create and enroll two Ziti Endpoints (one for our ssh server, one for the client) the sshd server will run ziti-tunnel for this demonstration. Conveniently it will run on the same machine I used to setup the Ziti Network . the client, in this case, is my local machine and I'll zscp files both to and from both the remote machine. Create the Ziti Service we'll use and authorize the two endpoints to use this service Use the zscp binary from the client side and the ziti-tunnel binary from the serving side to connect Harden sshd further by removing port 22 from any internet-based firewall configuration (for example, from within the security-groups wizard in AWS) or by forcing sshd to only listen on localhost/127.0.0.1 After ensuring these steps are complete, you will have the ability to copy files across your Ziti Network. The traffic will be even more secure since now a Ziti Network is required for the connection, requiring that strong identity before even being able to access the sshd server. And of course now sshd is 'dark' - it no longer needs the typical port 22 to be exposed to any network. Given all the prerequisites are satisfied, we can put zscp to use. Simply download the binary for your platform: linux windows MacOs Sending and Receiving Files with Zscp Once you have the executable downloaded, make sure it is named zscp and for simplicity's sake we'll assume it's on the path. Just like zssh to ssh , zscp provides the same basic functionality as scp . As with most tooling, executing the binary with no arguments will display the expected usage. There are two main functions of zscp . Just like scp you can send and receive from the remote host. To send files we use this basic syntax: ./zscp LOCAL_FILEPATHS... <REMOTE_USERNAME>@TARGET_IDENTITY:REMOTE_FILEPATH Then, to retrieve remote files we use a similar syntax: ./zscp <REMOTE_USERNAME>@TARGET_IDENTITY:REMOTE_FILEPATH LOCAL_FILEPATH Below is a working example of using zscp to send a file to a remote machine. In this case the remote username is not the same as my local username. Just like with scp , I'll need to supply the username in my command and it will use the same syntax that regular scp uses. Here I am zscp'ing as username ubuntu to the remote computer that is joined to the Ziti Network using the identity named ziti-tunnel-aws . ./zscp local/1.txt ubuntu@ziti-tunnel-aws:remote INFO connection to edge router using token 6c2e8b79-ce8e-483e-a9f8-a930530e706a INFO sent file: /Users/name/local/1.txt ==> /home/ubuntu/remote/1.txt This is only a basic example on how we can use zscp to send a singular file to a remote computer. In the next section, we will go over how to use zscp flags for extended functionality. Zscp Flags Just like zssh , zscp has the same flags to pass in: ssh key, ziti configuration file, service name, and one to toggle debug logging. All the defaults are the same as with zssh , thus both zscp and zssh will work without the -i and -c flag providing the files exist at the default locations. Refer to [zitifying-ssh][2] for instructions on how to use the flags below. -i, --SshKeyPath string Path to ssh key. default: $HOME/.ssh/id_rsa -c, --ZConfig string Path to ziti config file. default: $HOME/.ziti/zssh.json -d, --debug pass to enable additional debug information -s, --service string service name. (default \"zssh\") In addition to the flags above, zscp has a flag to enable recursive copying: -r, --recursive pass to enable recursive file transfer To use the recursive flag, you must input a directory into the LOCAL_FILEPATH argument. Just like scp , zscp will copy all file contents under the provided directory. You can see below how we can use the -r flag to send all contents of big_directory . Contents of big_directory on local computer: tree local local  big_directory  1.txt  2.txt  3.txt  small_directory1   4.txt  small_directory2   5.txt  small_directory3  6.txt Here is the command and output: $ zscp -r big_directory ubuntu@ziti-tunnel-aws:remote INFO connection to edge router using token d6c268ee-e4f5-4836-bd38-2fc1558257aa INFO sent file: /Users/name/local/big_directory/1.txt ==> /home/ubuntu/remote/big_directory/1.txt INFO sent file: /Users/name/local/big_directory/2.txt ==> /home/ubuntu/remote/big_directory/2.txt INFO sent file: /Users/name/local/big_directory/3.txt ==> /home/ubuntu/remote/big_directory/3.txt INFO sent file: /Users/name/local/big_directory/small_directory1/4.txt ==> /home/ubuntu/remote/big_directory/small_directory1/4.txt INFO sent file: /Users/name/local/big_directory/small_directory2/5.txt ==> /home/ubuntu/remote/big_directory/small_directory2/5.txt INFO sent file: /Users/name/local/big_directory/small_directory3/6.txt ==> /home/ubuntu/remote/big_directory/small_directory3/6.txt After zssh'ing to the remote machine, we can prove that all files have been transferred to remote device: ubuntu@IP:~$ tree remote/ remote/  big_directory  1.txt  2.txt  3.txt  small_directory1   4.txt  small_directory2   5.txt  small_directory3  6.txt Recursive copying also works to retrieve all contents of a directory on the remote machine. I hope this post has helped you get familiar with another ziti-empowered developer's tool and hopefully it's becoming more clear why zitifying your application will make it more resilient to attack and make the act of connecting to remote services trivial. Have a look at the code over at GitHub or continue reading on to the next zitification - kubectl !"
  },
  "articles/zitification/zitifying-scp/zitifying-scp.contents.html": {
    "href": "articles/zitification/zitifying-scp/zitifying-scp.contents.html",
    "title": "First Things First | Ziti",
    "keywords": "In the previous post we talked about how we could take a well-known application and improve its security by zitifying it, producing zssh . The logical next step after zitifying ssh would be to extend the functionality of zssh to cover moving files securely as well, enter zscp . A zitified scp effectively creates a more secure command line tool for sending and receiving files between ziti-empowered devices. Once zitified, we can use zscp using ziti identity names just like we did in zitifying ssh . I recommend reading the previous article ) if you haven't to learn more about the benefits of zitifying tools like ssh and scp . First Things First zscp functions with the same prerequisites as zssh : Establish a Ziti Network Create and enroll two Ziti Endpoints (one for our ssh server, one for the client) the sshd server will run ziti-tunnel for this demonstration. Conveniently it will run on the same machine I used to setup the Ziti Network . the client, in this case, is my local machine and I'll zscp files both to and from both the remote machine. Create the Ziti Service we'll use and authorize the two endpoints to use this service Use the zscp binary from the client side and the ziti-tunnel binary from the serving side to connect Harden sshd further by removing port 22 from any internet-based firewall configuration (for example, from within the security-groups wizard in AWS) or by forcing sshd to only listen on localhost/127.0.0.1 After ensuring these steps are complete, you will have the ability to copy files across your Ziti Network. The traffic will be even more secure since now a Ziti Network is required for the connection, requiring that strong identity before even being able to access the sshd server. And of course now sshd is 'dark' - it no longer needs the typical port 22 to be exposed to any network. Given all the prerequisites are satisfied, we can put zscp to use. Simply download the binary for your platform: linux windows MacOs Sending and Receiving Files with Zscp Once you have the executable downloaded, make sure it is named zscp and for simplicity's sake we'll assume it's on the path. Just like zssh to ssh , zscp provides the same basic functionality as scp . As with most tooling, executing the binary with no arguments will display the expected usage. There are two main functions of zscp . Just like scp you can send and receive from the remote host. To send files we use this basic syntax: ./zscp LOCAL_FILEPATHS... <REMOTE_USERNAME>@TARGET_IDENTITY:REMOTE_FILEPATH Then, to retrieve remote files we use a similar syntax: ./zscp <REMOTE_USERNAME>@TARGET_IDENTITY:REMOTE_FILEPATH LOCAL_FILEPATH Below is a working example of using zscp to send a file to a remote machine. In this case the remote username is not the same as my local username. Just like with scp , I'll need to supply the username in my command and it will use the same syntax that regular scp uses. Here I am zscp'ing as username ubuntu to the remote computer that is joined to the Ziti Network using the identity named ziti-tunnel-aws . ./zscp local/1.txt ubuntu@ziti-tunnel-aws:remote INFO connection to edge router using token 6c2e8b79-ce8e-483e-a9f8-a930530e706a INFO sent file: /Users/name/local/1.txt ==> /home/ubuntu/remote/1.txt This is only a basic example on how we can use zscp to send a singular file to a remote computer. In the next section, we will go over how to use zscp flags for extended functionality. Zscp Flags Just like zssh , zscp has the same flags to pass in: ssh key, ziti configuration file, service name, and one to toggle debug logging. All the defaults are the same as with zssh , thus both zscp and zssh will work without the -i and -c flag providing the files exist at the default locations. Refer to [zitifying-ssh][2] for instructions on how to use the flags below. -i, --SshKeyPath string Path to ssh key. default: $HOME/.ssh/id_rsa -c, --ZConfig string Path to ziti config file. default: $HOME/.ziti/zssh.json -d, --debug pass to enable additional debug information -s, --service string service name. (default \"zssh\") In addition to the flags above, zscp has a flag to enable recursive copying: -r, --recursive pass to enable recursive file transfer To use the recursive flag, you must input a directory into the LOCAL_FILEPATH argument. Just like scp , zscp will copy all file contents under the provided directory. You can see below how we can use the -r flag to send all contents of big_directory . Contents of big_directory on local computer: tree local local  big_directory  1.txt  2.txt  3.txt  small_directory1   4.txt  small_directory2   5.txt  small_directory3  6.txt Here is the command and output: $ zscp -r big_directory ubuntu@ziti-tunnel-aws:remote INFO connection to edge router using token d6c268ee-e4f5-4836-bd38-2fc1558257aa INFO sent file: /Users/name/local/big_directory/1.txt ==> /home/ubuntu/remote/big_directory/1.txt INFO sent file: /Users/name/local/big_directory/2.txt ==> /home/ubuntu/remote/big_directory/2.txt INFO sent file: /Users/name/local/big_directory/3.txt ==> /home/ubuntu/remote/big_directory/3.txt INFO sent file: /Users/name/local/big_directory/small_directory1/4.txt ==> /home/ubuntu/remote/big_directory/small_directory1/4.txt INFO sent file: /Users/name/local/big_directory/small_directory2/5.txt ==> /home/ubuntu/remote/big_directory/small_directory2/5.txt INFO sent file: /Users/name/local/big_directory/small_directory3/6.txt ==> /home/ubuntu/remote/big_directory/small_directory3/6.txt After zssh'ing to the remote machine, we can prove that all files have been transferred to remote device: ubuntu@IP:~$ tree remote/ remote/  big_directory  1.txt  2.txt  3.txt  small_directory1   4.txt  small_directory2   5.txt  small_directory3  6.txt Recursive copying also works to retrieve all contents of a directory on the remote machine. I hope this post has helped you get familiar with another ziti-empowered developer's tool and hopefully it's becoming more clear why zitifying your application will make it more resilient to attack and make the act of connecting to remote services trivial. Have a look at the code over at GitHub or continue reading on to the next zitification - kubectl !"
  },
  "articles/zitification/zitifying-scp/zscp-cheatsheat.html": {
    "href": "articles/zitification/zitifying-scp/zscp-cheatsheat.html",
    "title": "establish some variables which are used below | Ziti",
    "keywords": "establish some variables which are used below service_name=zscpSvc client_identity=\"${service_name}\"Client server_identity=\"${service_name}\"Server the_port=22 create two identities. one host - one client. Only necessary if you want/need them. Skippable if you already have an identity. provided here to just 'make it easy' to test/try ziti edge create identity device \"${server_identity}\" -a \"${service_name}\"ServerEndpoints -o \"${server_identity}\".jwt ziti edge create identity device \"${client_identity}\" -a \"${service_name}\"ClientEndpoints -o \"${client_identity}\".jwt if you want to modify anything, often deleting the configs/services is easier than updating them it's easier to delete all the items too - so until you understand exactly how ziti works, make sure you clean them all up before making a change ziti edge delete config \"${service_name}\"-host.v1 ziti edge delete config \"${service_name}\"-client-config ziti edge delete service \"${service_name}\" ziti edge delete service-policy \"${service_name}\"-binding ziti edge delete service-policy \"${service_name}\"-dialing ziti edge create config \"${service_name}\"-host.v1 host.v1 '{\"protocol\":\"tcp\", \"address\":\"localhost\",\"port\":'\"${the_port}\"', \"listenOptions\": {\"bindUsingEdgeIdentity\":true}}'# intercept is not needed for zscp/zssh but make it for testing if you like ziti edge create config \"${service_name}\"-client-config intercept.v1 '{\"protocols\":[\"tcp\"],\"addresses\":[\"'\"${service_name}.ziti\"'\"], \"portRanges\":[{\"low\":'\"${the_port}\"', \"high\":\"'${the_port}\"'}]}' ziti edge create service \"${service_name}\" --configs \"${service_name}\"-client-config,\"${service_name}\"-host.v1 ziti edge create service-policy \"${service_name}\"-binding Bind --service-roles '@'\"${service_name}\" --identity-roles '#'\"${service_name}\"'ServerEndpoints' ziti edge create service-policy \"${service_name}\"-dialing Dial --service-roles '@'\"${service_name}\" --identity-roles '#'\"${service_name}\"'ClientEndpoints'"
  },
  "articles/zitification/zitifying-ssh/index.html": {
    "href": "articles/zitification/zitifying-ssh/index.html",
    "title": "Zitifying SSH | Ziti",
    "keywords": "Zitifying SSH As we learned in the opening post , \"zitifying\" an application means to embed a Ziti SDK into an application and leverage the power of a Ziti Network to provide secure, truly zero-trust access to your application no matter where in the world that application goes. In this post we are going to see how we have zitified ssh and why. Future posts will expand on this even further by showing how NetFoundry uses zssh to support our customers. Why SSH? As I sit here typing these words, I can tell you're skeptical. I can tell you're wondering why in the world we would even attempt to mess with ssh at all. After all, ssh has been a foundation of the administration of not only home networks but also corporate networks and the internet itself. Surely if millions (billions?) of computers can interact every day safely and securely using ssh there is \"no need\" for us to be spending time zitifying ssh right? (Spoiler alert: wrong) I'm sure you've guessed that this is not the case whatsoever. After all, attackers don't leave ssh alone just because it's not worth it to try! Put a machine on the open internet, expose ssh on port 22 and watch for yourself all the attempts to access ssh using known default/weak/bad passwords flood in. Attacks don't only come from the internet either! Attacks from a single compromised machine on your network very well could behave in the same way as an outside attacker. This is particularly true for ransomware-style attacks as the compromised machine attempts to expand/multiply. The problems don't just stop here either. DoS attacks, other zero-day type bugs and more are all waiting for any service sitting on the open internet. A zitified ssh client is superior since the port used by ssh can be eliminated from the internet-based firewall preventing any connections whatsoever from any network client. In this configuration the ssh process is effectively \" dark\". The only way to ssh to a machine configured in this way is to have an identity authorized for that Ziti Network . It doesn't stop there though. A Ziti Network mandates the use of a strong identity. You cannot access any services defined in a Ziti Network without having gone through the enrollment process to create a strong identity used for bidirectional authentication and authorization. With Ziti, you can't even connect to SSH without first being authorized to connect to the remote SSH server. Contrast that to SSH. With SSH you need access the sshd port before starting the authentication process. This requires the port to be exposed to the network, exposing it to attack. With SSH you are also usually allowed to authenticate without providing a strong identity using a username and password. Even if you are choosing to use the more secure pub/private key authentication for SSH, the remote machine still needed the public key added to the authorized_keys file before allowing connections to it via SSH. This is all-too-often a step which a human will do, making the process of authorizing a user or revoking access relatively cumbersome. Ziti provides a secure, centralized location to manage authorization of users to services. Ziti makes it trivial to grant or revoke access to a given set of services to users immediately. Lastly, Ziti provides support for continual authorization through the use of policy checks. These policy checks run continuously. If a user suddenly fails to meet a particular policy, access to the services provided via the Ziti Network are revoked immediately. Cool right? Let's see how we did it and how you can do the same thing using a Ziti Network . Overview of SSH - notice how port 22 is open to inbound connections: How It's Done There are a few steps necessary before being able to use zssh : Establish a Ziti Network Create and enroll two Ziti Endpoints (one for our ssh server, one for the client) the sshd server will run ziti-tunnel for this demonstration. Conveniently it will run on the same machine I used to setup the Ziti Network . the client will run zssh from my local machine, and I'll zssh to the other endpoint Create the Ziti Service we'll use and authorize the two endpoints to use this service Use the zssh binary from the client side and the ziti-tunnel binary from the serving side to connect Harden sshd further by removing port 22 from any internet-based firewall configuration (for example, from within the security-groups wizard in AWS) or by forcing sshd to only listen on localhost/127.0.0.1 Overview of ZSSH - notice port 22 is no longer open to inbound connections: After performing these steps you'll have an sshd server that is dark to the internet. Accessing the server via ssh must now occur using the Ziti Network. Since the service is no longer accessible directly through a network, it is no longer susceptible to the types of attacks mentioned previously! Zssh in Action Once the prerequisites are satisfied, we can see zssh in action. Simply download the binary for your platform: linux windows MacOs Once you have the executable download, make sure it is named zssh and for simplicity's sake we'll assume it's on the path. A goal for zssh is to make the usage of the command very similar to the usage of ssh . Anyone familiar with ssh should be able to pick up zssh easily. As with most tooling, executing the binary with no arguments will display the expected usage. The general format when using zssh will be similar to that of ssh : zssh <remoteUsername>@<targetIdentity> Below you can see me zssh from my local machine to the AWS machine secured by ziti-tunnel : ./zssh ubuntu@ziti-tunnel-aws INFO[0000] connection to edge router using token 95c45123-9415-49d6-930a-275ada9ae06f connected. ubuntu@ip-172-31-27-154:~$ It really was that simple! Now let's break down the current flags for zssh and exactly how this worked. Zssh Flags We know that zssh requires access to a Ziti Network but it is not clear from the example above is where zzsh found the credentials required to access the network. zssh supports three basic flags: -i, --SshKeyPath string Path to ssh key. default: $HOME/.ssh/id_rsa -c, --ZConfig string Path to ziti config file. default: $HOME/.ziti/zssh.json -d, --debug pass to enable additional debug information -h, --help help for this command -s, --service string service name. default: zssh (default \"zssh\") What you see above is exactly the output zssh provides should you pass the -h/--help flag or execute zssh without any parameters. The -i/--SshKeyPath flag is congruent to the -i flag for ssh . You would use it to supply your key to the ssh client. Under the hood of zssh is a full-fledged ssh client that works similarly to how ssh does. If your ~/.ssh/id_rsa file is in the authorized_keys of the remote machine, then you won't need to specify the -i/ flag (as I didn't in my example). Using zssh requires the use of a public/private key in order for the zssh client to connect to the remote machine. The -c/--ZConfig flag controls access to the network. A configuration file must be supplied to use zssh but does not need to be supplied as part of the command. By default, zssh will look at your home directory in a folder named .ziti for a file named zssh.json . In bash this is would be the equivalent of $HOME . In Windows this is the equivalent the environment variable named USERPROFILE . You do not need to supply this flag if a file exists at the default location. You can specify this flag to use zssh with other networks. The -s/--service flag is for passing in a different service name other than \"zssh\". By defualt, the service name will be \"zssh\", but if you would like to access a different service use the -s flag followed by the service name. The -d/--debug flag outputs additional information to assist you with debugging. For example: $ ./zssh ubuntu@ziti-tunnel-aws -d INFO[0000] sshKeyPath set to: /home/myUser/.ssh/id_rsa INFO[0000] ZConfig set to: /home/myUser/.ziti/zssh.json INFO[0000] username set to: ubuntu INFO[0000] targetIdentity set to: ziti-tunnel-aws INFO[0000] connection to edge router using token 95c45123-a234-412e-8997-96139fbd1938 connected. ubuntu@ip-172-31-27-154:~$ Shown above is also one additional piece of information, the remote username. Shown in the example above I have zssh ed to an ubuntu image in AWS. When it was provisioned AWS used the username ubuntu . In order to zssh to this machine I need to tell the remote sshd server that I wish to attach as the ubuntu user. If your username is the same for your local environment as the remote machine you do not need to specify the username. For example, my local username is cd (my initials). When I zssh to my dev machine I can simply use zssh ClintLinux : $ ./zssh ClintLinux INFO[0000] connection to edge router using token 909dfb4f-fa83-4f73-af8e-ed251bcd30be connected. cd@clint-linux-vm ~ Hopefully this post has been helpful and insightful. Zitifying an application is POWERFUL !!!! The next post in this series will cover how we extended the same code we used for zssh and zitified scp . Have a look at the code over at GitHub"
  },
  "articles/zitification/zitifying-ssh/zitifying-ssh.contents.html": {
    "href": "articles/zitification/zitifying-ssh/zitifying-ssh.contents.html",
    "title": "Why SSH? | Ziti",
    "keywords": "As we learned in the opening post , \"zitifying\" an application means to embed a Ziti SDK into an application and leverage the power of a Ziti Network to provide secure, truly zero-trust access to your application no matter where in the world that application goes. In this post we are going to see how we have zitified ssh and why. Future posts will expand on this even further by showing how NetFoundry uses zssh to support our customers. Why SSH? As I sit here typing these words, I can tell you're skeptical. I can tell you're wondering why in the world we would even attempt to mess with ssh at all. After all, ssh has been a foundation of the administration of not only home networks but also corporate networks and the internet itself. Surely if millions (billions?) of computers can interact every day safely and securely using ssh there is \"no need\" for us to be spending time zitifying ssh right? (Spoiler alert: wrong) I'm sure you've guessed that this is not the case whatsoever. After all, attackers don't leave ssh alone just because it's not worth it to try! Put a machine on the open internet, expose ssh on port 22 and watch for yourself all the attempts to access ssh using known default/weak/bad passwords flood in. Attacks don't only come from the internet either! Attacks from a single compromised machine on your network very well could behave in the same way as an outside attacker. This is particularly true for ransomware-style attacks as the compromised machine attempts to expand/multiply. The problems don't just stop here either. DoS attacks, other zero-day type bugs and more are all waiting for any service sitting on the open internet. A zitified ssh client is superior since the port used by ssh can be eliminated from the internet-based firewall preventing any connections whatsoever from any network client. In this configuration the ssh process is effectively \" dark\". The only way to ssh to a machine configured in this way is to have an identity authorized for that Ziti Network . It doesn't stop there though. A Ziti Network mandates the use of a strong identity. You cannot access any services defined in a Ziti Network without having gone through the enrollment process to create a strong identity used for bidirectional authentication and authorization. With Ziti, you can't even connect to SSH without first being authorized to connect to the remote SSH server. Contrast that to SSH. With SSH you need access the sshd port before starting the authentication process. This requires the port to be exposed to the network, exposing it to attack. With SSH you are also usually allowed to authenticate without providing a strong identity using a username and password. Even if you are choosing to use the more secure pub/private key authentication for SSH, the remote machine still needed the public key added to the authorized_keys file before allowing connections to it via SSH. This is all-too-often a step which a human will do, making the process of authorizing a user or revoking access relatively cumbersome. Ziti provides a secure, centralized location to manage authorization of users to services. Ziti makes it trivial to grant or revoke access to a given set of services to users immediately. Lastly, Ziti provides support for continual authorization through the use of policy checks. These policy checks run continuously. If a user suddenly fails to meet a particular policy, access to the services provided via the Ziti Network are revoked immediately. Cool right? Let's see how we did it and how you can do the same thing using a Ziti Network . Overview of SSH - notice how port 22 is open to inbound connections: How It's Done There are a few steps necessary before being able to use zssh : Establish a Ziti Network Create and enroll two Ziti Endpoints (one for our ssh server, one for the client) the sshd server will run ziti-tunnel for this demonstration. Conveniently it will run on the same machine I used to setup the Ziti Network . the client will run zssh from my local machine, and I'll zssh to the other endpoint Create the Ziti Service we'll use and authorize the two endpoints to use this service Use the zssh binary from the client side and the ziti-tunnel binary from the serving side to connect Harden sshd further by removing port 22 from any internet-based firewall configuration (for example, from within the security-groups wizard in AWS) or by forcing sshd to only listen on localhost/127.0.0.1 Overview of ZSSH - notice port 22 is no longer open to inbound connections: After performing these steps you'll have an sshd server that is dark to the internet. Accessing the server via ssh must now occur using the Ziti Network. Since the service is no longer accessible directly through a network, it is no longer susceptible to the types of attacks mentioned previously! Zssh in Action Once the prerequisites are satisfied, we can see zssh in action. Simply download the binary for your platform: linux windows MacOs Once you have the executable download, make sure it is named zssh and for simplicity's sake we'll assume it's on the path. A goal for zssh is to make the usage of the command very similar to the usage of ssh . Anyone familiar with ssh should be able to pick up zssh easily. As with most tooling, executing the binary with no arguments will display the expected usage. The general format when using zssh will be similar to that of ssh : zssh <remoteUsername>@<targetIdentity> Below you can see me zssh from my local machine to the AWS machine secured by ziti-tunnel : ./zssh ubuntu@ziti-tunnel-aws INFO[0000] connection to edge router using token 95c45123-9415-49d6-930a-275ada9ae06f connected. ubuntu@ip-172-31-27-154:~$ It really was that simple! Now let's break down the current flags for zssh and exactly how this worked. Zssh Flags We know that zssh requires access to a Ziti Network but it is not clear from the example above is where zzsh found the credentials required to access the network. zssh supports three basic flags: -i, --SshKeyPath string Path to ssh key. default: $HOME/.ssh/id_rsa -c, --ZConfig string Path to ziti config file. default: $HOME/.ziti/zssh.json -d, --debug pass to enable additional debug information -h, --help help for this command -s, --service string service name. default: zssh (default \"zssh\") What you see above is exactly the output zssh provides should you pass the -h/--help flag or execute zssh without any parameters. The -i/--SshKeyPath flag is congruent to the -i flag for ssh . You would use it to supply your key to the ssh client. Under the hood of zssh is a full-fledged ssh client that works similarly to how ssh does. If your ~/.ssh/id_rsa file is in the authorized_keys of the remote machine, then you won't need to specify the -i/ flag (as I didn't in my example). Using zssh requires the use of a public/private key in order for the zssh client to connect to the remote machine. The -c/--ZConfig flag controls access to the network. A configuration file must be supplied to use zssh but does not need to be supplied as part of the command. By default, zssh will look at your home directory in a folder named .ziti for a file named zssh.json . In bash this is would be the equivalent of $HOME . In Windows this is the equivalent the environment variable named USERPROFILE . You do not need to supply this flag if a file exists at the default location. You can specify this flag to use zssh with other networks. The -s/--service flag is for passing in a different service name other than \"zssh\". By defualt, the service name will be \"zssh\", but if you would like to access a different service use the -s flag followed by the service name. The -d/--debug flag outputs additional information to assist you with debugging. For example: $ ./zssh ubuntu@ziti-tunnel-aws -d INFO[0000] sshKeyPath set to: /home/myUser/.ssh/id_rsa INFO[0000] ZConfig set to: /home/myUser/.ziti/zssh.json INFO[0000] username set to: ubuntu INFO[0000] targetIdentity set to: ziti-tunnel-aws INFO[0000] connection to edge router using token 95c45123-a234-412e-8997-96139fbd1938 connected. ubuntu@ip-172-31-27-154:~$ Shown above is also one additional piece of information, the remote username. Shown in the example above I have zssh ed to an ubuntu image in AWS. When it was provisioned AWS used the username ubuntu . In order to zssh to this machine I need to tell the remote sshd server that I wish to attach as the ubuntu user. If your username is the same for your local environment as the remote machine you do not need to specify the username. For example, my local username is cd (my initials). When I zssh to my dev machine I can simply use zssh ClintLinux : $ ./zssh ClintLinux INFO[0000] connection to edge router using token 909dfb4f-fa83-4f73-af8e-ed251bcd30be connected. cd@clint-linux-vm ~ Hopefully this post has been helpful and insightful. Zitifying an application is POWERFUL !!!! The next post in this series will cover how we extended the same code we used for zssh and zitified scp . Have a look at the code over at GitHub"
  },
  "articles/zitification/zitifying-ssh/zssh-cheat-sheet.html": {
    "href": "articles/zitification/zitifying-ssh/zssh-cheat-sheet.html",
    "title": "establish some variables which are used below | Ziti",
    "keywords": "establish some variables which are used below service_name=zsshSvc client_identity=\"${service_name}\"Client server_identity=\"${service_name}\"Server the_port=22 create two identities. one host - one client. Only necessary if you want/need them. Skippable if you already have an identity. provided here to just 'make it easy' to test/try ziti edge create identity device \"${server_identity}\" -a \"${service_name}\"ServerEndpoints -o \"${server_identity}\".jwt ziti edge create identity device \"${client_identity}\" -a \"${service_name}\"ClientEndpoints -o \"${client_identity}\".jwt if you want to modify anything, often deleting the configs/services is easier than updating them it's easier to delete all the items too - so until you understand exactly how ziti works, make sure you clean them all up before making a change ziti edge delete config \"${service_name}\"-host.v1 ziti edge delete config \"${service_name}\"-client-config ziti edge delete service \"${service_name}\" ziti edge delete service-policy \"${service_name}\"-binding ziti edge delete service-policy \"${service_name}\"-dialing ziti edge create config \"${service_name}\"-host.v1 host.v1 '{\"protocol\":\"tcp\", \"address\":\"localhost\",\"port\":'\"${the_port}\"', \"listenOptions\": {\"bindUsingEdgeIdentity\":true}}' intercept is not needed for zscp/zssh but make it for testing if you like ziti edge create config \"${service_name}\"-client-config intercept.v1 '{\"protocols\":[\"tcp\"],\"addresses\":[\"'\"${service_name}.ziti\"'\"], \"portRanges\":[{\"low\":'\"${the_port}\"', \"high\":'\"${the_port}\"'}]}' ziti edge create service \"${service_name}\" --configs \"${service_name}\"-client-config,\"${service_name}\"-host.v1 ziti edge create service-policy \"${service_name}\"-binding Bind --service-roles '@'\"${service_name}\" --identity-roles '#'\"${service_name}\"'ServerEndpoints' ziti edge create service-policy \"${service_name}\"-dialing Dial --service-roles '@'\"${service_name}\" --identity-roles '#'\"${service_name}\"'ClientEndpoints'"
  },
  "glossary/glossary.html": {
    "href": "glossary/glossary.html",
    "title": "Glossary | Ziti",
    "keywords": "Glossary Here you will find a list of terms you may come across as you are using Ziti. Network Overlay, Overlay A Ziti network is implemented as an \"overlay\". A network overlay abstracts away the layers beneath it, providing a new set of abstractions for designing and implementing software and systems. Good programming abstractions allow developers to focus on the rules implemented by those abstractions without being concerned with the layers below the abstraction. Ziti's overlay allows developers to focus on connectivity between components without having to be concerned with low-level details of how that connectivity is managed. Service Definition A service definition is used to \"bind\" a service to a specific underlay network expression, through one or more nodes on a Ziti overlay network. A service definition usually includes a terminating router (or routers) and one or more SDK or underlay network endpoints where the service can be reached. Session A session is an \"instance\" of a service on behalf of an initiating endpoint, which is connected to a terminating endpoint. A session has strong identity and security between the initiating endpoint, terminating endpoint, and throughout the links between. A session selects a specific set of routers to traverse between the endpoints, and that path can change dynamically due to network performance. Initiating Router, Terminating Router An initiating router is the router which initiates a request for a session on behalf of a connected endpoint. A terminating router is the router which provides access to the service associated with the session request. Every session links an initiating endpoint (through an initiating router), with a terminating endpoint (through a terminating router). Initiating Endpoint, Terminating Endpoint See \"initiating router\" and \"terminating router\" above. The initiating endpoint is the endpoint responsible for requesting connectivity to a service. The terminating endpoint is the endpoint that provides the service. Path The path is the set of Ziti Routers traversed by a session from an initiating router to a terminating router. Ziti aggressively optimizes the path for throughput and reliability, and so it may change during the session. Underlay We refer to lower-level network concerns as \"underlay\". IP networking would be an example of an underlay concept. Xgress (Xctrl, Xmgmt), Ziti Fabric SDK Xgress is a set of extension components for the Ziti fabric, which enable overlay applications to participate in the overlay network. Xgress focuses on extending the data plane, providing interfaces for creating initiating and terminating endpoints. Xctrl and Xmgmt focus on extending the control and management planes of the fabric. Xgress is the core of the Ziti Fabric SDK. Ziti Controller, Controller A Ziti Controller is a process that is installed on a host, which allows it to coordinate a Ziti network. The Ziti Controller is designed to be extensible through Ziti fabric extension mechanisms (Xctrl, Xmgmt), which means that it is capable of hosting extensions to the fabric control and management planes. Ziti Edge, Edge The Ziti Edge implements the zero trust connectivity framework as an overlay application on top of the Ziti Fabric. The Ziti Edge provides connectivity implementations for a number of important endpoint types, including applications that embed Ziti connectivity through the Ziti Edge SDK. The Ziti Edge provides fallback connectivity solutions for non-Ziti applications using components like the Ziti tunnelers, and the Ziti proxy. Ziti Enabled Application A Ziti Enabled Application is an application that embeds the Ziti Endpoint SDK, such that it can participate on a Ziti network to either access or host services. Ziti Endpoint SDK, Endpoint SDK, SDK The Ziti Endpoint SDK provides software components that are designed to be embedded into customer applications so that they can participate natively in a Ziti network. The SDK targets golang, Swift, C, C#, and potentially other programming languages, allowing programs in those languages to work with idioms and concepts native to those environments. The SDK provides support for both accessing and hosting services that are available on a Ziti network. Ziti Fabric, Fabric The Ziti Fabric provides the core of the network overlay. The Ziti Fabric implements a routable mesh network, which can provide reliable connectivity between any two points on the network. The fabric provides software extension mechanisms that allow the overlay to be embedded into new overlay applications. The Ziti Edge is an example of an overlay application implemented on top of Ziti Fabric extension mechanisms (Xgress, Xctrl, Xmgmt). Ziti Network, Ziti Ziti is a modern, programmable network overlay with associated edge components, for application-embedded, zero trust network connectivity, written by developers for developers. Ziti is NetFoundry's next-generation programmable networking product. Ziti is used to create Ziti Networks. Ziti Router, Router A Ziti Router is a process that is installed on a host, which allows it to participate in a Ziti Fabric. The router is designed to be extensible through Ziti fabric extension mechanisms (Xgress), which means that it is capable of \"hosting\" overlay network applications like the Ziti Edge. Ziti Service, Service A Ziti network is primarily concerned with providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service would be defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Ziti Service, Service - Hosted Similar to a Ziti Service however the destination is not described as an IP address and port but rather it is expressed as a Ziti Identity. When used with a Ziti SDK it is possible to create a truly zero-trust application. Ziti Tunneler, Tunneler A Ziti Tunneler provides connectivity for applications that are not Ziti enabled. Our tunneler implementations provide an underlay connectivity component (TUN, tproxy, etc.), and then use the Ziti Endpoint SDK such that they can bridge connectivity onto the Ziti network."
  },
  "index.html": {
    "href": "index.html",
    "title": "Get Started - Build a Network! | Ziti",
    "keywords": "Welcome to the OpenZiti Project! The OpenZiti project is a free, open source project focused on bringing Zero Trust to any application. The project provides all the pieces required to implement or integrate Zero Trust into your solutions: The overlay network Tunneling Applications for all operating systems Numerous SDKs making it easy to add Zero Trust concepts directly into your application Ziti makes it easy to embed Zero Trust, programmable networking directly into your app. With Ziti you can have Zero Trust, high performance networking on any Internet connection, without VPNs! Get Started - Build a Network! Ziti make Zero Trust easy but you'll need an overlay network in order to start on your Zero Trust journey. We recommend you start with a simple network. Once you understand the basic concepts it can make more sense to move on to more complex network topologies. Choose what sort of network you want to build. Everything Local (Not Docker) Everything Local (I love Docker) Everything Local (Docker Compose) Host It Myself (I have a server) I Have a Network! What's Next? Fantastic! Now that you have a Ziti Network all setup and ready to go, the next step is learning about all of the pieces which go into it. There's a lot to learn and our docs are there to help you understand any extra details you need help ironing out. If the docs don't, we love issues for how to improve our docs or if you're feeling up for it we'd love to see any PRs to make the docs better! You'll find a more extensive list of the quickstarts we have. Get Started With an SDK The OpenZiti project offers numerous SDKs to start with. Pick your favorite language and follow along with a simple tutorial! If your favorite language is not shown, perhaps you can use the C SDK and integrate via FFI. C Lang Go Swift Android Java NodeJS C# (.NET) Not Ready to Go Fully App-Embedded? That's ok - Zero Trust adoption is a journey! Get started with a couple of very simple examples which will get you familiar with the technology overall. These samples will leverage one of the tunneling apps . Simple Webapp Sound Good? Now that you've seen how cool OpenZiti is - maybe consider starring us on GitHub? It helps others find the project! Show your support of OpenZiti today! Star <!-- Place this tag in your head or just before your close body tag. -->"
  },
  "test.html": {
    "href": "test.html",
    "title": "this is a markdown test | Ziti",
    "keywords": "this is a markdown test testing nov16 - one more commit just to feel good"
  },
  "ziti/cli/cli.html": {
    "href": "ziti/cli/cli.html",
    "title": "| Ziti",
    "keywords": "CLI help coming soon..."
  },
  "ziti/clients/android.html": {
    "href": "ziti/clients/android.html",
    "title": "Android | Ziti",
    "keywords": "Android The Android tunneler is currently in an open beta. Find the app in the Play store here . The source code for the Android tunneler is in GitHub and it is based on the SDK for the JVM ."
  },
  "ziti/clients/how-to-choose.html": {
    "href": "ziti/clients/how-to-choose.html",
    "title": "Choosing a Ziti Client | Ziti",
    "keywords": "Choosing a Ziti Client After creating a Ziti Network you will quickly find the need for a client that can connect directly to the overlay. There are two types of clients for Ziti Networks: SDK-based and Tunneler-based. Which client is right for you is a relatively straightforward question to answer."
  },
  "ziti/clients/iOS.html": {
    "href": "ziti/clients/iOS.html",
    "title": "iOS | Ziti",
    "keywords": "iOS The iOS tunneler is currently in preview. Find the app in the Apple store here"
  },
  "ziti/clients/linux.html": {
    "href": "ziti/clients/linux.html",
    "title": "Linux | Ziti",
    "keywords": "Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet Troubleshooting The simplest step you can take toward a diagnosis is to reduce the minimum message log level by adding --verbose to your command. This usually means lower-level DEBUG messages and above are emitted in addition to the default level of INFO level and above e.g. WARN, ERROR, etc... If the tunneler is crashing then it may be crucial to collect and analyze the core dump file. You may need to enable saving core dumps depending upon your OS configuration. You can see how dump files are handled by inspecting this file, which is from Ubuntu 20.10.  cat /proc/sys/kernel/core_pattern |/usr/share/apport/apport %p %s %c %d %P %E In this case the dump is handled by apport which saves the file in /var/crash . I'll need to follow the apport documentation to learn how to unpack and parse the dump file."
  },
  "ziti/clients/macos.html": {
    "href": "ziti/clients/macos.html",
    "title": "MacOS | Ziti",
    "keywords": "MacOS The MacOS tunneler is currently in preview. Find the app in the Mac App Store"
  },
  "ziti/clients/overview.html": {
    "href": "ziti/clients/overview.html",
    "title": "Clients overview | Ziti",
    "keywords": "Clients overview"
  },
  "ziti/clients/proxy-example.html": {
    "href": "ziti/clients/proxy-example.html",
    "title": "| Ziti",
    "keywords": "The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "ziti/clients/sdk-quickinfo.html": {
    "href": "ziti/clients/sdk-quickinfo.html",
    "title": "| Ziti",
    "keywords": "If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/sdks.html": {
    "href": "ziti/clients/sdks.html",
    "title": "Ziti SDKs | Ziti",
    "keywords": "Ziti SDKs If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/tunneler.html": {
    "href": "ziti/clients/tunneler.html",
    "title": "Tunnelers | Ziti",
    "keywords": "Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. Ziti provides tunnelers for each major operating system. Windows MacOS Linux iOS Android Each tunneller operates similarly. The goal is to have the tunneler intercecpt traffic destined for Ziti services and forward that traffic over the Ziti overlay instead of the underlay network. There are two basic modes a tunneler operate in: seamless and proxy. A seamless tunneler will transparently intercept traffic via IPv4 address or DNS whereas a tunneler in proxy mode works as a proxy. Seamless mode is transparent to existing services and applications. Proxy mode is not as transparent at all. It requires applications to send traffic to the localhost proxy specifically. This means when running in proxy mode - it does not do any intercepting at all. Here you can learn about the ways each tunneler operates and see the similarities as well as any differences. Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet Troubleshooting The simplest step you can take toward a diagnosis is to reduce the minimum message log level by adding --verbose to your command. This usually means lower-level DEBUG messages and above are emitted in addition to the default level of INFO level and above e.g. WARN, ERROR, etc... If the tunneler is crashing then it may be crucial to collect and analyze the core dump file. You may need to enable saving core dumps depending upon your OS configuration. You can see how dump files are handled by inspecting this file, which is from Ubuntu 20.10.  cat /proc/sys/kernel/core_pattern |/usr/share/apport/apport %p %s %c %d %P %E In this case the dump is handled by apport which saves the file in /var/crash . I'll need to follow the apport documentation to learn how to unpack and parse the dump file. Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN Android The Android tunneler is currently in an open beta. Find the app in the Play store here . The source code for the Android tunneler is in GitHub and it is based on the SDK for the JVM . iOS The iOS tunneler is currently in preview. Find the app in the Apple store here MacOS The MacOS tunneler is currently in preview. Find the app in the Mac App Store"
  },
  "ziti/clients/tunneler-overview.html": {
    "href": "ziti/clients/tunneler-overview.html",
    "title": "| Ziti",
    "keywords": "A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. Ziti provides tunnelers for each major operating system. Windows MacOS Linux iOS Android"
  },
  "ziti/clients/which-client.html": {
    "href": "ziti/clients/which-client.html",
    "title": "Choosing a client | Ziti",
    "keywords": "Choosing a client Once you have a Ziti Network - you are going to require a Ziti-aware client in order to access the network. There are two types of clients and depending on your needs you'll choose to either use a tunneler or you will use an SDK to securely access the Ziti Network. Choosing which type of client you will use to connect to a Ziti Network is a straightfoward process and comes down to a single question. If you are you installing Ziti in front of an existing application which has already been developed and deployed you need to use a tunneler . If you are developing a new product, starting from scratch and you want to take advantage of a fully zero-trust solution you will probably want to use an SDK. Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. Ziti provides tunnelers for each major operating system. Windows MacOS Linux iOS Android Read more on using tunnelers here SDK If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/windows.html": {
    "href": "ziti/clients/windows.html",
    "title": "Windows | Ziti",
    "keywords": "Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "ziti/cli-snippets/login.html": {
    "href": "ziti/cli-snippets/login.html",
    "title": "| Ziti",
    "keywords": "# load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert"
  },
  "ziti/comparisons/overview.html": {
    "href": "ziti/comparisons/overview.html",
    "title": "OpenZiti Comparison Overview | Ziti",
    "keywords": "OpenZiti Comparison Overview This is the landing page for comparisons. First might be service mesh"
  },
  "ziti/comparisons/service-mesh.html": {
    "href": "ziti/comparisons/service-mesh.html",
    "title": "OpenZiti Compared to Service Mesh | Ziti",
    "keywords": "OpenZiti Compared to Service Mesh Words here... From the root of this branch I will run: ./gendoc.sh -glc && docfx serve docs-local/ (it's a sparser/faster checkout)"
  },
  "ziti/config-store/consuming.html": {
    "href": "ziti/config-store/consuming.html",
    "title": "Consuming Configuration Data | Ziti",
    "keywords": "Consuming Configuration Data Configuration data can be retrieved directly, but it will usually be consumed by applications via the SDK. When an SDK authenticates, it will indicate which configuration types it can process. Then, when listing services, the SDK will recieve configuation data in-line. This can be done from the CLI as well. If we've set up a service ssh as follows: $ ziti edge create config ssh-client my-app \\ '{ \"hostname\" : \"ssh.company.com\", \"port\" : 22 }' $ ziti edge create service ssh --configs ssh The SDKs will present this configuration in language specific ways. You can see the data the SDK are working with from the SDK, by specifying configuration types when listing services. NOTES You can specify all to see all the configuration data. In addition to the config block which has the embedded configuration data there's also a configs section which lists all the associated configurations by ID. All associated configurations will always be listed here, regardless of which configuration types are requested. $ ziti edge list services -j --config-types my-app 'name=\"ssh\"' { \"meta\": { \"filterableFields\": [ \"id\", \"createdAt\", \"updatedAt\", \"name\" ], \"pagination\": { \"limit\": 10, \"offset\": 0, \"totalCount\": 1 } }, \"data\": [ { \"id\": \"5d802b56-2ce2-4d28-b95c-01c968948ecc\", \"createdAt\": \"2020-06-01T14:36:36.856984972Z\", \"updatedAt\": \"2020-06-01T14:36:36.856984972Z\", \"_links\": { \"configs\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc/configs\" }, \"self\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc\" }, \"service-edge-router-policies\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc/service-edge-router-policies\" }, \"service-policies\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc/service-policies\" }, \"terminators\": { \"href\": \"./services/5d802b56-2ce2-4d28-b95c-01c968948ecc/terminators\" } }, \"tags\": {}, \"name\": \"ssh\", \"terminatorStrategy\": \"smartrouting\", \"roleAttributes\": null, \"permissions\": [ \"Bind\", \"Dial\" ], \"configs\": [ \"e471379b-3f40-4ddf-8bae-621491127543\" ], \"config\": { \"my-app\": { \"hostname\": \"ssh.company.com\", \"port\": 22 } } } ] }"
  },
  "ziti/config-store/managing.html": {
    "href": "ziti/config-store/managing.html",
    "title": "Managing Configurations | Ziti",
    "keywords": "Managing Configurations Here is a JSON schema, modeled on the tunneler client configuration. { \"$id\": \"http://myapp.company.com/schemas/myapp.v1.config.json\", \"additionalProperties\": false, \"properties\": { \"hostname\": { \"type\": \"string\" }, \"port\": { \"maximum\": 65535, \"minimum\": 0, \"type\": \"integer\" } }, \"required\": [ \"hostname\", \"port\" ], \"type\": \"object\" } Put the schema in a file named example-config-type.json , and you can create a configuration type named my-app with it. $ ziti edge create config-type my-app --schema-file example-config-type.json You can now create a configuration of this type $ ziti edge create config ssh-client my-app \\ '{ \"hostname\" : \"ssh.company.com\", \"port\" : 22 }' Finally, you can reference this when creating a service. $ ziti edge create service ssh --configs ssh If a particular site wanted SSH on a different port, you could create a different configuration $ ziti edge create config scranton-office-ssh-client my-app \\ '{ \"hostname\" : \"ssh.company.com\", \"port\" : 2222 }' The identity corresponding to a tunneler at that site could then be configured to use that configuration. $ ziti edge create identity service scranton-office $ ziti edge update identity-configs scranton-office ssh scranton-office-ssh-client $ ziti edge list identity service-configs scranton-office service: ssh config: scranton-office-ssh-client results: 1-1 of 1 Overrides can be removed as well, if they are no longer needed. $ ziti edge update identity-configs scranton-office ssh scranton-office-ssh-client --remove $ ziti edge list identity service-configs scranton-office results: none"
  },
  "ziti/config-store/overview.html": {
    "href": "ziti/config-store/overview.html",
    "title": "Configuration | Ziti",
    "keywords": "Configuration Ziti has the capability to define a configuration schema for an application and provide service configuration for those applications which need additional metadata. Why Centralized Configuration? One might ask why have this feature in Ziti when applications can store configuration data in local configuration files. While this approach works, centralized management makes deployments much easier. It can be difficult or impossible to update a file on a device out in the field, whereas updating the configuration in Ziti is easy, and running clients will quickly be notified of service changes. The Ziti tunneler applicatons provide an example how configuration data can be used. Tunnelers need to know what ip/dns and port(s) to intercept for services they are proxying on the client side Tunnelers need to know where to reach out to applications they are proxying on the server side Overview The configuration store has four components: Configuration types Configuration types define a type of configuration, including an optional JSON schema that the configuration data must conform to. Configuration types have the following attributes: A name An optional JSON schema to validate configurations of the type Standard edge attributes: id, tags, createdAt, updatedAt Configurations Configurations have the following attributes: A name The configuration data, which is arbitrary JSON data, so long as it conforms to the type schema (if specified) Standard edge attributes: id, tags, createdAt, updatedAt Services Each service can be linked to multiple configuration. Services can have one configuration linked for each configuration type. Identities An identity can have a configuration specified for a given service and configuration type. This will override any configuration for the service for that type This configuration model has the following properties: Different applications can have their own configuration for the same service Applications can have multiple configuration types for themselves where it makes sense Ziti tunnelers have one type for the client side and one for the server side, since they have different properties and not every service with use both Since an application can support multiple configuration types, applications can version their configuration types as their needs change"
  },
  "ziti/docker-quickstart.html": {
    "href": "ziti/docker-quickstart.html",
    "title": "Ziti Quickstart | Ziti",
    "keywords": "Ziti Quickstart This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant ziti concepts refer to the overview . This guide will utilize Docker to stand up a full and complete network. If you are unfamiliar with Docker take a moment and follow along with the steps for installing and running an application on your operating system. Once you feel comfortable, proceed to the steps below. From Nothing to Network Obtain the software necessary to run a Ziti network. You will need"
  },
  "ziti/downloads/enroller.html": {
    "href": "ziti/downloads/enroller.html",
    "title": "| Ziti",
    "keywords": "Windows MacOS Linux Linux/ARM"
  },
  "ziti/downloads/enroller-lts.html": {
    "href": "ziti/downloads/enroller-lts.html",
    "title": "| Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/downloads/overview.html": {
    "href": "ziti/downloads/overview.html",
    "title": "Ziti Related Downloads | Ziti",
    "keywords": "Ziti Related Downloads Here you'll find links to the various binaries needed to make a Ziti network or client work. Current Linux, MacOS, Windows Enroller Windows MacOS Linux Linux/ARM Tunneler Windows MacOS Linux iOS Android Previous Enroller Windows MacOS Linux Tunneler Windows MacOS Linux"
  },
  "ziti/downloads/tunneler.html": {
    "href": "ziti/downloads/tunneler.html",
    "title": "| Ziti",
    "keywords": "Windows MacOS Linux iOS Android"
  },
  "ziti/downloads/tunneler-lts.html": {
    "href": "ziti/downloads/tunneler-lts.html",
    "title": "| Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/downloads/ziti-cli.html": {
    "href": "ziti/downloads/ziti-cli.html",
    "title": "| Ziti",
    "keywords": "Linux, MacOS, Windows"
  },
  "ziti/getting-started.html": {
    "href": "ziti/getting-started.html",
    "title": "Getting Started! | Ziti",
    "keywords": "p{color:red;} li{ font-weight: bold; color: green; } foo Getting Started! abc def ghi"
  },
  "ziti/hello-ziti.html": {
    "href": "ziti/hello-ziti.html",
    "title": "| Ziti",
    "keywords": "If you are seeing this - you have successfully connected to a Ziti network!"
  },
  "ziti/identities/create-identity-cli.html": {
    "href": "ziti/identities/create-identity-cli.html",
    "title": "| Ziti",
    "keywords": "#creates a new user named \"NewUser\" ziti edge create identity user \"NewUser\" -o NewUser.jwt"
  },
  "ziti/identities/creating.html": {
    "href": "ziti/identities/creating.html",
    "title": "Creating an Identity | Ziti",
    "keywords": "Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created and enrolled. There are generally three enrollment methods for identities: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities Choosing an Enrollment Method Choosing which type of enrollment your identity will use comes down to whether you are using a 3rd Party CA or not. If the network does not have a 3rd Party Certificate configured the only option is to use the One Time Token (OTT) enrollment method. If one or more 3rd Party CA is installed you will need to understand the intention of each 3rd Party certificate. Each of the types of enrollments are secure it just depends on your actual network setup as to which type to choose. If you don't know - just use the One Time Token (OTT) method. The identity can always be recreated at a later date if necessary. One Time Token (OTT) The One Time Token method is available to all Ziti networks. A one time token enrolled identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the Ziti Admin Console. After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create an identity for one time token enrollment using the ziti cli tool. This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to the device where the permanent identity JSON file will be installed by running the enroll command. #creates a new user named \"NewUser\" ziti edge create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview The Ziti Controller is capable of using an existing PKI for authentication and authorization rather than to PKI configured in the Ziti Controller. Certificates that are not controlled by the Ziti Controller are referred to as \"3rd party\". If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" } 3rd Party CA - One Time Token 3rd Party CA OTT enrollment is closely related to OTT Enrollment . The main difference is the utilization of a 3rd party CA certificate rather than the configured Ziti Edge CA and PKI. In this method, the system does not have access to the 3rd party CA private key and thus cannot provide CSR fulfillment capabilities. Instead it is assumed that the enrolling device has a separate process to acquire signed certificates. Rather than submitting a CSR the client uses an already acquired signed certificate as its client certificate for the enrollment request. The client certificate is validated against the CA certificate tied to the one time token. Similar to the OTT Enrollment process, identities must be provisioned ahead of enrollment in order to generate one time token required and to creat the jwt that can be delivered to enrolling devices. This means that the provisioning of the Ziti Edge identities and the client certificates must be coordinated. Identities can be enrolled with a one time token flow similar to the one time token flow . 3rd Party CA - Auto Enrolled CA Auto Enrollment is useful in situations where devices are provisioned with certificates en-mass that need to be able to register as identities within Ziti Edge. This enrollment method allows for device provisioning processes to skip the manual configuration of Ziti Edge and instead allow clients to present a signed client certificate to generate an identity during the enrollment process. The identity will grant the client access to authenticate only - any authorization will need to be done after the device identities have been created. A certificate can only be used for one identity. The Ziti Edge system does not allow the same certificate to be used for multiple identities. An enrollment request is comprised of a special enrollment URL used to perform an HTTP POST request using the signed client certificate as the TLS client certificate and an optional JSON payload that allows the client to specify the devices display name and internal username. See enrollment for more details on enrolling. New 3rd Party CA Identity via UI New 3rd Party Identity via CLI On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save #creates a new user named \"NewUser\" ziti edge create identity user \"NewUser\" -o NewUser.jwt Choosing an Identity Type The three types of identities are: User Device Service These are functionally equivalent and have identical properties. You may wish to express the intended purpose of an identity by choosing one or another type when the identity is created. The type can not be changed."
  },
  "ziti/identities/enrolling.html": {
    "href": "ziti/identities/enrolling.html",
    "title": "Enrolling an Identity | Ziti",
    "keywords": "Enrolling an Identity All connections made to the Ziti network leverage mutual TLS which means every client needs a valid X509 certificate which it will present to the Ziti network during the connection process. The process of obtaining a key/certificate pair and presenting it securely to the Ziti Controller is called \"Enrollment\". Overview All identities need to be enrolled with the Ziti Controller so the Ziti Controller can authenticate the incoming connection. This process is slightly different for each type of identity and is complex. The easiest way to enroll an identity is to use either the Ziti Desktop Edge/Ziti Mobile Edge for your operating system. Alternatively, you may perform the enrollment separate with the ziti CLI: Linux, MacOS, Windows One Time Token Enrollment - Internal PKI Perhaps the easiest path to an enrolled identity is by using the one-time token enrollment flow. This flow leverages the PKI configured in the Ziti Controller. Using the one-time token flow - the ziti CLI will generate a private key and a certificate signing request for the Ziti Controller's built-in certificate authority to fulfill. Follow these steps to enroll an identity with a one-time token: create the Identity download or copy the JWT - this file contains the single use token run ziti : Example Usage: ziti edge enroll \\ --jwt ${jwt_file} \\ --out ${identity_config_file} Important The output from the ziti is a permanent identity configuration file which must be stored securely. This file contains within it the private key that backs the certificate issued by the Ziti Controller. This file should not be transferred or shared and should not be moved from the machine unless you are confident you understand the risks involved in doing so. 3rd Party CA - One Time Token This process is similar to the One Time Token flow from above. This flow expects that a private key and certificate have already been created on or distributed to the machine that is about to enroll and that the certificate presented is signed by a third party CA already validated in the Ziti Controller. Follow these steps to enroll a 3rd Pary CA - one-time token identity: create the Identity download or copy the JWT - this file contains the one-time token run the ziti-tunneler for your given operating system. Notice you can provide the name of the identity : Example Usage: ziti edge enroll \\ --cert ${user_certificate} \\ --key ${user_private_key} \\ --jwt ${one_time_jwt_file} \\ --out ${identity_config_file} 3rd Party CA - Auto When using a third party CA identity creation process in the Ziti Controller is automatic. The act of enrolling the identity will create it. Like \"3rd Party CA One Time Token\" - this flow expects that a private key and certificate have already been created on or distributed to the machine that is about to enroll. The certificate presented to the Ziti Controller must be issued by a third party CA that was already imported and verified in the Ziti Controller with the isAutoCaEnrollmentEnabled property set to true. Using the ziti CLI will also require the re-use of a permanent JWT that is unique to the external CA. The JWT can be downloaded from the Ziti Controller from: ${controller_uri}/cas/${id}/jwt where ${controller_uri} represents the fully qualified address of the Ziti Controller api and ${id} represents the identifier for the given third party CA. Example Usage: ziti edge enroll \\ --cert ${user_certificate} \\ --key ${user_private_key} \\ --jwt ${reusable_ca_jwt_file} \\ --out ${identity_config_file} If supplied the idname will be used as the name for the identity created. The default name of auto-created identities is generated from a template that uses values from the user certificate i.e. [caName]-[commonName] ."
  },
  "ziti/identities/overview.html": {
    "href": "ziti/identities/overview.html",
    "title": "Ziti Identities | Ziti",
    "keywords": "Ziti Identities Ziti is built on the foundation of zero-trust. A solid pillar of that foundation requires that all connections in a Ziti-enabled network are authenticated. Identities are the basis for Ziti authentication. All devices connecting to a Ziti network will have an Identity which is presented at the time of a connection being established by both the device initiating the connection and the device receiving the incoming connection. Ziti implements mutual TLS in order to authenticate both sides of a connection. Conceptually an identity can be thought of as congruent to a user account. Identities are logical entities stored inside the Ziti Controller which map an X509 certifcate to a particular named identity. Identities exist not only to authenticate connections but are also used to authorize identities within Ziti. See Policies for more information on authoriziation of identities. 3rd Party Certificates The certificate a Ziti Edge client presents can be generated by the Ziti Controller using the configured PKI or this certificate can come from a existing PKI not controlled by the Ziti Controller. Certificates which are not created by the Ziti Controller are referred to as \"3rd Party\" because from the perspective of the Ziti Controller the certificates are not from the configured PKI. Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created and enrolled. There are generally three enrollment methods for identities: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities Choosing an Enrollment Method Choosing which type of enrollment your identity will use comes down to whether you are using a 3rd Party CA or not. If the network does not have a 3rd Party Certificate configured the only option is to use the One Time Token (OTT) enrollment method. If one or more 3rd Party CA is installed you will need to understand the intention of each 3rd Party certificate. Each of the types of enrollments are secure it just depends on your actual network setup as to which type to choose. If you don't know - just use the One Time Token (OTT) method. The identity can always be recreated at a later date if necessary. One Time Token (OTT) The One Time Token method is available to all Ziti networks. A one time token enrolled identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the Ziti Admin Console. After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create an identity for one time token enrollment using the ziti cli tool. This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to the device where the permanent identity JSON file will be installed by running the enroll command. #creates a new user named \"NewUser\" ziti edge create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview The Ziti Controller is capable of using an existing PKI for authentication and authorization rather than to PKI configured in the Ziti Controller. Certificates that are not controlled by the Ziti Controller are referred to as \"3rd party\". If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" } 3rd Party CA - One Time Token 3rd Party CA OTT enrollment is closely related to OTT Enrollment . The main difference is the utilization of a 3rd party CA certificate rather than the configured Ziti Edge CA and PKI. In this method, the system does not have access to the 3rd party CA private key and thus cannot provide CSR fulfillment capabilities. Instead it is assumed that the enrolling device has a separate process to acquire signed certificates. Rather than submitting a CSR the client uses an already acquired signed certificate as its client certificate for the enrollment request. The client certificate is validated against the CA certificate tied to the one time token. Similar to the OTT Enrollment process, identities must be provisioned ahead of enrollment in order to generate one time token required and to creat the jwt that can be delivered to enrolling devices. This means that the provisioning of the Ziti Edge identities and the client certificates must be coordinated. Identities can be enrolled with a one time token flow similar to the one time token flow . 3rd Party CA - Auto Enrolled CA Auto Enrollment is useful in situations where devices are provisioned with certificates en-mass that need to be able to register as identities within Ziti Edge. This enrollment method allows for device provisioning processes to skip the manual configuration of Ziti Edge and instead allow clients to present a signed client certificate to generate an identity during the enrollment process. The identity will grant the client access to authenticate only - any authorization will need to be done after the device identities have been created. A certificate can only be used for one identity. The Ziti Edge system does not allow the same certificate to be used for multiple identities. An enrollment request is comprised of a special enrollment URL used to perform an HTTP POST request using the signed client certificate as the TLS client certificate and an optional JSON payload that allows the client to specify the devices display name and internal username. See enrollment for more details on enrolling. New 3rd Party CA Identity via UI New 3rd Party Identity via CLI On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save #creates a new user named \"NewUser\" ziti edge create identity user \"NewUser\" -o NewUser.jwt Choosing an Identity Type The three types of identities are: User Device Service These are functionally equivalent and have identical properties. You may wish to express the intended purpose of an identity by choosing one or another type when the identity is created. The type can not be changed. Enrolling an Identity All connections made to the Ziti network leverage mutual TLS which means every client needs a valid X509 certificate which it will present to the Ziti network during the connection process. The process of obtaining a key/certificate pair and presenting it securely to the Ziti Controller is called \"Enrollment\". Overview All identities need to be enrolled with the Ziti Controller so the Ziti Controller can authenticate the incoming connection. This process is slightly different for each type of identity and is complex. The easiest way to enroll an identity is to use either the Ziti Desktop Edge/Ziti Mobile Edge for your operating system. Alternatively, you may perform the enrollment separate with the ziti CLI: Linux, MacOS, Windows One Time Token Enrollment - Internal PKI Perhaps the easiest path to an enrolled identity is by using the one-time token enrollment flow. This flow leverages the PKI configured in the Ziti Controller. Using the one-time token flow - the ziti CLI will generate a private key and a certificate signing request for the Ziti Controller's built-in certificate authority to fulfill. Follow these steps to enroll an identity with a one-time token: create the Identity download or copy the JWT - this file contains the single use token run ziti : Example Usage: ziti edge enroll \\ --jwt ${jwt_file} \\ --out ${identity_config_file} Important The output from the ziti is a permanent identity configuration file which must be stored securely. This file contains within it the private key that backs the certificate issued by the Ziti Controller. This file should not be transferred or shared and should not be moved from the machine unless you are confident you understand the risks involved in doing so. 3rd Party CA - One Time Token This process is similar to the One Time Token flow from above. This flow expects that a private key and certificate have already been created on or distributed to the machine that is about to enroll and that the certificate presented is signed by a third party CA already validated in the Ziti Controller. Follow these steps to enroll a 3rd Pary CA - one-time token identity: create the Identity download or copy the JWT - this file contains the one-time token run the ziti-tunneler for your given operating system. Notice you can provide the name of the identity : Example Usage: ziti edge enroll \\ --cert ${user_certificate} \\ --key ${user_private_key} \\ --jwt ${one_time_jwt_file} \\ --out ${identity_config_file} 3rd Party CA - Auto When using a third party CA identity creation process in the Ziti Controller is automatic. The act of enrolling the identity will create it. Like \"3rd Party CA One Time Token\" - this flow expects that a private key and certificate have already been created on or distributed to the machine that is about to enroll. The certificate presented to the Ziti Controller must be issued by a third party CA that was already imported and verified in the Ziti Controller with the isAutoCaEnrollmentEnabled property set to true. Using the ziti CLI will also require the re-use of a permanent JWT that is unique to the external CA. The JWT can be downloaded from the Ziti Controller from: ${controller_uri}/cas/${id}/jwt where ${controller_uri} represents the fully qualified address of the Ziti Controller api and ${id} represents the identifier for the given third party CA. Example Usage: ziti edge enroll \\ --cert ${user_certificate} \\ --key ${user_private_key} \\ --jwt ${reusable_ca_jwt_file} \\ --out ${identity_config_file} If supplied the idname will be used as the name for the identity created. The default name of auto-created identities is generated from a template that uses values from the user certificate i.e. [caName]-[commonName] ."
  },
  "ziti/index.html": {
    "href": "ziti/index.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "ziti/manage/controller.html": {
    "href": "ziti/manage/controller.html",
    "title": "Ziti Controller | Ziti",
    "keywords": "Ziti Controller The Ziti Controller is the process that coordinates a Ziti Networks . It is responsible for authenticating incoming connections from identities. It also authorizes access to services for any given identity. The Ziti Controller provides two RESTful APIs for other processes to interact with it. Take a look at the API doc page for more info. Prerequisite - PKI Public Key Infrastructure (PKI) is a complex topic. See the pki page for additional details about the sort of needs and considerations relevant to the Ziti Controller. You will need a correct PKI setup for Ziti to work. If you follow one of the quickstart guides , a full PKI will be generated for you. This is probably the best way to start out. Sizing Guidelines The Ziti Controller and Ziti Routers are still in the process of being stress tested. We recommend starting with a small scale deployment until key performance indicators start to hint that the server requires more resources. A Ziti Networks will have two important metrics: CPU and network capacity. Modest sized networks require minimal investments in infrastructure. Start with small machines and increase as needed. Configuration The Ziti Controller is configured using a yaml file. If you follow one of the quickstart guides a configuration file will be generated. You can also find a sample config file from the ziti repo . Each section is annotated and should provide you enough information to modify a given setting. Most of the fields are straight-forward. The pki-related fields are the ones you will need to pay particular attention to. See the pki page for relevant information on pki settings. Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues."
  },
  "ziti/manage/edge-router.html": {
    "href": "ziti/manage/edge-router.html",
    "title": "Edge Router | Ziti",
    "keywords": "Edge Router The Edge Router is the entry point for Ziti-based clients. It is responsible for authenticating incoming connections by verifying the connecting client has a valid network session. It also routes traffic to whatever the destination is for the given service. In simple deployments - a single edge router might be deployed. This is the case with the Ziti Network Quickstart . In the coming months it will be possible to produce complicated deployments having multiple Edge Routers deployed in a myriad of locations. Sizing Guidelines The Ziti Controller and Ziti Routers are still in the process of being stress tested. We recommend starting with a small scale deployment until key performance indicators start to hint that the server requires more resources. A Ziti network will have two important metrics: CPU and network capacity. Modest sized networks require minimal investments in infrastructure. Start with small machines and increase as needed. Configuration The Edge Router is configured using a yaml file. An example configuration file can be found here . Each section is annotated and should provide enough information to modify a given setting. Most of the fields are straight-forward. Edge Router Identity The pki-related fields in the identity section are important to understand and pay particular attention to. The files specified here are generated durring the process of enrolling the edge router. As is also stated in the configuration file these files do not need to exist before enrollment. These files will be written to during the enrollment process. This means the process running the enrollment will need the correct privledges grated to it in order to write - or overwrite those files. If the key specified in the identity section already exists - it will not be overwritten. Instead it will be used during the enrollment process. Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues. Enrollment Enrollment is the process of securely generating information used to identify a given client. All endpoints need to be enrolled in one way or another. The Edge Router is a client of a Ziti Network and thus it too must be enrolled before it will be able to participate in a Ziti network. An Edge Router is enrolled using the ziti-router enroll command and sub-command. Running ziti-router enroll In order to enroll the Edge Router a valid configuration file is needed. After creating a valid configuration the jwt for the Edge Router also needs to be obtained from the Ziti Controller. The jwt can be retrieved from the Ziti Controller via the Ziti Controller's REST API at https://${controller-name}:${controller-port}/edge-routers. With a valid configuration file and jwt the router can now be enrolled using: ziti-router enroller [path to configuration file] --jwt [path to jwt] ."
  },
  "ziti/manage/logging-snippet.html": {
    "href": "ziti/manage/logging-snippet.html",
    "title": "Logging | Ziti",
    "keywords": "Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues."
  },
  "ziti/manage/manage.html": {
    "href": "ziti/manage/manage.html",
    "title": "Managing Ziti | Ziti",
    "keywords": "Managing Ziti Ziti management needs to be hands off. The only times one should be expected to be concerned with managing a Ziti instance is during the initial installation and when trying to expand the Ziti footprint. Installation Ziti Edge - Developer Edition An initial, simple installation of Ziti is already provided for you when using the Ziti Network Quickstart . The installation will contain a Ziti Controller , a Ziti Edge Router and corresponding PKI . See the corresponding sections for additional details. Ziti Installation - the long way At its most simple, a basic Ziti Network is composed of only two (or three depending on whether you count the database) components. The Ziti Controller and a Ziti Edge Router . (Note: these executables are not currently available for separate download but will be coming in the months ahead.) Expanding Ziti At this time Ziti is only offered as the Ziti Edge - Developer Edition which is not expandable beyond a single node at this time. As you would exepct, allowing Ziti to be expanded past the developer experience is planned. Check back in the coming months for more information."
  },
  "ziti/manage/pki.html": {
    "href": "ziti/manage/pki.html",
    "title": "Public Key Infrastructure (PKI) | Ziti",
    "keywords": "Public Key Infrastructure (PKI) All Ziti Networks leverage Public Key Infrastructure (PKI) to provide secure network connections. This page is not intended to be a comprehensive guide. What it is, is a set of rules that must be followed to properly configure a Ziti Network. If there are issues when connecting any portion of a Ziti Network to another - this page should serve as a starting point of understanding. Note PKI is a complex topic and it is recommended to be familiar with what is a PKI as well as how to properly use and configure a one before making any decisions about the PKI the Ziti Network uses. The Ziti Network allows the operator to declare any trust anchors as valid. This means Ziti does not need to be configured with a full chain of certificates which link fully back to a root CA. A configuration using a full chain back to a root CA is of course supported but it is not explicitly required. This allows the operator to configure a Ziti Network using one or more chains of trust back to the provided trust anchors. The sections below will describe where these trust anchors can be configured. Ziti Network components are required to present a certificate to other Ziti Network components during the connection establishment. This certificate will need to be valid per the configured trust anchor store being connected to. Ziti Controller The Ziti Controller has three distinct sections related to PKI: identity , edge.api.identity , edge.enrollment.signingCert . The edge.api.identity configuration section is optional and is provided to allow the external REST endpoint to present a certificate that is different than the one configured in the identity section. Connections to the Ziti Controller are considered valid if the certificate presented during connection is signed by a trust anchor declared within the identity.ca configuration or if the certificate presented is signed by the certificate specified in the edge.enrollment.signingCert . PKI Configuration The identity section of the Ziti Controller configuration is used by the Ziti Controller when connections are established to or from other components of a Ziti Network. There are four sections in the identity block: cert , server_cert , key , ca . ca : A file representing a group of certificates with one or more certificate chains terminating at a trust anchor. When a Ziti Network component connects to the Ziti Controller and offers a certificate for validation the incoming connection is checked to see if it signed by a trust anchor specified in this file. key : Also referred to as the private key . It is generated first and used to produce the certificates specified in the cert and server_cert fields of the Ziti Controller configuration file. cert : The certificate presented to other Ziti Network components during connection establishment. server_cert : The certificate returned by the Ziti Controller when other Ziti Network components attempt to communicate to the Ziti Controller over the IP and port specified in the ctrl.listener or mgmt.listener fields of the Ziti Controller configuration file. If an edge section is present in the configuration file and no edge.api.identity section exists this certificate is also returned to incoming connections to the edge.api.advertise endpoint. Edge Router An Edge Router has one section related to PKI: identity . It is important to note that an Edge Router will manage its own PKI. Allowing the Edge Router to manage its own PKI is almost certainly desired. The only setting that an operator may wish to provide is the key field of the identity. This field is treated differently than the other values specified. If the key specified does not exist a new key will be generated. If the key provided exists the Edge Router will use it and the other fields will be regenerated and overwritten as necessary. The certificate generated will be signed by the Ziti Controller using the certificate specified in edge.enrollment.signingCert . PKI Configuration The identity section of the Edge Router configuration is used by the Edge Router when connections are established to or from the other components of a Ziti Network. There are four sections in the identity block: cert , server_cert , key , ca . ca : A file representing a group of certificates with one or more certificate chains terminating at a trust anchor. When a Ziti Network component connects to the Edge Router and offers a certificate for validation the incoming connection is checked to see if it signed by a trust anchor specified in this file. key : Also referred to as the private key . It is generated first and used to produce the certificates specified in the cert and server_cert fields of the Edge Router configuration file. cert : The certificate presented to other Ziti Network components during connection establishment. server_cert : The certificate returned by the Edge Router when other Ziti Network components attempt to communicate to the Edge Router over the IP and port specified in the ctrl.listener or mgmt.listener fields of the Edge Router configuration file. Third Party CA (optional) A third party CA is one which is maintained and managed entirely outside of the Ziti Network. This is an important feature for organizations wishing to administer and maintain the certificates used by the different pieces of the Ziti Network. A Ziti Network is capable of using third party PKIs as the trust mechanism for enrollment and authentication of clients for a Ziti Network. With the PKI being managed externalliy a Ziti Network is never in posession of the private key. This means the Ziti Network cannot maintain nor distribute certificates necessary for creating secure connections. The Ziti Network is only capable of verifying if the certificate presented was signed by the externally managed PKI. Maintaining a PKI outside of the Ziti Network is a more complex configuration. If a PKI is already established and maintained externally setting up a Ziti Network with a third party CA may be desired. Registering the CA A Ziti Network will not trust any third party CA implicitly. Before a third party CA can be used for enrollment and authentication of clients in a Ziti Network it must be registered with the Ziti Controller to ensure certificates signed by the third party CA can be trusted. Registering a third party CA is done by using the REST endpoint /cas from the Ziti Controller. To register a third party CA the following information is required to be posted to the endpoint: name : the desired name of the CA isEnrollmentEnabled : a boolean value indicating if the CA can be used for enrollment. Defaults to true. Set to false to prevent further enrollments using this CA isAuthEnabled : a boolean value indicating if the CA can be used for authentication. Defaults to true. Set to false to prevent all authentication from endpoints signed by this certificate Assuming the create request was well formed and successful, the response from this invocation will contain a field representing the id of the third party CA at data.id . The id of the third party CA will be needed when validating the third party CA. Validating the CA After being submitted to the Ziti Controller, the third party CA will have the isCsrValidated field set to false indicating it is not yet ready for use. A second step is needed to ensure the third party CA is setup properly as a CA. This step ensures the third party CA provided is capable of fullfilling CSR requests. Clients attempting to connect to a Ziti Network using the third party CA will be rejected. To validate the third party CA a CSR must be generated and fulfilled by the third party CA to generate a certificate with the common name (CN) field set to a value assigned by the Ziti Controller. The Ziti Controller /cas REST endpoint can be interrogated to retrieve the details for a specific third party CA. The field necessary to validate the third party CA is data.verificationToken and is obtained at this endpoint. A certificate is then created and signed by the third party CA with the common name field set to the verificationToken. To finish verifying the third party CA, the certificate created with the verificationToken is posted back to the Ziti Controller at /cas/${id}/verify . The id is also obtained during the creation process. After posting the certificate with the verificationToken as the common name the third party CA will change from isVerified=false to isVerified=true . PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. This guide will also use the paths you will find in the Ziti Edge - Developer Edition. Change paths accordingly. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just make sure bash, openssl, ruby, and jq are installed. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (without ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi if [[ \"\" == \"$2\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) edge_router_ca=$(yaml2json $edge_router_config_file | jq -j .identity.ca) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "ziti/manage/pki-troubleshooting.html": {
    "href": "ziti/manage/pki-troubleshooting.html",
    "title": "PKI Troubleshooting | Ziti",
    "keywords": "PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. This guide will also use the paths you will find in the Ziti Edge - Developer Edition. Change paths accordingly. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just make sure bash, openssl, ruby, and jq are installed. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (without ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi if [[ \"\" == \"$2\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) edge_router_ca=$(yaml2json $edge_router_config_file | jq -j .identity.ca) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "ziti/manage/router-overview.html": {
    "href": "ziti/manage/router-overview.html",
    "title": "Ziti Router | Ziti",
    "keywords": "Ziti Router A Ziti Router is a process that is installed on a host which allows it to participate in a Ziti network. There are two types of routers: edge routers and fabric routers. At this time edge routers are available for use with a Ziti Network . See the Ziti Network Quickstart for details about how to create your network. Read more about edge routers here ."
  },
  "ziti/manage/troubleshooting.html": {
    "href": "ziti/manage/troubleshooting.html",
    "title": "Troubleshooting | Ziti",
    "keywords": "Troubleshooting This is where troubleshooting information will be added. Right now the biggest issue people have had is during initial setup of a Ziti Network and with PKI configuration. As additional troubleshooting needs become apparent this page will be updated. PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. This guide will also use the paths you will find in the Ziti Edge - Developer Edition. Change paths accordingly. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just make sure bash, openssl, ruby, and jq are installed. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (without ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi if [[ \"\" == \"$2\" ]] then echo \"Usage: verifyCertAgainstPool [cert to test] [ca pool to use]\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) edge_router_ca=$(yaml2json $edge_router_config_file | jq -j .identity.ca) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json controller_config_file=~/.config/ziti/ziti-controller/ziti_controller.yml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -j .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -j .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -j .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/enrolled-identity.json edge_router_config_file=~/.config/ziti/ziti-router/ziti_router.yml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -j .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "ziti/manage/tunneler.html": {
    "href": "ziti/manage/tunneler.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "ziti/metrics/file.html": {
    "href": "ziti/metrics/file.html",
    "title": "File Reporter | Ziti",
    "keywords": "File Reporter The Ziti Controller event system can write metrics to a file for direct viewing or post-processing into a metrics system of your choice. Ziti Configuration There are two independent configurations that need to be set up for metric event reporting to work: Report Interval: The controller and routers need to have a metric reporting interval set. The interval determines how often metrics will be sent to the controller and possibly written out to file Event Subscription: The subscription is configured in the controller, and determines which of the reported metrics are written. Metrics Reporting The reporting interval is defined in the metrics.reportInterval property. While the controller and each router can have a different reporting interval, we suggest that you set them all the same to make lining up metrics across the cluster easier. Example: metrics: reportInterval: 20s Routers support an additional configuration parameter MessageQueueSize which is the number of unsent metrics messages that can sit in the router metrics queue before metrics gathering is paused. Example: metrics: reportInterval: 20s messageQueueSize: 20 // Default 10 Metrics Writing Writing of metrics is broken into two pieces: subscription: Which metrics will be written hander: how the metrics will be written Metrics Subscription The metrics subscription defines which metrics will be written and how they will be written. There are two parts to a metrics event reporter The subscription has three components sourceFilter: Which components to write metrics for. This is a regular expression. ctrl_client: Special marker for the controller Router ID: Get metrics for one and only one router .*: Get metrics from the controller and all routers metricFilter: Which metrics to report. This is a regular exporession .*pool.*: Report only pool metrics .*: Report all metrics Example: events: allControllerMetrics: subscriptions: - type: metrics sourceFilter: ctrl_client metricFilter: .* justEdgeRouterPoolMetrics: subscriptions: - type: metrics sourceFilter: .* metricFilter: .*pool.* Metrics Handling The metrics handler defined how metrics are to be written. It is comprised of: type: The type of handler. Supported types are: file: Metrics will be written to a file maxsizemb: File rolling - log files will be rolled when they reach this size. Default size is 10mb . maxbackups File rolling - the number of files to keep. Default is 0 (unlimited) . format: The format of the metric. Supported formats are: json path: The name of the file to write metrics to File Rolling files are rolled when they reach a size of maxsizemb . Files are renamed from name.log to name-iso8601.log For example, name-2022-06-07T18-50-44.568.log Example Write 100mb files, saving 2 of them. handler: type: file format: json maxsizemb: 100 maxbackups: 2 path: /tmp/controller-metrics.log Puting it all together Controller configuration file: metrics: reportInterval: 20s events: allControllerMetrics: subscriptions: - type: metrics sourceFilter: ctrl_client metricFilter: .* handler: type: file format: json maxsizemb: 50 maxbackups: 2 path: /tmp/controller-metrics.log justPoolMetrics: subscriptions: - type: metrics sourceFilter: .* metricFilter: .*pool.* handler: type: file format: json maxsizemb: 100 maxbackups: 5 path: /tmp/router-pool-metrics.log Router configuration files: metrics: reportInterval: 20s Types of Metrics Reported Ziti is instrumenting more code and adding additional metrics all of the time. This section will describe the different types of metrics that ziti reports, not individual metric names. intValue/floatValue A gauge of a single value. The value is the current metric value, and can go up and down over time Histogram Standard histogram with: min max mean stdev variance percentiles p50 p75 p95 p99 p999 p9999 Timer Timer metric with: count m1_rate m5_rate m15_rate min max mean std_dev variance percentiles p50 p75 p95 p99 p999 p9999 Metric Examples intValue { \"metric_type\": \"intValue\", \"namespace\": \"metrics\", \"source_id\": \"ctrl_client\", \"version\": 2, \"timestamp\": { \"seconds\": 1654625684, \"nanos\": 479708609 }, \"metric\": \"pool.listener.mgmt.worker_count\", \"metrics\": { \"value\": 1 }, \"source_event_id\": \"acb85925-0e17-4ca0-90cb-9a2498b33bc8\" } Histogram { \"metric_type\": \"histogram\", \"namespace\": \"metrics\", \"source_id\": \"ctrl_client\", \"source_entity_id\": \"xpw7BEDAk\", \"version\": 2, \"timestamp\": { \"seconds\": 1654625684, \"nanos\": 479708609 }, \"metric\": \"ctrl.queue_time\", \"metrics\": { \"count\": 57, \"max\": 21647, \"mean\": 15266.508771929824, \"min\": 5753, \"p50\": 15670, \"p75\": 16558.5, \"p95\": 18362.699999999997, \"p99\": 21647, \"p999\": 21647, \"p9999\": 21647, \"std_dev\": 2604.8795245927113, \"variance\": 6785397.337642349 }, \"source_event_id\": \"acb85925-0e17-4ca0-90cb-9a2498b33bc8\" } Timer { \"metric_type\": \"timer\", \"namespace\": \"metrics\", \"source_id\": \"ctrl_client\", \"version\": 2, \"timestamp\": { \"seconds\": 1654625684, \"nanos\": 479708609 }, \"metric\": \"api.session.enforcer.run\", \"metrics\": { \"count\": 11, \"m15_rate\": 0.2, \"m1_rate\": 0.2, \"m5_rate\": 0.2, \"max\": 6842849, \"mean\": 1096126.3636363635, \"mean_rate\": 0.20374652060865114, \"min\": 254514, \"p50\": 335348, \"p75\": 1212318, \"p95\": 6842849, \"p99\": 6842849, \"p999\": 6842849, \"p9999\": 6842849, \"std_dev\": 1858257.4031879376, \"variance\": 3453120576502.777 }, \"source_event_id\": \"acb85925-0e17-4ca0-90cb-9a2498b33bc8\" }"
  },
  "ziti/metrics/inspect.html": {
    "href": "ziti/metrics/inspect.html",
    "title": "On Demand | Ziti",
    "keywords": "On Demand The Ziti Controller supports pulling metrics on demand via the inspections framework. The inspections framework is part of the fabric API, hosted by the controller. The fabric API binding will need to be enabled in the controller configuration file for this to work. Ziti Command Line The Ziti fabric CLI has support for the inspect command built in. Here's an example: ziti fabric inspect '.*' metrics:json Let's break that command down a bit: ziti fabric inspect: The base fabric inspect command. .*: The network components to inspect. .* inspects everything, other options include: ctrl_client: Just the controller Router Id: Just a single router metrics:json: Get metrics in json format. Other formats include: prometheus: Get metrics in the Prometheus text exposition format . Tip The default CLI result will strip json markup. Add -j to the inspect command to get the raw json output."
  },
  "ziti/metrics/metric-types.html": {
    "href": "ziti/metrics/metric-types.html",
    "title": "Types of Metrics Reported | Ziti",
    "keywords": "Types of Metrics Reported Ziti is instrumenting more code and adding additional metrics all of the time. This section will describe the different types of metrics that ziti reports, not individual metric names. intValue/floatValue A gauge of a single value. The value is the current metric value, and can go up and down over time Histogram Standard histogram with: min max mean stdev variance percentiles p50 p75 p95 p99 p999 p9999 Timer Timer metric with: count m1_rate m5_rate m15_rate min max mean std_dev variance percentiles p50 p75 p95 p99 p999 p9999"
  },
  "ziti/metrics/overview.html": {
    "href": "ziti/metrics/overview.html",
    "title": "Ziti Metrics | Ziti",
    "keywords": "Ziti Metrics Ziti can report system metrics in a few different ways Scraping metrics using the Prometheus format Writing to a file On demand report No metrics are reported by default. Prometheus Endpoint The network controller can expose a /metrics endpoint that returns metrics for the whole network in the prometheus format. See Prometheus for more information. File Reporter The network controller can write metrics to a text file at a configurable rate. The controller writes metrics for the whole network. See File for more information. On Demand The inspect facility built into the Ziti Fabric CLI can retrieve metrics from some or all network components on demand. The metrics can be displayed in plain text or json format. See Inspect for more information"
  },
  "ziti/metrics/prometheus.html": {
    "href": "ziti/metrics/prometheus.html",
    "title": "Prometheus Endpoint | Ziti",
    "keywords": "Prometheus Endpoint The Ziti Controller can expose a /metrics endpoint that serves network metrics in the Prometheus text exposition format . The endpoint is exposed over HTTPS, and has optional support for client authentication via a certificate. Ziti Configuration The Prometheus metric binding is configured as part of the controller configuration file. Binding The Prometheus metrics api is not bound to any interface by default. The metrics api can be bound to the same network interface and port as the other Ziti APIs, or it can be set up on its own interface and/or port. Listener Just for Metrics The metric api can be configured to listen on its own combination of network interface and port by adding a new section under the web configuration web # Binding for other Ziti APIs - name: apis bindPoints: - interface: 0.0.0.0:1280 address: 0.0.0.0:1280 options: idleTimeout: 5000ms #http timeouts, new readTimeout: 5000ms writeTimeout: 100000ms apis: # binding - required # Specifies an API to bind to this webListener. Built-in APIs are # - health-checks # - edge-management # - edge-client # - fabric-management # - metrics - binding: health-checks options: { } - binding: fabric - binding: edge-management # options - variable optional/required # This section is used to define values that are specified by the API they are associated with. # These settings are per API. The example below is for the `edge-api` and contains both optional values and # required values. options: { } - binding: edge-client options: { } # New binding for metrics - name: apis-metrics-localhost bindPoints: #interface - required # A host:port string on which network interface to listen on. 0.0.0.0 will listen on all interfaces - interface: 127.0.0.1:2112 # address - required # The public address that external incoming requests will be able to resolve. Used in request processing and # response content that requires full host:port/path addresses. address: 127.0.0.1:2112 options: apis: - binding: metrics options: { } Add Metrics API to an Existing Listener The metrics binding can be added to an existing listener in the controller. web -name: apis bindpoints: apis: - binding: health-checks options: { } - binding: fabric - binding: edge-management options: { } - binding: edge-client options: { } - binding: metrics options: { } Authentication Authentication is done by adding a client certificate to the metrics binding. The metrics endpoint will return a 401 if this certificate is not presented by clients when they connect. The certificate is completely stand-alone - it does not need to be signed by Ziti. The configuration is added as an option in the metrics binding. The file must be an x509 certificate. - binding: metrics options: { scrapeCert: \"/etc/prometheus/prom-client.crt\" } Prometheus Configuration TLS Configuration The /metrics api requires TLS configuration in Prometheus. The Prometheus scrape config must have the ziti web public key, or be configured to ignore private keys. - job_name: ziti scheme: https metrics_path: /metrics honor_labels: true honor_timestamps: true tls_config: // Path to the cert file with the ziti public key ca_file: /etc/prometheus/server.crt // OR ignore the key insecure_skip_verify: true static_configs: - targets: - '127.0.0.1:2112' With Authentication It's a good idea to have metrics protected by a certificate to prevent neferious actors from pulling metrics about your network. The Prometheus scrape configuration can be configured with a keystore for this purpose: - job_name: ziti scheme: https metrics_path: /metrics honor_labels: true honor_timestamps: true tls_config: cert_file: /etc/prometheus/prom-client.crt key_file: /etc/prometheus/prom-client.key ca_file: /etc/prometheus/server.crt static_configs: - targets: - '127.0.0.1:2112' Examples Setup Metrics Authentication In this example you will: Create a new cert and signing request Sign the key Add the key into your Ziti Controller configuration Add the key to your prometheus scrape config Create a cert for metric scraping # Create the certificate and signing request openssl req -new -newkey rsa:2048 -nodes -keyout prom-client.key -out prom-client.csr # Process the cert signing signing request. This cert will be good for 10 years. openssl x509 -req -days 3650 -in /tmp/prom-client.csr -signkey prom-client.key -out prom-client.crt Add the Cert to Ziti Open your ziti configuration file and set up the metrics api binding as shown in the Authentication section above. Some common things to watch out for: The Ziti Controller will need to be restarted after editing the configuration file Best practices is to use a separate metrics listener that is only accessible from Prometheus. This configuration will expose the metrics/ on the loopback address, port 2112. Add this text to the web section of your network controller configuration file - name: metrics-localhost bindPoints: - interface: 127.0.0.1:2112 address: 127.0.0.1:2112 apis: - binding: metrics options: { scrapeCert: \"/path/to/prom-client.crt\" } Test the Key I use curl to test my keys when I set up metrics. If Ziti is configured to bind metrics to 127.0.0.1:2112 then curl command will be: curl -i -k --cert /path/to/prom-client.crt --key /path/to/prom-client.key https://127.0.0.1:2112/metrics The options to the curl command mean: -i: Print the http status code and response headers -k: Ziti uses a self-signed cert, this option tells curl to ignore the server certificate --cert: The path to the prom-client.crt created above --key: The path to prom-client.key created above The result should spit out a bunch of metrics. If you see a 401 response then double-check that you've copied all of the bits from the certificate into the controller configuration file. Add the Key to Prometheus The key is added to Promtetheus by referencing the crt and key files from the Ziti scrape configuration. Your scrape config will look something like this: global: scrape_interval: 10s scrape_timeout: 10s rule_files: - alert.yml scrape_configs: - job_name: self metrics_path: /metrics static_configs: - targets: - 'prometheus:9090' - job_name: ziti scheme: https metrics_path: /metrics honor_labels: true # Ziti supplies system labels for the edge routers, so we need to obey them honor_timestamps: true # Honor server timestamps instead of using the scrape timestamp for metrics tls_config: cert_file: /path/to/prom-client.crt key_file: /path/to/prom-client.key insecure_skip_verify: true static_configs: - targets: - '127.0.0.1:2112'"
  },
  "ziti/overview.html": {
    "href": "ziti/overview.html",
    "title": "Overview | Ziti",
    "keywords": "Overview Ziti represents the next generation of secure, open-source networking for your applications. Ziti has several components. The Ziti fabric provides a scalable, pluggable, networking mesh with built in smart routing The Ziti edge components provide a secure, Zero Trust entry point into your network The Ziti SDKs allow you to integrate Ziti directly into your applications The Ziti tunnelers and proxies allow existing applications and networks to take advantage of a Ziti deployment Security Features Zero Trust and Application Segmentation Dark Services and Routers End to end encryption Performance and Reliability A scalable mesh fabric with smart routing Support for load balancing services for both horizontal scale and failover setups Developer Focus Open source code, available with the Apache 2.0 license Fully programable REST management APIs SDKs for a variety of programming languages Application specific configuration store allowing centralized management of configuration allowing you to add structured configuration specific to your application An extensible fabric, allowing you to add your own load balancing algorithms interconnect protocols ingress and egress protocols metrics collections frameworks control and management plane messaging and semantics Easy Management A flexible and expressive policy model for managing access to services and edge routers A web based admin console Pre-built tunnelers and proxies for a variety of operating systems, including mobile Let's break some of these buzzwords down. Zero Trust/Application Segmentation Many networking security solutions act like a wall around an internal network. Once you are through the wall, you have access to everything inside. Zero trust solutions enforce not just access to a network, but access to individual applications within that network. Every client in a Ziti system must have an identity with provisioned certificates. The certificates are used to establish secure communications channels as well as for authentication and authorization of the associated identity. Whenever the client attempts to access a network application, Ziti will first ensure that the identity has access to the application. If access is revoked, open network connections will be closed. This model enables Ziti systems to provide access to multiple applications while ensuring that clients only get access to those applications to which they have been granted access. In addition to requiring cert based authentication for clients, Ziti uses certificates to authorize communication between Ziti components. Dark Services and Routers There are various levels of accessibility a network application/service can have. Many network services are available to the world. The service then relies on authentication and authorization policies to prevent unwanted access. Firewalls can be used to limit access to specific IP or ranges. This increases security at the cost of flexibility. Adding users can be complicated and users may not be able to easily switch devices or access the service remotely. Services can be put behind a VPN or made only accessible to an internal network, but there are some downsides to this approach. If you can access the VPN or internal network for any reason, all services in that VPN become more vulnerable to you. VPNs are not usually appropriate for external customers or users. For end users, VPNs add an extra step that needs to be done each time they want to access the service. Services can be made dark, meaning they do not have any ports open for anyone to even try and connect to. Making something dark can be done in a few ways, but the way it's generally handled in Ziti is that services reach out and establish one or more connections to the Ziti network fabric. Clients coming into the fabric can then reach the service through these connections after being authenticated and authorized. Ziti routers, which make up the fabric, can also be dark. Routers locoated in private networks will usually be made dark. These routers will reach out of the private network to talk to the controller and to make connections to join the network fabric mesh. This allows the services and routers in your private networks to make only outbound connections, so no holes have to opened for inbound traffic. Services can be completely dark if they are implemented with a Ziti SDK. If this is not possible a Ziti tunneler or proxy can be colocated with the service. The service then only needs to allow connections from the local machine or network, depending on how close you colocate the proxy to the service. End to End Encryption If you take advantage of Ziti's developer SDKs and embed Ziti in your client and server applications, your traffic can be configured to be seamlessly encrypted from the client application to server application. If you prefer to use tunnelers or proxy applications, the traffic can be ecnrypted for you from machine to machine or private network to private network. Various combinations of the above are also supported. End-to-end encryption means that even if systems between the client and server are compromised, your traffic cannot be decrypted or tampered with. Getting started with Ziti If you are looking to jump right in, feet first, you can follow along with one of our up-and-running quickstart guides . These environments are perfect for evaluators to get to know Ziti and the capabilities it offers. The environment was not designed for large scale deployment or for long-term usage. You can certainly deploy and maintain your own once you understand how to create a scalable network, that's what these guides are meant to provide, a start. If you are looking for a managed service to help you run a truly global, scalable network browse over to our website at http://netfoundry.io to learn more. Contributing The Ziti project welcomes contributions including, but not limited to, code, documentation and bug reports. All Ziti code is found on Github under the OpenZiti organization. ziti : top level project which builds all Ziti executables edge : edge components and model which includes identity, polices and config fabric : fabric project which includes core controller and router foundation : project which contains library code used across multiple projects SDKs ziti-sdk-c : C SDK ziti-sdk-csharp : C# SDK ziti-sdk-jvm : SDK for JVM based languages ziti-sdk-swift : Swift SDK ziti-sdk-nodejs : NodeJS SDK sdk-golang : Go SDK ziti-doc : Documention (which you are currently reading) A Discourse forum is available Ziti was developed and open sourced by NetFoundry, Inc . NetFoundry continues to fund and contribute to Ziti. Overview of a Ziti Network The Ziti Network (Ziti) is composed of the following building blocks: Ziti Controller, Ziti Router, Ziti Edge Router, Ziti Edge Clients. These components are used in conjunction to provide secure connectivity between two points such as a client to a server. This type of network is considered an overlay network because it provides secure connectivity on top  or overlaying  existing networking infrastructure. Here's an overview of a network: ZITI CONTROLLER The Ziti Controller is the central function of the Ziti Network. The Ziti Controller provides the configuration plane. It is responsible for configuring Ziti services as well as being the central point for managing the identities used by users, devices and the nodes making up the Ziti Network. Lastly but critically, the Ziti Controller is responsible for authentication and authorization for every connection in the Ziti network. The Ziti Controller must be configured with public key infrastructure (pki). The configured pki is used to create secure, mutually authenticated TLS (mTLS) network connections between any two pieces of the Ziti Network. The Ziti Controller does not provide its own pki but for the Ziti Controller to sign certificate requests (CSR) the Ziti Controller will need to be configured with a key and certificate used for signing. (Optionally, the Ziti CLI can be used to generate a pki if needed) The Ziti Controller also supports using a third-party pki should the operator of the Ziti Network have an existing pki they wish to reuse. Utilizing a third-party CA pushes the burden of obtaining and distributing properly signed certificates to the operator of the Ziti network but for sophisticated customers this might make overall management of the network easier. The Ziti Controller uses an out of process database (Postgres) to store the information needed to manage the network. ZITI FABRIC ROUTER Ziti Fabric Routers are the fundamental building blocks of the Ziti Network. These routers are responsible for securely and reliably delivering traffic from one Ziti Network node to the traffics destination. Ziti Fabric Routers are linked together to form a mesh network. This mesh is constantly being monitored for latency and the fastest paths are used when routing traffic to the destination. The monitoring also allows for active failover to ensure a reliable network connection even in the case of a node failure. ZITI EDGE ROUTER Another fundamental building block of the Ziti Network is the Ziti Edge Router. The Ziti Edge Router is the entry point for Edge Clients connecting to the Ziti Network. The Ziti Edge Router is a specialized Ziti Router incorporating the functionality of a Ziti Router to enable it to route traffic over the Ziti network as a Ziti Router would to a given destination. The Ziti Edge Router in combination with the Ziti Controller is responsible for authenticating and authorizing Ziti Edge Clients. ZITI EDGE CLIENTS Connecting to the Ziti Network requires a Ziti Edge Client. Edge Clients are designed to work with both brownfield and greenfield applications. If the solution being developed includes developing new software Ziti offers SDKs targeting various languages and runtimes to provide fast, reliable and secure connectivity. These SDKs provide the capabilities needed to securely connect to the Ziti Network and are designed to be easily incorporated into the target application. When adding secure connectivity to an already existing solution Ziti offers specialized Edge Clients called tunnelers which provide seamless, secure connectivity and do not require changes to the target application. USING ZITI Once the Ziti Network is established and deployed the next step is to configure the software-powered network. The three main concepts necessary to configure a Ziti Network are: Identities, Services, and Policies. SERVICES A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti Service is defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Services also declare a node where traffic that exits the Ziti Network needs to be sent do before exiting. Its possible for the node traffic enters to be the same it exits and its possible for traffic needing to traverse the Ziti Network Routers to reach the correct node. Simply specifying the node is all the end-user need do, the Ziti Network handles the rest. IDENTITIES Identities represent individual endpoints in the Ziti Network which can establish connectivity. All connections made within the Ziti Network are mutually authenticated using X509 Certificates. Every Identity is mapped to a given certificates signature. Ziti Edge Clients present this certificate when initiating connections to the Ziti Network. The presented certificate is used by the Ziti Network to authorize the client and enumerate the services the Identity is authorized to use. POLICIES Policies control how Identities, Services and Edge Routers are allowed to interact. In order to use a service the identity must be granted access to the service. Also, since all access to a service goes through one more edge routers, both the service and the identity must be granted to access to the same edge router or edge routers. ROLE ATTRIBUTES Entities such as identities, services and edge routers can be added to policies explicity, either by id or name. Entities can also be tagged with role attributes. Role attributes are simple strings like sales , Boston , us-employees or support . Their meaning is decided by the administrator. Policies can include entities by specifying a set of role attributes to match. SERVICE POLICIES Service Policies encapsulate the mapping between identities and services in a software-powered network. In the simplest terms, Service Policies are a group of services and a group of identities. The act of adding a service to a Service Policy will grant the identities in that Service Policy access to the given service. Similarly, adding an identity to a Service Policy will grant that identity access to the services mapped in that Service Policy. Service policies controls both which identities may dial a service (use the service) and which identities may bind a service (provide or host the service). Each Service Policy may either grant dial or bind access, but not both. EDGE ROUTER POLICIES Edge Router Policies manage the mapping between identities and edge routers. Edge Router Policies are a group of edge routers and a group of identities. Adding an edge router to an Edge Router Policy will grant the identities in that Edge Router Policy access to the given edge router. Similarly, adding an identity to an Edge Router Policy will grant that identity access to the edge routers mapped in that Edge Router Policy. SERVICE EDGE ROUTER POLICIES Service Edge Router Policies manage the mapping between services and edge routers. Service Edge Router Policies are a group of edge routers and a group of services. Adding an edge router to a Service Edge Router Policy will grant the services in that Service Edge Router Policy access to the given edge router. Similarly, adding a service to a Service Edge Router Policy will grant that service access to the edge routers mapped in that Service Edge Router Policy."
  },
  "ziti/policies/create-edge-router-policy-cli.html": {
    "href": "ziti/policies/create-edge-router-policy-cli.html",
    "title": "| Ziti",
    "keywords": "To create an Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create an edge router policy named 'my-policy' which allows all identities to use all edge-routers ziti edge create edge-router-policy my-policy --identity-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/policies/create-edge-router-policy-ui.html": {
    "href": "ziti/policies/create-edge-router-policy-ui.html",
    "title": "| Ziti",
    "keywords": "On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy, such as \"My Edge Router Policy\" Enter the edge routers you want to include in the policy Specific edge routers can be referenced by ID or name using @ . For example, an edge router called us-east-4 can be referenced using @us-east-4 . Edge routers can be referenced by role attribute using # . For example, any edge router which has the us-seast role attribute will be included if #us-east is included in the edge routers roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save"
  },
  "ziti/policies/create-service-edge-router-policy-cli.html": {
    "href": "ziti/policies/create-service-edge-router-policy-cli.html",
    "title": "| Ziti",
    "keywords": "To create a Service Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service edge router policy which allows all services to use all edge routers ziti edge create service-edger-router-policy 'my-policy' --service-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/policies/create-service-edge-router-policy-ui.html": {
    "href": "ziti/policies/create-service-edge-router-policy-ui.html",
    "title": "| Ziti",
    "keywords": "On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Edge Router Policy Choose a name for the Service Edge Router Policy, such as \"My Service Edge Router Policy\" Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save"
  },
  "ziti/policies/create-service-policy-cli.html": {
    "href": "ziti/policies/create-service-policy-cli.html",
    "title": "| Ziti",
    "keywords": "To create a Service Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service policy named 'my-policy' which allows all identities to dial/connect to all services ziti edge create service-policy my-policy Dial --identity-roles '#all' --service-roles '#all'"
  },
  "ziti/policies/create-service-policy-ui.html": {
    "href": "ziti/policies/create-service-policy-ui.html",
    "title": "| Ziti",
    "keywords": "On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy, such as \"My Service Policy\" Select \"Dial\" or \"Bind\" in the Type dropdown Dial policies allow identities to use or connect to the service Bind policies allow identities to host or provide the service Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save"
  },
  "ziti/policies/creating-edge-router-policies.html": {
    "href": "ziti/policies/creating-edge-router-policies.html",
    "title": "Creating an Edge Router Policy | Ziti",
    "keywords": "Creating an Edge Router Policy New Edge Router Policy via UI New Edge Router Policy via CLI On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy, such as \"My Edge Router Policy\" Enter the edge routers you want to include in the policy Specific edge routers can be referenced by ID or name using @ . For example, an edge router called us-east-4 can be referenced using @us-east-4 . Edge routers can be referenced by role attribute using # . For example, any edge router which has the us-seast role attribute will be included if #us-east is included in the edge routers roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create an Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create an edge router policy named 'my-policy' which allows all identities to use all edge-routers ziti edge create edge-router-policy my-policy --identity-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/policies/creating-service-edge-router-policies.html": {
    "href": "ziti/policies/creating-service-edge-router-policies.html",
    "title": "Creating a Service Policy | Ziti",
    "keywords": "Creating a Service Policy New Service Edge Router Policy via UI New Service Edge Router Policy via CLI On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Edge Router Policy Choose a name for the Service Edge Router Policy, such as \"My Service Edge Router Policy\" Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create a Service Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service edge router policy which allows all services to use all edge routers ziti edge create service-edger-router-policy 'my-policy' --service-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/policies/creating-service-policies.html": {
    "href": "ziti/policies/creating-service-policies.html",
    "title": "Creating a Service Policy | Ziti",
    "keywords": "Creating a Service Policy New Service Policy via UI New Service Policy via CLI On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy, such as \"My Service Policy\" Select \"Dial\" or \"Bind\" in the Type dropdown Dial policies allow identities to use or connect to the service Bind policies allow identities to host or provide the service Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create a Service Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service policy named 'my-policy' which allows all identities to dial/connect to all services ziti edge create service-policy my-policy Dial --identity-roles '#all' --service-roles '#all'"
  },
  "ziti/policies/overview.html": {
    "href": "ziti/policies/overview.html",
    "title": "Policies | Ziti",
    "keywords": "Policies Ziti policies control which identities can access or host which services via which edge routers. There are three kinds of policies, and we'll walk through what kind of access each policy type grants, as well as walk through some use cases. Each policy type relates two of the following entity types: identities, services and edge routers. Service Policies Service policies are entities within the Ziti Controller which provide identities authorization to services. There are two kinds of service policies: Dial policies, which control who can use a service Bind policies, which control who can provide a service They are separate because in most cases a given identity will not both use and provide any given service, so it's important to be able to distinguish between the two privileges. Service policies are how access to application can be segmented. Each service (and corresponding application) can be accessed only by the identities which are given access to it. An identity can have access to any number of services, and it is straightforward to add or remove identities from service policies. With roles and role attributes (described below), it's easy to group entities and minimize manual maintenance of groups. Having at least one Service Policy is vital because without any service policies the Ziti network will have no identities authorized to send traffic over the Ziti network. Edge Router Policies Edge router policies are entities within the Ziti Controller which provide identities access to edge routers. In order to access or provide a service the identity must first access the Ziti network fabric. Edge routers are the points through which SDK based applications can get that access. Not every identity should necessarily be allowed to use every edge router. Identities or groups of identities may have dedicated edge routers for a number of reasons. For resource isolation due to SLAs For resource isolation because they are hosting a service Edge routers may be colocated with a set of identities A group of identities may need to use a particular version of an edge router Having at least one Edge Router Policy is necessary because without at least one, no identities will be able to send traffic over the Ziti network because traffic must enter the network via an edge router. Service Edge Router Policies Service edge router policies are entities within the Ziti Controller which provide services access to edge routers. They are similar to edge router policies except they determine via which edge routers a service can be used or provided. There are a few reasons you might want to have pools of edge routers dedicated particular services or service groups. Resource isolation due to SLAs Geographic/political boundaries. Some services may need to be accessible only from specific areas to comply with local laws Having at least one Service Edge Router Policy is vital because without at least one, no services will be able to accept traffic over the Ziti network because traffic must enter the network via an edge router. Roles and Role Attributes In order for policies to work they need a way to specify which entities to include in the policy. All Ziti policies work the same way. The entities included in policies (identities, serviced and edge routers) can all be assigned role attributes For example: an identity could be given the attributes sales , eu if that identity belongs to a sales person from the European Union Each policy has two list of roles, one for each entity type that the policy is relating Service policies have identityRoles and serviceRoles Edge router policies have identityRoles and edgeRouterRoles Service edge router policies have edgeRouterRoles and serviceRoles Each list can contain role attributes, which are prefixed by hash tags, and ids, which are prefixed with at-symbols. For example: a service policy might have identityRoles = [#sales, #north-america, @81cc68d0-700a-491f-8e98-4b43a0b30a9f] serviceRoles = [#office, @738006f2-e33e-4964-945f-7431000d229f] Note that external tools such as the CLI and the ZAC will likely use names instead of IDs. So the roles might instead look like identityRoles = [#sales, #north-america, @jsmith-laptop] serviceRoles = [#office, @crm-suite] Each policy also has a semantic. The semantic dictates how multiple role attributes will be interpreted. [#sales, #eu] could mean every identity which has #sales and #eu , or it could mean every identity which has #sales or #eu The allOf semantic will include only entities have all the listed role attributes The anyOf semantic will include all entities that have any of the listed role attributes No matter the semantic, any entities which are listed by @id will be included in the policy There is a special role attribute #all which will include all entities of a given type. This is useful for simpler setups which may not be segmenting edge routers, as well as for development and testing. Policy Interaction Important Note: When an identity is using a service, the identity and service must have at least one on-line edge router in common in order for a connection to be made. When an identity is trying to establish a session to use or host a service the Ziti controller will verify that they access via service policy. Once the session is established, the controller will return a list of edge routers that the identity can use to connect to that service. The list will be all edge routers which both the identity and service have access to. It is possible that an identity may have access to a service and access to edge routers, but none of those edge routers can be used to access that particular service. Policy Advisor To help diagnose issues there is a policy advisor API which the CLI has a wrapper for. $ ziti edge policy-advisor services -q OKAY : simple-client (1) -> simple (1) Common Routers: (1/1) Dial: Y Bind: N OKAY : simple-server (1) -> simple (1) Common Routers: (1/1) Dial: N Bind: Y $ ziti edge policy-advisor services ssh simple-client -q ERROR: simple-client (1) -> ssh (1) Common Routers: (1/1) Dial: N Bind: N - No access to service. Adjust service policies. The policy advisor can look at all services or identities, or a specific service and identity, and see if there are any common problems, such as: Does an identity not have access to any services? Does a service have no one who can access it? Do a service and identity have no edge routers in common? Do a service and identity have edge routers in common, but they are all off-line? Managing Policies Service Policies Creating a Service Policy New Service Policy via UI New Service Policy via CLI On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy, such as \"My Service Policy\" Select \"Dial\" or \"Bind\" in the Type dropdown Dial policies allow identities to use or connect to the service Bind policies allow identities to host or provide the service Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create a Service Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service policy named 'my-policy' which allows all identities to dial/connect to all services ziti edge create service-policy my-policy Dial --identity-roles '#all' --service-roles '#all' Edge Router Policies Creating an Edge Router Policy New Edge Router Policy via UI New Edge Router Policy via CLI On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy, such as \"My Edge Router Policy\" Enter the edge routers you want to include in the policy Specific edge routers can be referenced by ID or name using @ . For example, an edge router called us-east-4 can be referenced using @us-east-4 . Edge routers can be referenced by role attribute using # . For example, any edge router which has the us-seast role attribute will be included if #us-east is included in the edge routers roles list. Enter the identities you want to include in the policy Specific identities can be referenced by ID or name using @ . For example, as identity called jsmith-desktop can be referenced using @jsmith-desktop . Identities can be referenced by role attribute using # . For example, any identity which has the sales role attribute will be included if #sales is included in the identities roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create an Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create an edge router policy named 'my-policy' which allows all identities to use all edge-routers ziti edge create edge-router-policy my-policy --identity-roles '#all' --edge-router-roles '#all' Service Edge Router Policies Creating a Service Policy New Service Edge Router Policy via UI New Service Edge Router Policy via CLI On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Edge Router Policy Choose a name for the Service Edge Router Policy, such as \"My Service Edge Router Policy\" Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Enter the services you want to include in the policy Specific services can be referenced by ID or name using @ . For example, a service called ssh can be referenced using @ssh . Services can be referenced by role attribute using # . For example, any service which has the sales role attribute will be included if #sales is included in the service roles list. Specify the role semantic If you select Has Any Role then if you specify multiple roles then all entities which include any of the roles will be included. If you select Must Have All Roles , then if you specify multiple roles then only entities which include all of the given roles will be included Click save To create a Service Edge Router Policy using the CLI issue the following commands. (ensure you are logged in ) # Create a service edge router policy which allows all services to use all edge routers ziti edge create service-edger-router-policy 'my-policy' --service-roles '#all' --edge-router-roles '#all'"
  },
  "ziti/quickstart.html": {
    "href": "ziti/quickstart.html",
    "title": "| Ziti",
    "keywords": ""
  },
  "ziti/quickstarts/hsm/softhsm.html": {
    "href": "ziti/quickstarts/hsm/softhsm.html",
    "title": "SoftHSMv2 | Ziti",
    "keywords": "SoftHSMv2 Overview SoftHSMv2 is a purely software-based implementation of PKCS#11. Because it is software it is not as secure as a physical HSM but it is very useful to explore the world of PKCS#11 and how it can be used with a Ziti-enabled client. In this quickstart you will see the commands used to work with SoftHSMv2 and ziti. Since this is a quickstart limited context will be provided for each step. When appropriate there will be a small amount of context included to aid in understanding of what is happening and why. Warning This quickstart intended audience is for more technically savvy indiviuals. You will need to be familar with the command line interface of your operating system. Prerequistites SoftHSMv2 is downloaded and installed in a known location OpenSC is installed and pkcs11-tool is either on the PATH or at a known location ziti and ziti-tunnel are both on the path. Let's Do This - SoftHSMv2 Here's the list of steps we'll accomplish in this quickstart: Establish a bunch of environment variables to make it easy to copy/paste the other commands. You'll want to look at these environment variables . They need to be setup properly. If you have problems with this guide it is almost certainly because you have an environment variable setup incorrectly. Double check them. Make a directory and generate a configuration file for SoftHSM Use the Ziti CLI to: create two identities - one demonstrating an RSA key, one EC enroll the identities create a test service create test router/service policies Use the pkcs11-tool provided by OpenSC to interact with SoftHSM to: initialize the SoftHSM driver create a key Use ziti-tunnel to enroll the identities using SoftHSM Use ziti-tunnel in proxy mode to verify things are working and traffic is flowing over the Ziti Network Establish Environment Variables Open a command line and establish the following environment varibles. Linux/MacOS Windows # the name of the ziti controller you're logging into export ZITI_CTRL=local-edge-controller # the location of the certificate(s) to use to validate the controller export ZITI_CTRL_CERT=/path/to/controller.cert export ZITI_USER=myUserName export ZITI_PWD=myPassword # a name for the configuration export HSM_NAME=softhsm_demo # the path to the root of the softhsm config files export HSM_ROOT=/home/cd/.softhsm # path to the softhsm2 library export PKCS11_MODULE=/usr/local/lib/softhsm/libsofthsm2.so # the id of the key - you probably want to leave these alone unless you know better export HSM_ID1=01 export HSM_ID2=02 # the pins used when accessing the pkcs11 api export HSM_SOPIN=1111 export HSM_PIN=2222 export RSA_ID=${HSM_NAME}${HSM_ID1}_rsa export EC_ID=${HSM_NAME}${HSM_ID2}_ec # location for the config file and tokens to be placed export HSM_DEST=${HSM_ROOT}/${HSM_NAME} export HSM_LABEL=${HSM_NAME}-label export SOFTHSM2_CONF=${HSM_DEST}/softhsm.config export HSM_TOKENS_DIR=\"${HSM_DEST}/tokens/\" # make an alias for ease alias p='pkcs11-tool --module $PKCS11_MODULE' Ensure you use the correct dll. If you use an x86 dll with x64 binaries you'll get an error. REM the name of the ziti controller you're logging into SET ZITI_CTRL=local-edge-controller REM the location of the certificate(s) to use to validate the controller SET ZITI_CTRL_CERT=c:\\path\\to\\controller.cert SET ZITI_USER=myUserName SET ZITI_PWD=myPassword REM a name for the configuration SET HSM_NAME=softhsm_demo REM the path to the root of the softhsm config files SET HSM_ROOT=c:\\path\\to\\softhsm REM path to the softhsm2 library SET PKCS11_MODULE=%HSM_ROOT%\\lib\\softhsm2.dll --- or --- SET PKCS11_MODULE=%HSM_ROOT%\\lib\\softhsm2-x64.dll REM the id of the key - you probably want to leave these alone unless you know better SET HSM_ID1=01 SET HSM_ID2=02 SET RSA_ID=%HSM_NAME%%HSM_ID1%_rsa SET EC_ID=%HSM_NAME%%HSM_ID2%_ec REM the pins used when accessing the pkcs11 api SET HSM_SOPIN=1111 SET HSM_PIN=2222 SET HSM_DEST=%HSM_ROOT%\\%HSM_NAME% SET HSM_LABEL=%HSM_NAME%-label SET SOFTHSM2_CONF=%HSM_DEST%\\softhsm.config SET HSM_TOKENS_DIR=%HSM_DEST%\\tokens\\ REM make an alias for ease doskey p=\"c:\\Program Files\\OpenSC Project\\OpenSC\\tools\\pkcs11-tool.exe\" --module %PKCS11_MODULE% $* Make Directories and Generate Config Files Linux/MacOS Windows cd ${HSM_ROOT} rm -rf ${HSM_NAME} mkdir -p ${HSM_TOKENS_DIR} cd ${HSM_NAME} # Create a text file at ${SOFTHSM2_CONF} with these contents but make sure you replace the tokendir entry with ${HSM_TOKENS_DIR} cat > ${SOFTHSM2_CONF} <<HERE # SoftHSM v2 configuration file directories.tokendir = ${HSM_TOKENS_DIR} objectstore.backend = file # ERROR, WARNING, INFO, DEBUG log.level = INFO # If CKF_REMOVABLE_DEVICE flag should be set slots.removable = false # Enable and disable PKCS#11 mechanisms using slots.mechanisms. slots.mechanisms = ALL HERE cd /d %HSM_ROOT% rmdir /s /q %HSM_NAME% mkdir %HSM_TOKENS_DIR% cd /d %HSM_NAME% # Create a text file at %SOFTHSM2_CONF% with these contents but make sure you replace the tokendir entry with %HSM_TOKENS_DIR% echo ^ # SoftHSM v2 configuration file ^ directories.tokendir = %HSM_TOKENS_DIR% ^ objectstore.backend = file ^ # ERROR, WARNING, INFO, DEBUG ^ log.level = INFO ^ # If CKF_REMOVABLE_DEVICE flag should be set ^ slots.removable = false ^ # Enable and disable PKCS#11 mechanisms using slots.mechanisms. ^ slots.mechanisms = ALL > %SOFTHSM2_CONF% Use the Ziti CLI Linux/MacOS Windows ziti edge login $ZITI_CTRL:1280 -u $ZITI_USER -p $ZITI_PWD -c $ZITI_CTRL_CERT # create a new identity and output the jwt to a known location ziti edge create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" # create a second new identity and output the jwt to a known location ziti edge create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\" ziti edge login %ZITI_CTRL%:1280 -u %ZITI_USER% -p %ZITI_PWD% -c %ZITI_CTRL_CERT% REM create a new identity and output the jwt to a known location ziti edge create identity device \"%RSA_ID%\" -o \"%HSM_DEST%\\%RSA_ID%.jwt\" REM create a second new identity and output the jwt to a known location ziti edge create identity device \"%EC_ID%\" -o \"%HSM_DEST%\\%EC_ID%.jwt\" Use pkcs11-tool to Setup SoftHSMv2 Linux/MacOS Windows p --init-token --label \"ziti-test-token\" --so-pin $HSM_SOPIN # create a couple of keys - one rsa and one ec p -p $HSM_PIN -k --key-type rsa:2048 --id \"${HSM_ID1}\" --label ziti-rsa-key --usage-sign --usage-decrypt p -p $HSM_PIN -k --key-type EC:prime256v1 --id ${HSM_ID2} --label ziti-ecdsa-key --usage-sign --usage-decrypt p --init-token --label \"ziti-test-token\" --so-pin %HSM_SOPIN% p --init-pin --pin \"%HSM_PIN%\" --so-pin %HSM_SOPIN% REM create a couple of keys - one rsa and one ec p -p \"%HSM_PIN%\" -k --key-type rsa:2048 --id \"%HSM_ID1%\" --label ziti-rsa-key --usage-sign --usage-decrypt p -p \"%HSM_PIN%\" -k --key-type EC:prime256v1 --id \"%HSM_ID2%\" --label ziti-ecdsa-key --usage-sign --usage-decrypt Use ziti-tunnel to Enroll the Identities Linux/MacOS Windows ziti-tunnel enroll -j \"${HSM_DEST}/${RSA_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID1}&pin=${HSM_PIN}\" -v ziti-tunnel enroll -j \"${HSM_DEST}/${EC_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID2}&pin=${HSM_PIN}\" -v ziti-tunnel enroll -j \"%HSM_DEST%\\%RSA_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID1%&pin=%HSM_PIN%\" -v ziti-tunnel enroll -j \"%HSM_DEST%\\%EC_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID2%&pin=%HSM_PIN%\" -v Use ziti-tunnel to Verify Things Work Linux/MacOS Windows # if you only have a single edge router this command will work without the need for copy/paste EDGE_ROUTER_ID=$(ziti edge list edge-routers | cut -d \" \" -f2) # IF the above command doesn't work - run this command and get the id from the first edge-router. # ziti edge list edge-routers # then use the id returned from the above command and put it into a variable for use in a momment # EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge delete config wttrconfig ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will # send a request to wttr.in to retreive a weather forecast ziti edge delete service wttr.ziti ziti edge create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig # start one or both proxies ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & # use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network curl -H \"Host: wttr.in\" http://localhost:8000 curl -H \"Host: wttr.in\" http://localhost:9000 REM these two commands can't be copied and pasted - you need to get the result of the first command and use it in the next REM run this command and get the id from the first edge-router. ziti edge list edge-routers REM use the id returned from the above command and put it into a variable for use in a momment SET EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} REM remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge delete config wttrconfig ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" REM recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will REM send a request to wttr.in to retreive a weather forecast ziti edge delete service wttr.ziti ziti edge create service wttr.ziti \"%EDGE_ROUTER_ID%\" tcp://wttr.in:80 --configs wttrconfig REM start one or both proxies - use ctrl-break or ctrl-pause to terminate these processes start /b ziti-tunnel proxy -i \"%HSM_DEST%/%RSA_ID%.json\" wttr.ziti:8000 -v start /b ziti-tunnel proxy -i \"%HSM_DEST%/%EC_ID%.json\" wttr.ziti:9000 -v REM use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network curl -H \"Host: wttr.in\" http://localhost:8000 > \"%HSM_DEST%\\example_%RSA_ID%.txt\" curl -H \"Host: wttr.in\" http://localhost:9000 > \"%HSM_DEST%\\example_%EC_ID%.txt\" REM show the results in the console type \"%HSM_DEST%\\example_%RSA_ID%.txt\" type \"%HSM_DEST%\\example_%EC_ID%.txt\" REM ctrl-break or ctrl-pause to kill the tunnelers Putting It All Together Above we've only shown the commands that need to run and not what the output of those commands would look like. Here we'll see all the commands put together along with all the output from the commands. This section is long - you are warned! Also note that this content is subject to change. If the output you see is not identical it's because the software has changed since this information was captured. File an issue if you'd like to see it updated. Sample Output Linux/MacOS Windows The tabs to the right contain example output from running all the commands in sequence. If you want to see what the output would likely look like click one of the tabs to the right. Reminder - it's a lot of commands and a lot of output! :) cd@sg1 ~/.softhsm/softhsm_demo $ # the name of the ziti controller you're logging into cd@sg1 ~/.softhsm/softhsm_demo $ export ZITI_CTRL=local-edge-controller cd@sg1 ~/.softhsm/softhsm_demo $ # the location of the certificate(s) to use to validate the controller cd@sg1 ~/.softhsm/softhsm_demo $ export ZITI_CTRL_CERT=/path/to/controller.cert cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ export ZITI_USER=myUserName cd@sg1 ~/.softhsm/softhsm_demo $ export ZITI_PWD=myPassword cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # a name for the configuration cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_NAME=softhsm_demo cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # the path to the root of the softhsm config files cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_ROOT=/home/cd/.softhsm cd@sg1 ~/.softhsm/softhsm_demo $ # location for the config file and tokens to be placed cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_DEST=${HSM_ROOT}/${HSM_NAME} cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # path to the softhsm2 library cd@sg1 ~/.softhsm/softhsm_demo $ export PKCS11_MODULE=/usr/local/lib/softhsm/libsofthsm2.so cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # the id of the key - you probably want to leave these alone unless you know better cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_ID1=01 cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_ID2=02 cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # the pins used when accessing the pkcs11 api cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_SOPIN=1111 cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_PIN=2222 cd@sg1 ~/.softhsm/softhsm_demo $ export RSA_ID=${HSM_NAME}${HSM_ID1}_rsa cd@sg1 ~/.softhsm/softhsm_demo $ export EC_ID=${HSM_NAME}${HSM_ID2}_ec cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_DEST=${HSM_ROOT}/${HSM_NAME} cd@sg1 ~/.softhsm/softhsm_demo $ export SOFTHSM2_CONF=${HSM_DEST}/softhsm.config cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_LABEL=${HSM_NAME}-label cd@sg1 ~/.softhsm/softhsm_demo $ export HSM_TOKENS_DIR=\"${HSM_DEST}/tokens/\" cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # make an alias for ease cd@sg1 ~/.softhsm/softhsm_demo $ alias p='pkcs11-tool --module $PKCS11_MODULE' cd@sg1 ~/.softhsm/softhsm_demo $ cd ${HSM_ROOT} cd@sg1 ~/.softhsm $ cd@sg1 ~/.softhsm $ rm -rf ${HSM_NAME} mkdir -p ${HSM_TOKENS_DIR} cd ${HSM_NAME} # Create a text file at ${SOFTHSM2_CONF} with these contents but make sure you replace the tokendir entry with ${HSM_TOKENS_DIR} cat > ${SOFTHSM2_CONF} <<HERE # SoftHSM v2 configuration file directories.tokendir = ${HSM_TOKENS_DIR} objectstore.backend = file # ERROR, WARNING, INFO, DEBUG log.level = INFO cd@sg1 ~/.softhsm $ mkdir -p ${HSM_TOKENS_DIR} # If CKF_REMOVABLE_DEVICE flag should be set slots.removable = false cd@sg1 ~/.softhsm $ cd@sg1 ~/.softhsm $ cd ${HSM_NAME} cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # Create a text file at ${SOFTHSM2_CONF} with these contents but make sure you replace the tokendir entry with ${HSM_TOKENS_DIR} cd@sg1 ~/.softhsm/softhsm_demo $ cat > ${SOFTHSM2_CONF} <<HERE > # SoftHSM v2 configuration file > > directories.tokendir = ${HSM_TOKENS_DIR} > objectstore.backend = file > > # ERROR, WARNING, INFO, DEBUG > log.level = INFO > > # If CKF_REMOVABLE_DEVICE flag should be set > slots.removable = false > > # Enable and disable PKCS#11 mechanisms using slots.mechanisms. > slots.mechanisms = ALL > HERE cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge login $ZITI_CTRL:1280 -u $ZITI_USER -p $ZITI_PWD -c $ZITI_CTRL_CERT # create a new identity and output the jwt to a known location ziti edge create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" # create a second new identity and output the jwt to a known location ziti edge create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\"Token: 28da1089-1636-4e6b-b5c7-96edc8d6162f cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # create a new identity and output the jwt to a known location cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" dbf953bc-a987-4a89-a93d-0d6dac13150f Enrollment expires at 2020-02-23T13:31:35.306053182Z cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # create a second new identity and output the jwt to a known location cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\" cfffe40d-b859-4a5a-ab4f-c9621a57ec85 Enrollment expires at 2020-02-23T13:31:36.676560457Z cd@sg1 ~/.softhsm/softhsm_demo $ p --init-token --label \"ziti-test-token\" --so-pin $HSM_SOPIN # create a couple of keys - one rsa and one ec p -p $HSM_PIN -k --key-type rsa:2048 --id \"${HSM_ID1}\" --label ziti-rsa-key --usage-sign --usage-decrypt p -p $HSM_PIN -k --key-type EC:prime256v1 --id ${HSM_ID2} --label ziti-ecdsa-key --usage-sign --usage-decryptUsing slot 0 with a present token (0x0) Token successfully initialized cd@sg1 ~/.softhsm/softhsm_demo $ p --init-pin --pin $HSM_PIN --so-pin $HSM_SOPIN Using slot 0 with a present token (0x7f834e53) User PIN successfully initialized cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # create a couple of keys - one rsa and one ec cd@sg1 ~/.softhsm/softhsm_demo $ p -p $HSM_PIN -k --key-type rsa:2048 --id \"${HSM_ID1}\" --label ziti-rsa-key --usage-sign --usage-decrypt Using slot 0 with a present token (0x7f834e53) Key pair generated: Private Key Object; RSA label: ziti-rsa-key ID: 01 Usage: decrypt, sign, unwrap Public Key Object; RSA 2048 bits label: ziti-rsa-key ID: 01 Usage: encrypt, verify, wrap cd@sg1 ~/.softhsm/softhsm_demo $ p -p $HSM_PIN -k --key-type EC:prime256v1 --id ${HSM_ID2} --label ziti-ecdsa-key --usage-sign --usage-decrypt Using slot 0 with a present token (0x7f834e53) Key pair generated: Private Key Object; EC label: ziti-ecdsa-key ID: 02 Usage: decrypt, sign, unwrap Public Key Object; EC EC_POINT 256 bits EC_POINT: 0441046f9ae0bbc3cbe62e6bbad50ad673add3ba1ee5a07f5391893df956c53d67c62b727ca1004fe9b44027e8e1f1605a602946257b1b1d20ba00342cec85c13a0462 EC_PARAMS: 06082a8648ce3d030107 label: ziti-ecdsa-key ID: 02 Usage: encrypt, verify, wrap cd@sg1 ~/.softhsm/softhsm_demo $ ziti-tunnel enroll -j \"${HSM_DEST}/${RSA_ID}.jwt\" -k \"pkcs11:///${PKCS11_MODULE}?id=${HSM_ID1}&pin=${HSM_PIN}\" -v DEBU[0000] jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjQ2NDY5NSwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6IjIzOTNjNDgwLTc0NGMtNDc3OS05NjU3LWNhOTdlMzUzOWQ0ZiIsInN1YiI6ImRiZjk1M2JjLWE5ODctNGE4OS1hOTNkLTBkNmRhYzEzMTUwZiJ9.OucLqJYgvGO0zov3ADI4oM0i0CASfpD6GUUAck5cBKVJqUN8jsdHe272CwnR7TH1w7uUNr5zPDJnwklVRQ0kzgxqFe9lGqNOxKtYecr-oI50K-J_OShPu_LkJ8dpmUk-OEzc1mq29KsIVu9GLUI43FLYD7SWFZZFsYk6iB8H4PPRrUNZucTcApgNNHljlwl8n-my5N3STqazJf7YUIHOh-OiW8rJFXZYf5gri_B6uDGQo-ZcMOISWCTRjPxe2boHK0ymrUanbe_i9vHbOQRIik7J6xOEA2-Vu-QW9WY4bEvl0_LChdV4YBG09EtWsJndl1AIsD0AP0fCjgD6FifAbpmiZx_YoqOM-KCbN9Vts9_FobNfT0rt9s7RzcHImj22jxEQtSNVbrjnulPwzhBM2PnOKrHJtq8KGgsGlC-aC1pUkiRS-eMHDOshDUFk16p56UXm9QS4d1rPmCQ8yksgEdeurRydmBKCr2tr1v9hC7gSxY1sOBF-b9k7HBGuinomuyeF6CRRMRYMiYz26suZXvP70ufJ5Z2h6hYqvIIGtpk_MxMuVl8r9iylWq3P7oqbDo74g3p3OSFwRUDm5llBuZKJUzQXYE3435NdpHeStKu4K2VYvGGCxpWe950ONrAGzwSYtYdOVvkgGxBreO3RNiQN427XD9yZw66pXXqIRV0 INFO[0000] using engine : pkcs11 DEBU[0000] loading key context=pkcs11 url=\"pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=01&pin=2222\" INFO[0000] using driver: //usr/local/lib/softhsm/libsofthsm2.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (2139311699) context=pkcs11 DEBU[0000] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0000] no cas provided in caPool. using system provided cas DEBU[0000] fetching certificates from server DEBU[0000] loading key context=pkcs11 url=\"pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=01&pin=2222\" INFO[0000] using driver: //usr/local/lib/softhsm/libsofthsm2.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (2139311699) context=pkcs11 DEBU[0000] found signing mechanism context=pkcs11 sign mechanism=0 enrolled successfully. identity file written to: /home/cd/.softhsm/softhsm_demo/softhsm_demo01_rsa.json cd@sg1 ~/.softhsm/softhsm_demo $ ziti-tunnel enroll -j \"${HSM_DEST}/${EC_ID}.jwt\" -k \"pkcs11:///${PKCS11_MODULE}?id=${HSM_ID2}&pin=${HSM_PIN}\" -v DEBU[0000] jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjQ2NDY5NiwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6ImJlZTJlY2U3LTE4ZTAtNGQ3Zi04NmRlLTU4NmM5MTAyNDY3YiIsInN1YiI6ImNmZmZlNDBkLWI4NTktNGE1YS1hYjRmLWM5NjIxYTU3ZWM4NSJ9.nRCE-_osr6rdVUcfyR-irvAWitCSK0pm7WaG0hOC0-O22SFs8tYw7uKvbGmNkFoVsUYK4y6A4X77Q6JPNPDIzwWl1TO788B4UiJNh6x5jFEKMawzzPbq-wGq0PLstLsULOryxRtIMdHRYaCrxspC9mIZTrIWe85iPPjirOJ0Pgq0-Li2hZmBtlFOh8zTzYGmXVQtKhA-obIDSa12Nrt6gpgpNl1Ob_EXWWkwC5rcdm4yKpiKx7wYjxBRKc4ZLODmNahe69KiG5XD9A5I5o6YWQDs-pgl3Op44U9Kk94fGSZPcgzkPUC8NaX1eWgYh6RCMs3uSp6TMi8bRisPCOW770K3CxPpCS1fKg9rpyPninFShjRMvsbf999ldWh3YKmLJXvtinQF3szbmCsVaTI4-NxlkhLcdL2Qo6ivLz_kddNfzmDFcOEcLerR0D_Ugt0mPi0RidgkX0J00uXqd1SqYyI3b68KyVd5U3hIoL8NRQ1gAluky0jSe-xj5vfTgxYiJNZlUqCA4DvGdXl98NiWu40eHEz5ksKePbB_LVCmcMW3mPNdQjmDw4fdKvfZs0FdqgOcBGzbfQznpt3UV1pgL7Kdl6EfZppP1FNjqaxHyiEqkdINY0X5k33CDV4IVuS0ZDbOuQHInfG2ggLLS_vykC37w5iJe19ECSMWd_JzgQc INFO[0000] using engine : pkcs11 DEBU[0000] loading key context=pkcs11 url=\"pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=02&pin=2222\" INFO[0000] using driver: //usr/local/lib/softhsm/libsofthsm2.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (2139311699) context=pkcs11 DEBU[0000] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0000] EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> context=pkcs11 WARN[0000] failed to get mechanism info [1044] context=pkcs11 error=\"pkcs11: 0x70: CKR_MECHANISM_INVALID\" DEBU[0000] no cas provided in caPool. using system provided cas DEBU[0000] fetching certificates from server DEBU[0000] loading key context=pkcs11 url=\"pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=02&pin=2222\" INFO[0000] using driver: //usr/local/lib/softhsm/libsofthsm2.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (2139311699) context=pkcs11 DEBU[0000] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0000] EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> context=pkcs11 WARN[0000] failed to get mechanism info [1044] context=pkcs11 error=\"pkcs11: 0x70: CKR_MECHANISM_INVALID\" enrolled successfully. identity file written to: /home/cd/.softhsm/softhsm_demo/softhsm_demo02_ec.json cd@sg1 ~/.softhsm/softhsm_demo $ # run this command and get the id from the first edge-router. cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge list edge-routers id: c34734a4-d5de-430b-a5dc-7fa05363b28d name: local-edge-router role attributes: {} cd@sg1 ~/.softhsm/softhsm_demo $ EDGE_ROUTER_ID=c34734a4-d5de-430b-a5dc-7fa05363b28d cd@sg1 ~/.softhsm/softhsm_demo $ # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge delete config wttrconfig ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will # send a request to wttr.in to retreive a weather forecast ziti edge delete service wttr.ziti ziti edge create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig # start one or both proxies ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" 384166bd-0781-4189-ae66-6789cc1952b2 cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will cd@sg1 ~/.softhsm/softhsm_demo $ # send a request to wttr.in to retreive a weather forecast cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge delete service wttr.ziti cd@sg1 ~/.softhsm/softhsm_demo $ ziti edge create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig eb5c5fe8-5781-4760-9962-90ab708027f2 cd@sg1 ~/.softhsm/softhsm_demo $ cd@sg1 ~/.softhsm/softhsm_demo $ # start one or both proxies cd@sg1 ~/.softhsm/softhsm_demo $ ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & [1] 14821 cd@sg1 ~/.softhsm/softhsm_demo $ ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & [2] 14822 cd@sg1 ~/.softhsm/softhsm_demo $ [ 0.005] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.007] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.006] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=02&pin=2222]} loading key [ 0.007] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: //usr/local/lib/softhsm/libsofthsm2.so [ 0.008] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11:////usr/local/lib/softhsm/libsofthsm2.so?id=01&pin=2222]} loading key [ 0.008] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: //usr/local/lib/softhsm/libsofthsm2.so [ 0.019] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (2139311699) [ 0.020] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (2139311699) [ 0.023] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.024] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.023] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.loadECDSApub [pkcs11]: EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> [ 0.023] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.getECDSAmechanism [pkcs11]: {error=[pkcs11: 0x70: CKR_MECHANISM_INVALID]} failed to get mechanism info [1044] [ 0.025] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.024] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.060] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[de50dbc8-a00b-49aa-8fcc-285be8babdb4] id=[25692bf8-6cb1-4133-8b86-575a8ea65f09]} Got api session: {25692bf8-6cb1-4133-8b86-575a8ea65f09 de50dbc8-a00b-49aa-8fcc-285be8babdb4} [ 0.060] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token de50dbc8-a00b-49aa-8fcc-285be8babdb4 [ 0.069] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[45eae1d0-8ad0-4428-9900-c328ed9e3d23] id=[b8654830-b9e9-4450-9116-072ab4e8cca5]} Got api session: {b8654830-b9e9-4450-9116-072ab4e8cca5 45eae1d0-8ad0-4428-9900-c328ed9e3d23} [ 0.069] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 45eae1d0-8ad0-4428-9900-c328ed9e3d23 [ 0.106] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token de50dbc8-a00b-49aa-8fcc-285be8babdb4 [ 0.113] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 45eae1d0-8ad0-4428-9900-c328ed9e3d23 [ 0.160] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 0.160] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 0.160] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.160] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.160] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[eb5c5fe8-5781-4760-9962-90ab708027f2]} requesting session [ 0.170] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.170] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.170] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[eb5c5fe8-5781-4760-9962-90ab708027f2]} requesting session [ 0.200] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[a5291ddc-a86e-48c9-975e-662bc3bcb0d7]} acquired network session [ 0.200] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:8000]} service is listening [ 0.221] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[d4330d93-a6e1-4e48-91e1-cb26520f09d2]} acquired network session [ 0.222] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 0.222] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 0.222] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:9000]} service is listening jobs [1]- Running ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & [2]+ Running ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & cd@sg1 ~/.softhsm/softhsm_demo $ curl -H \"Host: wttr.in\" http://localhost:8000 [ 8.289] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started [ 8.302] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 8.302] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 8.304] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 8.304] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 8.304] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{D8nP}]: started [ 8.305] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{D8nP}]: started [ 8.306] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 8.306] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 8.544] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{D8nP}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 8.544] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 8.544] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:60053] src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel started [ 8.545] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {chSeq=[-1] edgeSeq=[1] connId=[1] type=[EdgeDataType]} writing 71 bytes [ 8.547] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8907 bytes [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes Weather report: Laurelton, United States Mist _ - _ - _ - 35..39 F _ - _ - _  5 mph _ - _ - _ - 3 mi 0.2 in   Thu 13 Feb   Morning  Noon  Evening  Night    .-. Light drizzle  .-. Light drizzle  _`/\"\".-. Moderate or he _`/\"\".-. Patchy light s  ( ). 39..41 F  ( ). 41..46 F  ,\\_( ). 33..39 F  ,\\_( ). 30..+35 F   (___(__)  3-5 mph  (___(__)  8-10 mph  /(___(__)  7-9 mph  /(___(__)  6-8 mph       3 mi      1 mi  * * * * 5 mi  * * * 4 mi       0.2 in | 66%      0.0 in | 64%  * * * * 0.0 in | 29%  * * * 0.0 in | 57%     Fri 14 Feb   Morning  Noon  Evening  Night    Overcast  Cloudy  _`/\"\".-. Patchy snow po \\ / Partly cloudy   .--. 8..21 F  .--. 12..23 F  ,\\_( ). 10..21 F  _ /\"\".-. 1..14 F   .-( ).  9-12 mph  .-( ).  10-11 mph  /(___(__)  11-14 mph  \\_( ).  9-15 mph   (___.__)__) 6 mi  (___.__)__) 6 mi   *  * 6 mi  /(___(__) 5 mi   0.0 in | 0%  0.0 in | 0%  *  *  0.0 in | 0%  0.0 in | 0%     Sat 15 Feb   Morning  Noon  Evening  Night    \\ / Sunny  \\ / Sunny  Overcast  Overcast   .-. 14..17 F  .-. 19..24 F  .--. 21..30 F  .--. 17..26 F    ( )   2 mph   ( )   3-4 mph  .-( ).  9-13 mph  .-( ).  8-14 mph   `- 6 mi  `- 6 mi  (___.__)__) 6 mi  (___.__)__) 6 mi   / \\ 0.0 in | 0%  / \\ 0.0 in | 0%  0.0 in | 0%  0.0 in | 0%   Follow @igor_chubin for wttr.in updates [ 9.968] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60053] src-local=[127.0.0.1:8000]} stopping pipe [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 9.968] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end cd@sg1 ~/.softhsm/softhsm_demo $ [ 10.969] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 10.969] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 10.969] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:8000] dst-remote=[127.0.0.1:60053]} stopping pipe [ 10.969] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60053] src-local=[127.0.0.1:8000] dst-local=[:1]} tunnel closed: 71 bytes sent; 8907 bytes received curl -H \"Host: wttr.in\" http://localhost:9000 [ 14.253] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started [ 14.265] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 14.265] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 14.266] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 14.266] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 14.266] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 14.266] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{DGp7}]: started [ 14.266] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 14.266] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{DGp7}]: started [ 14.405] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{DGp7}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 14.405] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 14.405] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60058]} tunnel started [ 14.405] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 14.405] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {connId=[1] type=[EdgeDataType] chSeq=[-1] edgeSeq=[1]} writing 71 bytes [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8907 bytes [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes Weather report: Laurelton, United States Mist _ - _ - _ - 35..39 F _ - _ - _  5 mph _ - _ - _ - 3 mi 0.2 in   Thu 13 Feb   Morning  Noon  Evening  Night    .-. Light drizzle  .-. Light drizzle  _`/\"\".-. Moderate or he _`/\"\".-. Patchy light s  ( ). 39..41 F  ( ). 41..46 F  ,\\_( ). 33..39 F  ,\\_( ). 30..+35 F   (___(__)  3-5 mph  (___(__)  8-10 mph  /(___(__)  7-9 mph  /(___(__)  6-8 mph       3 mi      1 mi  * * * * 5 mi  * * * 4 mi       0.2 in | 66%      0.0 in | 64%  * * * * 0.0 in | 29%  * * * 0.0 in | 57%     Fri 14 Feb   Morning  Noon  Evening  Night    Overcast  Cloudy  _`/\"\".-. Patchy snow po \\ / Partly cloudy   .--. 8..21 F  .--. 12..23 F  ,\\_( ). 10..21 F  _ /\"\".-. 1..14 F   .-( ).  9-12 mph  .-( ).  10-11 mph  /(___(__)  11-14 mph  \\_( ).  9-15 mph   (___.__)__) 6 mi  (___.__)__) 6 mi   *  * 6 mi  /(___(__) 5 mi   0.0 in | 0%  0.0 in | 0%  *  *  0.0 in | 0%  0.0 in | 0%     Sat 15 Feb   Morning  Noon  Evening  Night    \\ / Sunny  \\ / Sunny  Overcast  Overcast   .-. 14..17 F  .-. 19..24 F  .--. 21..30 F  .--. 17..26 F    ( )   2 mph   ( )   3-4 mph  .-( ).  9-13 mph  .-( ).  8-14 mph   `- 6 mi  `- 6 mi  (___.__)__) 6 mi  (___.__)__) 6 mi   / \\ 0.0 in | 0%  / \\ 0.0 in | 0%  0.0 in | 0%  0.0 in | 0%   Follow @igor_chubin for wttr.in updates [ 14.605] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60058]} stopping pipe [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 14.605] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end cd@sg1 ~/.softhsm/softhsm_demo $ [ 15.606] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 15.606] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 15.606] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[127.0.0.1:9000] dst-remote=[127.0.0.1:60058] src-remote=[wttr.ziti] src-local=[:1]} stopping pipe [ 15.606] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:60058] src-local=[127.0.0.1:9000]} tunnel closed: 71 bytes sent; 8907 bytes received jobs [1]- Running ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & [2]+ Running ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & cd@sg1 ~/.softhsm/softhsm_demo $ killall ziti-tunnel [ 21.732] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 21.731] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 21.732] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 21.731] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 21.732] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 21.731] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 21.731] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 21.732] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 21.731] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 21.732] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 21.731] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 21.732] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 21.731] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor [ 21.732] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor [1]- Done ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v [2]+ Done ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v cd@sg1 ~/.softhsm/softhsm_demo $ jobs cd@sg1 ~/.softhsm/softhsm_demo c:\\path\\to\\softhsm\\softhsm_demo>REM the name of the ziti controller you're logging into c:\\path\\to\\softhsm\\softhsm_demo>SET ZITI_CTRL=local-edge-controller c:\\path\\to\\softhsm\\softhsm_demo>REM the location of the certificate(s) to use to validate the controller c:\\path\\to\\softhsm\\softhsm_demo>SET ZITI_CTRL_CERT=c:\\path\\to\\controller.cert c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>SET ZITI_USER=myUserName c:\\path\\to\\softhsm\\softhsm_demo>SET ZITI_PWD=myPassword c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM a name for the configuration c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_NAME=softhsm_demo c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM the path to the root of the softhsm config files c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_ROOT=c:\\path\\to\\softhsm c:\\path\\to\\softhsm\\softhsm_demo>REM path to the softhsm2 library c:\\path\\to\\softhsm\\softhsm_demo>SET PKCS11_MODULE=%HSM_ROOT%\\lib\\softhsm2.dll c:\\path\\to\\softhsm\\softhsm_demo>--- or --- '---' is not recognized as an internal or external command, operable program or batch file. c:\\path\\to\\softhsm\\softhsm_demo>SET PKCS11_MODULE=%HSM_ROOT%\\lib\\softhsm2-x64.dll c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM the id of the key - you probably want to leave these alone unless you know better c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_ID1=01 c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_ID2=02 c:\\path\\to\\softhsm\\softhsm_demo>SET RSA_ID=%HSM_NAME%%HSM_ID1%_rsa c:\\path\\to\\softhsm\\softhsm_demo>SET EC_ID=%HSM_NAME%%HSM_ID2%_ec c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM the pins used when accessing the pkcs11 api c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_SOPIN=1111 c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_PIN=2222 c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_DEST=%HSM_ROOT%\\%HSM_NAME% c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_LABEL=%HSM_NAME%-label c:\\path\\to\\softhsm\\softhsm_demo>SET SOFTHSM2_CONF=%HSM_DEST%\\softhsm.config c:\\path\\to\\softhsm\\softhsm_demo>SET HSM_TOKENS_DIR=%HSM_DEST%\\tokens\\ c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM make an alias for ease c:\\path\\to\\softhsm\\softhsm_demo>doskey p=\"c:\\Program Files\\OpenSC Project\\OpenSC\\tools\\pkcs11-tool.exe\" --module %PKCS11_MODULE% $* c:\\path\\to\\softhsm\\softhsm_demo>cd /d %HSM_ROOT% c:\\path\\to\\softhsm> c:\\path\\to\\softhsm>rmdir /s /q %HSM_NAME% c:\\path\\to\\softhsm>mkdir %HSM_TOKENS_DIR% c:\\path\\to\\softhsm> c:\\path\\to\\softhsm>cd /d %HSM_NAME% c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo># Create a text file at %SOFTHSM2_CONF% with these contents but make sure you replace the tokendir entry with %HSM_TOKENS_DIR% '#' is not recognized as an internal or external command, operable program or batch file. c:\\path\\to\\softhsm\\softhsm_demo>echo ^ More? # SoftHSM v2 configuration file ^ More? More? directories.tokendir = %HSM_TOKENS_DIR% ^ More? More? objectstore.backend = file ^ More? More? # ERROR, WARNING, INFO, DEBUG ^ More? More? log.level = INFO ^ More? More? # If CKF_REMOVABLE_DEVICE flag should be set ^ More? More? slots.removable = false ^ More? More? # Enable and disable PKCS#11 mechanisms using slots.mechanisms. ^ More? More? slots.mechanisms = ALL > %SOFTHSM2_CONF% c:\\path\\to\\softhsm\\softhsm_demo>ziti edge login %ZITI_CTRL%:1280 -u %ZITI_USER% -p %ZITI_PWD% -c %ZITI_CTRL_CERT% Token: c6f4d504-6095-4118-8f13-3c787821963f c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM create a new identity and output the jwt to a known location c:\\path\\to\\softhsm\\softhsm_demo>ziti edge create identity device \"%RSA_ID%\" -o \"%HSM_DEST%\\%RSA_ID%.jwt\" a625ee46-b799-4e9f-a92c-59a579cb9756 Enrollment expires at 2020-02-23T14:22:08.902166003Z c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM create a second new identity and output the jwt to a known location c:\\path\\to\\softhsm\\softhsm_demo>ziti edge create identity device \"%EC_ID%\" -o \"%HSM_DEST%\\%EC_ID%.jwt\" 08889f51-1639-4cd0-9c18-ffcc5e315f3e Enrollment expires at 2020-02-23T14:22:09.634832703Z c:\\path\\to\\softhsm\\softhsm_demo>p --init-token --label \"ziti-test-token\" --so-pin %HSM_SOPIN% Using slot 0 with a present token (0x0) Token successfully initialized c:\\path\\to\\softhsm\\softhsm_demo>p --init-pin --pin \"%HSM_PIN%\" --so-pin %HSM_SOPIN% Using slot 0 with a present token (0x1af2a063) User PIN successfully initialized c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM create a couple of keys - one rsa and one ec c:\\path\\to\\softhsm\\softhsm_demo>p -p \"%HSM_PIN%\" -k --key-type rsa:2048 --id \"%HSM_ID1%\" --label ziti-rsa-key --usage-sign --usage-decrypt Using slot 0 with a present token (0x1af2a063) Key pair generated: Private Key Object; RSA label: ziti-rsa-key ID: 01 Usage: decrypt, sign, unwrap Access: sensitive, always sensitive, never extractable, local Public Key Object; RSA 2048 bits label: ziti-rsa-key ID: 01 Usage: encrypt, verify, wrap Access: local c:\\path\\to\\softhsm\\softhsm_demo>p -p \"%HSM_PIN%\" -k --key-type EC:prime256v1 --id \"%HSM_ID2%\" --label ziti-ecdsa-key --usage-sign --usage-decrypt Using slot 0 with a present token (0x1af2a063) Key pair generated: Private Key Object; EC label: ziti-ecdsa-key ID: 02 Usage: decrypt, sign, unwrap Access: sensitive, always sensitive, never extractable, local Public Key Object; EC EC_POINT 256 bits EC_POINT: 04410419240eaf1e7628c94dbb3ab46f0b4c5b3fe8bab8227b67ed9bdea6d107547c16ac401437f674c73986697cc2c0e4ae0416775ee8ec0b65f1fe6c935acdc4b35a EC_PARAMS: 06082a8648ce3d030107 label: ziti-ecdsa-key ID: 02 Usage: encrypt, verify, wrap Access: local c:\\path\\to\\softhsm\\softhsm_demo>ziti-tunnel enroll -j \"%HSM_DEST%\\%RSA_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID1%&pin=%HSM_PIN%\" -v time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjQ2NzcyOCwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6IjQwZjE5Y2VhLWFjYWYtNDQyMy1iNzhjLWI2NjU4MDA0NGI2MSIsInN1YiI6ImE2MjVlZTQ2LWI3OTktNGU5Zi1hOTJjLTU5YTU3OWNiOTc1NiJ9.LkziWbgKeJtZ6f5dd169K32Gq86-6ly13v7iHn7Zj_ITFudxXzLa2dl3JonBRg6hNW8ghiPNZ7JpcSkRiaN8npKUHAnsZfr1kPE-NR-eJmUTqM88UhznQJOKyAZzA-dLxRfsRgmU9ESLVsAQEE4wefPz8AlsXWGYK9oWx-X0SEwu4TgjCWP1jEd7pQJXw5ZXIBYLZMG0buIFaKgskH-inpK7BF2LZc9ENr6nj4W4X_tm7kbzGdQ-ofzlhJMBHFz2w_qQXDqXiYWf59Wrszd9-3y0rbvykmc9L8G3B1YlICKyD6mhaPt4fLquZEOwsyeOgH9BLJhX9I33nfYZe_mQf4jzhw5U13K1VKaL-JGwfXntwrKMUJhB62NDMLNALMDqc4hK3BKp1wdZT5YL2Y91J2lLa50mg0OG9ASvkmh7dW3FhDFntl9UnSuPmVJExfMJJCXwe0DgbLcg0TugUuioJ9iCrAZ2tTsLoXDIqLj4zqDhe2nCXdTGgqGpa2ftqNWsUxJmZM2V8ll8Mb2tcuNu0WHcpZ1nH9iXuNHWRsLyowIZB0NJoIvYRlHzlPiSjJxZlNdMSh2jm6tZ7_sAyw_cIAU20yJ3KSGE2PT9bCgkISiYEZ2V5Q3cyGIi0OMP7IqZ5vomqHhkF41C4LIH7A4NKCWMztTwt-WOIndGX5yB1GA\" time=\"2020-02-13T09:22:18-05:00\" level=info msg=\"using engine : pkcs11\\n\" time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=01&pin=2222\" time=\"2020-02-13T09:22:18-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\softhsm\\\\lib\\\\softhsm2-x64.dll\" context=pkcs11 time=\"2020-02-13T09:22:18-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (452108387)\" context=pkcs11 time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"no cas provided in caPool. using system provided cas\" time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"fetching certificates from server\" time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=01&pin=2222\" time=\"2020-02-13T09:22:18-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\softhsm\\\\lib\\\\softhsm2-x64.dll\" context=pkcs11 time=\"2020-02-13T09:22:18-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (452108387)\" context=pkcs11 time=\"2020-02-13T09:22:18-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 enrolled successfully. identity file written to: c:\\path\\to\\softhsm\\softhsm_demo\\softhsm_demo01_rsa.json c:\\path\\to\\softhsm\\softhsm_demo>ziti-tunnel enroll -j \"%HSM_DEST%\\%EC_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID2%&pin=%HSM_PIN%\" -v time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjQ2NzcyOSwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6ImU0NDhlMGVjLTk4Y2ItNDBjMC05MmE4LWE2YjMyZDJlY2UwMCIsInN1YiI6IjA4ODg5ZjUxLTE2MzktNGNkMC05YzE4LWZmY2M1ZTMxNWYzZSJ9.HHlGcNPh1E83SG3ncCzIPLpav4fRZ44eAeq9Igr24CHT3TCJXXooFNVY5LYtTJ3ydsE6RVPn3UCrP_72CK4Y8Bc-OHDxtPsl0wQwH90tYIz68d2Br0D8kBjjLnYNfsQS0w4t9GEdnNLD8WfjIF8V1croBksrA0jyDiZFak67tKwohzftmm7bNNibA2KvNFVSa_ZaD1lT-SR5xEHaTkR4LpBhPSN9HeR6TAj0c0LsFgFAm_4LrX14r3eufCxxj0TIEHPvxqa_dMJq3TuUFQQPvSIStnXKd9i4gTnFhFdxeZ4J4R94IT6UdzAVD1lIBA9tta7XrMgKpG7Yl8OX60rh3je4S73WAff4kZg6gFpL2RckHuCGdn4AoAXPJoFqBerQ3xybAVNW913fxtw942juVBhjb4Ex2LzZylkRrQmJ3xV5s3-MuW8-1-2N1lK5u1JK_sulrCx5trrvFb99z2INnNh0baVFq_7-3KozVsE0RNiXGc5dAjhNFWJWXT9H6PhIzzJ-0l84ZQaloxon1b70LnoVPC8g2z-Psvv8-Pc2JIlg5K4DLIXsagD4n4S1Fh8aqAyduF5Sc7ddVQ20-8Fz8iIZXNEGvNa9KwuHVzrk3UZJ3cB7Q1oWDshHPcMd7B4AtyV4z9U4qUP7syyAYkGYrMT_F26uNmIb0s2eW6xDf68\" time=\"2020-02-13T09:22:19-05:00\" level=info msg=\"using engine : pkcs11\\n\" time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=02&pin=2222\" time=\"2020-02-13T09:22:19-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\softhsm\\\\lib\\\\softhsm2-x64.dll\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (452108387)\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil>\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=warning msg=\"failed to get mechanism info [1044]\" context=pkcs11 error=\"pkcs11: 0x70: CKR_MECHANISM_INVALID\" time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"no cas provided in caPool. using system provided cas\" time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"fetching certificates from server\" time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=02&pin=2222\" time=\"2020-02-13T09:22:19-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\softhsm\\\\lib\\\\softhsm2-x64.dll\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (452108387)\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-13T09:22:19-05:00\" level=debug msg=\"EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil>\" context=pkcs11 time=\"2020-02-13T09:22:19-05:00\" level=warning msg=\"failed to get mechanism info [1044]\" context=pkcs11 error=\"pkcs11: 0x70: CKR_MECHANISM_INVALID\" enrolled successfully. identity file written to: c:\\path\\to\\softhsm\\softhsm_demo\\softhsm_demo02_ec.json c:\\path\\to\\softhsm\\softhsm_demo>REM run this command and get the id from the first edge-router. c:\\path\\to\\softhsm\\softhsm_demo>ziti edge list edge-routers id: 727f0074-9011-4b79-955b-a6a9e3bb67b1 name: local-edge-router role attributes: {} c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM use the id returned from the above command and put it into a variable for use in a momment c:\\path\\to\\softhsm\\softhsm_demo>SET EDGE_ROUTER_ID=727f0074-9011-4b79-955b-a6a9e3bb67b1 c:\\path\\to\\softhsm\\softhsm_demo>REM remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 c:\\path\\to\\softhsm\\softhsm_demo>ziti edge delete config wttrconfig c:\\path\\to\\softhsm\\softhsm_demo>ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" 7e73d98c-e44f-4360-9a48-6d1c812f0a75 c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>REM recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will c:\\path\\to\\softhsm\\softhsm_demo>REM send a request to wttr.in to retreive a weather forecast c:\\path\\to\\softhsm\\softhsm_demo>ziti edge delete service wttr.ziti c:\\path\\to\\softhsm\\softhsm_demo>ziti edge create service wttr.ziti \"%EDGE_ROUTER_ID%\" tcp://wttr.in:80 --configs wttrconfig 04ccec0c-3329-4f8f-8942-9dbd378bb15e c:\\path\\to\\softhsm\\softhsm_demo>REM start one or both proxies - use ctrl-break or ctrl-pause to terminate these processes c:\\path\\to\\softhsm\\softhsm_demo>start /b ziti-tunnel proxy -i \"%HSM_DEST%/%RSA_ID%.json\" wttr.ziti:8000 -v c:\\path\\to\\softhsm\\softhsm_demo>[ 0.026] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.027] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=01&pin=2222]} loading key [ 0.028] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: c:\\path\\to\\softhsm\\lib\\softhsm2-x64.dll [ 0.036] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (452108387) [ 0.043] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.044] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.079] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {id=[087afe19-9c8b-40f4-88c9-962d9e04f1b8] token=[28c9472d-8540-413d-9f8e-532139dfbdcb]} Got api session: {087afe19-9c8b-40f4-88c9-962d9e04f1b8 28c9472d-8540-413d-9f8e-532139dfbdcb} [ 0.080] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 28c9472d-8540-413d-9f8e-532139dfbdcb [ 0.124] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 28c9472d-8540-413d-9f8e-532139dfbdcb [ 0.166] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 0.166] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 0.167] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.169] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.169] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[04ccec0c-3329-4f8f-8942-9dbd378bb15e]} requesting session [ 0.203] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[4b9096a5-4bef-4296-813d-252aebe7ebe6]} acquired network session [ 0.203] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:8000]} service is listening start /b ziti-tunnel proxy -i \"%HSM_DEST%/%EC_ID%.json\" wttr.ziti:9000 -v c:\\path\\to\\softhsm\\softhsm_demo>[ 0.017] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.017] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11://c:%5Cpath%5Cto%5Csofthsm%5Clib%5Csofthsm2-x64.dll?id=02&pin=2222]} loading key [ 0.018] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: c:\\path\\to\\softhsm\\lib\\softhsm2-x64.dll [ 0.026] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (452108387) [ 0.034] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.034] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.loadECDSApub [pkcs11]: EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> [ 0.035] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.getECDSAmechanism [pkcs11]: {error=[pkcs11: 0x70: CKR_MECHANISM_INVALID]} failed to get mechanism info [1044] [ 0.037] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.074] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[68289015-5910-464f-8c1f-4870c28cfbb1] id=[32d29510-6285-4cff-80b3-a9630ffef388]} Got api session: {32d29510-6285-4cff-80b3-a9630ffef388 68289015-5910-464f-8c1f-4870c28cfbb1} [ 0.074] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 68289015-5910-464f-8c1f-4870c28cfbb1 [ 0.123] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 68289015-5910-464f-8c1f-4870c28cfbb1 [ 0.162] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.163] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.164] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[04ccec0c-3329-4f8f-8942-9dbd378bb15e]} requesting session [ 0.204] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[d09009a6-a2b2-405b-8125-8f9c021ff8de]} acquired network session [ 0.204] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 0.206] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 0.207] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {addr=[0.0.0.0:9000] service=[wttr.ziti]} service is listening c:\\path\\to\\softhsm\\softhsm_demo>curl -H \"Host: wttr.in\" http://localhost:8000 > \"%HSM_DEST%\\example_%RSA_ID%.txt\" [ 14.743] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Spee[ 14.758] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates d[ 14.758] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 14.759] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 14.759] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 14.760] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{PpLP}]: started [ 14.760] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 14.761] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 14.761] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{PpLP}]: started 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 14.874] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{PpLP}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 14.874] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 14.875] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:62125] src-local=[127.0.0.1:8000]} tunnel started [ 14.878] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {edgeSeq=[1] connId=[1] type=[EdgeDataType] chSeq=[-1]} writing 71 bytes [ 14.879] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 15.057] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {connId=[1] seq=[1]} handling received EdgeDataType [ 15.057] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8964 bytes [ 15.058] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 100 8799 100 8799 0 0 28111 0 --:--:-- --:--:-- --:--:-- 28111 [ 15.067] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[127.0.0.1:62125] src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti]} stopping pipe [ 15.067] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 15.069] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 15.069] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 15.070] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end c:\\path\\to\\softhsm\\softhsm_demo>[ 16.070] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 16.070] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 16.071] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-remote=[127.0.0.1:62125] src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:8000]} stopping pipe [ 16.072] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-remote=[wttr.ziti] src-remote=[127.0.0.1:62125] src-local=[127.0.0.1:8000] dst-local=[:1]} tunnel closed: 71 bytes sent; 8964 bytes received c:\\path\\to\\softhsm\\softhsm_demo> curl -H \"Host: wttr.in\" http://localhost:9000 > \"%HSM_DEST%\\example_%EC_ID%.txt\" [ 18.776] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started % Total % Received % Xferd Average Speed Time Time Time Current [ 18.785] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 18.785] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 18.786] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 18.786] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 18.787] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 18.787] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{15kP}]: started [ 18.789] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 18.789] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{15kP}]: started Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 18.902] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{15kP}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 18.903] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 18.904] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:62130] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel started [ 18.905] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {type=[EdgeDataType] chSeq=[-1] edgeSeq=[1] connId=[1]} writing 71 bytes [ 18.906] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 19.334] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 19.335] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8964 bytes [ 19.336] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 100 8799 100 8799 0 0 15628 0 --:--:-- --:--:-- --:--:-- 15628 [ 19.344] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[127.0.0.1:62130] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} stopping pipe [ 19.344] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 19.345] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 19.347] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 19.349] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end c:\\path\\to\\softhsm\\softhsm_demo> c:\\path\\to\\softhsm\\softhsm_demo>[ 20.345] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 20.345] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 20.347] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:62130] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel closed: 71 bytes sent; 8964 bytes received [ 20.349] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[127.0.0.1:9000] dst-remote=[127.0.0.1:62130] src-remote=[wttr.ziti] src-local=[:1]} stopping pipe tpye \"%HSM_DEST%\\example_%RSA_ID%.txt\" 'tpye' is not recognized as an internal or external command, operable program or batch file. c:\\path\\to\\softhsm\\softhsm_demo>type \"%HSM_DEST%\\example_%RSA_ID%.txt\" Weather report: Laurelton, United States Mist _ - _ - _ - 35..39 F _ - _ - _  5 mph _ - _ - _ - 3 mi 0.0 in   Thu 13 Feb   Morning  Noon  Evening  Night    .-. Light rain  .-. Light rain  _`/\"\".-. Moderate or he \\ / Partly cloudy   ( ). 35..37 F  ( ). 39..41 F  ,\\_( ). 32..39 F  _ /\"\".-. 26..+33 F   (___(__)  4-6 mph  (___(__)  5-6 mph  /(___(__)  8-10 mph  \\_( ).  9-14 mph       5 mi      5 mi  * * * * 5 mi  /(___(__) 4 mi       0.1 in | 79%      0.0 in | 80%  * * * * 0.0 in | 25%  0.0 in | 51%     Fri 14 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Sunny  \\ / Partly cloudy  \\ / Clear   _ /\"\".-. 3..17 F  .-. 6..19 F  _ /\"\".-. 8..19 F  .-. 5..14 F   \\_( ).  11-13 mph   ( )   11-13 mph  \\_( ).  9-12 mph   ( )   7-11 mph   /(___(__) 6 mi  `- 6 mi  /(___(__) 6 mi  `- 6 mi   0.0 in | 0%  / \\ 0.0 in | 0%  0.0 in | 0%  / \\ 0.0 in | 0%     Sat 15 Feb   Morning  Noon  Evening  Night    \\ / Sunny  \\ / Sunny  \\ / Partly cloudy  \\ / Partly cloudy   .-. 12..17 F  .-. 17..24 F  _ /\"\".-. 21..30 F  _ /\"\".-. 15..24 F    ( )   3-4 mph   ( )   6-7 mph  \\_( ).  8-13 mph  \\_( ).  7-14 mph   `- 6 mi  `- 6 mi  /(___(__) 6 mi  /(___(__) 6 mi   / \\ 0.0 in | 0%  / \\ 0.0 in | 0%  0.0 in | 0%  0.0 in | 0%   Follow @igor_chubin for wttr.in updates c:\\path\\to\\softhsm\\softhsm_demo>type \"%HSM_DEST%\\example_%EC_ID%.txt\" Weather report: Laurelton, United States Mist _ - _ - _ - 35..39 F _ - _ - _  5 mph _ - _ - _ - 3 mi 0.0 in   Thu 13 Feb   Morning  Noon  Evening  Night    .-. Light rain  .-. Light rain  _`/\"\".-. Moderate or he \\ / Partly cloudy   ( ). 35..37 F  ( ). 39..41 F  ,\\_( ). 32..39 F  _ /\"\".-. 26..+33 F   (___(__)  4-6 mph  (___(__)  5-6 mph  /(___(__)  8-10 mph  \\_( ).  9-14 mph       5 mi      5 mi  * * * * 5 mi  /(___(__) 4 mi       0.1 in | 79%      0.0 in | 80%  * * * * 0.0 in | 25%  0.0 in | 51%     Fri 14 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Sunny  \\ / Partly cloudy  \\ / Clear   _ /\"\".-. 3..17 F  .-. 6..19 F  _ /\"\".-. 8..19 F  .-. 5..14 F   \\_( ).  11-13 mph   ( )   11-13 mph  \\_( ).  9-12 mph   ( )   7-11 mph   /(___(__) 6 mi  `- 6 mi  /(___(__) 6 mi  `- 6 mi   0.0 in | 0%  / \\ 0.0 in | 0%  0.0 in | 0%  / \\ 0.0 in | 0%     Sat 15 Feb   Morning  Noon  Evening  Night    \\ / Sunny  \\ / Sunny  \\ / Partly cloudy  \\ / Partly cloudy   .-. 12..17 F  .-. 17..24 F  _ /\"\".-. 21..30 F  _ /\"\".-. 15..24 F    ( )   3-4 mph   ( )   6-7 mph  \\_( ).  8-13 mph  \\_( ).  7-14 mph   `- 6 mi  `- 6 mi  /(___(__) 6 mi  /(___(__) 6 mi   / \\ 0.0 in | 0%  / \\ 0.0 in | 0%  0.0 in | 0%  0.0 in | 0%   Follow @igor_chubin for wttr.in updates c:\\path\\to\\softhsm\\softhsm_demo>"
  },
  "ziti/quickstarts/hsm/yubikey.html": {
    "href": "ziti/quickstarts/hsm/yubikey.html",
    "title": "YubiKey by Yubico | Ziti",
    "keywords": "YubiKey by Yubico Yubico is a manufacturer of HSM deviceis. A popular line of HSM produced by Yubico is the YubiKey. This quickstart guide will use specific device from Yubico - the YubiKey 5 nfc . Overview The YubiKey 5 nfc is a multi-purpose device with a few different security-minded uses. One of the applications on the device is an application called PIV or \"Personal Identity Verification\". PIV is a standard published by NIST and describes the kinds of credentials which make up the standard. PIV credentials have certificates and key pairs, pin numbers, biometrics like fingerprints and pictures, and other unique identifiers. When put together into a PIV credential, it provides the capability to implement multi-factor authentication for networks, applications and buildings. In this quickstart you will see the commands and tools needed to use a YubiKey 5 nfc with a Ziti Network. This document is intended to serve as a quickstart. That means limited context will be provided for each step. When appropriate there will be a small amount of context or a comment included to aid in understanding of what is happening and why. Most if not all of these commands are easily searched for using your search engine of choice. Warning This quickstart intended audience is for more technically savvy indiviuals. You will need to be familar with the command line interface of your operating system. Prerequistites YubiKey 5 nfc - clearly you'll need one in order to use this quickstart! OpenSC is installed and pkcs11-tool is either on the PATH or at a known location. Not required however this quickstart uses the pkcs11-tool to illustrate that the device is PKCS#11 compliant. HSM manufacturers will generally provide a similar tool and often expand it's usage. See more below. yubico-piv-tool - YubiKey privides a similar tool to the pkcs11-tool . This tool is needed to be installed because it contains the pkcs#11 module (driver) for the HSM. As this is a tool specific to Yubico we've chosen to not use this in the following commands. Ensure the YubiKey is factory reset. To avoid any compliations with existing information in the YubiKey ensure the device is factory reset using the YubiKey Manager . In order to successfully use the YubiKey the libraries provided by the yubico-piv-tool MUST either be on the path or in a common location that is known to the OS. On linux this is likely done by the YubiKey software installation but on Windows you'll need to take any additional actions highlighted in the Windows-specific sections. Linux Only: If you're using linux - you'll need to follow the build instructions provided by Yubico. Before you can do anything with the Yubikey you'll need to make sure the libykcs11.so exists on your system. When creating this quickstart the library was built to ./yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so . Ubuntu was used to test this guide. An attempt was also made with linux mint however the attempt failed when trying to compile the Yubikey software and was aborted. It would likely have worked if enough effort was put into discovering why that linux variant had issues pulling and compiling the necessary software. If you see strange errors when following this guide and are not using Ubuntu it may be related. ziti and ziti-tunnel are both downloaded and on the path. Let's Use the YubiKey! Here's the list of steps we'll accomplish in this quickstart: Establish a bunch of environment variables to make it easy to copy/paste the other commands. You'll want to look at these environment variables . They need to be setup properly. If you have problems with this guide it is almost certainly because you have an environment variable setup incorrectly. Double check them. Make a directory and generate a configuration files for Ziti Use the Ziti CLI to: create two identities - one demonstrating an RSA key, one EC enroll the identities create a test service create test router/service policies Use the pkcs11-tool provided by OpenSC to interact with the YubiKey to: initialize the PIV app create a key Use ziti-tunnel to enroll the identities using the YubiKey Use ziti-tunnel in proxy mode to verify things are working and traffic is flowing over the Ziti Network Warning Do NOT use id 2 or 02 for any keys you add. Id 02 corresponds to the YubiKey's \"Management Key\". You will not be able to write a key into this location. The error you will see will indicate: CKR_USER_NOT_LOGGED_IN . Establish Environment Variables Open a command line and establish the following environment varibles. Note that for the YubiKey we do not use id 02 as it appears to be reserved by the YubiKey. The default SOPIN and PIN are used as well. When using the YubiKey Manager software the \"SO PIN\" corresponds to the \"Management Key\" while \"pin\" is the same both here and in the YubiKey Manager. Linux/MacOS Windows # the name of the ziti controller you're logging into export ZITI_CTRL=local-edge-controller # the location of the certificate(s) to use to validate the controller export ZITI_CTRL_CERT=/path/to/controller.cert export ZITI_USER=myUserName export ZITI_PWD=myPassword # a name for the configuration export HSM_NAME=yubikey_demo # path to the yubikey pkcs11 libraries export HSM_ROOT=/path/to/yubico-piv-tool-2.0.0 export PKCS11_MODULE=${HSM_ROOT}/ykcs11/.libs/libykcs11.so # the id of the key - you probably want to leave these alone unless you know better export HSM_ID1=01 export HSM_ID2=03 # the pins used when accessing the pkcs11 api export HSM_SOPIN=010203040506070801020304050607080102030405060708 export HSM_PIN=123456 export RSA_ID=${HSM_NAME}${HSM_ID1}_rsa export EC_ID=${HSM_NAME}${HSM_ID2}_ec # location for the config files to be placed export HSM_DEST=${HSM_ROOT}/${HSM_NAME} export HSM_LABEL=${HSM_NAME}-label # make an alias for ease alias p='pkcs11-tool --module $PKCS11_MODULE' Warning Ensure you use the correct dll. If you use an x86 dll with x64 binaries you'll get an error. Warning With Windows - make sure you update the path to include the folder of libykcs11-1.dll as additional libraries are needed by the pkcs11 driver! REM the name of the ziti controller you're logging into SET ZITI_CTRL=local-edge-controller REM the location of the certificate(s) to use to validate the controller SET ZITI_CTRL_CERT=c:\\path\\to\\controller.cert SET ZITI_USER=myUserName SET ZITI_PWD=myPassword REM a name for the configuration SET HSM_NAME=yubikey_windemo REM the path to the root of the yubikey piv tool SET HSM_ROOT=c:\\path\\to\\yubico-piv-tool-2.0.0 REM path to the pkcs11 library SET PATH=%PATH%;%HSM_ROOT%\\bin SET PKCS11_MODULE=%HSM_ROOT%\\bin\\libykcs11-1.dll REM the id of the key - you probably want to leave these alone unless you know better SET HSM_ID1=01 SET HSM_ID2=03 SET RSA_ID=%HSM_NAME%%HSM_ID1%_rsa SET EC_ID=%HSM_NAME%%HSM_ID2%_ec REM the pins used when accessing the pkcs11 api SET HSM_SOPIN=010203040506070801020304050607080102030405060708 SET HSM_PIN=123456 SET HSM_DEST=%HSM_ROOT%\\%HSM_NAME% SET HSM_LABEL=%HSM_NAME%-label SET HSM_TOKENS_DIR=%HSM_DEST%\\tokens\\ REM make an alias for ease doskey p=\"c:\\Program Files\\OpenSC Project\\OpenSC\\tools\\pkcs11-tool.exe\" --module %PKCS11_MODULE% $* Make Directories for Config Files Linux/MacOS Windows cd ${HSM_ROOT} rm -rf ${HSM_NAME} mkdir -p ${HSM_NAME} cd ${HSM_NAME} cd /d %HSM_ROOT% rmdir /s /q %HSM_NAME% mkdir %HSM_NAME% cd /d %HSM_NAME% Use the Ziti CLI Linux/MacOS Windows ziti edge login $ZITI_CTRL:1280 -u $ZITI_USER -p $ZITI_PWD -c $ZITI_CTRL_CERT # create a new identity and output the jwt to a known location ziti edge create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" # create a second new identity and output the jwt to a known location ziti edge create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\" ziti edge login %ZITI_CTRL%:1280 -u %ZITI_USER% -p %ZITI_PWD% -c %ZITI_CTRL_CERT% REM create a new identity and output the jwt to a known location ziti edge create identity device \"%RSA_ID%\" -o \"%HSM_DEST%\\%RSA_ID%.jwt\" REM create a second new identity and output the jwt to a known location ziti edge create identity device \"%EC_ID%\" -o \"%HSM_DEST%\\%EC_ID%.jwt\" Use pkcs11-tool to Setup the YubiKey Linux/MacOS Windows p --init-token --label \"ziti-test-token\" --so-pin $HSM_SOPIN # create a couple of keys - one rsa and one ec p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id $HSM_ID1 --login-type so --so-pin $HSM_SOPIN --label defaultkey p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id $HSM_ID2 --login-type so --so-pin $HSM_SOPIN --label defaultkey p --init-token --label \"ziti-test-token\" --so-pin %HSM_SOPIN% REM create a couple of keys - one rsa and one ec p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id %HSM_ID1% --login-type so --so-pin %HSM_SOPIN% --label defaultkey p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id %HSM_ID2% --login-type so --so-pin %HSM_SOPIN% --label defaultkey Use ziti-tunnel to Enroll the Identities Linux/MacOS Windows ziti-tunnel enroll -j \"${HSM_DEST}/${RSA_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID1}&pin=${HSM_PIN}\" -v ziti-tunnel enroll -j \"${HSM_DEST}/${EC_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID2}&pin=${HSM_PIN}\" -v ziti-tunnel enroll -j \"%HSM_DEST%\\%RSA_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID1%&pin=%HSM_PIN%\" -v ziti-tunnel enroll -j \"%HSM_DEST%\\%EC_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID2%&pin=%HSM_PIN%\" -v Use ziti-tunnel to Verify Things Work Linux/MacOS Windows # if you only have a single edge router this command will work without the need for copy/paste EDGE_ROUTER_ID=$(ziti edge list edge-routers | cut -d \" \" -f2) # IF the above command doesn't work - run this command and get the id from the first edge-router. # ziti edge list edge-routers # then use the id returned from the above command and put it into a variable for use in a momment # EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge delete config wttrconfig ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will # send a request to wttr.in to retreive a weather forecast ziti edge delete service wttr.ziti ziti edge create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig # start one or both proxies ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & # use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network curl -H \"Host: wttr.in\" http://localhost:8000 curl -H \"Host: wttr.in\" http://localhost:9000 REM these two commands can't be copied and pasted - you need to get the result of the first command and use it in the next REM run this command and get the id from the first edge-router. ziti edge list edge-routers REM use the id returned from the above command and put it into a variable for use in a momment SET EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} REM remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge delete config wttrconfig ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" REM recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will REM send a request to wttr.in to retreive a weather forecast ziti edge delete service wttr.ziti ziti edge create service wttr.ziti \"%EDGE_ROUTER_ID%\" tcp://wttr.in:80 --configs wttrconfig REM start one or both proxies - use ctrl-break or ctrl-pause to terminate these processes start /b ziti-tunnel proxy -i \"%HSM_DEST%/%RSA_ID%.json\" wttr.ziti:8000 -v start /b ziti-tunnel proxy -i \"%HSM_DEST%/%EC_ID%.json\" wttr.ziti:9000 -v REM use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network curl -H \"Host: wttr.in\" http://localhost:8000 > \"%HSM_DEST%\\example_%RSA_ID%.txt\" curl -H \"Host: wttr.in\" http://localhost:9000 > \"%HSM_DEST%\\example_%EC_ID%.txt\" REM set the codepage for the cmd prompt so that the output looks nice chcp 65001 REM show the results in the console type \"%HSM_DEST%\\example_%RSA_ID%.txt\" type \"%HSM_DEST%\\example_%EC_ID%.txt\" REM ctrl-break or ctrl-pause to kill the tunnelers Putting It All Together Above we've only shown the commands that need to run and not what the output of those commands would look like. Here we'll see all the commands put together along with all the output from the commands. This section is long - you are warned! Also note that this content is subject to change. If the output you see is not identical it's because the software has changed since this information was captured. File an issue if you'd like to see it updated. Sample Output Linux/MacOS Windows The tabs to the right contain example output from running all the commands in sequence. If you want to see what the output would likely look like click one of the tabs to the right. Reminder - it's a lot of commands and a lot of output! :) -- coming soon-- cd@cd-ubuntuvm: # the name of the ziti controller you're logging into cd@cd-ubuntuvm: export ZITI_CTRL=local-edge-controller cd@cd-ubuntuvm: # the location of the certificate(s) to use to validate the controller cd@cd-ubuntuvm: export ZITI_CTRL_CERT=/path/to/controller.cert cd@cd-ubuntuvm: cd@cd-ubuntuvm: export ZITI_USER=myUserName cd@cd-ubuntuvm: export ZITI_PWD=myPassword cd@cd-ubuntuvm: cd@cd-ubuntuvm: # a name for the configuration cd@cd-ubuntuvm: export HSM_NAME=yubikey_demo cd@cd-ubuntuvm: cd@cd-ubuntuvm: # path to the yubikey pkcs11 libraries cd@cd-ubuntuvm: export HSM_ROOT=/path/to/yubico-piv-tool-2.0.0 cd@cd-ubuntuvm: export PKCS11_MODULE=${HSM_ROOT}/ykcs11/.libs/libykcs11.so cd@cd-ubuntuvm: cd@cd-ubuntuvm: # the id of the key - you probably want to leave these alone unless you know better cd@cd-ubuntuvm: export HSM_ID1=01 cd@cd-ubuntuvm: export HSM_ID2=03 cd@cd-ubuntuvm: cd@cd-ubuntuvm: # the pins used when accessing the pkcs11 api cd@cd-ubuntuvm: export HSM_SOPIN=010203040506070801020304050607080102030405060708 cd@cd-ubuntuvm: export HSM_PIN=123456 cd@cd-ubuntuvm: export RSA_ID=${HSM_NAME}${HSM_ID1}_rsa cd@cd-ubuntuvm: export EC_ID=${HSM_NAME}${HSM_ID2}_ec cd@cd-ubuntuvm: cd@cd-ubuntuvm: # location for the config files to be placed cd@cd-ubuntuvm: export HSM_DEST=${HSM_ROOT}/${HSM_NAME} cd@cd-ubuntuvm: export HSM_LABEL=${HSM_NAME}-label cd@cd-ubuntuvm: cd@cd-ubuntuvm: # make an alias for ease cd@cd-ubuntuvm: alias p='pkcs11-tool --module $PKCS11_MODULE' cd@cd-ubuntuvm: cd ${HSM_ROOT} rm -rf ${HSM_NAME} cd@cd-ubuntuvm: cd@cd-ubuntuvm: rm -rf ${HSM_NAME} mkdir -p ${HSM_NAME} cd@cd-ubuntuvm: mkdir -p ${HSM_NAME} cd@cd-ubuntuvm: cd@cd-ubuntuvm: cd ${HSM_NAME} cd@cd-ubuntuvm: ziti edge login $ZITI_CTRL:1280 -u $ZITI_USER -p $ZITI_PWD -c $ZITI_CTRL_CERT # create a new identity and output the jwt to a known location ziti edge create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" # create a second new identity and output the jwt to a known location ziti edge create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\"Token: 7083e601-cc2f-4636-94c0-959174e76264 cd@cd-ubuntuvm: cd@cd-ubuntuvm: # create a new identity and output the jwt to a known location cd@cd-ubuntuvm: ziti edge create identity device \"${RSA_ID}\" -o \"${HSM_DEST}/${RSA_ID}.jwt\" 76877717-9bce-4f34-ae7a-2ce313b8267a Enrollment expires at 2020-02-24T14:56:19.961322754Z cd@cd-ubuntuvm: cd@cd-ubuntuvm: # create a second new identity and output the jwt to a known location cd@cd-ubuntuvm: ziti edge create identity device \"${EC_ID}\" -o \"${HSM_DEST}/${EC_ID}.jwt\" bdd18e58-e474-4ed3-98eb-c68ed96377be Enrollment expires at 2020-02-24T14:56:21.673599433Z cd@cd-ubuntuvm: p --init-token --label \"ziti-test-token\" --so-pin $HSM_SOPIN p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id $HSM_ID1 --login-type so --so-pin $HSM_SOPIN --label defaultkey p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id $HSM_ID2 --login-type so --so-pin $HSM_SOPIN --label defaultkeyUsing slot 0 with a present token (0x0) Token successfully initialized cd@cd-ubuntuvm: cd@cd-ubuntuvm: # create a couple of keys - one rsa and one ec cd@cd-ubuntuvm: p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id $HSM_ID1 --login-type so --so-pin $HSM_SOPIN --label defaultkey Using slot 0 with a present token (0x0) Key pair generated: Private Key Object; RSA label: Private key for PIV Authentication ID: 01 Usage: decrypt, sign Public Key Object; RSA 2048 bits label: Public key for PIV Authentication ID: 01 Usage: encrypt, verify cd@cd-ubuntuvm: p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id $HSM_ID2 --login-type so --so-pin $HSM_SOPIN --label defaultkey Using slot 0 with a present token (0x0) Key pair generated: Private Key Object; EC label: Private key for Key Management ID: 03 Usage: decrypt, sign Public Key Object; EC EC_POINT 256 bits EC_POINT: 044104ee01d2c979d4050a2f6e357b2cbe518c3adf816cb08c5b3116318b9cc92328213bb923ea1a3ce9bc46093ffec03912b1e7eda679287fd65419e47d337ca0bb8c EC_PARAMS: 06082a8648ce3d030107 label: Public key for Key Management ID: 03 Usage: encrypt, verify cd@cd-ubuntuvm: ziti-tunnel enroll -j \"${HSM_DEST}/${RSA_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID1}&pin=${HSM_PIN}\" -v DEBU[0000] jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjU1NjE3OSwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6Ijk5NjVlZmQzLTliMjItNDk3ZS04NDdiLTM1NWI3MjE1NTZjMyIsInN1YiI6Ijc2ODc3NzE3LTliY2UtNGYzNC1hZTdhLTJjZTMxM2I4MjY3YSJ9.ohrYUZQK5xum-70AYARu8hYYxhvA9Cm2rEln6jVp8VDvMLRuIQi9bXNO1e2NQtkZLGzo3akg4Brx_QxM-9SIRKdBDYzgaN_otpV6y9XAQjVlarVvtA1bBA9OfQU1SyVGNkkaA2l660cY5gfsGb5TqBQt6wQ7KvMfzZvPhXFdQAMoXW-O2OaRh3jJGPne29-Hoz_thObv5PMTVlCGpzO6tKKfPnoV9p8HchjLHMMybEZO_xITyY_6UmkOPpeSJHdjWxJdkXu0xT8wC9PzAXK2xYYwgmW4yA8ygz2RJP6gXYd5maD-f1jgh87ELeN5dG2ksuy5Fh3_kyFAGg1X7dSnfmXSA0fWH-YPK54aSJe2fcCIt41O9pnqwepPT_7nCB4wSxVhuIugUBh_wYeJzXKI8tVnyv8nLyWhYqMwKRqTtiJM7EtxpBUPD6E35x3d4bw_fkVJ5z36NOIaGRmqhltPIsYMaFDwIE-nUU714Ra-cf8xN9lHuNoi_4Ehf8sR2YwLTsk7mJ9TKZkhLIj2KgwjL2KNCoM9n6MQtJJMq3Ae6H_xVxi2-DA_9zkbusdNi2j11OoIAtBGJQ4ONC5ekRsp_bTbb9GAxF-fO8oAQeFUXWyCpywRV8gT3G4huAlcofZTDnMtcyVvTJbvs8zYRtBM9jCKpUOmHuzb4FefgU-6kP0 INFO[0000] using engine : pkcs11 DEBU[0000] loading key context=pkcs11 url=\"pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=01&pin=123456\" INFO[0000] using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (0) context=pkcs11 DEBU[0001] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0001] no cas provided in caPool. using system provided cas DEBU[0001] fetching certificates from server DEBU[0001] loading key context=pkcs11 url=\"pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=01&pin=123456\" INFO[0001] using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so context=pkcs11 WARN[0002] slot not specified, using first slot reported by the driver (0) context=pkcs11 DEBU[0002] found signing mechanism context=pkcs11 sign mechanism=0 enrolled successfully. identity file written to: /path/to/yubico-piv-tool-2.0.0/yubikey_demo/yubikey_demo01_rsa.jsoncd@cd-ubuntuvm: ziti-tunnel enroll -j \"${HSM_DEST}/${EC_ID}.jwt\" -k \"pkcs11://${PKCS11_MODULE}?id=${HSM_ID2}&pin=${HSM_PIN}\" -v DEBU[0000] jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjU1NjE4MSwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6IjQwYTg1NmMxLWFiZmItNDQ4ZS1hN2E3LWE3YjZkMzVmYWU4OSIsInN1YiI6ImJkZDE4ZTU4LWU0NzQtNGVkMy05OGViLWM2OGVkOTYzNzdiZSJ9.o5hGXqZXWUuj-zkg-Xd335AbZUe9zNtvQmhE4cNFZNw40eRXNTBeFntLWjWv7-41AtsHbPwmQgWQfDdHS8JuLbhLS-8ZNSL3ZThBwnTiKtgYQvg_aArcu1FbPiw3jdiiHqXu0JoIToCEFX4kMjAJIZlzRi05J0d5w6Wvvjy3V7SqT_8viLla6l3PXsa1_xnHCc89HebuKB_qYds-XO2JvXTOFP0A3dSe6UgierjrTPvRxLMbf8TIfSOFtAc6bbSy17H8S0XrNiL-1bA9Ja9KKpB_ynGTygpM3h1vXda0niJN-_TpPdTX9kFEXOn-DpvAGKW8X6ggPlnpF7Rmfx9AEarA9ft-nRjx4Z4vyoAlukSc7LfnjAqTg9CCsN0-hKB1d1PnAOuWfHP5IZ2w1zibcUvdRQMoW2Twk_P75MP8rjr19VtZu5bDweZjP10-eHt3_QYeujaylBfb7VkJuRtSyh6IeWAb-IlIaJx7hzjGqssqNPn0vqVdf43Sc0h-PJcVTOkNPpcBIbxHPL5IVyujCWUSj4NUSgVh72uQIKjxC-WrkT8i-hEnGbJRYUL2NDcS190yt21AJAAkDPBTiFA_LR0aR7lEPzQV-lsjJzjmta7V460OKATsU8oo82_S8dVv8oYndk2kRboVsCWvR7_6H95CEnmRjAfI0Emxwkg1raA INFO[0000] using engine : pkcs11 DEBU[0000] loading key context=pkcs11 url=\"pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=03&pin=123456\" INFO[0000] using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so context=pkcs11 WARN[0000] slot not specified, using first slot reported by the driver (0) context=pkcs11 DEBU[0001] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0001] EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> context=pkcs11 DEBU[0001] no cas provided in caPool. using system provided cas DEBU[0001] fetching certificates from server DEBU[0001] loading key context=pkcs11 url=\"pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=03&pin=123456\" INFO[0001] using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so context=pkcs11 WARN[0001] slot not specified, using first slot reported by the driver (0) context=pkcs11 DEBU[0001] found signing mechanism context=pkcs11 sign mechanism=0 DEBU[0001] EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> context=pkcs11 enrolled successfully. identity file written to: /path/to/yubico-piv-tool-2.0.0/yubikey_demo/yubikey_demo03_ec.jsoncd@cd-ubuntuvm: cd@cd-ubuntuvm: # if you only have a single edge router this command will work without the need for copy/paste cd@cd-ubuntuvm: EDGE_ROUTER_ID=$(ziti edge list edge-routers | cut -d \" \" -f2) # IF the above command doesn't work - run this command and get the id from the first edge-router. # ziti edge list edge-routers # then use the id returned from the above command and put it into a variable for use in a momment # EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 ziti edge delete config wttrconfig ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will cd@cd-ubuntuvm: cd@cd-ubuntuvm: # IF the above command doesn't work - run this command and get the id from the first edge-router. cd@cd-ubuntuvm: # ziti edge list edge-routers cd@cd-ubuntuvm: cd@cd-ubuntuvm: # then use the id returned from the above command and put it into a variable for use in a momment cd@cd-ubuntuvm: # EDGE_ROUTER_ID={insert the 'id' from above - example: 64d4967b-5474-4f06-8548-5700ed7bfa80} cd@cd-ubuntuvm: cd@cd-ubuntuvm: # remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 cd@cd-ubuntuvm: ziti edge delete config wttrconfig ziti edge delete service wttr.ziti ziti edge create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig # start one or both proxies ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & cd@cd-ubuntuvm: ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" 4ff768fa-0e7e-4b4d-ab4e-5c5aec5bd28d cd@cd-ubuntuvm: cd@cd-ubuntuvm: # recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will cd@cd-ubuntuvm: # send a request to wttr.in to retreive a weather forecast cd@cd-ubuntuvm: ziti edge delete service wttr.ziti cd@cd-ubuntuvm: ziti edge create service wttr.ziti \"${EDGE_ROUTER_ID}\" tcp://wttr.in:80 --configs wttrconfig 1827c649-9ba6-4f5a-b122-a8cb9d4e4893 cd@cd-ubuntuvm: cd@cd-ubuntuvm: # start one or both proxies cd@cd-ubuntuvm: ziti-tunnel proxy -i \"${HSM_DEST}/${RSA_ID}.json\" wttr.ziti:8000 -v & [1] 5969 cd@cd-ubuntuvm: ziti-tunnel proxy -i \"${HSM_DEST}/${EC_ID}.json\" wttr.ziti:9000 -v & [2] 5970 cd@cd-ubuntuvm: [ 0.001] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.001] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.002] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=03&pin=123456]} loading key [ 0.002] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so [ 0.004] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11:///path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so?id=01&pin=123456]} loading key [ 0.004] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: /path/to/yubico-piv-tool-2.0.0/ykcs11/.libs/libykcs11.so [ 0.085] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (0) [ 1.793] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 1.793] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.loadECDSApub [pkcs11]: EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> [ 1.793] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 1.912] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[426a9b25-5f9c-4d3d-9319-30096cb584fc] id=[30b4cc4a-1e71-4e34-971c-bd5bead0477b]} Got api session: {30b4cc4a-1e71-4e34-971c-bd5bead0477b 426a9b25-5f9c-4d3d-9319-30096cb584fc} [ 1.912] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 426a9b25-5f9c-4d3d-9319-30096cb584fc [ 1.956] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 426a9b25-5f9c-4d3d-9319-30096cb584fc [ 2.000] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 2.000] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 2.000] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[1827c649-9ba6-4f5a-b122-a8cb9d4e4893]} requesting session [ 2.033] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {id=[ee783e84-c888-4912-ba1b-b79334590d3e] service=[wttr.ziti]} acquired network session [ 2.034] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 2.034] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 2.034] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:9000]} service is listening [ 2.038] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (0) [ 3.863] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 3.864] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 4.099] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[a2d721d4-4b4a-466f-b310-b7eabd539e75] id=[deaf5b97-e467-431a-9f16-4546e4ef42fc]} Got api session: {deaf5b97-e467-431a-9f16-4546e4ef42fc a2d721d4-4b4a-466f-b310-b7eabd539e75} [ 4.099] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token a2d721d4-4b4a-466f-b310-b7eabd539e75 [ 4.146] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token a2d721d4-4b4a-466f-b310-b7eabd539e75 [ 4.189] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 4.189] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 4.189] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 4.189] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 4.189] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[1827c649-9ba6-4f5a-b122-a8cb9d4e4893]} requesting session [ 4.222] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[a53212ef-404e-4528-9d36-02852db9c595]} acquired network session [ 4.222] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:8000]} service is listening cd@cd-ubuntuvm: cd@cd-ubuntuvm: # use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network cd@cd-ubuntuvm: curl -H \"Host: wttr.in\" http://localhost:8000 [ 12.111] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started [ 12.315] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 12.315] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 12.316] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 12.316] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 12.316] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 12.316] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 12.316] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{oEzq}]: started [ 12.316] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{oEzq}]: started [ 12.557] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{oEzq}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 12.557] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 12.557] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:41838] src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel started [ 12.558] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {connId=[1] type=[EdgeDataType] chSeq=[-1] edgeSeq=[1]} writing 71 bytes [ 12.558] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8852 bytes [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes Weather report: Laurelton, United States Overcast .--. 14..24 F .-( ).  13 mph (___.__)__) 9 mi 0.0 in   Fri 14 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Sunny  \\ / Clear  \\ / Clear   _ /\"\".-. 6..19 F  .-. 8..21 F  .-. 8..19 F  .-. 3..14 F   \\_( ).  11-13 mph   ( )   11-13 mph   ( )   11-13 mph   ( )   8-13 mph   /(___(__) 5 mi  `- 6 mi  `- 6 mi  `- 6 mi   0.0 in | 0%  / \\ 0.0 in | 0%  / \\ 0.0 in | 0%  / \\ 0.0 in | 0%     Sat 15 Feb   Morning  Noon  Evening  Night    \\ / Sunny  \\ / Partly cloudy  \\ / Partly cloudy  \\ / Partly cloudy   .-. 14..17 F  _ /\"\".-. 17..24 F  _ /\"\".-. 21..30 F  _ /\"\".-. 17..24 F    ( )   3 mph  \\_( ).  6-8 mph  \\_( ).  9-14 mph  \\_( ).  8-14 mph   `- 6 mi  /(___(__) 6 mi  /(___(__) 6 mi  /(___(__) 6 mi   / \\ 0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%     Sun 16 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Partly cloudy  Overcast  Overcast   _ /\"\".-. 24..30 F  _ /\"\".-. 35..39 F  .--. 37..39 F  .--. 32..33 F   \\_( ).  4-7 mph  \\_( ).  7-8 mph  .-( ).  6-9 mph  .-( ).  3-8 mph   /(___(__) 6 mi  /(___(__) 6 mi  (___.__)__) 6 mi  (___.__)__) 6 mi   0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%   Follow @igor_chubin for wttr.in updates [ 12.735] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-remote=[wttr.ziti] src-remote=[127.0.0.1:41838] src-local=[127.0.0.1:8000] dst-local=[:1]} stopping pipe [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 12.735] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 12.736] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 12.736] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end cd@cd-ubuntuvm: [ 13.736] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 13.736] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 13.736] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-remote=[127.0.0.1:41838] src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:8000]} stopping pipe [ 13.736] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:41838] src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel closed: 71 bytes sent; 8852 bytes received cd@cd-ubuntuvm: cd@cd-ubuntuvm: curl -H \"Host: wttr.in\" http://localhost:9000 [ 17.991] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started [ 18.099] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 18.099] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 18.100] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 18.100] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 18.100] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 18.100] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 18.100] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{Jn2J}]: started [ 18.100] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{Jn2J}]: started [ 18.211] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{Jn2J}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 18.211] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 18.211] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {dst-remote=[wttr.ziti] src-remote=[127.0.0.1:57980] src-local=[127.0.0.1:9000] dst-local=[:1]} tunnel started [ 18.211] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {connId=[1] type=[EdgeDataType] chSeq=[-1] edgeSeq=[1]} writing 71 bytes [ 18.211] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8852 bytes [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes Weather report: Laurelton, United States Overcast .--. 14..24 F .-( ).  13 mph (___.__)__) 9 mi 0.0 in   Fri 14 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Sunny  \\ / Clear  \\ / Clear   _ /\"\".-. 6..19 F  .-. 8..21 F  .-. 8..19 F  .-. 3..14 F   \\_( ).  11-13 mph   ( )   11-13 mph   ( )   11-13 mph   ( )   8-13 mph   /(___(__) 5 mi  `- 6 mi  `- 6 mi  `- 6 mi   0.0 in | 0%  / \\ 0.0 in | 0%  / \\ 0.0 in | 0%  / \\ 0.0 in | 0%     Sat 15 Feb   Morning  Noon  Evening  Night    \\ / Sunny  \\ / Partly cloudy  \\ / Partly cloudy  \\ / Partly cloudy   .-. 14..17 F  _ /\"\".-. 17..24 F  _ /\"\".-. 21..30 F  _ /\"\".-. 17..24 F    ( )   3 mph  \\_( ).  6-8 mph  \\_( ).  9-14 mph  \\_( ).  8-14 mph   `- 6 mi  /(___(__) 6 mi  /(___(__) 6 mi  /(___(__) 6 mi   / \\ 0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%     Sun 16 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Partly cloudy  Overcast  Overcast   _ /\"\".-. 24..30 F  _ /\"\".-. 35..39 F  .--. 37..39 F  .--. 32..33 F   \\_( ).  4-7 mph  \\_( ).  7-8 mph  .-( ).  6-9 mph  .-( ).  3-8 mph   /(___(__) 6 mi  /(___(__) 6 mi  (___.__)__) 6 mi  (___.__)__) 6 mi   0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%   Follow @igor_chubin for wttr.in updates [ 18.379] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:57980] src-local=[127.0.0.1:9000]} stopping pipe [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 18.379] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end cd@cd-ubuntuvm: [ 19.382] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 19.382] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 19.382] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-remote=[127.0.0.1:57980] src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:9000]} stopping pipe [ 19.383] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:57980] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel closed: 71 bytes sent; 8852 bytes received cd@cd-ubuntuvm: killall ziti-tunnel [ 25.856] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 25.856] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 25.856] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 25.856] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal terminated [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 cd@cd-ubuntuvm: [ 25.856] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 25.856] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 25.856] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 25.856] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor [ 25.856] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM the name of the ziti controller you're logging into c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET ZITI_CTRL=local-edge-controller c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM the location of the certificate(s) to use to validate the controller c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET ZITI_CTRL_CERT=c:\\path\\to\\controller.cert c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET ZITI_USER=myUserName c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET ZITI_PWD=myPassword c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM a name for the configuration c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_NAME=yubikey_windemo c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_ROOT=c:\\path\\to\\yubico-piv-tool-2.0.0 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM path to the pkcs11 library c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET PATH=%PATH%;%HSM_ROOT%\\bin c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET PKCS11_MODULE=%HSM_ROOT%\\bin\\libykcs11-1.dll c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM the id of the key - you probably want to leave these alone unless you know better c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_ID1=01 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_ID2=03 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET RSA_ID=%HSM_NAME%%HSM_ID1%_rsa c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET EC_ID=%HSM_NAME%%HSM_ID2%_ec c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM the pins used when accessing the pkcs11 api c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_SOPIN=010203040506070801020304050607080102030405060708 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_PIN=123456 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_DEST=%HSM_ROOT%\\%HSM_NAME% c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_LABEL=%HSM_NAME%-label c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET HSM_TOKENS_DIR=%HSM_DEST%\\tokens\\ c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM make an alias for ease c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>doskey p=\"c:\\Program Files\\OpenSC Project\\OpenSC\\tools\\pkcs11-tool.exe\" --module %PKCS11_MODULE% $* c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>cd /d %HSM_ROOT% c:\\path\\to\\yubico-piv-tool-2.0.0> c:\\path\\to\\yubico-piv-tool-2.0.0>rmdir /s /q %HSM_NAME% c:\\path\\to\\yubico-piv-tool-2.0.0>mkdir %HSM_NAME% c:\\path\\to\\yubico-piv-tool-2.0.0> c:\\path\\to\\yubico-piv-tool-2.0.0>cd /d %HSM_NAME% c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge login %ZITI_CTRL%:1280 -u %ZITI_USER% -p %ZITI_PWD% -c %ZITI_CTRL_CERT% Token: 2e4b9d55-fe89-4e35-8101-7d8a5f492b8b c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM create a new identity and output the jwt to a known location c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge create identity device \"%RSA_ID%\" -o \"%HSM_DEST%\\%RSA_ID%.jwt\" 43b76397-c65e-43a9-a326-b58f83cacfea Enrollment expires at 2020-02-24T14:47:02.783676578Z c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM create a second new identity and output the jwt to a known location c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge create identity device \"%EC_ID%\" -o \"%HSM_DEST%\\%EC_ID%.jwt\" fa116b87-d322-4058-a8c1-d41f21a9e051 Enrollment expires at 2020-02-24T14:47:03.521726623Z c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>p --init-token --label \"ziti-test-token\" --so-pin %HSM_SOPIN% Using slot 0 with a present token (0x0) Token successfully initialized c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM create a couple of keys - one rsa and one ec c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>p -k --key-type rsa:2048 --usage-sign --usage-decrypt --login --id %HSM_ID1% --login-type so --so-pin %HSM_SOPIN% --label defaultkey Using slot 0 with a present token (0x0) Key pair generated: Private Key Object; RSA label: Private key for PIV Authentication ID: 01 Usage: decrypt, sign Access: sensitive, always sensitive, never extractable, local Public Key Object; RSA 2048 bits label: Public key for PIV Authentication ID: 01 Usage: encrypt, verify Access: local c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>p -k --key-type EC:prime256v1 --usage-sign --usage-decrypt --login --id %HSM_ID2% --login-type so --so-pin %HSM_SOPIN% --label defaultkey Using slot 0 with a present token (0x0) Key pair generated: Private Key Object; EC label: Private key for Key Management ID: 03 Usage: decrypt, sign Access: sensitive, always sensitive, never extractable, local Public Key Object; EC EC_POINT 256 bits EC_POINT: 044104c5f6b528121fbe67e44dc2f966a2df9df97d5e712e40fdf6df74ba8c166d069d0eee65886c115034821b3e3c3c890e910ffe05efc70d281e531ae8073915f579 EC_PARAMS: 06082a8648ce3d030107 label: Public key for Key Management ID: 03 Usage: encrypt, verify Access: local c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti-tunnel enroll -j \"%HSM_DEST%\\%RSA_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID1%&pin=%HSM_PIN%\" -v time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjU1NTYyMiwiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6ImYwYjIxZjQ4LTk3N2QtNDVlZi04ZDZlLWY5YzllMzlkYTg1YSIsInN1YiI6IjQzYjc2Mzk3LWM2NWUtNDNhOS1hMzI2LWI1OGY4M2NhY2ZlYSJ9.lAfmkZb_3-qPtW4hWaaHsL_7rZiHlN3LKGIrudX4K91idw5C-AdcjT-smbfSlDBqmZElU0iomrmT4TJ3SbGM9yRhrnRZBgsbC76dKO6sbNuCEGLeMJ_pJFGo7ZZC32wLm2HsvCXszwjMXOrr1ndvWUKs3KkUhvmbBEIA4x566McsngeZ5B4ILso4BmL4KJcef-n-PuI14V42n7uzOu_KZomEGSNZ34LCg0cbWcsUmoeV8d3Vgb3xSR16wyyl7tC_pGvH1qPvaWmNUQ9BWk1j730C6RXLHZ3zECOUXqIjYTOaXkoDEpuXceNF5gNm9Cx76UwpKJlSEyD_LFbkULJL4_zmKy9w9JreSUh6cnkPW7ltXluEt-Wy1VckkwOPUCRXCQ_AuxvClhOPUW_Y-PW8Qbooou7eo8v-ZPAuFqx04_DkPdhMPn2h6CyZiqEM5ZqN_ln-Q6BAUgpBHmAFUuPDnCXk0R1l74Yc23z55hrfFreR9-t4BGl6ZBiV9oAa6kz4-8MTkg_osGJOAn3S0T_mFORCES68dppVAF9Lv8kaFkZsJE3pyQeApyYqtIZWZUUiQH4S3ssFfwuoy9KmP9lvSo4Ampl7whygx6B6nf5EiSvkQyvNPSW1L5VQeI3eShQbrUHVnrBMY2BQHa86Wqz6ICdSLQHW1P_Z6yX71HKa06A\" time=\"2020-02-14T09:47:46-05:00\" level=info msg=\"using engine : pkcs11\\n\" time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=01&pin=123456\" time=\"2020-02-14T09:47:46-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\yubico-piv-tool-2.0.0\\\\bin\\\\libykcs11-1.dll\" context=pkcs11 time=\"2020-02-14T09:47:46-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (0)\" context=pkcs11 time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"no cas provided in caPool. using system provided cas\" time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"fetching certificates from server\" time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=01&pin=123456\" time=\"2020-02-14T09:47:46-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\yubico-piv-tool-2.0.0\\\\bin\\\\libykcs11-1.dll\" context=pkcs11 time=\"2020-02-14T09:47:46-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (0)\" context=pkcs11 time=\"2020-02-14T09:47:46-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 enrolled successfully. identity file written to: c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo\\yubikey_windemo01_rsa.json c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti-tunnel enroll -j \"%HSM_DEST%\\%EC_ID%.jwt\" -k \"pkcs11://%PKCS11_MODULE%?id=%HSM_ID2%&pin=%HSM_PIN%\" -v time=\"2020-02-14T09:47:47-05:00\" level=debug msg=\"jwt to parse: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbSI6Im90dCIsImV4cCI6MTU4MjU1NTYyMywiaXNzIjoiaHR0cHM6Ly9sb2NhbC1lZGdlLWNvbnRyb2xsZXI6MTI4MCIsImp0aSI6ImY1NzVkZTI0LTcyYzctNDcxZS1hMzI0LTUyMjE3ZWFlYmExNCIsInN1YiI6ImZhMTE2Yjg3LWQzMjItNDA1OC1hOGMxLWQ0MWYyMWE5ZTA1MSJ9.cMyzS7o4ou2XUN6d3C-fx6i7sleIZO5b_LeqOxBNkAZO6l7JFIAp54ak8TUYD-chsVnSZ-bYPiuO-lbPIR2UrZvN6SshOowiQpAKQPggL2y0UZJAqzRoxfzlkjBZXi5BjRSTGTW3nRd9y40AwR_aAkOr4IztYbREGBYvfTK4QX-NSVvSoGVCiBeKFC6PO_8nuAUxMgL_ODVpPVA1ThO5l6Jzut_N5LgysaxTjp8WWsAIvUIbnIxJ7y_hTvmKFQ9hbLuTLaWZ091AA-469dxzbMzQVe_xDSwpQDGfYgRm02_uRlKUlm_w_sPdytaNb54u0I0-la83r31S8ugyGz3xMD-xLDHVKwxZ7dUArQf3oKzGZNhCc6MMJQBI81jbHaeSCNlpDJugYDDG0bx1E87cU7Nt88h-jaLOwEOqozsG_4myhoFaMRGx-unNP8Lr-zlPtU3AGMTu21AvCq4CCg0HYLdKVjCkQ3m6N29wOrMgF_3G_hdvTLDTeHY2wKnJIBHg3lg106a7J6WtiM9CyS_N_01kCtwFWK49662GQPv6_IVb6eKokhtcA4-2E1F6H8v5BCUljzfjpfQ4EQds7uDtQSL3i3muBLuXkLUW86H98q8XVnQZms_41T2n6MWmo5smOYrs4--rM1R-in3lmKymd8nmmN-L2GuJF5zsRaiq0r4\" time=\"2020-02-14T09:47:47-05:00\" level=info msg=\"using engine : pkcs11\\n\" time=\"2020-02-14T09:47:47-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=03&pin=123456\" time=\"2020-02-14T09:47:47-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\yubico-piv-tool-2.0.0\\\\bin\\\\libykcs11-1.dll\" context=pkcs11 time=\"2020-02-14T09:47:47-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (0)\" context=pkcs11 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil>\" context=pkcs11 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"no cas provided in caPool. using system provided cas\" time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"fetching certificates from server\" time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"loading key\" context=pkcs11 url=\"pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=03&pin=123456\" time=\"2020-02-14T09:47:48-05:00\" level=info msg=\"using driver: c:\\\\path\\\\to\\\\yubico-piv-tool-2.0.0\\\\bin\\\\libykcs11-1.dll\" context=pkcs11 time=\"2020-02-14T09:47:48-05:00\" level=warning msg=\"slot not specified, using first slot reported by the driver (0)\" context=pkcs11 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"found signing mechanism\" context=pkcs11 sign mechanism=0 time=\"2020-02-14T09:47:48-05:00\" level=debug msg=\"EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil>\" context=pkcs11 enrolled successfully. identity file written to: c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo\\yubikey_windemo03_ec.json c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM these two commands can't be copied and pasted - you need to get the result of the first command and use it in the next c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM run this command and get the id from the first edge-router. c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge list edge-routers id: 0c2c2049-3577-479c-aa09-625fa0e15d31 name: local-edge-router role attributes: {} c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM use the id returned from the above command and put it into a variable for use in a momment c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>SET EDGE_ROUTER_ID=0c2c2049-3577-479c-aa09-625fa0e15d31 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM remove/recreate the config - here we'll be instructing the tunneler to listen on localhost and port 9000 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge delete config wttrconfig c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge create config wttrconfig ziti-tunneler-client.v1 \"{ \\\"hostname\\\" : \\\"localhost\\\", \\\"port\\\" : 9000 }\" b2c7af06-072d-4ff2-9f73-8d1456a16d5a c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM recreate the service with the EDGE_ROUTER_ID from above. Here we are adding a ziti service that will c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM send a request to wttr.in to retreive a weather forecast c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge delete service wttr.ziti c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>ziti edge create service wttr.ziti \"%EDGE_ROUTER_ID%\" tcp://wttr.in:80 --configs wttrconfig 5a11bfce-b716-4d7a-944b-ea72e6225549 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM start one or both proxies - use ctrl-break or ctrl-pause to terminate these processes c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>start /b ziti-tunnel proxy -i \"%HSM_DEST%/%RSA_ID%.json\" wttr.ziti:8000 -v c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>start /b ziti-tunnel proxy -i \"%HSM_DEST%/%EC_ID%.json\" wttr.ziti:9000 -v c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM[ 0.013] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.013] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=01&pin=123456]} loading key [ 0.014] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: c:\\path\\to\\yubico-piv-tool-2.0.0\\bin\\libykcs11-1.dll [ 0.012] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Start: starting proxy interceptor [ 0.012] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {url=[pkcs11://c:%5Cpath%5Cto%5Cyubico-piv-tool-2.0.0%5Cbin%5Clibykcs11-1.dll?id=03&pin=123456]} loading key [ 0.013] INFO github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: using driver: c:\\path\\to\\yubico-piv-tool-2.0.0\\bin\\libykcs11-1.dll [ 0.025] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (0) [ 0.195] WARNING github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: slot not specified, using first slot reported by the driver (0) [ 0.688] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.689] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.699] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.(*engine).LoadKey [pkcs11]: {sign mechanism=[0]} found signing mechanism [ 0.699] DEBUG github.com/netfoundry/ziti-foundation/identity/engines/pkcs11.loadECDSApub [pkcs11]: EC oid[1.2.840.10045.3.1.7], rest: [], err: <nil> [ 0.700] INFO github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: attempting to authenticate [ 0.812] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[3b8bbb76-5984-495e-94cd-9752fe6a4d61] id=[55a4e9aa-eb78-4a19-a685-92aa19fd7177]} Got api session: {55a4e9aa-eb78-4a19-a685-92aa19fd7177 3b8bbb76-5984-495e-94cd-9752fe6a4d61} [ 0.813] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 3b8bbb76-5984-495e-94cd-9752fe6a4d61 [ 0.866] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 3b8bbb76-5984-495e-94cd-9752fe6a4d61 [ 0.920] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 0.936] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 0.939] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[5a11bfce-b716-4d7a-944b-ea72e6225549]} requesting session [ 0.960] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).Authenticate: {token=[79e3ef58-d712-4821-9f8b-3e2a947bd7b5] id=[4af36742-61ac-49cc-8935-08a8ab14d6c6]} Got api session: {4af36742-61ac-49cc-8935-08a8ab14d6c6 79e3ef58-d712-4821-9f8b-3e2a947bd7b5} [ 0.975] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 79e3ef58-d712-4821-9f8b-3e2a947bd7b5 [ 0.983] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[9eb75dd2-88df-4b6c-8a1e-f9d1a6e15adc]} acquired network session [ 0.984] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 1.002] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:9000]} service is listening [ 1.003] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 1.023] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getServices: using api session token 79e3ef58-d712-4821-9f8b-3e2a947bd7b5 [ 1.071] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.ziti [ 1.071] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: requesting session from https://local-edge-controller:1280/sessions [ 1.072] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti.(*contextImpl).getSession: {service_id=[5a11bfce-b716-4d7a-944b-ea72e6225549]} requesting session [ 1.102] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[wttr.ziti] id=[5589a3dc-0301-4563-bf65-cf1143f9db3b]} acquired network session [ 1.102] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: starting tunnel for newly available service netcat7256 [ 1.103] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.interceptor.Intercept: {service=[netcat7256]} service netcat7256 was not specified at initialization. not intercepting [ 1.104] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).handleTCP: {service=[wttr.ziti] addr=[0.0.0.0:8000]} service is listening use a browser - or curl to verify the ziti tunneler is listening locally and the traffic has flowed over the ziti network c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>curl -H \"Host: wttr.in\" http://localhost:8000 > \"%HSM_DEST%\\example_%RSA_ID%.txt\" [ 7.803] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 7.948] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 7.948] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 7.949] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 7.950] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 7.950] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 7.950] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{nJXo}]: started [ 7.951] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{nJXo}]: started [ 7.951] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 8.082] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{nJXo}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 8.082] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 8.083] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:52952]} tunnel started [ 8.084] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 8.085] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {edgeSeq=[1] connId=[1] type=[EdgeDataType] chSeq=[-1]} writing 71 bytes [ 8.252] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 8.252] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8852 bytes [ 8.255] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 100 8687 100 8687 0 0 18522 0 --:--:-- --:--:-- --:--:-- 18522 [ 8.269] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:52952] src-local=[127.0.0.1:8000]} stopping pipe [ 8.269] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 8.270] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 8.271] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 8.273] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>curl -H \"Host: wttr.in\" http://localhost:9000 > \"%HSM_DEST%\\example_%EC_ID%.txt\" [ 8.298] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: started % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0[ 8.379] DEBUG github.com/netfoundry/ziti-foundation/transport/tls.Dial: server provided [2] certificates [ 8.379] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: started [ 8.380] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).sendHello [u{classic}->i{}]: exited [ 8.381] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*classicDialer).Create [tls:local-edge-router:3022]: exited [ 8.381] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{oWqn}]: started [ 8.383] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).txer [ch{ziti-sdk}->u{classic}->i{oWqn}]: started [ 8.384] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxAddSinkEvent).Handle: {connId=[1]} Added sink to mux. Current sink count: 1 [ 8.385] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).AddMsgSink: {connId=[1]} added to msg mux [ 8.495] DEBUG github.com/netfoundry/ziti-foundation/channel2.(*channelImpl).rxer [ch{ziti-sdk}->u{classic}->i{oWqn}]: waiter found for message. type [60784], sequence [1], replyFor [1] [ 8.495] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Connect: {connId=[1]} connected [ 8.495] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:52954] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel started [ 8.496] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgChannel).WriteTraced: {connId=[1] type=[EdgeDataType] chSeq=[-1] edgeSeq=[1]} writing 71 bytes [ 8.496] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes [ 8.665] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgEvent).Handle: {seq=[1] connId=[1]} handling received EdgeDataType [ 8.666] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} got buffer from queue 8852 bytes [ 8.667] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} read buffer = 32768 bytes 100 8687 100 8687 0 0 23165 0 --:--:-- --:--:-- --:--:-- 24130 [ 8.674] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[127.0.0.1:52954] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} stopping pipe [ 8.674] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: begin [ 8.675] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*muxRemoveSinkEvent).Handle: {connId=[1]} Removed sink from mux. Current sink count: 0 [ 8.675] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/edge.(*MsgMux).RemoveMsgSinkById: {connId=[1]} removed from msg mux [ 8.676] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Close: {connId=[1]} close: end c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>[ 9.271] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 9.271] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 9.271] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:8000] dst-remote=[127.0.0.1:52952]} stopping pipe [ 9.271] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-local=[127.0.0.1:8000] dst-local=[:1] dst-remote=[wttr.ziti] src-remote=[127.0.0.1:52952]} tunnel closed: 71 bytes sent; 8852 bytes received [ 9.676] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} sequencer closed, closing connection [ 9.676] DEBUG github.com/netfoundry/ziti-sdk-golang/ziti/internal/edge_impl.(*edgeConn).Read: {connId=[1]} return EOF from closing/closed connection [ 9.676] INFO github.com/netfoundry/ziti-edge/tunnel.myCopy: {src-remote=[wttr.ziti] src-local=[:1] dst-local=[127.0.0.1:9000] dst-remote=[127.0.0.1:52954]} stopping pipe [ 9.677] INFO github.com/netfoundry/ziti-edge/tunnel.Run: {src-remote=[127.0.0.1:52954] src-local=[127.0.0.1:9000] dst-local=[:1] dst-remote=[wttr.ziti]} tunnel closed: 71 bytes sent; 8852 bytes received REM set the codepage for the cmd prompt so that the output looks nice c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>chcp 65001 Active code page: 65001 c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM show the results in the console c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>type \"%HSM_DEST%\\example_%RSA_ID%.txt\" Weather report: Laurelton, United States Overcast .--. 14..24 F .-( ).  13 mph (___.__)__) 9 mi 0.0 in   Fri 14 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Sunny  \\ / Clear  \\ / Clear   _ /\"\".-. 6..19 F  .-. 8..21 F  .-. 8..19 F  .-. 3..14 F   \\_( ).  11-13 mph   ( )   11-13 mph   ( )   11-13 mph   ( )   8-13 mph   /(___(__) 5 mi  `- 6 mi  `- 6 mi  `- 6 mi   0.0 in | 0%  / \\ 0.0 in | 0%  / \\ 0.0 in | 0%  / \\ 0.0 in | 0%     Sat 15 Feb   Morning  Noon  Evening  Night    \\ / Sunny  \\ / Partly cloudy  \\ / Partly cloudy  \\ / Partly cloudy   .-. 14..17 F  _ /\"\".-. 17..24 F  _ /\"\".-. 21..30 F  _ /\"\".-. 17..24 F    ( )   3 mph  \\_( ).  6-8 mph  \\_( ).  9-14 mph  \\_( ).  8-14 mph   `- 6 mi  /(___(__) 6 mi  /(___(__) 6 mi  /(___(__) 6 mi   / \\ 0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%     Sun 16 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Partly cloudy  Overcast  Overcast   _ /\"\".-. 24..30 F  _ /\"\".-. 35..39 F  .--. 37..39 F  .--. 32..33 F   \\_( ).  4-7 mph  \\_( ).  7-8 mph  .-( ).  6-9 mph  .-( ).  3-8 mph   /(___(__) 6 mi  /(___(__) 6 mi  (___.__)__) 6 mi  (___.__)__) 6 mi   0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%   Follow @igor_chubin for wttr.in updates c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>type \"%HSM_DEST%\\example_%EC_ID%.txt\" Weather report: Laurelton, United States Overcast .--. 14..24 F .-( ).  13 mph (___.__)__) 9 mi 0.0 in   Fri 14 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Sunny  \\ / Clear  \\ / Clear   _ /\"\".-. 6..19 F  .-. 8..21 F  .-. 8..19 F  .-. 3..14 F   \\_( ).  11-13 mph   ( )   11-13 mph   ( )   11-13 mph   ( )   8-13 mph   /(___(__) 5 mi  `- 6 mi  `- 6 mi  `- 6 mi   0.0 in | 0%  / \\ 0.0 in | 0%  / \\ 0.0 in | 0%  / \\ 0.0 in | 0%     Sat 15 Feb   Morning  Noon  Evening  Night    \\ / Sunny  \\ / Partly cloudy  \\ / Partly cloudy  \\ / Partly cloudy   .-. 14..17 F  _ /\"\".-. 17..24 F  _ /\"\".-. 21..30 F  _ /\"\".-. 17..24 F    ( )   3 mph  \\_( ).  6-8 mph  \\_( ).  9-14 mph  \\_( ).  8-14 mph   `- 6 mi  /(___(__) 6 mi  /(___(__) 6 mi  /(___(__) 6 mi   / \\ 0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%     Sun 16 Feb   Morning  Noon  Evening  Night    \\ / Partly cloudy  \\ / Partly cloudy  Overcast  Overcast   _ /\"\".-. 24..30 F  _ /\"\".-. 35..39 F  .--. 37..39 F  .--. 32..33 F   \\_( ).  4-7 mph  \\_( ).  7-8 mph  .-( ).  6-9 mph  .-( ).  3-8 mph   /(___(__) 6 mi  /(___(__) 6 mi  (___.__)__) 6 mi  (___.__)__) 6 mi   0.0 in | 0%  0.0 in | 0%  0.0 in | 0%  0.0 in | 0%   Follow @igor_chubin for wttr.in updates c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>REM ctrl-break or ctrl-pause to kill the tunnelers c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo> [ 39.022] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal interrupt [ 39.015] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal interrupt c:\\path\\to\\yubico-piv-tool-2.0.0\\yubikey_windemo>[ 39.023] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal interrupt [ 39.017] DEBUG github.com/netfoundry/ziti-edge/tunnel/intercept.ServicePoller: caught signal interrupt [ 39.025] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 39.018] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: wttr.ziti [ 39.025] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 39.019] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 39.026] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 39.020] INFO github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: stopping tunnel for unavailable service: netcat7256 [ 39.027] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 39.020] ERROR github.com/netfoundry/ziti-edge/tunnel/intercept.updateServices: failed to stop intercepting: StopIntercepting not implemented by proxy interceptor [ 39.028] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor [ 39.021] INFO github.com/netfoundry/ziti-edge/tunnel/intercept/proxy.(*interceptor).Stop: stopping proxy interceptor REM set the codepage for the cmd prompt so that the output looks nice"
  },
  "ziti/quickstarts/hsm-overview.html": {
    "href": "ziti/quickstarts/hsm-overview.html",
    "title": "Hardware Security Modules (HSM) - PKCS11 | Ziti",
    "keywords": "Hardware Security Modules (HSM) - PKCS11 A hardware security module (HSM) is a physical piece of equipment which is designed specifically to protect cryptographic keys and aid with cryptographical processing. HSMs are designed to manage sensitive information and are generally able to be connected and disconnected from a computer trying to use the HSM. Why an HSM Without a doubt the biggest benefit of an HSM is that it is a physical piece of hardware. This means that any cryptographic keys protecting data is stored in the HSM and those keys are able to be removed from any given device which had the HSM attached. Because these keys are not kept as files on a computer but are instead stored inside a physical piece of equipment attached to the computer it is more secure since there are no files for an attacker to find and copy. With an HSM you can be sure that they only computer with the relevant key is the one with the HSM attached to it. Another benefit of HSMs is that they are focused on security. The keys stored inside of many if not all HSMs are designed to not be able to be exported. This means that there's no chance for these keys to be extracted remotely and used outside of the HSM itself, further increasing the security of these important keys. Enabling a Ziti Endpoint Using an HSM Enabling a Ziti endpoint to utilize an HSM is straight forward but does require a bit of technical understanding. We have provided a couple of guides on how to enable an HSM with Ziti. The Ziti SDKs all interact with HSMs which support and provide a PKCS#11 library. PKCS#11 is a specification that outlines the programming interface software can use to interact with cryptographic hardware such as smart cards or HSMs. Quickstarts We have included a couple of quickstarts illustrating two different PKCS#11 drivers to help with understanding. You will want to go to the OpenSC Project as it is what provides the pkcs11-tool which is used to interact with the HSMs. The first quickstart is based on softhsm . This one focuses on software that provides an emulated HSM. This is useful for learning and understandin but it is not an actual HSM. Being software it doesn't have the important benefit of being a physical device but it does have one substantial advantage; it's entirely free. The second quickstart uses an actual physical device - a Yubico Yubikey. The specific key we used is a Yubikey 5 nfc ."
  },
  "ziti/quickstarts/kubernetes/README.html": {
    "href": "ziti/quickstarts/kubernetes/README.html",
    "title": "| Ziti",
    "keywords": "make a link to the ziti quickstart here mklink /j sidecar-tunnel c:\\git\\ziti\\quickstart\\kubernetes-sidecar-tunnel"
  },
  "ziti/quickstarts/network/aws-quickstart.html": {
    "href": "ziti/quickstarts/network/aws-quickstart.html",
    "title": "| Ziti",
    "keywords": "Ziti Edge Developer Edition has been replaced. See here for current deployment options."
  },
  "ziti/quickstarts/network/azure-quickstart.html": {
    "href": "ziti/quickstarts/network/azure-quickstart.html",
    "title": "| Ziti",
    "keywords": "Ziti Edge Developer Edition has been replaced. See here for current deployment options."
  },
  "ziti/quickstarts/network/common-quickstart.html": {
    "href": "ziti/quickstarts/network/common-quickstart.html",
    "title": "Obtain and Change the Default Password | Ziti",
    "keywords": "Obtain and Change the Default Password When first launched - the instance will deposit a file into the file system at $HOME/.config/ziti/ziti-cli.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti Controller by issuing this command: jq -r .password $HOME/.config/ziti/ziti-cli.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these commands: Note If you are not already, you will need to be logged in to use the ziti cli # load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Ziti Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Leave the enrollment type as \"One Time Token\" Click save To create a new identity using the CLI simply issue these commands: #creates a new user named \"NewUser\" ziti edge create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. The easiest way to enroll an identity is to use either the Ziti Desktop Edge/Ziti Mobile Edge for your operating system. Alternatively the ziti-tunneler for your operating system can be downloaded and used to enroll the identity. Download the ziti-tunneler for your operating system. Windows MacOS Linux iOS Android Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-tunneler enroll --jwt NewUser.jwt The enrollment process will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service Config via UI New Service Config via CLI On the left side nav bar, click \"Ziti Config\" In the top right corner of the screen click the \"plus\" image to add a new config Enter the name: eth0.ziti.config.ui In the \"Types\" box choose: \"ziti-tunneler-client.v1\" In the \"Hostname\" box enter: eth0.ziti.ui In the \"Port\" box enter: 80 Click save to save the config Note If you are not already, you will need to be logged in to use the ziti cli # load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert # create the config ziti edge create config eth0.ziti.config.cli ziti-tunneler-client.v1 '{ \"hostname\" : \"eth0.ziti.cli\", \"port\" : 80 }' New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the service, enter: eth0.ziti.svc.ui Under Configurations choose the ziti-tunneler-client.v1 config named: eth0.ziti.config.ui Click save To create a new service using the CLI simply issue these two commands: # create the service and refernce the cli config added earlier ziti edge create service ziti.eth0.svc.cli --configs ziti.eth0.config.cli New Terminator via UI New Terminator via CLI On the left side nav bar, click \"Edge Services\" On the top nav bar, click \"Terminators\" In the top right corner of the screen click the \"plus\" image to add a new terminator In the \"Service\" dropdown, choose: eth0.ziti.svc.ui In the \"Router\" dropdown, choose: ziti-er01 <- NOTE: a bug in the UI will make this show up 'empty' choose it anyway as shown: In the \"Address\" box enter: tcp:eth0.me:80 Click save To create a new service using the CLI simply issue these two commands: # create the service and refernce the cli config added earlier ziti edge create terminator eth0.ziti.svc.cli \"ziti-er01\" tcp:eth0.me:80 Create Policies Use policies to allow identities to access services allow identities to use edge routers allow services to use edge routers Warning The policies shown here are for demonstration purposes only. These policies will grant all identities access to all routers and all services. This is certainly not what you want in a production setup! Please read more about policies and experiment with different combinations to understand how best to apply policies in an actual network Read more about Policies here New Policies via UI New Policies via CLI New Edge Router Policy On the left side nav bar, click \"Ziti Policies\" It should already be selected, but if not, on the top nav bar, click \"Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy, enter: All Edge Routers Inside the \"Router Roles\" box, type #all and press the enter key. Make sure the #all tag gets applied. It should look like this: Inside the \"Identity Roles\" box, type #all and press the enter key. Make sure the #all tag gets applied. It should look like this: Leave the \"Semantics\" box as \"Has Any Role\" Click save New Service Policy On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Policies\" In the top right corner of the screen click the \"plus\" image to add a new Service Policy Choose a name for the Service Policy, enter: All Services - Dial In the \"Type\" dropdown, change select \"Dial\" Inside the \"Service Roles\" box, type #all and press the enter key. Make sure the #all tag gets applied. It should look like this: Inside the \"Identity Roles\" box, type #all and press the enter key. Make sure the #all tag gets applied. It should look like this: Leave the \"Semantics\" box as \"Has Any Role\" Click save New Service Edge Router Policy On the left side nav bar, click \"Ziti Policies\" On the top nav bar, click \"Service Edge Router Policies\" In the top right corner of the screen click the \"plus\" image to add a new Edge Router Policy Choose a name for the Edge Router Policy, enter: All Edge Routers All Services Inside the \"Router Roles\" box, type #all and press the enter key. Make sure the #all tag gets applied. It should look like this: Inside the \"Service Roles\" box, type #all and press the enter key. Make sure the #all tag gets applied. It should look like this: Leave the \"Semantics\" box as \"Has Any Role\" Click save To create some policies using the CLI issue the following commands: Note If you are not already, you will need to be logged in to use the ziti cli. # load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert # Create an edge router policy which allows all identities to use all edge routers ziti edge create edge-router-policy all-edge-routers-cli --edge-router-roles '#all' --identity-roles '#all' # Create a service policy which allows all identities to use all services ziti edge create service-policy all-services-dial-cli Dial --service-roles '#all' --identity-roles '#all' # Create a service edge router policy which allows all services to use all edge routers ziti edge create service-edge-router-policy all-edge-routers-all-services --edge-router-roles '#all' --service-roles '#all' Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. Windows MacOS Linux iOS Android The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt Ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory Run the ziti-tunnel in proxy mode. Choose the command based on how you created the service. Created Service via UI Created Service via CLi ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:1111 Navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your instance. Delivered to your machine safely and securely over your Ziti network."
  },
  "ziti/quickstarts/network/hosted.html": {
    "href": "ziti/quickstarts/network/hosted.html",
    "title": "Host OpenZiti Anywhere | Ziti",
    "keywords": "Host OpenZiti Anywhere You can absolutely choose to host your OpenZiti Network anywhere you like. It is not necessary for the server to be on the open internet. If it works better for you to deploy OpenZiti on your own network, great, do that. The only requirement to be aware of is that every piece of the a network will need to be able to communicate to the controller at least one edge router. If you have a server available on the open internet, or you will provision one for use with OpenZiti, that's the ideal scenario. With a zero trust overlay network provided by OpenZiti, you can rest assured that your traffic is safe even when using commodity internet. Furthermore, you do not need to worry about being on a network you trust, as all networks are considered untrustworthy, even your work/home network! Installation When starting out deploying a OpenZiti Network , we recommend you follow and use the expressInstall function provided by the OpenZiti project. Once you're familiar with the network and the configuration options available you'll be better equipped to make changes. Firewall The first issue you will need to deal with is opening some ports. A network will consist of at least one controller and at least one edge router. Both of these components will require ports to be open. For the controller you will need to open two ports through your firewall, one port for the REST API, and one the control plane. Edge routers will also require two ports open. One for the links created between routers to form the mesh network, and one port for incoming client connections. The ports you choose are not important but unless you change them these ports will default to the following: Controller REST API: 1280 (port 8441 used below) Management API: 6262 Edge Router Edge connections: 3022 (port 8442 used below) Fabric links: 10080 It would be reasonable to change all these ports to use ports 443 and 80 since those ports are almost always open outbound from all but the most strict networks. If you're going to be making connections from one of those networks, also verify that outbound access to these ports is available. Express Install With the firewall ports open you will now be able to source the script which provides the expressInstall function and execute it. You probably should consider DNS names before actually running the script. By default, the script will use the bash hostname function to determine a reasonable default for the PKI that will be generated as well as the configuration files that are output. The script allows you to configure these values and if you are deploying to a cloud provider (AWS, Azure, OCI, IBM, Digital Ocean, GCP, etc.) you will almost certainly want to use the public DNS name of your instance. You possibly want to override the IP address to use as well, but using DNS names is superior to using IP addresses in case your IP changes. The quickest and easiest thing to do, is simply find your external DNS name and set it into the EXTERNAL_DNS environment variable. For example: export EXTERNAL_DNS=\"ec2-18-100-100-100.us-east-2.compute.amazonaws.com\" Note Make sure you have jq installed on your machine. From ubuntu that would look like: sudo apt update && sudo apt install jq -y Once you do that, you'll be able to execute these commands just as shown to have your controller and first edge router configured and ready to turn on: export EXTERNAL_IP=\"$(curl -s eth0.me)\" export ZITI_EDGE_CONTROLLER_IP_OVERRIDE=\"${EXTERNAL_IP}\" export ZITI_EDGE_ROUTER_IP_OVERRIDE=\"${EXTERNAL_IP}\" export ZITI_EDGE_CONTROLLER_HOSTNAME=\"${EXTERNAL_DNS}\" export ZITI_EDGE_ROUTER_HOSTNAME=\"${EXTERNAL_DNS}\" export ZITI_EDGE_CONTROLLER_PORT=8441 export ZITI_EDGE_ROUTER_PORT=8442 # now download, source, and execute the expressInstall function source /dev/stdin <<< \"$(wget -qO- https://raw.githubusercontent.com/openziti/ziti/release-next/quickstart/docker/image/ziti-cli-functions.sh)\"; expressInstall Systemd If the operating system you are deploying on supports it, after the commands above are run there will two other useful functions defined in your shell which will allow you to generate a systemd file for the controller and the edge router. This is useful to make sure the controller can restart automatically should you shutdown/restart the server. To generate these files run: createControllerSystemdFile createRouterSystemdFile \"${ZITI_EDGE_ROUTER_RAWNAME}\" # example: ubuntu@ip-172-31-23-18:~$ createControllerSystemdFile Controller systemd file written to: /home/ubuntu/.ziti/quickstart/ip-172-31-23-18/ip-172-31-23-18-edge-controller.service ubuntu@ip-172-31-23-18:~$ createRouterSystemdFile \"${ZITI_EDGE_ROUTER_RAWNAME}\" Router systemd file written to: /home/ubuntu/.ziti/quickstart/ip-172-31-23-18/ip-172-31-23-18-edge-router.service ubuntu@ip-172-31-23-18:~$ After the files are generated, you can then install them for use by systemd by running: sudo cp \"${ZITI_HOME}/${ZITI_EDGE_CONTROLLER_RAWNAME}.service\" /etc/systemd/system/ziti-controller.service sudo cp \"${ZITI_HOME}/${ZITI_EDGE_ROUTER_RAWNAME}.service\" /etc/systemd/system/ziti-router.service sudo systemctl daemon-reload sudo systemctl start ziti-controller sudo systemctl start ziti-router Now, both the controller and the edge router will restart automatically! After a few seconds you can then run these commands and verify systemd has started the processes and see the status: sudo systemctl -q status ziti-controller --lines=0 --no-pager sudo systemctl -q status ziti-router --lines=0 --no-pager  ziti-controller.service - Ziti-Controller Loaded: loaded (/etc/systemd/system/ziti-controller.service; disabled; vendor preset: enabled) Active: active (running) since Thu 2021-11-11 19:05:46 UTC; 8s ago Main PID: 2375 (ziti-controller) Tasks: 7 (limit: 1154) Memory: 43.7M CGroup: /system.slice/ziti-controller.service 2375 /home/ubuntu/.ziti/quickstart/ip-10-0-0-1/ziti-bin/ziti-v0.22.11/ziti-controller run /home/ubuntu/.ziti/quickstart/ip-10-0-0-1/co ubuntu@ip-10-0-0-1:~$ sudo systemctl -q status ziti-router --lines=0 --no-pager  ziti-router.service - Ziti-Router for ip-10-0-0-1-edge-router Loaded: loaded (/etc/systemd/system/ziti-router.service; disabled; vendor preset: enabled) Active: active (running) since Thu 2021-11-11 19:05:47 UTC; 8s ago Main PID: 2385 (ziti-router) Tasks: 6 (limit: 1154) Memory: 231.4M CGroup: /system.slice/ziti-router.service 2385 /home/ubuntu/.ziti/quickstart/ip-10-0-0-1/ziti-bin/ziti-v0.22.11/ziti-router run /home/ubuntu/.ziti/quickstart/ip-10-0-0-1/ip-10 Adding Environment Variables Back to the Shell If you log out and log back in again you can source the '.env' file located at: . ~/.ziti/quickstart/$(hostname)/$(hostname).env . Below is an example of logging in, not having ZITI_HOME set, sourcing the .env file and then showing ZITI_HOME set: Last login: Thu May 20 11:36:25 2021 from 67.246.244.61 ubuntu@ip-10-0-0-1:~$ echo $ZITI_HOME ubuntu@ip-10-0-0-1:~$ . ~/.ziti/quickstart/$(hostname)/$(hostname).env adding /home/ubuntu/.ziti/quickstart/ip-10-0-0-1/ziti-bin/ziti-v0.20.2 to the path ubuntu@ip-10-0-0-1:~$ echo $ZITI_HOME /home/ubuntu/.ziti/quickstart/ip-10-0-0-1 Install Ziti Admin Console (ZAC) [Optional] Once you have the network up and running, if you want to install the UI management console, the ZAC, follow along with the installation guide Using the Overlay Now you have your zero trust overlay network in place, you probably want to try it out. Head on over to the services quickstart and start the journey to understanding how to use OpenZiti."
  },
  "ziti/quickstarts/network/local-docker-compose.html": {
    "href": "ziti/quickstarts/network/local-docker-compose.html",
    "title": "Local - Docker Compose | Ziti",
    "keywords": "Local - Docker Compose If you are not familiar with it, Docker Compose is a tool for defining and running multi-container Docker applications. It makes deploying multiple containers easy by using a declarative format defined via yaml. Ziti provides a Docker compose file that will get you up and running very quickly assuming you have both docker and docker-compose already installed in your system. Preparation - Required Files First, grab the compose file from the ziti repository . Using curl that would look like this: curl -o docker-compose.yaml https://raw.githubusercontent.com/openziti/ziti/release-next/quickstart/docker/docker-compose.yml Next, grab the default environment file or just make a file in this folder that looks like this: curl -o .env https://raw.githubusercontent.com/openziti/ziti/release-next/quickstart/docker/.env or cat > .env <<DEFAULT_ENV_FILE ZITI_IMAGE=openziti/quickstart ZITI_VERSION=latest ZITI_CONTROLLER_RAWNAME=ziti-controller ZITI_EDGE_CONTROLLER_RAWNAME=ziti-edge-controller DEFAULT_ENV_FILE Running via Docker Compose Once the compose file is downloaded and the .env file exists, you'll be able to start this network using docker-compose just like you can with any other compose file: docker-compose up Note Docker compose will name your containers based on the folder you were in when you started them. For me, I've made a folder named docker so all my containers start with docker_ . You can influence how this works by adding --project-name docker (or whatever name you like) to your docker-compose up/down commands docker-compose --project-name docker up Stopping the Network This docker-compose file will generate a volume mount as well as a two docker networks. When you issue docker-compose --project-name docker down the volume mapping will not be removed. If you wish to remove the volume, you'll need to specify the -v flag to the docker-compose command. Leave the -v off your command if you want to just stop the containers without losing the controller database and PKI. Deployment Diagram This docker-compose file will create quite a few containers on your behalf. Here is an overview of the network that will get created: As you can see there's a fair bit going on in there, let's break it down. The first thing to notice is that the entire image is within the scope of a Docker network. You'll see with this compose file there are three pieces of the overlay which span the Docker network: the controller, an edge router, and a websocket-based edge router. Deployment Simplified The stock docker-compose.yml deploys many components and is somewhat complex. If you prefer a simplified deployment via Docker compose, one which only includes the basic controller and edge router combination you can instead download the simplified-docker-compose.yml Networks Inside the Docker network you'll see there are three networks: the blue docker network the red docker network the purple \"logical\" network Docker will ensure only the pieces within a given network, can only communicate within that network. This network topology is designed to approximate, very loosely, what it would be like to have a publicly deployed network. The purple network would approximate the internet itself, the blue network would represent a cloud provider's private network (such as AWS) and the red network could represent another cloud provider network (like Azure). Those details are not important, the important part is that the networks are totally private to one another. See more on this topic below in the \"Testing\" section. Purple Network There is no Docker network named \"purple\" in the compose file, it's entirely a logical construct. It is shown only for clarity. All the assets in the purple network are in both the blue and red docker networks (which is why it's referred to as purple). The assets in the purple network need to be in both the red and blue networks because the assets located in the blue and red networks need to communicate to the public edge routers and also need to communicate to the controller. If that's confusing, see the \"Testing\" section below which will hopefully make this more clear. Red Network The red network exists for demonstration only at this time. As you can see there are no assets inside the red network other than the private, ziti-private-red router and the ziti-fabric-router-br . This means there's nothing in the red network for Ziti to access. It would serve as a great place for you to put your own assets and explore using Ziti! Blue Network The blue network contains two important assets, the ziti-private-blue router and the web-test-blue server. Along with those assets, the network also contains the ziti-fabric-router-br . Although the web-test-blue server does export a port by default (port 80 on your localhost, will translate to port 8000 on the web-test-blue server), you can use Ziti to access this server without the exported port. The \"Fabric\" Router The ziti-fabric-router-br exists to illustrate that you can create edge routers that are not necessarily fully public. This is the only router which can communicate to all the other routers. The Ziti mesh may choose to use this router if the algorithm indicates it's the fastest path. Perhaps we'll see more about this in future docs. Testing the Network Using Docker Locally A quick note. If you are not well-versed with Docker you might forget that exposing ports in Docker is one thing, but you'll also need to have a hosts entry for the containers you want to access from outside the Docker network. This quickstart will expect that you understand this and for every router you add you will want to make sure you add a host entry. In the docker-compose example you will want/need hosts entries for at least: ziti-edge-controller , ziti-edge-router And if you want to expose any other routers - of course you'll need/want to have entries for those as well. Testing Now that we have used docker-compose to deploy a relatively complicated network, we can start testing it out to make sure everything is in place and looks correct. Let's try it out. To test, we will use docker and exec into the running controller. Since we've used docker-compose , we know the name that will be created (you could use docker ps to find it if you need). Let's exec into the controller with: docker exec -it docker_ziti-controller_1 /bin/bash Once exec'ed into the controller, the ziti CLI will be added to your PATH for you. There is also the zitiLogin alias to make it easy for you to authenticate to the Ziti controller. Run zitiLogin now and ensure you're authenticated. ziti@724087d30014:/openziti$ zitiLogin Token: 55ec6721-f33b-4101-970a-412331bd7578 Saving identity 'default' to /openziti/ziti-cli.json Test - Edge Routers Online Once authenticated, let's see if all our routers are online by running ziti edge list edge-routers : ziti@724087d30014:/openziti$ ziti edge list edge-routers id: BZ.Y7vMdAI name: ziti-edge-router isOnline: true role attributes: {} id: NELWwjMd8 name: ziti-private-blue isOnline: true role attributes: {} id: l9-W7jMf8 name: ziti-fabric-router-br isOnline: true role attributes: {} id: rqZW7vMdA name: ziti-edge-router-wss isOnline: true role attributes: {} id: xmiYwvMf8 name: ziti-private-red isOnline: true role attributes: {} We can see all the routers are online - excellent. Test - Edge Router Identites In this compose file, we have used a script that adds an identity for each of our edge routers as well. We can see those by running ziti@724087d30014:/openziti$ ziti edge list identities : ziti@724087d30014:/openziti$ ziti edge list identities id: BZ.Y7vMdAI name: ziti-edge-router type: Router role attributes: {} id: NELWwjMd8 name: ziti-private-blue type: Router role attributes: {} id: Q4Y-OTcwo name: Default Admin type: User role attributes: {} id: l9-W7jMf8 name: ziti-fabric-router-br type: Router role attributes: {} id: rqZW7vMdA name: ziti-edge-router-wss type: Router role attributes: {} id: xmiYwvMf8 name: ziti-private-red type: Router role attributes: {} Notice there is an identity for every router. Test - Network Connectivity Success Recall that the controller should be able to contact both the red and blue edge routers. Let's use ping and verify: ziti@724087d30014:/openziti$ ping ziti-private-red -c 1 PING ziti-private-red (172.29.0.2): 56 data bytes 64 bytes from 172.29.0.2: icmp_seq=0 ttl=64 time=0.387 ms --- ziti-private-red ping statistics --- 1 packets transmitted, 1 packets received, 0% packet loss round-trip min/avg/max/stddev = 0.387/0.387/0.387/0.000 ms ziti@724087d30014:/openziti$ ping ziti-private-blue -c 1 PING ziti-private-blue (172.28.0.6): 56 data bytes 64 bytes from 172.28.0.6: icmp_seq=0 ttl=64 time=0.633 ms --- ziti-private-blue ping statistics --- 1 packets transmitted, 1 packets received, 0% packet loss round-trip min/avg/max/stddev = 0.633/0.633/0.633/0.000 ms Test - Network Connectivity Failure Now let's exit the Ziti controller and instead attach to the private blue router by running this command: docker exec -it docker_ziti-private-blue_1 /bin/bash . Once attached to the blue router we'll verify that we cannot connect to the private red router: ziti@e610d6b44166:/openziti$ ping ziti-private-red -c 1 ping: unknown host Unknown host - the private blue router cannot connect to the red router. Test - Web Test Blue While we're attached to the blue router - let's make sure we can connect to that web-test-blue server. ziti@e610d6b44166:/openziti$ curl http://web-test-blue:8000 <pre> Hello World ## . ## ## ## == ## ## ## ## ## === /\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\\___/ === ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~ \\______ o _,/ \\ \\ _,' `'--.._\\..--'' </pre> Don't forget - you can also access this from the exported port 80 on your local machine too! curl http://localhost:80 <pre> Hello World ## . ## ## ## == ## ## ## ## ## === /\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\\___/ === ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~ \\______ o _,/ \\ \\ _,' `'--.._\\..--'' </pre> Install Ziti Admin Console (ZAC) [Optional] Once you have the network up and running, if you want to install the UI management console, the ZAC, follow along with the installation guide Using the Overlay Now you have your zero trust overlay network in place, you probably want to try it out. Head on over to the services quickstart and start the journey to understanding how to use OpenZiti."
  },
  "ziti/quickstarts/network/local-no-docker.html": {
    "href": "ziti/quickstarts/network/local-no-docker.html",
    "title": "Local - No Docker | Ziti",
    "keywords": "Local - No Docker This page will show you how to get your Ziti Network up and running quickly and easily, entirely locally. Since you'll be running everything locally, you'll have no issues communicating between network components. All the processes will run locally, and you'll be responsible for starting and stopping them when you want to turn the overlay network on or off. Preparation There is not much preparation necessary to getting up-and-running locally. At this time, this guide expects that you'll be running commands within a bash shell. If you're running Windows, you will need to make sure you have Windows Subsystem for Linux installed for now. We plan to provide a Powershell script in the future, but for now the script requires you to be able to use bash . Make sure your local ports 1280, 6262, 10000 are free before running the controller. These ports are the default ports used by the controller. Also ensure ports 10080 and 3022 are open as these are the default ports the edge router will use. One-liner Setup Running the latest version of Ziti locally is as simple as running this one command (the command will require the jq utility be installed): source /dev/stdin <<< \"$(wget -qO- https://raw.githubusercontent.com/openziti/ziti/release-next/quickstart/docker/image/ziti-cli-functions.sh)\"; expressInstall This script will perform an 'express' install of Ziti which does the following: download the latest version of the Ziti components ( ziti , ziti-controller , ziti-edge-router , ziti-tunnel ) extract the components into a predefined location: ~/.ziti/quickstart/$(hostname) create a full PKI for you to explore create a controller configuration using default values and the PKI created above create an edge-router configuration using default values and the PKI created above add helper functions and environment variables to your shell (explore the script to see all) Start the Components Once the latest version of Ziti has been downloaded and added to your path, it's time to start your controller and edge router. Start Your Controller Start your controller by running startZitiController . The location of the log file will be output for you to look at, tail etc. Notice that this log is written to the given location. There is no log rotation. Once run, you will see output that looks like the following: ziti-controller started as process id: 7282. log located at: ${HOME}/.ziti/quickstart/My-Mac-mini.local.domain/ziti-edge-controller.log Verify the Controller is Running Assuming you have sourced the script, you will have an environment variable set named $ZITI_EDGE_CONTROLLER_API . After the controller has started, your controller should be listening at that hostname:port combination. You can see what your value is set to by running echo $ZITI_EDGE_CONTROLLER_API . This variable defaults to: $(hostname):1280 . Make sure the controller is on and listening and then start the edge router. ~ % echo $ZITI_EDGE_CONTROLLER_API My-Mac-mini.local.domain:1280 Start Your Edge Router Now that the controller is ready, you can start the edge router created with the 'express' process. You can start this router locally by running startExpressEdgeRouter . You should see output that looks like this: Express Edge Router started as process id: 7555. log located at: ${HOME}/.ziti/quickstart/My-Mac-mini.local.domain/My-Mac-mini.local.domain-edge-router.log You can verify the edge router is listening by finding the value of $ZITI_EDGE_ROUTER_HOSTNAME:$ZITI_EDGE_ROUTER_PORT . Again, this will default to using $(hostname) as the host name and port 3022. Testing Your Overlay At this point you should have a functioning Ziti Network . The script you sourced provides another function to login to your network. Try this now by running zitiLogin . You should see something similar to this: ~ % zitiLogin Token: 40d2d280-a633-46c9-8499-ab2e005dd222 Saving identity 'default' to ${HOME}/.ziti/quickstart/My-Mac-mini.local.domain/ziti-cli.json Congratulations! You can now use the ziti CLI to interact with Ziti! ( Ziti CLI Help Here ) The ziti binary is not added to your path by default but will be available at \"${ZITI_BIN_DIR-}/ziti\" . Add that folder to your path, alias ziti if you like. Let's try to use this command to see if the edge router is online by running: \"${ZITI_BIN_DIR-}/ziti\" edge list edge-routers . ~ % \"${ZITI_BIN_DIR-}/ziti\" edge list edge-routers id: rhx6687N.P name: My-Mac-mini.local.domain isOnline: true role attributes: {} results: 1-1 of 1 Horray! Our edge router shows up and is online! Run Your First Service You can try out creating and running a simple echo service through ziti by running the first-service tutorial. ~ % \"${ZITI_BIN_DIR-}/ziti\" edge tutorial first-service Customizing the Express Install You can influence and customize the express installation somewhat if you wish. This is useful if trying to run more than one instance of Ziti locally. The most common settings you might choose to customize would be the ports used or the name of the network. Configuration File Location You can change the location of the configuration files output by adding a parameter to the expressInstall function invocation. However, if you do this you will also need to set other environment variables as well. Please realize that if you change these variables each of the \"hostname\" variables will need to be addressable: ZITI_CONTROLLER_HOSTNAME ZITI_EDGE_CONTROLLER_HOSTNAME ZITI_EDGE_CONTROLLER_PORT ZITI_EDGE_ROUTER_HOSTNAME ZITI_EDGE_ROUTER_PORT Here is an example which allows you to put all the files into a folder called: ${HOME}/.ziti/quickstart/newfolder , uses a host named 'localhost', and uses ports 8800 for the edge controller and 9090 for the edge router: ZITI_CONTROLLER_HOSTNAME=localhost; \\ ZITI_EDGE_CONTROLLER_HOSTNAME=localhost; \\ ZITI_EDGE_CONTROLLER_PORT=8800; \\ ZITI_EDGE_ROUTER_HOSTNAME=localhost;ZITI_EDGE_ROUTER_PORT=9090; \\ source ziti-cli-functions.sh; expressInstall newfolder Sourcing the Env File In the case you close your shell and you want to get the same environment variables back into your shell, you can just source the \"env\" file that is placed into the location you specified. For example, if you ran the example above where the deployed files went to ${HOME}/.ziti/quickstart/newfolder you would find an \"env\" file at ${HOME}/.ziti/quickstart/newfolder/newfolder.env and source it: source ${HOME}/.ziti/quickstart/newfolder/newfolder.env ~ % zitiLogin Token: aa1c7fb0-85d9-4a79-86b2-5df450c5b4de Saving identity 'default' to ${HOME}/.ziti/quickstart/newfolder/ziti-cli.json Install Ziti Admin Console (ZAC) [Optional] Once you have the network up and running, if you want to install the UI management console, the ZAC, follow along with the installation guide Using the Overlay Now you have your zero trust overlay network in place, you probably want to try it out. Head on over to the services quickstart and start the journey to understanding how to use OpenZiti."
  },
  "ziti/quickstarts/network/local-with-docker.html": {
    "href": "ziti/quickstarts/network/local-with-docker.html",
    "title": "Local - With Docker | Ziti",
    "keywords": "Local - With Docker Docker is a popular container engine, and many developers enjoy using solutions delivered via Docker. Ziti provides a single Docker container which contains the entire stack of Ziti components. This is not the most common mechanism for deploying containers, we recognize that. However, we think that this makes it a bit easier for people to get started with deploying Ziti components using Docker. We will certainly look to create individual containers for each component in the future but for now it's a single container. You can get this container by issuing docker pull openziti/quickstart:latest . Starting the Controller All Ziti Networks require a Ziti Controller . Without a controller, edge routers won't be able to authorize new connections rendering a new network useless. You must have a controller running. Required - Volume Mount Running Ziti locally via Docker will require you to mount a common folder which will be used to store the PKI of your network. Without a volume mount, you'll be forced to figure out how to get the PKI in place correctly. While this is a straightforward process once you know how to do it, when you're getting started this is undoubtedly complicated. We recommend that if you're starting out (or if you just don't want to be bothered with these details) you should just create a folder and volume mount that folder. It's expected that this volume mount map to /openziti/pki inside the container. Required - Known Name Other containers on the Docker network will need to address the controller. To do this, we will give this container a network alias. At this time it would appear that this also forces you to add the container to a network which is not the default network. This is a very useful feature which allows your containers to be isolated from one another and also will allow you to have multiple networks running locally if you desire. To create a Docker network issue: docker network create myFirstZitiNetwork Next - we need to make a folder to share our PKI as well as our environment file the controller emits. We'll just put it into your home directory. Move it wherever you like. mkdir -p ~/docker-volume/myFirstZitiNetwork Finally, we need to make an empty file where we expect the controller to put the env file. Let's do that now too. echo \"#ziti.env file\" > ~/docker-volume/myFirstZitiNetwork/ziti.env Later, when starting the controller, we'll supply this network as a parameter to the docker command as well as name the network. That's done with these two options: --network myFirstZitiNetwork --network-alias ziti-controller and we'll also supply the env file as the location for the controller to use to write into. Optional - Expose Controller Port Docker containers by default won't expose any ports that you could use from your local machine. If you want to be able to use this controller from outside of Docker, you'll need to export the controller's API port. That's easy to do, simply pass one more parameter to the docker command: -p ${externalPort}:${internalPort} Running the Controller Here's an example of how to make a folder for \"myFirstZitiNetwork\" in your home folder, and then launch a controller using that folder. Do note that this command passes a couple extra flags you'll see used on this page. Notably the --rm flag and the -it flag. The --rm flag instructs Docker to delete the container when the container exits. The -it flag will run the container interactively. Running interactively like this makes it easier to see the logs produced, but you will need a terminal for each process you want to run. The choice is yours, but in these examples we'll use -it to make seeing the output from the logs easier. Here's an example which will use the Docker network named \"myFirstZitiNetwork\" and expose the controller to your local computer on port 1280 (the default port). docker run \\ --network myFirstZitiNetwork \\ --network-alias ziti-controller \\ --network-alias ziti-edge-controller \\ -p 1280:1280 \\ -it \\ --rm \\ -v ~/docker-volume/myFirstZitiNetwork:/openziti/pki \\ -v ~/docker-volume/myFirstZitiNetwork/ziti.env:/openziti/ziti.env \\ openziti/quickstart \\ /openziti/scripts/run-controller.sh Edge Router At this point you should have a Ziti Controller running. You should have created your Docker network as well as creating the volume mount. Now it's time to connect your first edge router. The same Docker image that runs the controller can run an edge router. To start an edge router, you will run a very similar command as the one to start the controller with a couple of key differences. The first noticable difference is that we need to pass in the name of the edge router we want it to be. To use this network, the name supplied needs tobe addressable by clients. Also notice the port exported is port 3022. This is the default port used by edge routers. docker run \\ -e ZITI_EDGE_ROUTER_RAWNAME=ziti-edge-router-1 \\ --network myFirstZitiNetwork \\ --network-alias ziti-edge-router-1 \\ -p 3022:3022 \\ -it \\ --rm \\ -v ~/docker-volume/myFirstZitiNetwork:/openziti/pki \\ -v ~/docker-volume/myFirstZitiNetwork/ziti.env:/openziti/ziti.env \\ openziti/quickstart \\ /openziti/scripts/run-router.sh edge If you want to create a second edge router, you'll need to override the router port, don't forget to export that port too docker run \\ -e ZITI_EDGE_ROUTER_RAWNAME=ziti-edge-router-2 \\ -e ZITI_EDGE_ROUTER_PORT=4022 \\ --network myFirstZitiNetwork \\ --network-alias ziti-edge-router-2 \\ -p 4022:4022 \\ -it \\ --rm \\ -v ~/docker-volume/myFirstZitiNetwork:/openziti/pki \\ -v ~/docker-volume/myFirstZitiNetwork/ziti.env:/openziti/ziti.env \\ openziti/quickstart \\ /openziti/scripts/run-router.sh edge Testing the Network Using Docker Locally A quick note. If you are not well-versed with Docker you might forget that exposing ports in Docker is one thing, but you'll also need to have a hosts entry for the containers you want to access from outside of of the Docker network. This quickstart will expect that you understand this and for every router you add you will want to make sure you add a host entry. In the examples above we are adding three entities: ziti-edge-controller , ziti-edge-router-1 and ziti-edge-router-2 . Testing With the controller and router running, you can now attach to the Docker host running the Ziti controller and test that the router did indeed come online and is running as you expect. To do this, we'll use another feature of the docker command and exec into the machine. First, you'll need to know your Docker container name which you can figure out by running docker ps . $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b86c4b461e7 openziti/quickstart \"/openziti/scripts/r\" 10 minutes ago Up 10 minutes 0.0.0.0:3022->3022/tcp, :::3022->3022/tcp musing_engelbart a33d58248d6e openziti/quickstart \"/openziti/scripts/r\" 46 minutes ago Up 46 minutes 0.0.0.0:1280->1280/tcp, :::1280->1280/tcp xenodochial_cori Above, you'll see my controller is running in a container named \"xenodochial_cori\". I can tell because it's using the default port of 1280, the default port for the controller. Now I can exec into this container: docker exec -it xenodochial_cori /bin/bash Once in the container, I can now issue zitiLogin to authenticate the ziti CLI. zitiLogin Token: b16f182f-88b3-4fcc-9bfc-1e32319ca486 Saving identity 'default' to /openziti/ziti-cli.json And finally, once authenticated I can test to see if the edge router is online in the controller and as you'll see, the isOnline property is true! ziti@a33d58248d6e:/openziti$ ziti edge list edge-routers id: qNZyqZEix3 name: ziti-edge-router isOnline: true role attributes: {} results: 1-1 of 1 Install Ziti Admin Console (ZAC) [Optional] Once you have the network up and running, if you want to install the UI management console, the ZAC, follow along with the installation guide Using the Overlay Now you have your zero trust overlay network in place, you probably want to try it out. Head on over to the services quickstart and start the journey to understanding how to use OpenZiti."
  },
  "ziti/quickstarts/quickstart-overview.html": {
    "href": "ziti/quickstarts/quickstart-overview.html",
    "title": "Start Cooking With Ziti | Ziti",
    "keywords": "Start Cooking With Ziti Learn how to start integrating Zero Trust directly into your application! Explore our quickstarts and learn how to get your own zero trust overlay network setup. OpenZiti is bringing Zero Trust to networks all over the world! To really get the most out of Ziti, you'll want to embed it directly into your applications. Ziti provides numerous SDKs for this very purpose. If you're not ready to embed Zero Trust right into your application you can still get started by using one or more of the tunneling apps . Note If you get stuck on anything at all, remember that the link to the discourse sites is on the top right of all the doc pages. Don't be afraid to ask the community for help! Getting Started - Network When you're just getting started, the first thing you will need is access to a Ziti Network . For someone just starting out, there are four basic options: Run all the binaries locally Here you'll start and stop components on your own. This is great for learning but since it's all local, keeping any services you define actually separate from your local machine is a bit hard. Run locally using Docker This allows you to do some more complex things like actually isolate services from even yourself. Run on your own server This option is great for two situations. If you have a server This is great if you have other people you want to have access to your Ziti Network and aren't on the local network. If you would prefer not to deal with setting up the Ziti Network you can sign up for a free-tier account over at the NetFoundry Console Which network option sounds right for you? Run Everything Locally - no Docker Run Everything Locally - using Docker Run Everything Locally - Docker Compose Run Everything Hosted"
  },
  "ziti/quickstarts/services/host-access.html": {
    "href": "ziti/quickstarts/services/host-access.html",
    "title": "Your First Service - Zero Trust Host Access | Ziti",
    "keywords": "Your First Service - Zero Trust Host Access This document will demonstrate how to successfully deploy and secure an existing, \"brown field\" application using OpenZiti. You want to secure an application where you don't control the source or where you don't want to (or cannot) integrate an OpenZiti SDK into the application. These sorts of services are often web-based, so we'll focus here at exposing a web server. It's important to keep in mind that OpenZiti is a holistic zero trust networking solution. You can absolutely expose applications that are not web-based. For now, we'll start with a web server since that's a common need. Solution Overview Before we get into using OpenZiti, let's take a moment and review what the solution is like before we apply any zero trust networking principles. We will use some sort of http client, connect it over a network. The exact network does not matter. OpenZiti is applicable to any network be it host network, local network, the internet, private network, etc. Simple HTTP Solution Overview - Before Ziti The important aspect of this diagram is to notice that the HTTP server is provisioned on the underlay network and requires a hole through the firewall to allow clients to connect. Simple HTTP Solution - After Ziti After OpenZiti, we can see that there is no longer an open firewall to allow access to the HTTP server. Instead, the HTTP client will have its network requests intercepted by an OpenZiti tunneller. Once intercepted, the packets are then delivered to the OpenZiti overlay fabric which has the responsibility to deliver the intercepted packets to the target identity. Once delivered to the target identity, in this example, the traffic will offload back to the underlay network to be sent to the final destination: the HTTP Server. With an understanding of what we are looking to accomplish in this guide, let's get into it! Implementing the Service Prerequisite - OpenZiti Network You will need an OpenZiti overlay network in place before you can complete this guide. If you do not have an OpenZiti overlay network provisioned yet, follow a quickstart and get a network up and running. Prerequisite - HTTP Server You'll need an HTTP server which you plan to connect your HTTP client to. There are numerous ways to bring an HTTP server online but for this guide I have chosen to use docker and deploy a very simple HTTP application. The server will simply print out the \"docker whale\" when it's connected to. (This guide will not teach you how to install docker, nor how to install an HTTP server which is listening) If you are familiar with docker and wish to use the exact same example as shown here, simply run the container with: docker run -d --rm --name web-test -p 80:8000 crccheck/hello-world . Alternatively, if you have used the docker-compose quickstart to provision your OpenZiti overlay network, you will have this HTTP server available to use immediately. Prerequisite - HTTP Client Tunneller You will need to install an OpenZiti tunneller on the machine which represents the HTTP client. Later on we'll create an identity for this tunneller and use the identity to access the HTTP server. Prerequisite - HTTP Server Tunneller You will need to install an OpenZiti tunneller on the machine which represents the HTTP server. Later on we'll create an identity for this tunneller and use the identity to access the HTTP server. Note If you used the docker-compose quickstart the \"private\" edge routers are configured as tunnelers and will not require you to deploy another tunneler nor will you need to create another identity. Prerequisite - CLI If you plan to use the ziti CLI tool, you will either need to download and get the ziti executable on your path. If you have followed a quickstart, this will have been done for you and the executable will be located in ~/.ziti/quickstart/$(hostname)/ziti-bin/ . Also, the .env file the quickstart emits can be used to put this folder on your path by simply sourcing that file. For example, if you followed either the Local - No Docker or Host Ziti Anywhere quickstart, you should have a file that can be sourced. Here is an example of my personal \"Local - No Docker\" result when sourcing that file: $ source ~/.ziti/quickstart/$(hostname)/$(hostname).env adding /home/cd/.ziti/quickstart/sg3/ziti-bin/ziti-v0.25.6 to the path If you are using a docker-based example you can exec into the controller where the ziti CLI tool will be available and this file will be sourced for you as well. Here's an example when I use docker to exec into my controller locally: $ docker exec -it docker_ziti-controller_1 bash adding /openziti/ziti-bin to the path Configuring the Overlay - Overview With our overlay network ready and with two tunneling applications deployed and ready to be used, we can start to configure our solution. Here is an overview of the steps we will follow: Create an identity for the HTTP client and assign an attribute \"http-clients\". We'll use this attribute when authorizing the clients to access the HTTP service Create an identity for the HTTP server if you are not using an edge-router with the tunneling option enabled (see below). Also note that if you are using the docker-compose quickstart or just plan to use an edge-router with tunneling enabled you can also skip this step. Create an intercept.v1 config . This config is used to instruct the client-side tunneler how to correctly intercept the targeted traffic and put it onto the overlay. Create a host.v1 config . This config is used instruct the server-side tunneler how to offload the traffic from the overlay, back to the underlay. Create a service to associate the two configs created previously into a service. Create a service-policy to authorize \"HTTP Clients\" to \"dial\" the service representing the HTTP server. Create a service-policy to authorize the \"HTTP Server\" to \"bind\" the service representing the HTTP server. Start the server-side tunneller (unless using the docker-compose quickstart) with the HTTP server identity, providing access to the HTTP server. Start the client-side tunneller using the HTTP client identity. Access the HTTP server securely over the OpenZiti zero trust overlay We can do all these steps using the OpenZiti CLI tool: ziti . We can also accomplish this using the OpenZiti Admin Console. We'll demonstrate doing it both ways now. Configuring the Overlay Using Ziti CLI Here you can find the steps necessary to configure your overlay network. You can copy/paste and run them all at once, or you can go slowly and run one command at a time to see how each command works. These commands are all based on a shell similar to bash. If you are not using bash you'll need to adapt these scripts to your shell. HTTP Server IP/DNS Note that step 4 below requires you to have set the variable named http_server . This variable represents the location of the HTTP server relative to the OpenZiti tunneler you're using. Look at the diagram above. You will want to supply the IP/FQDN of the server which runs the HTTP server that is relative to the tunneler. As an example, if you were to use the docker-compose quickstart and are going to reference the pre-deployed HTTP server that comes with it, you'd set http_server to web-test-blue since that is a valid name of the container running the HTTP server. HTTP Server Identity Note that step 7 below requires you to have set the variable named http_server_id . All of the quickstarts provision an edge-router with the tunneler option ( -t ) enabled. This means that edge-router is configured to serve as a tunneller. Run ziti edge list identities to find the name of the identity associated to the router. # login to your controller - replace the host/port with the correct value ziti edge login localhost:1280 # optional login: # if you're using docker and have exec'ed into your controller using docker you should be able to run the alias `zitiLogin` to login # optional login: # if you've sourced the .env file from a quickstart you should be able to run the alias `zitiLogin` to login # 1. Create an identity for the HTTP client and assign an attribute \"http-clients\". We'll use this attribute when authorizing the clients to # access the HTTP service ziti edge create identity user http-client -a 'http-clients' -o http.client.jwt #2. Create an identity for the HTTP server if you are not using an edge-router with the tunneling option enabled ziti edge create identity user http-server -o http.server.jwt #3. Create an intercept.v1 config. This config is used to instruct the client-side tunneler how to correctly intercept # the targeted traffic and put it onto the overlay. ziti edge create config http.intercept.v1 intercept.v1 '{\"protocols\":[\"tcp\"],\"addresses\":[\"http.ziti\"], \"portRanges\":[{\"low\":80, \"high\":80}]}' #4. Create a host.v1 config. This config is used instruct the server-side tunneler how to offload the traffic from # the overlay, back to the underlay. ziti edge create config http.host.v1 host.v1 '{\"protocol\":\"tcp\", \"address\":\"'\"${http_server}\"'\", \"port\":8000}' #5. Create a service to associate the two configs created previously into a service. ziti edge create service http.svc --configs http.intercept.v1,http.host.v1 #6. Create a service-policy to authorize \"HTTP Clients\" to \"dial\" the service representing the HTTP server. ziti edge create service-policy http.policy.dial Dial --service-roles \"@http.svc\" --identity-roles '#http-clients' #7. Create a service-policy to authorize the \"HTTP Server\" to \"bind\" the service representing the HTTP server. ziti edge create service-policy http.policy.bind Bind --service-roles '@http.svc' --identity-roles \"@${http_server_id}\" #8. Start the server-side tunneller (unless using the docker-compose quickstart) with the HTTP server identity. # [optional] if you don't use an edge-router as your tunneler, you will need to download and run the tunneler for your OS # if you are using a ziti-router, skip to step 9 below # # This step is dependant on platform. For this demo we'll be using a virtual machine running linux and we'll be using the # ziti-edge-tunnel binary. Copy the http.server.jwt from step 2 to the server machine. For the example we'll use /tmp/http.server.jwt # # enroll the server identity using ziti-edge-tunnel ./ziti-edge-tunnel enroll --jwt /tmp/http.server.jwt --identity /tmp/http.server.json # run ziti-edge-tunnel for the client sudo ./ziti-edge-tunnel run -i /tmp/http.server.json #9. Start the client-side tunneller using the HTTP client identity. # This step is dependant on platform. For this demo we'll be using a virtual machine running linux and we'll be using the # ziti-edge-tunnel binary. Copy the http.client.jwt from step 1 to the client machine. For the example we'll use /tmp/http.client.jwt # # enroll the client identity using ziti-edge-tunnel ./ziti-edge-tunnel enroll --jwt /tmp/http.client.jwt --identity /tmp/http.client.json # run ziti-edge-tunnel for the client sudo ./ziti-edge-tunnel run -i /tmp/http.client.json #10. Access the HTTP server securely over the OpenZiti zero trust overlay curl http.ziti <pre> Hello World ## . ## ## ## == ## ## ## ## ## === /\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\\___/ === ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~ \\______ o _,/ \\ \\ _,' `'--.._\\..--'' </pre> Configuring the Overlay Using Ziti Admin Console -- COMING SOON -- Testing Everything Works Once you have set everything up As shown in the last step above - at this point you should be able to run a curl statement or use a browser to access \"http.ziti\"."
  },
  "ziti/quickstarts/services/index.html": {
    "href": "ziti/quickstarts/services/index.html",
    "title": "Starting With Services | Ziti",
    "keywords": "Starting With Services Once you have your zero trust overlay network in place and you want to start using it, you'll be wondering where to begin. You can start in a few different directions. Depending on your experience and what you're looking to do you'll have numerous directions to go in. This page will hopefully give you some insight into some of the choices you can make. Zero Trust Application Access OpenZiti is really about embedding zero trust directly into your applications. If you are a developer, you might want to start with your favorite language and start your OpenZiti journy with \"zero trust application access\". This means you'll take an SDK and embed it into an application you write! It's probably best to explore the best SDK for your language and find samples for that SDK to use. The landing page has links to all the SDKs to choose from. Zero Trust Host Access If you're not a developer, or if you have an application which you can't (or don't want to) change you can start with \"zero trust host access\". For this, you will install an OpenZiti tunneller on your \"clients\" and on your \"servers\" and provide access to your services using these executables. If this sounds like a good place to start, check out the host access quickstart ."
  },
  "ziti/quickstarts/zac/installation.html": {
    "href": "ziti/quickstarts/zac/installation.html",
    "title": "Installing Ziti Administration Console | Ziti",
    "keywords": "Installing Ziti Administration Console The Ziti Administration Console (ZAC) is a UI provided by the OpenZiti project which will allow you to configure and explore a Ziti Network . Installing the ZAC is relatively straightforward and can be accomplished in two basic ways shown below. Setting up the Ziti Admin Console Prerequisites It's expected that you're using bash for these commands. If you're using Windows we strongly recommend that you install and use Windows Subsystem for Linux (WSL). Other operating systems it's recommended you use bash unless you are able to translate to your shell accordingly. Note When running Ziti Administration Console, you should also prefer using https over http. In order to do this you will need to either create, or copy the certificates needed. Each section below tries to show you how to accomplish this on your own. Cloning From GitHub These steps are applicable to both the local, no docker as well as the hosted yourself deployments. Do note, these steps expect you have the necessary environment variables established in your shell. If you used the default parameters, you can establish these variables using the file at ${HOME}/.ziti/quickstart/$(hostname)/$(hostname).env . To deploy ZAC after following one of those guides, you can perform the following steps. Clone the ziti-console repo from github: git clone https://github.com/openziti/ziti-console.git \"${ZITI_HOME}/ziti-console\" Install node and npm and get the server ready: cd \"${ZITI_HOME}/ziti-console\" sudo apt install npm nodejs -y npm install Use the ziti-controller certificates for the Ziti Console: ln -s \"${ZITI_PKI}/${ZITI_EDGE_CONTROLLER_HOSTNAME}-intermediate/certs/${ZITI_EDGE_CONTROLLER_HOSTNAME}-server.chain.pem\" \"${ZITI_HOME}/ziti-console/server.chain.pem\" ln -s \"${ZITI_PKI}/${ZITI_EDGE_CONTROLLER_HOSTNAME}-intermediate/keys/${ZITI_EDGE_CONTROLLER_HOSTNAME}-server.key\" \"${ZITI_HOME}/ziti-console/server.key\" [Optional] Emit the Ziti Console systemd file and update systemd to start the Ziti Console. If you have not sourced the Ziti helper script, you need to in order to get the necessary function. createZacSystemdFile sudo cp \"${ZITI_HOME}/ziti-console.service\" /etc/systemd/system sudo systemctl daemon-reload sudo systemctl start ziti-console If you do not have systemd installed or if you just wish to start ZAC you can simply issue: node \"${ZITI_HOME}/ziti-console/server.js\" Initializing TLS TLS initialized on port: 8443 Ziti Server running on port 1408 [Optional] If using systemd - verify the Ziti Console is running by running the systemctl command sudo systemctl status ziti-console --lines=0 --no-pager #sample output of the command: ubuntu@ip-172-31-22-212:~$ sudo systemctl status ziti-console --lines=0 --no-pager  ziti-console.service - Ziti-Console Loaded: loaded (/etc/systemd/system/ziti-console.service; disabled; vendor preset: enabled) Active: active (running) since Wed 2021-05-19 22:04:44 UTC; 13h ago Main PID: 13458 (node) Tasks: 11 (limit: 1160) Memory: 33.4M CGroup: /system.slice/ziti-console.service 13458 /usr/bin/node /home/ubuntu/.ziti/quickstart/ip-172-31-22-212/ziti-console/server.js Using Docker Getting ZAC setup if you have followed the docker network quickstart should be straightforward. If you have used the default values from this quickstart you can issue the following command. Notice that this command uses the default path: ${HOME}/docker-volume/myFirstZitiNetwork . If you customized the path, replace the paths specified in the volume mount sections below accordingly (the '-v' lines). Also note this command will expose the http and https ports to your local computer. This is optional, read more about using docker for more details if necessary. docker run \\ --name zac \\ -p 1408:1408 \\ -p 8443:8443 \\ -v \"${HOME}/docker-volume/myFirstZitiNetwork/ziti-edge-controller-intermediate/keys/ziti-edge-controller-server.key\":/usr/src/app/server.key \\ -v \"${HOME}/docker-volume/myFirstZitiNetwork/ziti-edge-controller-intermediate/certs/ziti-edge-controller-server.chain.pem\":/usr/src/app/server.chain.pem \\ openziti/zac Note Do note that if you are exposing ports as shown above, you will need to ensure that ziti-edge-controller is addressable by your machine in order to use docker in this way. This guide does not go into how to do this in depth. One easy, and common mechanism to do this would be to edit the 'hosts' file of your operating system. A quick internet search should show you how to accomplish this. Using Docker Compose If you have followed the docker compose quickstart getting the ZAC running within the compose file is a bit cumbersome because the docker-compose file will generate a full PKI on your behalf. While this makes it very easy to get a basic network setup, it makes reusing that PKI in the ZAC difficult at this time. It's not difficult to reuse the PKI but you'll need to do the following: Start the network using docker-compose as normal. After running, copy the ziti-edge-controller server certificate chain and key from the controller using these commands: bash docker cp docker_ziti-controller_1:/openziti/pki/ziti-edge-controller-intermediate/keys/ziti-edge-controller-server.key . docker cp docker_ziti-controller_1:/openziti/pki/ziti-edge-controller-intermediate/keys/ziti-edge-controller-server.chain.pem . Once these files are copied out, shut down the running docker-compose docker-compose down . Do NOT remove the volume with -v . Now add the ZAC configuration lines to the compose file of your choice: ziti-console: image: openziti/zac ports: - \"1408:1408\" - \"8443:8443\" environment: - ZITI_EDGE_CONTROLLER_HOSTNAME=ziti-edge-router volumes: - ziti-fs:/openziti - type: bind source: ./ziti-edge-controller-server.key target: /usr/src/app/server.key - type: bind source: ./ziti-edge-controller-server.chain.pem target: /usr/src/app/server.chain.pem networks: - zitiblue - zitired After adding the ZAC configuration as shown, docker-compose will now start and expose the ZAC ports on 1408/8443. > [!Note] > Do note that if you are exposing ports as shown above, you will need to ensure that ziti-edge-controller is > addressable by your machine in order to use docker in this way. This guide does not go into how to do this in depth. > One easy, and common mechanism to do this would be to edit the 'hosts' file of your operating system. A quick > internet search should show you how to accomplish this. > Login and use the Ziti Console At this point you should be able to navigate to both: https://${ZITI_EDGE_CONTROLLER_HOSTNAME}:8443 and see the ZAC login screen. (The TLS warnings your browser will show you are normal - it's because these steps use a self-signed certificate generated in the install process) > [!NOTE] > If you are using docker-compose to start your network, when you access ZAC for the first time you will need to > specify the url of the controller. Since everything is running in docker compose this url is relative to the > internal docker compose network that is declared in the compose file. You would enter > https://ziti-edge-controller:1280 as the controller's URL Set the controller as shown (use the correct URL): Example using the \"everything local\" quickstart: Example using the \"docker-compose\" quickstart: Example using AWS \"host it anywhere\": Login with admin/admin IMPORTANT!!! Edit your profile and change the password"
  },
  "ziti/services/create-service-cli.html": {
    "href": "ziti/services/create-service-cli.html",
    "title": "| Ziti",
    "keywords": "# creates a new service named ssh ziti edge create service ssh # creates a new service named ssh with a terminator strategy which load-balances using random selection ziti edge create service ssh --terminator-strategy random # creates a router based terminator for ssh on router router1 which connects to the local machine ziti edge create terminator ssh router1 tcp:localhost:22 # creates a new service named postgresql with a terminator strategy which does failover ziti edge create service postgresql --terminator-strategy ha # creates a router based terminator for postgres on router router1 # this is the posgres primary, so precedence is set to required ziti edge create terminator postgresql router1 tcp:pg-primary:5432 --precedence required # creates a router based terminator for postgres on router router1 which connects to another machine # this is the posgresql secondary, so precedence is left at default ziti edge create terminator postgresql router1 tcp:pg-secondary:5432 # If the primary goes down, the controller will notice that dials are failing and set the # precedence to failed. New sessions will go to the secondary. When the primary is brought # back up, it can be marked as requred again ziti edge update terminator <terminator-id> --precedence required"
  },
  "ziti/services/creating.html": {
    "href": "ziti/services/creating.html",
    "title": "Creating a Service | Ziti",
    "keywords": "Creating a Service Here's how you can create a service. New non-hosted Service via UI New hosted Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose Router by name - for example \"ziti-gw01\" if you are using Ziti Edge - Developer Edition For Endpoint Service choose: protocol = tcp host = actual-hostname port = 2222 Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Leave Hosting Identities as is Click save On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-hosted-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose \"Hosted (No Router)\" for the Router Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Select one or more identities in \"Hosting Identities\" representing the identities which host the service Click save To create a new service via CLI simply issue these commands: # creates a new service named ssh ziti edge create service ssh # creates a new service named ssh with a terminator strategy which load-balances using random selection ziti edge create service ssh --terminator-strategy random # creates a router based terminator for ssh on router router1 which connects to the local machine ziti edge create terminator ssh router1 tcp:localhost:22 # creates a new service named postgresql with a terminator strategy which does failover ziti edge create service postgresql --terminator-strategy ha # creates a router based terminator for postgres on router router1 # this is the posgres primary, so precedence is set to required ziti edge create terminator postgresql router1 tcp:pg-primary:5432 --precedence required # creates a router based terminator for postgres on router router1 which connects to another machine # this is the posgresql secondary, so precedence is left at default ziti edge create terminator postgresql router1 tcp:pg-secondary:5432 # If the primary goes down, the controller will notice that dials are failing and set the # precedence to failed. New sessions will go to the secondary. When the primary is brought # back up, it can be marked as requred again ziti edge update terminator <terminator-id> --precedence required"
  },
  "ziti/services/overview.html": {
    "href": "ziti/services/overview.html",
    "title": "Ziti Services | Ziti",
    "keywords": "Ziti Services The primary strategy assumes that one function of Ziti is providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A service is defined by the following components: Name - the name of the service Termination - Ziti only provides access to a network service, it does not provide the service itself. The service must be able to get network traffic to whatever application or application cluster is actually providing the service, whether that provider has Ziti embedded or has no knowledge of Ziti Configuration - Ziti allows application specific configuration to be stored for services. See Configuration Store Authorization - For a details on controlling access to services, see Policies . Service Name Ziti services must have names that are unique to their Ziti installation. Service names are how clients address services in order to consume them. Services which are provided by applications with Ziti embedded also use the service name to indicate which service is being provided. Services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service is to be defined by a name and this name is registered with the Ziti Controller. Once declared, services can then be addressed directly by name from Ziti-aware clients. This means there are effecitvely a limitless number names available with no need for global DNS registration. The names assigned are unique to a Ziti Network and the application developer has total control over service names. Service Termination In Ziti, service termination refers to how a network traffic going over Ziti reaches the application (or application cluster) which is actually providing a service. There are a few basic ways in which a service can be terminated at an application. There are some trade-offs to consider for each type of termination. Do you want end-to-end zero trust? If yes, that requires that both the client and server have Ziti identities and can connect securely with provisioned certificates. Do you want Ziti to provide end-to-end encryption? Developers can always provide their own end-to-end encryption on top of the connectivity that Ziti provides, but not all modes of service termination allow Ziti to encrypt traffic end-to-end for you. How accessible to non-zero-trust clients do you want your server application to be? With the proper configuration applications can be fully 'dark', meaning they do not listen for connections. SDK Embedded Applications The server application can embed the Ziti Edge SDK. The application will have an enrolled identity and provisioned certificates. This has several advantages: Connections between the application and Ziti will be secured using certificates. This enables true zero-trust and end-to-end encrypted connections betwen SDK based clients and SDK based servers. With an identity, the server application can particpate in the Ziti security model. This means you can control which services the application can provide, and revoke access as needed. You can also control which edge routers the application may connect to. The application will be 'dark'. Instead of listening for incoming network connections, the application will make an outgoing, secured connection to one or more Ziti edge routers. It will then receive network requests over these secured connections. The downside to this approach, specifically for existing applications, is that the application must be refactored to use a Ziti Edge SDK. Depending on language and frameworks used, the effort required can range from updating a few lines of code to writing a new SDK from scratch for a language that's not supported yet. Proxied Applications For applications where it doesn't make sense to embed the SDK a Ziti SDK based proxy can provide access to the application. Often the proxy may take the form of a sidecar and be co-located with the application. This minimizes the attack surface. There are a few things to note about this approach. The application will not be completely dark. It must accept connections from wherever the proxy is located. The proxy may be co-located with the application, so the attack surface area may be tiny. However, tiny is still bigger than zero. Similarly, traffic can be encrypted between the client and the proxy, but traffic between the proxy and the application will not be covered under the Ziti end-to-end encryption. It may still be encrypted, if the client and server establish their own encryption at the discretion of the client and server implementors. Via the proxy, the application is still represented by an identity and thus participates in policies. Services which use proxies for server side termination may require extra configuration, so that the proxing application knows how to connect to the server application. Service configurations are discussed more below. Ziti Router Terminated Services Routers also have the ability to connect to applications providing services. This approach has its own advantages and disadvantages. Like the proxy approach, the application cannot be completely dark. The application must be reachable from the Ziti router. Ziti currently only offers end-to-end encryption between two SDK applications. Sessions terminating at a router cannot be end-to-end encrypted by Ziti. The data may still be end-to-end encrypted by the client and server, but that is up to the client and server implementors. Summary Termination Type End-to-end Zero Trust Managed by Policies Ziti Provided End-to-end encryption Dark Server Application SDK Embedded Yes Yes Yes Yes SDK Based Proxy No, only to proxy Yes (via Proxy) Only to proxy. If desired, full end-to-end must be done externally No. Can be relatively locked down, though Ziti Router No No No. If desired, end-to-end must be done externally No. Can be relatively locked down, though. Terminators Terminators represent a way to connect to a specific server application for a specific service. For an SDK based server (whether embedded or proxied), these are created automatically as the application connects and removed when the application disconnects. For router terminated services they must be created manually. When creating a terminator manually, the following must be specified. The router which will connect to the server application The binding. This indicates which Xgress component on the router will handle making the connection. This will generally be transport for tcp based applications and udp for UDP based applications See the ziti-fabric documentation for more information on the Xgress framework The address to connect to. This will generally take the form <protocol>:<host or ip>:<port> Example: tcp:localhost:5432 Availability and Scaling Services can be made highly available and/or horizontally scalable. There are two kinds of availability that server applications need to concern themselves with. Router HA/Scaling The first is allowing multiple routers to connect to a single application. Multiple Routers This ensures that the application will still be able to service requests even if a router fails or there is network partition separating a router and server application. It also will help ensure that the router layer doesn't become a bottleneck, as more routers can be addeded as necessary to scale out connectivity. Finally, it provides multiple network paths to the application. This gives smart routing more to choose optimal routes from as network conditions change. Application HA/Scaling The second is application availabilty and/or scalability. There will often be multiple instances of a service application running, either for failover or in a load balanced deployment. Failover Deployment Horizontal Scale Deployment Xt All types of availability and scalability involve multiple terminators. What distinguishes an HA failover setup from a load-balanced horizontal scale setup is how new sessions are assigned to terminators. For failover, we want sessions to always go to the same service instance. For horizontal scale, we want to load balance sessions across available instances. The fabric contains a framework called Xt (eXtensible Terminators) which allows defining terminator strategies and defines how terminator strategies and external components integrate with smart routing. The general flow of terminator selection goes as follows: A client requests a new session for a service Smart routing finds all the active terminators for the session (active meaning the terminator's router is connected) Smart routing calculates a cost for each terminator then hands the service's terminator strategy a list of terminators and their costs ranked from lowest to highest The strategy returns the terminator that should be used A new session is created using that path. Strategies will often work by adjusting terminator costs. The selection algorithm then simply returns the lowest cost option presented by smart routing. Costs There are a number of elements which feed the smart routing cost algorithm. Route Cost The cost of the route from the initiating route to the terminator router will be included in the terminator cost. This cost may be influenced by things such as link latencies and user determined link costs. Static Cost Each terminator has a static cost which can be set or updated when the terminator is created. SDK applications can set the terminator cost when they invoke the Listen operation. Precedence Each terminator has a precedence. There are three precedence levels: required , default and failed . Smart routing will always rank terminators with higher precedence levels higher than terminators with lower precedence levers. So required terminators will always be first, default second and failed third. Precedence levels can be used to implement HA. The primary will be marked as required and the secondary as default. When the primary is determined to be down, either by some internal or external set of heuristics, it will be marked as Failed and new sessions will go to the secondary. When the primary recovers it can be bumped back up to Required. Dynamic Cost Each terminator also has a dynamic cost that will move a terminator up and down relative to its precedence. This cost can be driven by stratagies or by external components. A strategy might use number of active of open sessions or dial successes and failures to drive the dynamic cost. Effective Cost Each terminator has an associated precedence and dynamic cost. This can be reduced to a single cost. The cost algorithm ensures terminators at different precedence levels do not overlap. So a terminator which is marked failed, with dynamic cost 0, will always have a higher calculated cost than a terminator with default precedence and maximum value for dynamic cost. Strategies The fabric currently provides four strategy implementions. smartrouting This is the default strategy. It always uses the lowest cost terminator. It drives costs as follows: Cost is proportional to number of open sessions Dial failures drive the cost up Dial successes drive the cost down, but only as much as they were previously driven up by failures weighted This strategy drives costs in the same way as the smartrouting strategy. However instead of always picking the lowest cost terminator it does a weighted random selection across all terminators of the highest precedence. If a terminator has double the cost of another terminator it should get picked approximately half as often. random This strategy does not change terminator weights. It does simple random selection across all terminators of the highest precedence. Creating a Service Here's how you can create a service. New non-hosted Service via UI New hosted Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose Router by name - for example \"ziti-gw01\" if you are using Ziti Edge - Developer Edition For Endpoint Service choose: protocol = tcp host = actual-hostname port = 2222 Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Leave Hosting Identities as is Click save On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-hosted-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose \"Hosted (No Router)\" for the Router Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Select one or more identities in \"Hosting Identities\" representing the identities which host the service Click save To create a new service via CLI simply issue these commands: # creates a new service named ssh ziti edge create service ssh # creates a new service named ssh with a terminator strategy which load-balances using random selection ziti edge create service ssh --terminator-strategy random # creates a router based terminator for ssh on router router1 which connects to the local machine ziti edge create terminator ssh router1 tcp:localhost:22 # creates a new service named postgresql with a terminator strategy which does failover ziti edge create service postgresql --terminator-strategy ha # creates a router based terminator for postgres on router router1 # this is the posgres primary, so precedence is set to required ziti edge create terminator postgresql router1 tcp:pg-primary:5432 --precedence required # creates a router based terminator for postgres on router router1 which connects to another machine # this is the posgresql secondary, so precedence is left at default ziti edge create terminator postgresql router1 tcp:pg-secondary:5432 # If the primary goes down, the controller will notice that dials are failing and set the # precedence to failed. New sessions will go to the secondary. When the primary is brought # back up, it can be marked as requred again ziti edge update terminator <terminator-id> --precedence required"
  },
  "ziti-android-app/CODE_OF_CONDUCT.html": {
    "href": "ziti-android-app/CODE_OF_CONDUCT.html",
    "title": "Code of Conduct | Ziti",
    "keywords": "Code of Conduct All open source projects managed by NetFoundry share a common code of conduct which all contributors are expected to follow. Please be sure you read, understand and adhere to the thoughts expressed therein. Individuals acting in any way that is considered in violation of the Code of Conduct will receive corrective actions appropriate for the violation. It is possible to act in ways which technically do not violate the Code of Conduct but are clearly against the spirit of the project. These situations will also be considered on a case by case basis and if necessary the Code of Conduct will be revised accordingly and approrpiate notifications will be made to the community and to the violator. Violations Contributors violating the Code of Conduct will receive public notification of the violation. Contined violations or aggregious violations of the Code of Conduct will result in the contributor being removed from the contributors list as well as further contributions being declined."
  },
  "ziti-android-app/CONTRIBUTING.html": {
    "href": "ziti-android-app/CONTRIBUTING.html",
    "title": "Contributing | Ziti",
    "keywords": "Contributing NetFoundry welcomes all and any contributions. All open source projects managed by NetFoundry share a common guide for contributions . If you are eager to contribute to a NetFoundry-managed open source project please read and act accordingly."
  },
  "ziti-android-app/README.html": {
    "href": "ziti-android-app/README.html",
    "title": "Ziti Android Quickstart | Ziti",
    "keywords": "Ziti Android Quickstart This is a simple app that demonstrates the use of Ziti SDK for Android (and Java). Prerequisites Android studio or other Android IDE Android simulator or device to run the app Running the app Create Ziti Network following the guide Create a service that is used by this app: name = ziti-weather-service hostname = wttr.ziti port = 80 endpoint host = wttr.in endpoint port = 80 endpoint protocol = tcp Create an identity for the device running this. You'll need one identity per device. You will need to configure access to the service for your new identity. Download enrollment JWT and copy it to the device. Once the app starts it will show notification to let user know that the app has not been enrolled Tapping the notification allows you to select enrollent token If enrollment is successful it shows shows notification on the screen After that the app can be used -- pushing the message button should load current weather for Charlotte on the screen"
  },
  "ziti-cmd/quickstart/aws.html": {
    "href": "ziti-cmd/quickstart/aws.html",
    "title": "Content moved | Ziti",
    "keywords": "Content moved This content has been moved to the official doc repository. Find it at https://openziti.github.io/ziti/quickstarts/quickstart-overview.html"
  },
  "ziti-cmd/quickstart/docker/README.html": {
    "href": "ziti-cmd/quickstart/docker/README.html",
    "title": "Building and Deploying the Latest Quickstart Docker Image | Ziti",
    "keywords": "Building and Deploying the Latest Quickstart Docker Image Build Docker Image for Local Dev (probably for docker-compose testing) change to this directory: cd quickstart/docker run the script ./buildLocalDev.sh which will create a openziti/quickstart:dev tag update .env and change the value for ZITI_VERSION to dev run docker-compose as normal Build Docker Image For Publication change to this directory: cd quickstart/docker set an environment variable: export ZITI_HOME=$(pwd) source the helper script: source ../ziti-cli-functions.sh cleanup the binary directory if it exists: rm -rf ./image/ziti.ignore issue this function to pull the latest ziti binaries: getLatestZiti move the ziti binaries: mv ziti-bin/ziti image/ziti.ignore/ build the docker image: docker build image -t openziti/quickstart exec into a container and make sure it's the version you expect: docker run --rm -it openziti/quickstart ziti version cleanup: rm ziti-*tar.gz; rm -rf ziti-bin Push Docker Image to dockerhub source ./image/ziti-cli-functions.sh just run ./pushLatestDocker.sh"
  },
  "ziti-cmd/quickstart/kubernetes/sidecar-tunnel/kubernetes-sidecar-tunnel-quickstart.html": {
    "href": "ziti-cmd/quickstart/kubernetes/sidecar-tunnel/kubernetes-sidecar-tunnel-quickstart.html",
    "title": "Kubernetes Sidecar Client | Ziti",
    "keywords": "Kubernetes Sidecar Client This guide shows you how to access a Ziti service from a pre-existing (or third party) application that's running in a Kubernetes Pod. To provide access to the service, we will deploy the ziti-tunnel client in a sidecar container. Overview The Ziti Network Quickstart walked you through standing up a Ziti instance and accessing a Ziti service from your workstation with ziti-tunnel . In this guide we'll deploy the same ziti-tunnel client, but instead of running it from the command line we will deploy it in a sidecar container in a Kubernetes Pod. This guide also demonstrates ziti-tunnel 's internal DNS server, which allows us to access Ziti services by hostname instead of IP address. Here's some detail on how the various intercept modes work on Linux Solution Overview Prerequisites Complete the Ziti Network Quickstart . This guide uses the Ziti Controller and Ziti Edge Router that are created in the Ziti Quickstart. Admin-level access to a Kubernetes cluster via kubectl . Create an Identity and AppWAN This guide will re-use the \"eth0.ziti.cli\" service that was created in the Ziti Network Quickstart. We will create a new identity for our client, with a new AppWAN that uses the eth0.ziti.cli service. Create the Identity: ziti edge controller create identity device tunnel-sidecar -o tunnel-sidecar.jwt Create the AppWAN and reference the service created in the Ziti Network Quickstart. We'll be using eth0.ziti.cli here but if you created eth0.ziti.ui in the quickstart - use that instead. Also note that in the tunnel-sidecar-demo.yaml: ziti edge controller create app-wan ziti-tunnel-appwan -i tunnel-sidecar -s eth0.ziti.cli Create a Kubernetes Secret The ziti-tunnel sidecar will access its identity by mounting a Kubernetes secret in the container. We can mount the JWT as a secret like this: $ kubectl create secret generic tunnel-sidecar.jwt --from-file=tunnel-sidecar.jwt secret/tunnel-sidecar.jwt created Deploy the Pod Deploy a Pod that runs a client application and ziti-tunnel as a sidecar container. For this demonstration, the client application is curl . Our Pod runs curl in a loop so we can see content from our Ziti service in the Pod's logs. Save the following yaml to a file named tunnel-sidecar-demo.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: tunnel-sidecar-pv-claim spec: accessModes: - ReadWriteOnce resources: requests: storage: 100Mi --- apiVersion: apps/v1 kind: Deployment metadata: name: ziti-tunnel-sidecar-demo spec: replicas: 1 selector: matchLabels: app: ziti-tunnel-sidecar-demo strategy: type: Recreate template: metadata: labels: app: ziti-tunnel-sidecar-demo spec: containers: - image: centos name: testclient command: [\"sh\",\"-c\",\"while true; set -x; do curl -sSLf eth0.ziti.cli 2>&1; set +x; sleep 5; done\"] - image: netfoundry/ziti-tunnel:latest name: ziti-tunnel env: - name: NF_REG_NAME value: tunnel-sidecar volumeMounts: - name: tunnel-sidecar-jwt mountPath: \"/var/run/secrets/kubernetes.io/enrollment-token\" readOnly: true - name: ziti-tunnel-persistent-storage mountPath: /netfoundry securityContext: capabilities: add: - NET_ADMIN dnsPolicy: \"None\" dnsConfig: nameservers: - 127.0.0.1 - 8.8.8.8 restartPolicy: Always volumes: - name: ziti-tunnel-persistent-storage persistentVolumeClaim: claimName: tunnel-sidecar-pv-claim - name: tunnel-sidecar-jwt secret: secretName: tunnel-sidecar.jwt You'll notice that the ziti-tunnel sidecar container has a few requirements: The name of the identity that is assumed by ziti-tunnel must be passed into the container with the NF_REG_NAME environment variable. The secret that we created above for the enrollment token must be mounted into the container at \"/var/run/secrets/netfoundry.io/enrollment-token\". A persistent volume must be mounted at \"/netfoundry\". This volume is used to save the json file that is created when the one-time enrollment token is used. If this volume is not persistent, you will need to provide a new enrollment token each time the Pod is restarted! Once the yaml is saved, we can deploy the Pod with kubectl $ kubectl apply -f ./tunnel-sidecar-demo.yaml persistentvolumeclaim/tunnel-sidecar-pv-claim created deployment.apps/ziti-tunnel-sidecar-demo created Test the Service First we need to get the name of the Pod that Kubernetes deployed for us: $ kubectl get pods ziti-tunnel-sidecar-demo-749c476989-6wpfn 1/1 Running 0 42s Then we can tail the logs for the \"testclient\" container: $ kubectl logs -f ziti-tunnel-sidecar-demo-749c476989-6wpfn --container testclient 54.67.121.213 54.67.121.213 54.67.121.213 Notice that the curl client is using the DNS name that we provided in the Ziti service definition to make the request."
  },
  "ziti-cmd/quickstart/README.html": {
    "href": "ziti-cmd/quickstart/README.html",
    "title": "Quickstart | Ziti",
    "keywords": "Quickstart This directory contains a set of scripts designed to make it easy to establish a starter overlay network. The expectation is that these scripts and docker image are useful for learning or for establishing simple networks. As with any solution it is common for additional changes to the configuration to be required after expanding beyond the initial setup. There are three different modes contained in these folders. One mode allows you very quickly get setup and run the two main components of a Ziti network: ziti-controller and ziti-router. The Express configuration will guide you here. The remaining two modes all use docker to establish environments. The first of the docker-based quickstarts uses docker-compose . You will find a fully defined Ziti Network in a compose file which should allow you to understand better and learn how multiple routers can be linked to form a mesh network or serve as an initial template to build your own compose file from. Lastly, you can choose to run docker directly. This mode is necessarily more verbose but should you prefer to not use docker-compose it can also illustrate how to establish a Ziti Network piece by piece. Prerequisites Bash All of these quickstarts will use bash. On MacOS/linux this will be natural however on Windows you'll want to ensure you have a suitable shell. There are numerous shells available but perhaps the simplest will be to use Windows Subsystem for Linux (WSL) . You might also use git-bash, cygwin, or any other bash shell you fancy. Docker/Docker Compose If you are interested in using the quickstarts which use docker/docker-compose you will clearly need to have one or both installed and be moderately familiar with whichever you are using. Review All Scripts Remember - it's always a good idea to review any scripts before you run them. We encourage you to review the scripts in these folders before running them. Express By far the easiest way to establish an environment quickly is to simply run the express install script found at ./quickstart/local/express/express-dev-env.sh . What It Does The express install script will do quite a few things to get you bootstrapped. It will: create a full suite of configuration files located by default at ~/.ziti/quickstart/$(hostname) create a full suite of PKI create a config file for the controller create a config file for an edge router download the latest distribution of ziti from github.com/openziti/ziti/releases unzip the distribution start the ziti-controller and ziti-router executables the ziti-controller should now be exposed on https://$(hostname):1280 Docker - Compose The docker-compose based example will create numerous ziti-router s as well as spooling up a ziti-controller and expose the controller on port 1280. This configuration is intended to look and feel like the following image: Here, a simple Ziti Network is shown which contains two public Ziti Edge Routers, one router without the \"edge\" enabled and usable only for transit, and two private edge routers: one blue, one red. The goal with this setup is to attempt to have a single isolated service that is not accessible from outside of the blue network (as best as possible with only docker). Docker - No Compose You can still startup a dev environment easily with docker only. In this example you will start a Ziti Controller as well as a single Ziti Edge Router. Prerequisite Since the openziti project is all about creating overlay networks - it's important for the docker containers to be able to communicate to one another. This is accomplished using a docker network and setting the alias of the container on that docker network. Before running the commands below please do the following: #declare a variable that defines the 'network' zitinw=\"myZitiNetwork\" #declare a fully qualified path to the location you want your shared files to go and create it zitinw_shared=\"${HOME}/.ziti/dockerenvs/${zitinw}\" mkdir -p \"${zitinw_shared}\" #make a docker network for isolation while allowing the parts to be able to interact docker network create \"$zitinw\" Starting the Containers To start the containers you can simply run these two commands in two different shells. (or choose to daemonize them once you're ready to do so). Take special note of the initial variables used in these commands. The ${zitinw} variable is expected to be set. See the Prerequisite section above: Ziti Controller: docker run -d --name \"${zitinw}-controller\" --volume \"${zitinw_shared}\":/openziti/shared -it --network=\"${zitinw}\" --network-alias=ziti-controller --network-alias=ziti-edge-controller --rm openziti/quickstart /openziti/scripts/run-controller.sh Ziti Edge Router: routerName=edge-router; docker run -d --name \"${zitinw}-${routerName}\" --rm -e ZITI_EDGE_ROUTER_RAWNAME=\"${routerName}\" --volume \"${zitinw_shared}\":/openziti/shared -it --network=\"${zitinw}\" --hostname \"${routerName}\" --network-alias=\"${routerName}\" --rm openziti/quickstart /openziti/scripts/run-router.sh edge"
  }
}