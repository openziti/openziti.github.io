"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[169],{1623:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"reference/ha/overview","title":"Controller Clustering","description":"Overview","source":"@site/docs/reference/ha/overview.md","sourceDirName":"reference/ha","slug":"/reference/ha/overview","permalink":"/docs/reference/ha/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/openziti/ziti-doc/tree/main/docusaurus/docs/reference/ha/overview.md","tags":[],"version":"current","lastUpdatedAt":1744078133000,"sidebarPosition":5,"frontMatter":{"sidebar_label":"Overview","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Router","permalink":"/docs/reference/configuration/router"},"next":{"title":"Overview","permalink":"/docs/reference/ha/bootstrapping/overview"}}');var o=t(74848),i=t(28453);const l={sidebar_label:"Overview",sidebar_position:5},s="Controller Clustering",a={},c=[{value:"Overview",id:"overview",level:2},{value:"What Do Controllers Do?",id:"what-do-controllers-do",level:3},{value:"Data Model",id:"data-model",level:4},{value:"Establish Routes",id:"establish-routes",level:4},{value:"Why Cluster Controllers?",id:"why-cluster-controllers",level:3},{value:"For SDK Clients/Tunnelers",id:"for-sdk-clientstunnelers",level:3},{value:"For Management Operations",id:"for-management-operations",level:3},{value:"Glossary",id:"glossary",level:3},{value:"Distributed Journal",id:"distributed-journal",level:4},{value:"Leader",id:"leader",level:4},{value:"Voting",id:"voting",level:4},{value:"Non-Voting Members",id:"non-voting-members",level:4},{value:"Limitations",id:"limitations",level:3},{value:"Quickstart",id:"quickstart",level:2}];function d(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"controller-clustering",children:"Controller Clustering"})}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(n.admonition,{type:"warning",children:[(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"NOTE: Controller HA is still in Beta"})}),(0,o.jsx)(n.p,{children:"It's quite functional now, but we are continuing to test and refine before we mark it GA."})]}),"\n",(0,o.jsx)(n.h3,{id:"what-do-controllers-do",children:"What Do Controllers Do?"}),"\n",(0,o.jsx)(n.p,{children:"OpenZiti controllers have two primary functions."}),"\n",(0,o.jsx)(n.h4,{id:"data-model",children:"Data Model"}),"\n",(0,o.jsx)(n.p,{children:"Controller maintain the data model, which tracks services, routers, policies, etc. They provide\nthis information to sdk clients, tunnelers and routers so that those applications know what\ntheir capabilities are."}),"\n",(0,o.jsx)(n.h4,{id:"establish-routes",children:"Establish Routes"}),"\n",(0,o.jsx)(n.p,{children:"Controllers establish routes for services on the behalf of clients and routers. They also\nupdate routes when better paths are available or when network topology changes, i.e. a link\nis broken or a router goes down."}),"\n",(0,o.jsx)(n.h3,{id:"why-cluster-controllers",children:"Why Cluster Controllers?"}),"\n",(0,o.jsx)(n.p,{children:"Every SDK client and tunneler adds load to controllers. It's important to be able to add\ncontrollers to ensure good performance for clients."}),"\n",(0,o.jsx)(n.p,{children:"Additionally, having a single controller means that the network has a single point of failure.\nHaving multiple controllers helps ensure that the network is available in the face up\nupgrades, hardware or network failures and other unexpected failure conditions."}),"\n",(0,o.jsx)(n.p,{children:"Having multiple controllers also allows network operators to place controllers geographically\nclose to clusters of clients to reduce latency."}),"\n",(0,o.jsx)(n.h3,{id:"for-sdk-clientstunnelers",children:"For SDK Clients/Tunnelers"}),"\n",(0,o.jsx)(n.p,{children:"A controller cluster offers the following advantages:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Horizontal scaling of SDK client services such as","\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Service lookups"}),"\n",(0,o.jsx)(n.li,{children:"Session creation"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Horizontal scaling of circuit creation"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This means that for everything that SDK clients and tunnelers depend on, controllers\ncan be scaled out and placed strategically to meet user demand."}),"\n",(0,o.jsx)(n.h3,{id:"for-management-operations",children:"For Management Operations"}),"\n",(0,o.jsx)(n.p,{children:"The HA controller cluster makes the data model available on all controllers in the cluster.\nThis means that clients can connect to any controller and be able to function.\nUpdates require coordination, so a minimum number of controllers are required to be\nup and connected for updates to work."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Every controller has the full data model, so reads don't require any coordination"}),"\n",(0,o.jsx)(n.li,{children:"If a controller is disconnected from the cluster while updates are happening, reads\nto that controller will return stale data. As soon as the controller reconnects, the\ndata model on that controller will catch up the current state."}),"\n",(0,o.jsx)(n.li,{children:"Update operations require that the cluster has a leader and that more than half of the\ncontrollers are up and able to communicate with each other."}),"\n",(0,o.jsx)(n.li,{children:"Updates can be initiated on any controller, they will be forwarded to the leader to\nbe applied."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"glossary",children:"Glossary"}),"\n",(0,o.jsx)(n.h4,{id:"distributed-journal",children:"Distributed Journal"}),"\n",(0,o.jsx)(n.p,{children:"OpenZiti uses a distributed journal to keep the data model in sync across controllers."}),"\n",(0,o.jsx)(n.p,{children:"Specifically, it uses the RAFT protocol."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Resources"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://raft.github.io/",children:"Raft Overview"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"http://thesecretlivesofdata.com/raft/",children:"Understanding Raft"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/hashicorp/raft",children:"Raft Implementation used by OpenZiti"})}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"leader",children:"Leader"}),"\n",(0,o.jsx)(n.p,{children:"The cluster leader is in charge of coordinating updates to the data model. The cluster\nhandles leader selection on its own. The cluster will hold elections to select the\nleader and leadership will move from node to node."}),"\n",(0,o.jsx)(n.p,{children:"If the leader goes down, a new leader will be elected."}),"\n",(0,o.jsx)(n.h4,{id:"voting",children:"Voting"}),"\n",(0,o.jsx)(n.p,{children:"Raft Clusters have voting and non-voting members. The more voting members a cluster has, the\nmore voting members can be off-line while still accepting updates."}),"\n",(0,o.jsx)(n.p,{children:"Only voting members may be elected to cluster leader."}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A cluster with one voting member (which is allowed) can have no members down"}),"\n",(0,o.jsx)(n.li,{children:"A cluster with three voting members can have one member down"}),"\n",(0,o.jsx)(n.li,{children:"A cluster with five voting members can have two members down"}),"\n",(0,o.jsx)(n.li,{children:"A cluster with seven voting members can have three members down"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The general formula is that a cluster with N voting members must have (N/2)+1 voting members\nup and connected in order to elect a leader and accept updates to the data model."}),"\n",(0,o.jsx)(n.h4,{id:"non-voting-members",children:"Non-Voting Members"}),"\n",(0,o.jsx)(n.p,{children:"If more voting members means better availability, why not make all members voting?"}),"\n",(0,o.jsx)(n.p,{children:"The more members a leader has to coordinate with to accept a data model update, the longer the\nupdate may take. Once the network has enough voting members to meet the uptime SLAs, other\nmembers add for performance reasons should be made non-voting members."}),"\n",(0,o.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,o.jsx)(n.p,{children:"The following limitations currently apply:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Circuits are owned by a controller. If the controller goes down, the circuit\nwill remain up, but can't be re-routed for performance or if a router goes down.\nThis matches the behavior of circuits on a network with a standalone controller."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"For a controller to route circuits on a router, that router must be connected\nto that controller. This means that routers should generally be connected to\nall controllers."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Improving routing is an ongoing focus for the OpenZiti project.\nIssues related to routing improvments can be found on the ",(0,o.jsx)(n.a,{href:"https://github.com/orgs/openziti/projects/13/views/1",children:"Routing Project Board"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"quickstart",children:"Quickstart"}),"\n",(0,o.jsxs)(n.p,{children:["The quickstart supports running in clustered mode, see\n",(0,o.jsx)(n.a,{href:"https://github.com/openziti/ziti/blob/main/doc/ha/quickstart.md",children:"this guide for more information"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var r=t(96540);const o={},i=r.createContext(o);function l(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);