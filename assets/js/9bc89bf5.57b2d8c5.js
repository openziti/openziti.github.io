"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[1349],{59595:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"reference/ha/operations","title":"Operating a Controller Cluster","description":"Cluster Management APIs","source":"@site/docs/reference/ha/operations.md","sourceDirName":"reference/ha","slug":"/reference/ha/operations","permalink":"/docs/reference/ha/operations","draft":false,"unlisted":false,"editUrl":"https://github.com/openziti/ziti-doc/tree/main/docusaurus/docs/reference/ha/operations.md","tags":[],"version":"current","lastUpdatedAt":1743027677000,"sidebarPosition":50,"frontMatter":{"sidebar_label":"Operations","sidebar_position":50},"sidebar":"docsSidebar","previous":{"title":"Routers","permalink":"/docs/reference/ha/routers"},"next":{"title":"Topology","permalink":"/docs/reference/ha/topology"}}');var s=t(74848),o=t(28453);const a={sidebar_label:"Operations",sidebar_position:50},i="Operating a Controller Cluster",l={},c=[{value:"Cluster Management APIs",id:"cluster-management-apis",level:2},{value:"REST Operations",id:"rest-operations",level:3},{value:"IPC Operations",id:"ipc-operations",level:3},{value:"Growing the Cluster",id:"growing-the-cluster",level:2},{value:"From An Existing Node",id:"from-an-existing-node",level:3},{value:"From A New Node",id:"from-a-new-node",level:3},{value:"Shrinking the Cluster",id:"shrinking-the-cluster",level:2},{value:"Restoring from Backup",id:"restoring-from-backup",level:2},{value:"Snapshot Application and Restarts",id:"snapshot-application-and-restarts",level:2},{value:"Events",id:"events",level:2},{value:"Metrics",id:"metrics",level:2},{value:"Open Ports",id:"open-ports",level:2},{value:"System of Record",id:"system-of-record",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"operating-a-controller-cluster",children:"Operating a Controller Cluster"})}),"\n",(0,s.jsx)(n.h2,{id:"cluster-management-apis",children:"Cluster Management APIs"}),"\n",(0,s.jsx)(n.p,{children:"A cluster can be managed via the REST endpoint and via the IPC agent."}),"\n",(0,s.jsx)(n.h3,{id:"rest-operations",children:"REST Operations"}),"\n",(0,s.jsxs)(n.p,{children:["The REST operations can be invoked remotely using the ",(0,s.jsx)(n.code,{children:"ziti"})," CLI as long as the\nthe CLI is logged in."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'$ ziti ops cluster \nController cluster operations\n\nUsage:\n  ziti ops cluster [flags]\n  ziti ops cluster [command]\n\nAvailable Commands:\n  add                 add cluster member\n  list                list cluster members and their status\n  remove              remove cluster member\n  transfer-leadership transfer cluster leadership to another member\n\nFlags:\n  -h, --help   help for cluster\n\nUse "ziti ops cluster [command] --help" for more information about a command.\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ipc-operations",children:"IPC Operations"}),"\n",(0,s.jsx)(n.p,{children:"The IPC versions can be invoked via the CLI and don't require any authentication,\nbut need to be run on the same machine as the controller, by a user with access\nto the IPC pipe."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'$ ziti agent cluster\nManage an HA controller cluster using the IPC agent\n\nUsage:\n  ziti agent cluster [flags]\n  ziti agent cluster [command]\n\nAvailable Commands:\n  add                 adds a node to the controller cluster\n  init                Initializes a cluster with a default administrator\n  list                lists the nodes in the controller cluster\n  remove              removes a node from the controller cluster\n  restore-from-db     Restores a cluster to the state in the given database snapshot\n  transfer-leadership triggers a new leader election in the controller cluster, optionally selecting a new preferred leader\n\nFlags:\n  -h, --help   help for cluster\n\nUse "ziti agent cluster [command] --help" for more information about a command.\n'})}),"\n",(0,s.jsx)(n.h2,{id:"growing-the-cluster",children:"Growing the Cluster"}),"\n",(0,s.jsx)(n.p,{children:"After at least one controller is running as part of a cluster and initialized,\nadditional nodes may be added to the cluster. Additional nodes should be configured\nsimilarly to the initial node, though advertise addresses will vary."}),"\n",(0,s.jsxs)(n.p,{children:["Assume a network where the first node has been initialized, and is available at ",(0,s.jsx)(n.code,{children:"ctrl1.ziti.example.com:1280"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If the second node is running at ",(0,s.jsx)(n.code,{children:"ctrl2.ziti.example.com:1280"}),", then it can be added to the\ncluster in one of two ways."]}),"\n",(0,s.jsx)(n.h3,{id:"from-an-existing-node",children:"From An Existing Node"}),"\n",(0,s.jsx)(n.p,{children:"From a node already in the cluster, in this case the initial node, the new node can be added as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"user@node1$ ziti agent cluster add tls:ctrl2.ziti.example.com:1280\n"})}),"\n",(0,s.jsx)(n.h3,{id:"from-a-new-node",children:"From A New Node"}),"\n",(0,s.jsx)(n.p,{children:"The new node, which is not yet part of the cluster, can also be directed to reach\nout to an existing cluster node and request to be joined."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"user@node2$ ziti agent cluser add tls:ctrl1.ziti.example.com:1280\n"})}),"\n",(0,s.jsx)(n.h2,{id:"shrinking-the-cluster",children:"Shrinking the Cluster"}),"\n",(0,s.jsx)(n.p,{children:"From any node in the cluster, nodes can be removed as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"user@node1$ ziti agent cluster remove ctrl2\n"})}),"\n",(0,s.jsx)(n.h2,{id:"restoring-from-backup",children:"Restoring from Backup"}),"\n",(0,s.jsx)(n.p,{children:"To restore from a database snapshot, use the following CLI command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ziti agent controller restore-from-db /path/to/backup.db\n"})}),"\n",(0,s.jsx)(n.p,{children:"As this is an agent command, it must be run on the same machine as the controller. The path\nprovided will be read by the controller process, not the CLI."}),"\n",(0,s.jsx)(n.p,{children:"The controller will apply the snapshot and then terminate. All controllers in the cluster will\nterminate and expect to be restarted. This is so in memory caches won't be out of sync with\nthe database which has changed."}),"\n",(0,s.jsx)(n.h2,{id:"snapshot-application-and-restarts",children:"Snapshot Application and Restarts"}),"\n",(0,s.jsx)(n.p,{children:"If a controller is out of communcation for a while, it may receive a snapshot to apply, rather\nthan a stream of events."}),"\n",(0,s.jsx)(n.p,{children:"If a controller receives a snapshot to apply after startup is complete, it will apply the snapshot and then\nterminate. This assumes that there is a process manager to restart controller after it terminates."}),"\n",(0,s.jsx)(n.p,{children:"This should only happen if a controller is connected to the cluster and then gets disconnected for\nlong enough that a snapshot is created while it's disconnected. Because applying a snapshot requires\nreplacing the underlying controller bolt DB, the easiest way to do that is restart. That way the\ncontroller don't have to worry about replacing the bolt DB underneath a running system."}),"\n",(0,s.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,s.jsxs)(n.p,{children:["All events now contain a ",(0,s.jsx)(n.code,{children:"event_src_id"})," to indicate which controller emitted them."]}),"\n",(0,s.jsxs)(n.p,{children:["There are some new events which are specific to clusters. See ",(0,s.jsx)(n.a,{href:"../events#cluster",children:"Cluster Events"}),"\nfor more detail."]}),"\n",(0,s.jsx)(n.h2,{id:"metrics",children:"Metrics"}),"\n",(0,s.jsxs)(n.p,{children:["In an HA system, routers will send metrics to all controllers to which they are connected. There is\na new ",(0,s.jsx)(n.code,{children:"doNotPropagate"})," flag in the metrics message, which will be set to false until the router has\nsuccessfully delivered the metrics message to a controller. The flag will then be set to true. So\nthe first controller to get the metrics message is expected to deliver the metrics message to the\nevents system for external integrators. The other controllers will have ",(0,s.jsx)(n.code,{children:"doNotPropage"})," set to true,\nand will only use the metrics message internally, to update routing data."]}),"\n",(0,s.jsx)(n.h2,{id:"open-ports",children:"Open Ports"}),"\n",(0,s.jsx)(n.p,{children:"Controllers now establish connections with each other, for two purposes."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Forwarding model updates to the leader, so they can be applied to the distributed journal"}),"\n",(0,s.jsx)(n.li,{children:"distributed journal communication"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Both kinds of traffic flow over the same connection."}),"\n",(0,s.jsx)(n.p,{children:"These connections do not require any extra open ports as the controller uses the control channel listener\nto listen to both router and controller connections. As part of the connection process the\nconnection type is provided and the appropriate authentication and connection setup happens based on\nthe connection type. If no connection type is provided, it's assumed to be a router."}),"\n",(0,s.jsx)(n.h2,{id:"system-of-record",children:"System of Record"}),"\n",(0,s.jsx)(n.p,{children:"In a controller that's not configured for HA, the bolt database is the system of record. In an HA\nsetup, the distributed journal (managed via RAFT) is the system of record. The raft journal is\nstored in two places, a snapshot directory and a bolt database of raft journal entries."}),"\n",(0,s.jsx)(n.p,{children:"So a non-HA setup will have:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ctrl.db"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"An HA setup will have:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"raft.db - the bolt database containing Raft journal entries"}),"\n",(0,s.jsx)(n.li,{children:"snapshots/ - a directory containing Raft snapshots. Each snapshot is snapshot of the controller\nbolt db"}),"\n",(0,s.jsx)(n.li,{children:"ctrl.db - the controller bolt db, with the current state of the model"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The location of all three is controlled by the ",(0,s.jsx)(n.a,{href:"../configuration/controller#cluster",children:"cluster/dataDir"})," config property."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"raft:\n  dataDir: /var/lib/ziti/controller/\n"})}),"\n",(0,s.jsx)(n.p,{children:"When an HA controller starts up, it will first apply the newest snapshot, then any newer journal\nentries that aren't yet contained in a snapshot. This means that an HA controller should start with\na blank DB that can be overwritten by snapshot and/or have journal entries applied to it. So an HA\ncontroller will delete or rename the existing controller database and start with a fresh bolt db."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(96540);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);