"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[13891],{31822:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var a=t(69088),o=t(74848),s=t(28453);const i={title:"Golang Aha! Moments: OOP",date:new Date("2024-11-01T14:05:06.000Z"),cuid:"cm2yt3p2r000109kzfpv88qvp",slug:"golang-aha-moments-oop",authors:["PaulLorenz"],image:"@site/blogs/openziti/v1730383460910/9b2d0062-8b76-47c6-b68d-24810fca9f8b.webp",imageDark:"@site/blogs/openziti/v1730383460910/9b2d0062-8b76-47c6-b68d-24810fca9f8b.webp",tags:["golang","java","object-oriented-programming","golang-aha"]},r="Is Go Object Oriented?",c={authorsImageUrls:[void 0]},l=[{value:"Inheritance vs Composition",id:"inheritance-vs-composition",level:3},{value:"Fun with functions: Nil Receivers",id:"fun-with-functions-nil-receivers",level:3},{value:"Handle different types with a common set of methods",id:"handle-different-types-with-a-common-set-of-methods",level:2},{value:"Duck(-ish) Typing",id:"duck-ish-typing",level:3},{value:"Package Coherency",id:"package-coherency",level:3},{value:"Requiring Type Interface Conformance",id:"requiring-type-interface-conformance",level:3},{value:"Fun with functions: Function Vs Interface",id:"fun-with-functions-function-vs-interface",level:3},{value:"Extending Interfaces",id:"extending-interfaces",level:3},{value:"Anonymous Interfaces",id:"anonymous-interfaces",level:3},{value:"We Want to Share Functionality Across Types",id:"we-want-to-share-functionality-across-types",level:2},{value:"Method Overriding vs Method Shadowing",id:"method-overriding-vs-method-shadowing",level:3},{value:"I Want Abstract Types!",id:"i-want-abstract-types",level:3},{value:"The Wrong Way",id:"the-wrong-way",level:3},{value:"A Better Way",id:"a-better-way",level:3},{value:"Strategies",id:"strategies",level:4},{value:"About OpenZiti",id:"about-openziti",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Moving to Go as my primary development language was a surprisingly easy transition. Coming from a language with strong OOP roots, like Java, I quickly found many analogs for the OOP constructs I was used to, but also had to adjust my thinking."}),"\n",(0,o.jsx)(n.p,{children:"This article walks through some of Go\u2019s object oriented features and also discusses how some patterns common in other languages can be written in a way that\u2019s closer to idiomatic Go. It also covers some features of Go that surprised and (in some cases) delighted me."}),"\n",(0,o.jsx)(n.p,{children:"Go allows you to group data into structs, and to associate logic to those structs."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'type Beans struct {\n    Count int\n}\n\nfunc (beans *Beans) Spill(n int) {\n    beans.Count = beans.Count - n\n    fmt.Printf("spilled %d beans\\n", n)\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Since Go supports these simple features, it meets certain bare-minimum standard for object oriented coding."}),"\n",(0,o.jsx)(n.p,{children:"However, as we\u2019ll cover below, many features like inheritance, method overriding, and abstract types work differently or not at all."}),"\n",(0,o.jsx)(n.h3,{id:"inheritance-vs-composition",children:"Inheritance vs Composition"}),"\n",(0,o.jsx)(n.p,{children:"Even in languages with a strong object oriented bias, people often give the advice to favor composition over inheritance. Large complicated type hierarchies can lead to fragile designs and unexpected behavior."}),"\n",(0,o.jsx)(n.p,{children:"Go is strongly biased towards composition. This, in my experience, leads to cleaner, simpler designs, that are easier to refactor and have less surprising behavior."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note:"})," Most of the patterns explored below aren\u2019t exclusive to Go. Go just encourages them more than other languages may."]}),"\n",(0,o.jsx)(n.h3,{id:"fun-with-functions-nil-receivers",children:"Fun with functions: Nil Receivers"}),"\n",(0,o.jsxs)(n.p,{children:["One difference from languages like Java, is that a nil receiver is allowed and can be handled in Go code. This is the equivalent of being able to call a method on a ",(0,o.jsx)(n.code,{children:"null"})," object in Java without a ",(0,o.jsx)(n.code,{children:"NullPointerException"})," and have the method check if ",(0,o.jsx)(n.code,{children:"this"})," is null."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'type Beans struct {\n    Count int\n}\n\nfunc (beans *Beans) Spill(n int) {\n    if beans == nil {\n        fmt.Printf("you\'ve got no beans to spill!\\n")\n     } else {    \n        beans.Count = beans.Count - n\n        fmt.Printf("spilled %d beans\\n", n)\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h1,{id:"what-do-we-want-to-do",children:"What do we want to do?"}),"\n",(0,o.jsx)(n.p,{children:"Rather than just look at language features, we\u2019re going to look at what we\u2019re trying to accomplish. Then we can see how to achieve our goals in Go, and how that might be different than a pure object-oriented approach."}),"\n",(0,o.jsx)(n.h2,{id:"handle-different-types-with-a-common-set-of-methods",children:"Handle different types with a common set of methods"}),"\n",(0,o.jsx)(n.p,{children:"For polymorphic types, Go uses interfaces."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'type Spillable interface {\n    Spill(amount int)\n}\n\ntype Beans struct {\n    Count int\n}\n\nfunc (beans *Beans) Spill(n int) {\n    beans.Count = beans.Count - n\n    fmt.Printf("spilled %d beans\\n", n)\n}\n\ntype Tea struct {\n    Volume int\n}\n\nfunc (t *Tea) Spill(n int) {\n    t.Volume = t.Volume - n\n    fmt.Printf("spilled %d ml of tea\\n", n)\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["You may have noticed that the types don\u2019t have to declare that they are ",(0,o.jsx)(n.code,{children:"Spillable"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"duck-ish-typing",children:"Duck(-ish) Typing"}),"\n",(0,o.jsx)(n.p,{children:"Unlike many other languages, Go types do not have to explicitly state which interfaces they implement. If the type has the correct methods, it can be used as that interface type."}),"\n",(0,o.jsx)(n.p,{children:"I\u2019m not sure if it\u2019s accurate to call this duck typing, since you still need to define interfaces. But from where I\u2019m standing, it looks a lot like duck typing and sounds like duck typing, so I\u2019m going to call it duck typing."}),"\n",(0,o.jsx)(n.p,{children:"This focuses the attention on where the interface is used, not where it\u2019s implemented. In cases where a type is used in multiple contexts, Go pushes you towards multiple interfaces, one for each context. In other languages, I\u2019ve seen types end up with one massive interface, covering all the possible contexts where it might be needed."}),"\n",(0,o.jsx)(n.p,{children:"Consider an HR application. It might have various entities"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"package employees\n\ntype Employee struct {\n    // has name, email, address, salary, etc\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"package vendors\n\ntype Vendor struct {\n   // has company name, email, address\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"You might have a couple of modules, one for sending out email notifications and another for payroll."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"package emailer\n\ntype Contact interface {\n   Email() string\n   Name() string\n}\n\nfunc SendEmail(contact Contact, subj, body string) error { ... }\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"package payroll\n\ntype Payee interface {\n    Name() string\n    HomeAddress() string\n    Salary() float32\n}\n\nfunc SendPaychecks(payee Payee) error { ... }\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note that the payroll and email packages don\u2019t know anything about the employee and vendor packages."}),"\n",(0,o.jsx)(n.h3,{id:"package-coherency",children:"Package Coherency"}),"\n",(0,o.jsxs)(n.p,{children:["Go encourages keeping interfaces in the package where they are consumed. Let\u2019s try adding an ",(0,o.jsx)(n.code,{children:"Email"})," method to ",(0,o.jsx)(n.code,{children:"Employee"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func (emp* Employee) Email(string subj, string body) error {\n    return email.Email(emp.EmailAddress, subj, body)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If the ",(0,o.jsx)(n.code,{children:"Contact"})," interface was defined in the ",(0,o.jsx)(n.code,{children:"employee"})," package, we\u2019d end up with a circular package dependency error. If the ",(0,o.jsx)(n.code,{children:"emailer"})," package didn\u2019t have a ",(0,o.jsx)(n.code,{children:"Contact"})," interface, and was able to take ",(0,o.jsx)(n.code,{children:"Employee"})," instances directly, that would also cause a circular package dependency error."]}),"\n",(0,o.jsx)(n.p,{children:"I found circular package dependency errors to be very frustrating when I first started with Go. Now however, having gotten more comfortable with Go style interfaces, I\u2019ve realized the following:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"It\u2019s OK to have smaller, highly specific interfaces per package. There may be some overlap, but each package will end up with exactly what\u2019s needed. This makes the use clearer for developers using the package."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Having the interfaces in the package will also decouple the package from other packages, eliminating circular dependency issues."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"I\u2019m still occasionally annoyed by circular dependency errors, but overall feel that the limitation promotes package decoupling and coherency."}),"\n",(0,o.jsx)(n.h3,{id:"requiring-type-interface-conformance",children:"Requiring Type Interface Conformance"}),"\n",(0,o.jsx)(n.p,{children:"In most cases, if your type doesn\u2019t match up with your interface, you\u2019ll get a compile error. In some cases, where you may be doing runtime checks before converting, you might not notice that your type no longer fits the interface."}),"\n",(0,o.jsx)(n.p,{children:"If you wish to guarantee at compile time that a specific type implements a given interface, you can do this as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"var _ Spillable = (*Tea)(nil)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"fun-with-functions-function-vs-interface",children:"Fun with functions: Function Vs Interface"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes you may have an API that only requires a single method. Something like:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type MessageHandler interface {\n    Handle(msg []byte) error\n}\n\ntype MessageHandlers interface {\n    AddHandler(msgType string, handler MessageHandler)\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This could also be implemented using a function type."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type MessageHandler func (msg []byte) error\n\ntype MessageHandlers interface {\n    AddHandler(msgType string, handler MessageHandler)\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Which to use? For some library consumers a function may be more convenient. For others, an interface to implement would be better. Fortunately Go lets you handle both. In Go a function type can have methods defined on it."}),"\n",(0,o.jsx)(n.p,{children:"This broke my brain slightly when I first encountered it, but it works well to allow both kinds of API."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type MessageHandler interface {\n    Handle(msg []byte) error\n}\n\ntype MessageHandlerF func (msg []byte) error\n\nfunc (f MessageHandlerF) Handle(msg []byte) error {\n    f(msg)\n}\n\n// example use\nhandlers.AddHandler(MessageHandlerF(func (msg []byte) error {\n    return nil\n}))\n"})}),"\n",(0,o.jsx)(n.h3,{id:"extending-interfaces",children:"Extending Interfaces"}),"\n",(0,o.jsxs)(n.p,{children:["Go interfaces can extend other interfaces. The classic examples are the types in the ",(0,o.jsx)(n.code,{children:"io"})," package."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type Closer interface {\n    Close() error\n}\n\ntype Reader interface {\n    Read(b []byte) (n, error)\n}\n\ntype ReadCloser() {\n   Closer\n   Reader\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Older versions of Go used to complain if you extended multiple interfaces that had overlapping method signatures. Recent versions of Go no longer have this limitation, as long as method signatures with the same name match exactly."}),"\n",(0,o.jsx)(n.h3,{id:"anonymous-interfaces",children:"Anonymous Interfaces"}),"\n",(0,o.jsx)(n.p,{children:"There may be times when you want to invoke a method on a variable, but the method isn\u2019t on the interface you\u2019ve got. You can use an anonymous interface to check if the method exists, and if it does, invoke it."}),"\n",(0,o.jsx)(n.p,{children:"I\u2019m not sure there\u2019s ever a strong reason to use an anonymous interface over declaring a named interface. I\u2019ve used this feature when an interface was only used in a single method."}),"\n",(0,o.jsx)(n.p,{children:"In this example we\u2019re looking for a non-standard close method."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func CloseIt(v any) error {\n    if closeable, ok := v.(interface{ CloseMe() error }); ok {\n        return closeable.CloseMe()\n    }\n    return nil\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"we-want-to-share-functionality-across-types",children:"We Want to Share Functionality Across Types"}),"\n",(0,o.jsx)(n.p,{children:"In object-oriented languages, extending a type (or sometimes multiple types) to create a new type is very common. Go does not allow structs to extend other structs in exactly the same way as most object oriented languages."}),"\n",(0,o.jsx)(n.p,{children:"What it does offer is type composition that can look something like inheritance. We\u2019ll look at how it works, and the potential pitfalls from this approach."}),"\n",(0,o.jsx)(n.p,{children:"Go allows embedding both structs and interfaces."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type Knocker interface {\n    Knock()\n}\n\ntype Door struct {\n    lock sync.Mutex\n    knocker Knocker\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The Door type has a lock and knocker. As they are, they are just struct members. Since they are private, they won\u2019t be accessible outside the package. If you try to ",(0,o.jsx)(n.code,{children:"Lock"})," the door or ",(0,o.jsx)(n.code,{children:"Knock"})," at the door, the compiler will complain."]}),"\n",(0,o.jsx)(n.p,{children:"A door isn\u2019t a lock or a knocker, it has a lock and and a knocker. However, it still makes sense to be able to Lock or Knock the door itself. We can do that as follows."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:" type Knocker interface {\n    Knock()\n}\n\ntype Door struct {\n    sync.Mutex\n    Knocker\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"When we embed types in our struct this way, the methods and fields of the embedded types become accessible at the top-level of the struct. The embedded types can still be referenced individually using the type name."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"door := &Door{\n    Knocker : &BrassKnocker{},\n}  \n\ndoor.Mutex.Lock()\ndoor.Unlock()\ndoor.Knocker.Knock()\ndoor.Knock()\n"})}),"\n",(0,o.jsx)(n.p,{children:"Note that we could also embed a pointer type."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type Door struct {\n    *sync.Mutex\n    Knocker\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"method-overriding-vs-method-shadowing",children:"Method Overriding vs Method Shadowing"}),"\n",(0,o.jsx)(n.p,{children:"Methods from embedded types can\u2019t be overridden, in an OO sense, but they can be shadowed. Here\u2019s an example to highlight the difference."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'type A struct {}\n\nfunc (a *A) String() string {\n    return a.Name() \n}\n\nfunc (a *A) Name() string {\n   return "A"\n}\n\ntype B struct {\n    A\n}\n\nfunc (b *B) Name() string {\n    return b.A.Name() + " or B"\n}\n\nfunc main () {\n    a := &A{}\n    b := &B{}\n    fmt.Println(a.Name())    // output: "A"\n    fmt.Println(a.String())  // output: "A"\n    fmt.Println(b.Name())    // output: "A or B"\n    fmt.Println(b.String())  // output: "A"      <-- Maybe unexpected\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Because ",(0,o.jsx)(n.code,{children:"A"})," doesn\u2019t know that it\u2019s embedded by ",(0,o.jsx)(n.code,{children:"B"}),", it won\u2019t call ",(0,o.jsx)(n.code,{children:"B"}),"'s versions of methods that have been overridden. As long as you use type embedding with a composition mindset instead of an inheritance mindset, you should be OK."]}),"\n",(0,o.jsx)(n.h3,{id:"i-want-abstract-types",children:"I Want Abstract Types!"}),"\n",(0,o.jsxs)(n.p,{children:["Abstract types can be a very useful way of providing some base functionality that relies on methods to be supplied by a sub-type. When I first started using Go, I was generally happy and productive with the language. Two things I missed from Java were generics and abstract data types. Generics have since come to ",(0,o.jsx)(n.a,{href:"https://go.dev/blog/intro-generics",children:"Go in version 1.18"}),", and I\u2019ve since learned patterns better suited to Go to replace abstract data types."]}),"\n",(0,o.jsx)(n.p,{children:"Here\u2019s a java example of an abstract data type:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"public abstract class AbstractDataStore<T> {\n    \n    public abstract T LoadEntity(Row r);\n    \n    public List<T> ListEntities(Database db, String query) {\n         Cursor c = db.ExecuteQuery(query);\n         List<T> result = new ArrayList<T>(); \n         while (c.HasNext()) {\n             Row row = c.Next();\n             T entity = this.LoadEntity(row);\n             result.Add(entity);\n         }\n         return result;\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"We\u2019ve got a data store that\u2019s got some generic functionality to iterate over database results and build an entity list. Each concrete implementation would manage the details specific to that entity type."}),"\n",(0,o.jsx)(n.h3,{id:"the-wrong-way",children:"The Wrong Way"}),"\n",(0,o.jsx)(n.p,{children:"The first time I tried modeling something like this in Go, I came up with a pattern similar to abstract types, but significantly worse because the underlying abstractions weren\u2019t there to support it."}),"\n",(0,o.jsx)(n.p,{children:"The idea was that if you defined the full API as an interface, the abstract type could keep a reference to the concrete type, and call it as necessary."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type DataStore[T any] interface {\n    LoadEntity(r *Row) T\n    ListEntities(db Database, query string) []T\n}\n\ntype BaseStore[T any] struct {\n    impl DataStore[T]\n}\n\nfunc (store *BaseStore[T]) ListEntities(db Database, query string) []T {\n    cursor = db.ExecuteQuery(query)\n    var result []T\n    for cursor.HasNext() {\n        row := cursor.Next()\n        entity := store.impl.LoadEntity(r)\n        result = append(result, entity)\n    }\n    return result\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["While this does work, it has a downside. If you treat it as an actual abstract type and try to override any of the base methods in the embedding type, they will only be shadowed. If you then ever forget to call the concrete version on the embedded ",(0,o.jsx)(n.code,{children:"impl"}),", you\u2019ll get the default version. This kind of bug can be easy to miss and hard to track down."]}),"\n",(0,o.jsx)(n.p,{children:"Subjectively, it also doesn\u2019t feel right. It feels like we\u2019re working against the language, rather than with it."}),"\n",(0,o.jsx)(n.h3,{id:"a-better-way",children:"A Better Way"}),"\n",(0,o.jsx)(n.p,{children:"The solution above is not that far off from something that feels more in line with Go\u2019s ethos."}),"\n",(0,o.jsx)(n.p,{children:"What is it we\u2019re trying to accomplish? We\u2019ve got a core set of functionality that needs to delegate some logic. There\u2019s another pattern that fits this description:"}),"\n",(0,o.jsx)(n.h4,{id:"strategies",children:"Strategies"}),"\n",(0,o.jsx)(n.p,{children:"Instead of trying to implement abstract types, we can use strategies. Let\u2019s look at what a strategy oriented version of the above code would look like:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"type EntityLoader[T any] interface {\n    LoadEntity(r *Row) T\n}\n\ntype Store[T any] struct {\n    entityLoader EntityLoader[T]\n}\n\nfunc (store *Store[T]) ListEntities(db Database, query string) []T {\n    cursor = db.ExecuteQuery(query)\n    var result []T\n    for cursor.HasNext() {\n        row := cursor.Next()\n        entity := store.entityLoader.LoadEntity(r)\n        result = append(result, entity)\n    }\n    return result\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"It looks very similar, but the intent is different. This is a composition-oriented approach. Rather than extending a BaseStore, then overriding pieces, we compose the various strategies we might need."}),"\n",(0,o.jsx)(n.p,{children:"This approach also lends itself to sharing functionality in a clean way. You might have three or four different strategies. Some of them might have default implementations that are rarely replaced. Some might have only a small set of implementations that are used across many instances. Some might be different for every instance."}),"\n",(0,o.jsx)(n.p,{children:"Rather than trying to shape these as overrides in a convoluted type hierarchy, each instance can mix and match as needed."}),"\n",(0,o.jsx)(n.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"Every language has some inbuilt preferences. If you\u2019re coming from a heavily object-oriented language, it can take time to adapt how you design your data types in Go. However, I think Go pushes you towards code that is less fragile and cleaner. If I were to write Java code again, it would be positively influenced by the habits I\u2019ve picked up from Go."}),"\n",(0,o.jsx)(n.h2,{id:"about-openziti",children:"About OpenZiti"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"http://github.com/openziti/ziti",children:"OpenZiti"})," is an open-source platform for providing secure and reliable access to network applications. It does this using strong, certificate-based identities, end-to-end encryption, mesh networking, policy-based access control, and app-embedded SDKs. If you find this interesting, please consider ",(0,o.jsx)(n.a,{href:"https://github.com/openziti/ziti/",children:(0,o.jsx)(n.strong,{children:"starring us on GitHub"})}),". It helps to support the project! And if you haven't seen it yet, check out ",(0,o.jsx)(n.a,{href:"https://zrok.io",children:(0,o.jsx)(n.strong,{children:"zrok.io"})}),". It's a free sharing platform built on OpenZiti! It uses the OpenZiti Go SDK since it's a ziti-native application. It's also ",(0,o.jsx)(n.a,{href:"https://github.com/openziti/zrok/",children:(0,o.jsx)(n.strong,{children:"all open source too!"})})]}),"\n",(0,o.jsxs)(n.p,{children:["Tell us how you're using OpenZiti on ",(0,o.jsx)(n.a,{href:"https://twitter.com/openziti",children:(0,o.jsx)(n.strong,{children:"X"})}),(0,o.jsx)(n.strong,{children:(0,o.jsx)("s",{children:"Twitter"})}),", ",(0,o.jsx)(n.a,{href:"https://www.reddit.com/r/openziti/",children:(0,o.jsx)(n.strong,{children:"Reddit"})}),", or over at our ",(0,o.jsx)(n.a,{href:"https://openziti.discourse.group/",children:(0,o.jsx)(n.strong,{children:"Discourse"})}),". Or you can check out ",(0,o.jsx)(n.a,{href:"https://youtube.com/openziti",children:(0,o.jsx)(n.strong,{children:"our content on YouTube"})})," if that's more your speed. Regardless of how, we'd love to hear from you."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var a=t(96540);const o={},s=a.createContext(o);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:n},e.children)}},69088:e=>{e.exports=JSON.parse('{"permalink":"/docs/openziti/blog/golang-aha-moments-oop","source":"@site/blog/golang-aha-moments-oop.md","title":"Golang Aha! Moments: OOP","description":"Moving to Go as my primary development language was a surprisingly easy transition. Coming from a language with strong OOP roots, like Java, I quickly found many analogs for the OOP constructs I was used to, but also had to adjust my thinking.","date":"2024-11-01T14:05:06.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Java","permalink":"/docs/openziti/blog/tags/java","description":"Java content"},{"inline":false,"label":"Object Oriented Programming","permalink":"/docs/openziti/blog/tags/object-oriented-programming","description":"OOP content"},{"inline":false,"label":"golang-aha","permalink":"/docs/openziti/blog/tags/golang-aha","description":"Golang Ahas!"}],"readingTime":12.33,"hasTruncateMarker":true,"authors":[{"name":"Paul Lorenz","title":"Author","url":"https://github.com/plorenz","imageURL":"https://avatars.githubusercontent.com/plorenz","key":"PaulLorenz","page":null}],"frontMatter":{"title":"Golang Aha! Moments: OOP","date":"2024-11-01T14:05:06.000Z","cuid":"cm2yt3p2r000109kzfpv88qvp","slug":"golang-aha-moments-oop","authors":["PaulLorenz"],"image":"@site/blogs/openziti/v1730383460910/9b2d0062-8b76-47c6-b68d-24810fca9f8b.webp","imageDark":"@site/blogs/openziti/v1730383460910/9b2d0062-8b76-47c6-b68d-24810fca9f8b.webp","tags":["golang","java","object-oriented-programming","golang-aha"]},"unlisted":false,"prevItem":{"title":"zrok Custom Domains","permalink":"/docs/openziti/blog/zrok-custom-domains"},"nextItem":{"title":"The safest way to make Portainer Internet accessible","permalink":"/docs/openziti/blog/the-safest-way-to-make-portainer-internet-accessible"}}')}}]);