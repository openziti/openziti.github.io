"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[7222],{21888:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"learn/introduction/features","title":"Features","description":"OpenZiti superpowers are distinguished between security, performance/reliability, and ease of management.","source":"@site/docs/learn/introduction/20-features.md","sourceDirName":"learn/introduction","slug":"/learn/introduction/features","permalink":"/docs/learn/introduction/features","draft":false,"unlisted":false,"editUrl":"https://github.com/openziti/ziti-doc/tree/main/docusaurus/docs/learn/introduction/20-features.md","tags":[],"version":"current","lastUpdatedAt":1743027857000,"sidebarPosition":20,"frontMatter":{"id":"features","title":"Features"},"sidebar":"docsSidebar","previous":{"title":"Key Concepts","permalink":"/docs/learn/introduction/key_concepts"},"next":{"title":"It\'s All Software","permalink":"/docs/learn/introduction/openziti-is-software"}}');var a=n(74848),r=n(28453);const o={id:"features",title:"Features"},s="Features",l={},d=[{value:"Security",id:"security",level:2},{value:"Private \u2018Dark\u2019 Networking",id:"private-dark-networking",level:3},{value:"Built-In, Not Bolted On",id:"built-in-not-bolted-on",level:3},{value:"Zero Trust",id:"zero-trust",level:3},{value:"Trusting Endpoints",id:"trusting-endpoints",level:3},{value:"E2E Encryption",id:"e2e-encryption",level:3},{value:"Flexible Identity",id:"flexible-identity",level:3},{value:"Private Authenticated DNS",id:"private-authenticated-dns",level:3},{value:"No Port Inference",id:"no-port-inference",level:3},{value:"Performance and Reliability",id:"performance-and-reliability",level:2},{value:"The Fabric [Overlay Mesh Network]",id:"the-fabric-overlay-mesh-network",level:3},{value:"Service Health",id:"service-health",level:3},{value:"Easy Management",id:"easy-management",level:2},{value:"Addressability",id:"addressability",level:3},{value:"Server to Client",id:"server-to-client",level:3},{value:"Application Portability",id:"application-portability",level:3},{value:"Easy Integration",id:"easy-integration",level:3},{value:"Multiple options of deployment",id:"multiple-options-of-deployment",level:3}];function c(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"features",children:"Features"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"OpenZiti"})," superpowers are distinguished between security, performance/reliability, and ease of management."]}),"\n",(0,a.jsx)(t.h2,{id:"security",children:"Security"}),"\n",(0,a.jsx)(t.h3,{id:"private-dark-networking",children:"Private \u2018Dark\u2019 Networking"}),"\n",(0,a.jsx)(t.p,{children:"Applications are increasingly exposed to the public internet (and networks, layer 3/4 in general). Open ports them vulnerable to threats / subject to vulnerability exploitation, or traditional private networking (VPNs, firewalls etc.) are cumbersome or unusable. OpenZiti makes them dark and invisible from the internet, with no holes from the firewalls. It makes it more reliable and focused management on the server preventing any unauthorized users from entering the server."}),"\n",(0,a.jsx)(t.h3,{id:"built-in-not-bolted-on",children:"Built-In, Not Bolted On"}),"\n",(0,a.jsx)(t.p,{children:"Traditional network security is exposed to the internet with at least some open ports allowing attackers to scan and potentially find an exploit. OpenZiti provides the ability to be embedded directly into the app using an SDK removing this threat and making security even stronger \u2013 i.e., we are not even trusting the host OS network, nor does the developer need to know port/IP."}),"\n",(0,a.jsx)(t.h3,{id:"zero-trust",children:"Zero Trust"}),"\n",(0,a.jsx)(t.p,{children:"Traditional systems allow users to connect before they authenticate. Many give access to the network without using separate firewalls and access control points \u2013 which slows down developers and burdens operators. OpenZiti mandates authentication and authorisation before any connectivity can be established using a strong identity. When connectivity is created, it can be micro-segmented using least privilege and attribute-based access control."}),"\n",(0,a.jsx)(t.h3,{id:"trusting-endpoints",children:"Trusting Endpoints"}),"\n",(0,a.jsx)(t.p,{children:"Clients and servers are assumed to be trusted if they comply with higher-level access controls. OpenZiti, as part of authentication and authorisation before connecting, allows posture checks to be set up to check endpoints pass certain tests, including MFA, AD domain membership, MAC address, OS version and required processes."}),"\n",(0,a.jsx)(t.h3,{id:"e2e-encryption",children:"E2E Encryption"}),"\n",(0,a.jsx)(t.p,{children:"We want to increase the security of our data across the network and, in general, are moving from TLS to mTLS but need to handle keys, PKI, and distribution. OpenZiti implements its own PKI, handles bootstrapping trust and provides both mTLS and end-to-end encryption by default (built on Libsodium). Our approach ensures low overhead, no need for keys, and prevents unintended users from viewing and modifying data."}),"\n",(0,a.jsx)(t.h3,{id:"flexible-identity",children:"Flexible Identity"}),"\n",(0,a.jsx)(t.p,{children:"Other technology stacks require using identity providers (IdP) from massive organisations. OpenZiti provides its internal system of strong identity using x509 and JWTs. It also allows you to bring an external IdP."}),"\n",(0,a.jsx)(t.h3,{id:"private-authenticated-dns",children:"Private Authenticated DNS"}),"\n",(0,a.jsx)(t.p,{children:"We need to set up and maintain a public DNS which can be queried or attacked while naming must follow specific IP/DNS specifications. OpenZiti does not need to rely on global DNS; authenticated and private DNS is implemented and accessed only by enrolled endpoints. You do not need to name services according to top-level domain etc."}),"\n",(0,a.jsx)(t.h3,{id:"no-port-inference",children:"No Port Inference"}),"\n",(0,a.jsx)(t.p,{children:"Attackers can use port sniffing to discern information on data flows (e.g., port 22 is SSH data). With OpenZiti, everything will be synthesised into port 443, all traffic will appear as Port 443. Attackers cannot figure out what services you use/immune to port sniffing.\nNo Source/Destination Inference \u2013 Attackers can intercept traffic and determine source and destination as valuable information for an attack. OpenZiti encrypts metadata as it moves across the overlay, removing this threat."}),"\n",(0,a.jsx)(t.h2,{id:"performance-and-reliability",children:"Performance and Reliability"}),"\n",(0,a.jsx)(t.h3,{id:"the-fabric-overlay-mesh-network",children:"The Fabric [Overlay Mesh Network]"}),"\n",(0,a.jsx)(t.p,{children:"Traditional connectivity is point-to-point, meaning any issues (e.g., high latency) anywhere on the underlying networking causes performance and reliability issues. OpenZiti provides an overlay with high availability and scalability across the mesh combined with active load balancing combined with smart routing to pick the lowest latency paths automatically."}),"\n",(0,a.jsx)(t.h3,{id:"service-health",children:"Service Health"}),"\n",(0,a.jsx)(t.p,{children:"If issues exist in the end-to-end path of an application, it stops working with no knowledge as to why. OpenZiti implements service dial health metrics to successfully understand which route responses are returned. This allows us to understand the overall service health of the application network and where unhealthy connections are to determine the most likely cause rapidly."}),"\n",(0,a.jsx)(t.h2,{id:"easy-management",children:"Easy Management"}),"\n",(0,a.jsx)(t.h3,{id:"addressability",children:"Addressability"}),"\n",(0,a.jsx)(t.p,{children:"We are normally subject to the limitation of DNS while having poor visibility on who is connecting, when, where etc. \u2013 especially if a company has a huge number of devices and apps. OpenZiti builds identity into every connection allowing direct addressability and circumventing top-level domain naming.\nNetwork Management \u2013 Large-scale networks are difficult to measure and report usage, success, and other measurements. OpenZiti uses its embedded identity for each connection to easily understand, measure and report on services and who \u2018exactly\u2019 tries to connect, utilizations, success rates, latency, and more."}),"\n",(0,a.jsx)(t.h3,{id:"server-to-client",children:"Server to Client"}),"\n",(0,a.jsx)(t.p,{children:"Various means to have a server communicate to the server (e.g., HTTP polling or WebSocket) have drawbacks and are not zero trust. OpenZiti allows any endpoints to communicate to other endpoints. There is no concept of client/server. Therefore, applications can be hosted and accessed by any other participating endpoint (as long as it has passed their authentication and authorisation checks)."}),"\n",(0,a.jsx)(t.h3,{id:"application-portability",children:"Application Portability"}),"\n",(0,a.jsx)(t.p,{children:"Application operators and users must consider how and where their applications will be hosted and set up various controls (e.g., firewalls). OpenZiti-powered applications can be hosted anywhere without worrying about managing ports, IP, DNS etc., while users can access them from anywhere without thinking about \u2018being on the network\u2019 as the network moves wherever they do."}),"\n",(0,a.jsx)(t.h3,{id:"easy-integration",children:"Easy Integration"}),"\n",(0,a.jsx)(t.p,{children:"Developers need to identify/configure their applications to interact with the networking \u2013 e.g., specifying the application ports/IP that will be used. OpenZiti is seamless and easy to integrate, and if using SDKs, developers do not need to specify (or even care about) ports/IPs or the underlying network."}),"\n",(0,a.jsx)(t.h3,{id:"multiple-options-of-deployment",children:"Multiple options of deployment"}),"\n",(0,a.jsxs)(t.p,{children:["Deploying software to desktop/server is never an easy task. Applications powered by OpenZiti enable you to reduce the deployment time & effort. You can integrate the SDK directly into the application that's already being deployed. If you can't integrate, you can use ",(0,a.jsx)(t.a,{href:"/docs/reference/tunnelers/",children:"Pre-built tunnelers and proxies for a variety of operating systems, including mobile"})," to allow existing applications and networks to take advantage of an OpenZiti deployment."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var i=n(96540);const a={},r=i.createContext(a);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);