"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[87951],{79278:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var s=t(61811),o=t(74848),a=t(28453);const i={title:"Golang Aha! Moments: Channels",date:new Date("2022-09-09T00:40:45.000Z"),cuid:"cl7tr5gdz01hqpgnv7zbl75uh",slug:"golang-aha-moments-channels",authors:["PaulLorenz"],image:"@site/blogs/openziti/v1662683219596/YY8xRufSo.jpg",imageDark:"@site/blogs/openziti/v1662683219596/YY8xRufSo.jpg",tags:["golang","developer","channels","openziti","golang-aha"]},r=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Channels",id:"channels",level:2},{value:"Channels For Signals",id:"channels-for-signals",level:2},{value:"Simple Broadcast",id:"simple-broadcast",level:3},{value:"Wake Signal",id:"wake-signal",level:3},{value:"Closing Multi-writer Channels",id:"closing-multi-writer-channels",level:2},{value:"Semaphores and Pools",id:"semaphores-and-pools",level:2},{value:"Event Handler Loops",id:"event-handler-loops",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(n.p,{children:["I work with Golang every day as a developer on the ",(0,o.jsx)(n.a,{href:"http://openziti.io",children:"OpenZiti project"}),". In learning Go,\nI've hit various stumbling blocks, settled on some best practices and hopefully gotten better at writing Go code.\nThis series exists to share some of the 'Aha!' moments I've had overcoming obstacles and finding solutions that\nsparked joy."]}),"\n",(0,o.jsxs)(n.p,{children:["This ",(0,o.jsx)(n.a,{href:"./tags/golang-aha",children:"series"})," is targeted both at new team members and for anyone in the Go community who might be interested. We'd be very happy to hear from others about their own 'aha' moments and also how the solutions presented strike your sensibilities. Suggested improvements, corrections and constructive criticism are welcome."]}),"\n",(0,o.jsx)(n.p,{children:"This first installment will cover various topics related to Go channels."}),"\n",(0,o.jsx)(n.h2,{id:"channels",children:"Channels"}),"\n",(0,o.jsx)(n.p,{children:"Channels are a core feature of Go. As is typical of Go, the channel API is small and simple, but provides a lot of power."}),"\n",(0,o.jsxs)(n.p,{children:["See here for a quick ",(0,o.jsx)(n.a,{href:"https://go.dev/tour/concurrency/2",children:"Go channels refresher"}),". Also, if you haven't read it yet, Dave Cheney's ",(0,o.jsx)(n.a,{href:"https://dave.cheney.net/2014/03/19/channel-axioms",children:"Channel Axioms"})," is worth a look."]}),"\n",(0,o.jsx)(n.h2,{id:"channels-for-signals",children:"Channels For Signals"}),"\n",(0,o.jsx)(n.h3,{id:"simple-broadcast",children:"Simple Broadcast"}),"\n",(0,o.jsx)(n.p,{children:"There are a few ways we can use channels to signal other goroutines. The first is if we want to broadcast a one time notification. For example, if you have a something with several associated goroutines and you want to clean them all up together, you can use a single unbuffered channel which they can monitor for closes."}),"\n",(0,o.jsx)(n.p,{children:"As an example, you might have a UDP socket listener that's handling UDP connections. Since UDP doesn't have timeouts, you need to make sure that idle connections are eventually cleaned up. So you create an idle connection scanner. You want the goroutine for this scanner to stop when the UDP socket listener is closed, so you pass it a channel that you'll close when the socket is closed."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-golang",children:'import (\n\t"time"\n)\n\ntype IdleScanner struct {\n\tcloseNotify <-chan struct{}\n}\n\nfunc (self *IdleScanner) run() {\n\tticker := time.NewTicker(time.Minute)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <- ticker.C:\n\t\t\t// scan for idle connections\n\t\tcase <- self.closeNotify:\n\t\t\treturn // shutting down\n\t\t}\n\t}\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Note that the ",(0,o.jsx)(n.code,{children:"IdleScanner"})," has a ",(0,o.jsx)(n.code,{children:"<- chan"}),", so it can only check if the channel is closed, it cannot close the channel itself."]}),"\n",(0,o.jsx)(n.p,{children:"This pattern can be seen in several places in OpenZiti. Here's one in a UDP connection handling context:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/openziti/edge/blob/v0.22.89/tunnel/udp%5C_vconn/conn.go#L51",children:"https://github.com/openziti/edge/blob/v0.22.89/tunnel/udp\\_vconn/conn.go#L51"})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Note that this pattern does have one downside for handling shutdown behavior, namely that you can signal components to shut down, but you can't tell when all the components are finished shutting down. In many use cases this is fine, but there are places where this would be a problem."}),"\n",(0,o.jsx)(n.h3,{id:"wake-signal",children:"Wake Signal"}),"\n",(0,o.jsxs)(n.p,{children:["In this example we have something running periodically, but we want to be able to trigger it to run sooner. With a single element channel, we can notify a goroutine. By using ",(0,o.jsx)(n.code,{children:"select"})," with",(0,o.jsx)(n.code,{children:"default"}),", we can ensure that signalling code doesn't block and that the receiving side only gets a single signal per loop."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-golang",children:'package main\n\nimport (\n\t"fmt"\n\t"sync/atomic"\n\t"time"\n)\n\nfunc NewWorker() *Worker {\n\tw := &Worker{\n\t\tsignal:  make(chan struct{}, 1),\n\t}\n\tgo w.run()\n\treturn w\n}\n\ntype Worker struct {\n\tsignal chan struct{}\n\tstopped atomic.Bool\n}\n\nfunc (self *Worker) run() {\n\tticker := time.NewTicker(time.Minute)\n\tdefer ticker.Stop()\n\n\tfor !self.stopped.Load() {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tself.work()\n\t\tcase <-self.signal:\n\t\t\tself.work()\n\t\t}\n\t}\n}\n\nfunc (self *Worker) work() {\n\tif !self.stopped.Load() {\n\t\tfmt.Println("working hard")\n\t}\n}\n\nfunc (self *Worker) RunNow() {\n\tselect {\n\tcase self.signal <- struct{}{}:\n\tdefault:\n\t}\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"This is used in OpenZiti in an event processor to force quicker evaluation of events for tests. See here:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/openziti/edge/blob/v0.22.89/controller/persistence/eventual%5C_eventer.go#L404",children:"https://github.com/openziti/edge/blob/v0.22.89/controller/persistence/eventual\\_eventer.go#L404"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"closing-multi-writer-channels",children:"Closing Multi-writer Channels"}),"\n",(0,o.jsx)(n.p,{children:"Closing channels can be complicated. On the reader side, things are generally simple. A read on a closed channel will return immediately with the zero value and flag indicating that it is closed."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-golang",children:'func main() {\n\tch := make(chan interface{}, 1)\n\tch <- "hello"\n\tval, ok := <- ch\n\n\tfmt.Printf("%v, %v\\n", val, ok) // prints hello, true\n\n\tclose(ch)\n\n\tval, ok = <- ch\n\tfmt.Printf("%v, %v\\n", val, ok) // prints <nil>, false\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"On the writer side, things can be more complicated. If you only have a single writer, it can be responsible for closing the channel. This notifies any blocker readers that the channel is closed. However, if there are multiple writers, this won't work. Writing to a closed channel will cause a panic. Closing an already closed channel will also cause a panic. So what to do?"}),"\n",(0,o.jsx)(n.p,{children:"The realization I eventually had was that the channel doesn't need to be closed. What we want to achieve is making sure the readers and writers are safely notified that they should stop trying to use the channel. For this, we can use a second channel, following the broadcast pattern shown above."}),"\n",(0,o.jsx)(n.p,{children:"Here is an example of a multi-reader/multi-writer queue which can be closed, notifying writers and readers that no further reads or writes should be made."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-golang",children:'package main\n\nimport (\n\t"errors"\n\t"sync/atomic"\n)\n\ntype Queue struct {\n\tch          chan int\n\tcloseNotify chan struct{}\n\tclosed      atomic.Bool\n}\n\nfunc (self *Queue) Push(val int) error {\n\tselect {\n\tcase self.ch <- val:\n\t\treturn nil\n\tcase <-self.closeNotify:\n\t\treturn errors.New("queue closed")\n\t}\n}\n\nfunc (self *Queue) Pop() (int, error) {\n    if self.closed.Load() {\n\t\treturn 0, errors.New("queue closed")\n    }        \n\tselect {\n\tcase val := <-self.ch:\n\t\treturn val, nil\n\tcase <-self.closeNotify:\n\t\treturn 0, errors.New("queue closed")\n\t}\n}\n\nfunc (self *Queue) Close() {\n\tif self.closed.CompareAndSwap(false, true) {\n\t\tclose(self.closeNotify)\n\t}\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["A variation on this would let readers drain the channel once it's closed. Because select case evaluation is random, we may not read a val from the channel once the close notify channel is closed. We can ensure that we return a value if it's available by modifying ",(0,o.jsx)(n.code,{children:"Pop()"})," as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-golang",children:'func (self *Queue) Pop() (int, error) {\n\tselect {\n\tcase val := <-self.ch:\n\t\treturn val, nil\n\tcase <-self.closeNotify:\n\t\tselect {\n\t\tcase val := <-self.ch:\n\t\t\treturn val, nil\n\t\tdefault:\n\t\t\treturn 0, errors.New("queue closed")\n\t\t}\n\t}\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"This pattern is used in several places in OpenZiti, including in the binary message framework (somewhat confusing also called channel) and the mesh network flow control."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://github.com/openziti/channel/blob/v1.0.2/impl.go",children:"https://github.com/openziti/channel/blob/v1.0.2/impl.go"})," (see rxer, txer)"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://github.com/openziti/fabric/blob/v0.19.64/router/xgress/xgress.go",children:"https://github.com/openziti/fabric/blob/v0.19.64/router/xgress/xgress.go"})," (littler harder to see, but can start with ",(0,o.jsx)(n.code,{children:"closeNotify"})," in the xgress struct)"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"semaphores-and-pools",children:"Semaphores and Pools"}),"\n",(0,o.jsx)(n.p,{children:"Because channels have a sized buffer and well defined blocking behavior, creating a semaphore implementation is very straightforward. We can create a channel with a buffer of the size we want our semaphore to have. We can then read and write from the channel to acquire and release the semaphore."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-golang",children:'package concurrenz\n\nimport "time"\n\ntype Semaphore interface {\n\tAcquire()\n\tAcquireWithTimeout(t time.Duration) bool\n\tTryAcquire() bool\n\tRelease() bool\n}\n\nfunc NewSemaphore(size int) Semaphore {\n\tresult := &semaphoreImpl{\n\t\tc: make(chan struct{}, size),\n\t}\n\tfor result.Release() {\n\t}\n\treturn result\n}\n\ntype semaphoreImpl struct {\n\tc chan struct{}\n}\n\nfunc (self *semaphoreImpl) Acquire() {\n\t<-self.c\n}\n\nfunc (self *semaphoreImpl) AcquireWithTimeout(t time.Duration) bool {\n\tselect {\n\tcase <-self.c:\n\t\treturn true\n\tcase <-time.After(t):\n\t\treturn false\n\t}\n}\n\nfunc (self *semaphoreImpl) TryAcquire() bool {\n\tselect {\n\tcase <-self.c:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (self *semaphoreImpl) Release() bool {\n\tselect {\n\tcase self.c <- struct{}{}:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We could use mostly the same implementation for a resource pool. Instead of a channel of ",(0,o.jsx)(n.code,{children:"struct{}"}),", we could have a channel of connections or buffers that are acquired and released."]}),"\n",(0,o.jsx)(n.p,{children:"This semaphore implementation is here:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/semaphore.go",children:"https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/semaphore.go"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Golang does have a weighted semaphore implementation in the extended libraries here: ",(0,o.jsx)(n.a,{href:"https://pkg.go.dev/golang.org/x/sync/semaphore",children:"https://pkg.go.dev/golang.org/x/sync/semaphore"})," which may be preferable."]}),"\n",(0,o.jsx)(n.p,{children:"That said, there are lots of ways to implement semaphores, but I appreciate how this implementation showcases some of the power and simplicity of Go channels."}),"\n",(0,o.jsx)(n.h2,{id:"event-handler-loops",children:"Event Handler Loops"}),"\n",(0,o.jsxs)(n.p,{children:["We often have a loop which is processing inputs from one or more channels. This is usually to keep a set of data local to a single goroutine, so we don't have to use any synchronization or worry about CPU cache effects. We use channels to feed data to the goroutine and/or to trigger different kinds of processing. A ",(0,o.jsx)(n.code,{children:"for"})," with ",(0,o.jsx)(n.code,{children:"select"})," loop can handle channels of different types. A first impulse might be to have a channel per type of work, or per type of data. However you can also use a single channel which takes an interface."]}),"\n",(0,o.jsx)(n.p,{children:"Here's a simple example where the processor is maintaining some cached data which can be updated externally. Presumably the processor would be doing something with the cached data, but we've left that out to focus on the pattern itself."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-golang",children:"type Event interface {\n\t// events are passed the processor so they don't each have to include it\n\tHandle(*Processor)\n}\n\ntype Processor struct {\n\tch          chan Event\n\tcloseNotify chan struct{}\n\tcache map[string]string\n}\n\nfunc (self *Processor) run() {\n\tfor {\n\t\tselect {\n\t\tcase event := <-self.ch:\n\t\t\tevent.Handle(self)\n\t\tcase <-self.closeNotify:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (self *Processor) queueEvent(evt Event) {\n\tselect {\n\tcase self.ch <- evt:\n\tcase <-self.closeNotify:\n\t\treturn\n\t}\n}\n\nfunc (self *Processor) UpdateCache(k, v string) {\n\tself.queueEvent(&updateCache{key: k, value: v})\n}\n\nfunc (self *Processor) Invalidate(k string) {\n\tself.queueEvent(invalidate(k))\n}\n\ntype updateCache struct {\n\tkey string\n\tvalue string\n}\n\nfunc (self *updateCache) Handle(p *Processor) {\n\tp.cache[self.key] = self.value\n}\n\ntype invalidate string\n\nfunc (self invalidate) Handle(p *Processor) {\n\tdelete(p.cache, string(self))\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This can be seen in OpenZiti here:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/openziti/sdk-golang/blob/v0.16.119/ziti/edge/msg%5C_mux%5C_ch.go#L104",children:"https://github.com/openziti/sdk-golang/blob/v0.16.119/ziti/edge/msg\\_mux\\_ch.go#L104"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Note that over time we've used this pattern less and moved more to using explicitly concurrent data structures. For example, we generally don't use the above type any more and instead use a different implementation which uses a copy-on-write map, as the data that was being protected was rarely being written, but read often. The alternative version can be found here: ",(0,o.jsx)(n.a,{href:"https://github.com/openziti/sdk-golang/blob/v0.16.119/ziti/edge/msg%5C_mux.go",children:"https://github.com/openziti/sdk-golang/blob/v0.16.119/ziti/edge/msg\\_mux.go"})," (not yet updated for generics)."]}),"\n",(0,o.jsx)(n.p,{children:"Funnily enough, after my initial post I found myself using this pattern again in some metrics processing code. I'll update this post once the code is complete."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"The Go Gopher was created by"})," ",(0,o.jsx)(n.a,{href:"http://reneefrench.blogspot.com/",children:(0,o.jsx)(n.em,{children:"Renee French"})})," ",(0,o.jsx)(n.em,{children:"and is licensed under"})," ",(0,o.jsx)(n.a,{href:"https://creativecommons.org/licenses/by/3.0/",children:(0,o.jsx)(n.em,{children:"Creative Commons Attribution 3.0"})})," ",(0,o.jsxs)(n.em,{children:["(see ",(0,o.jsx)(n.a,{href:"https://go.dev/blog/gopher",children:"https://go.dev/blog/gopher"}),")"]})]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(96540);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},61811:e=>{e.exports=JSON.parse('{"permalink":"/docs/openziti/blog/golang-aha-moments-channels","source":"@site/blog/golang-aha-moments-channels.md","title":"Golang Aha! Moments: Channels","description":"Introduction","date":"2022-09-09T00:40:45.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Developer","permalink":"/docs/openziti/blog/tags/developer","description":"Developer topics"},{"inline":false,"label":"Channels","permalink":"/docs/openziti/blog/tags/channels","description":"Communication channels"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"golang-aha","permalink":"/docs/openziti/blog/tags/golang-aha","description":"Golang Ahas!"}],"readingTime":8.35,"hasTruncateMarker":true,"authors":[{"name":"Paul Lorenz","title":"Author","url":"https://github.com/plorenz","imageURL":"https://avatars.githubusercontent.com/plorenz","key":"PaulLorenz","page":null}],"frontMatter":{"title":"Golang Aha! Moments: Channels","date":"2022-09-09T00:40:45.000Z","cuid":"cl7tr5gdz01hqpgnv7zbl75uh","slug":"golang-aha-moments-channels","authors":["PaulLorenz"],"image":"@site/blogs/openziti/v1662683219596/YY8xRufSo.jpg","imageDark":"@site/blogs/openziti/v1662683219596/YY8xRufSo.jpg","tags":["golang","developer","channels","openziti","golang-aha"]},"unlisted":false,"prevItem":{"title":"Introducing OpenZiti BrowZer","permalink":"/docs/openziti/blog/introducing-openziti-browzer"},"nextItem":{"title":"I Created a Zero Trust Overlay Network to Access HomeAssistant","permalink":"/docs/openziti/blog/zero-trust-overlay-network-to-access-homeassistant"}}')}}]);