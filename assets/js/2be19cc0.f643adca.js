"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[31500],{67313:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var i=t(36501),s=t(74848),a=t(28453);const r={title:"Securing Azure OpenAI Applications with OpenZiti",date:new Date("2023-10-15T23:07:06.000Z"),cuid:"clns2tgr1000309jwfpyngao7",slug:"securing-azure-openai-applications-with-openziti",authors:["DariuszSliwinski"],image:"@site/blogs/openziti/v1697652544795/ec49e795-33bd-4a09-aa16-96f4c80d2dc6.jpeg",imageDark:"@site/blogs/openziti/v1697652544795/ec49e795-33bd-4a09-aa16-96f4c80d2dc6.jpeg",ogimage:"/blogs/openziti/v1697652407252/6a647546-7930-4b48-bd16-e85779dbf127.jpeg",tags:["openai","application-security","aks","zerotrust","workload-identity"]},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Scope",id:"scope",level:3},{value:"Architectures",id:"architectures",level:2},{value:"Before OpenZiti Overlay",id:"before-openziti-overlay",level:3},{value:"With OpenZiti Overlay",id:"with-openziti-overlay",level:3},{value:"Option I",id:"option-i",level:4},{value:"Option II",id:"option-ii",level:4},{value:"Infrastructure Deployment",id:"infrastructure-deployment",level:2},{value:"AKS Module",id:"aks-module",level:4},{value:"Edge Router",id:"edge-router",level:4},{value:"Extras - helm/kubernetes providers, kubectl config",id:"extras---helmkubernetes-providers-kubectl-config",level:4},{value:"Configuration Snippets for the Overlay Network",id:"configuration-snippets-for-the-overlay-network",level:3},{value:"Host.v1 service config",id:"hostv1-service-config",level:4},{value:"Intercept.v1 service config",id:"interceptv1-service-config",level:4},{value:"Edge Router Policy",id:"edge-router-policy",level:3},{value:"ZDE Test Client",id:"zde-test-client",level:3},{value:"Service Policy",id:"service-policy",level:3},{value:"Plan Deployment",id:"plan-deployment",level:3},{value:"OpenAI Apps Deployment",id:"openai-apps-deployment",level:3},{value:"Application Reachability",id:"application-reachability",level:3},{value:"Ziti Endpoint in the cluster",id:"ziti-endpoint-in-the-cluster",level:4},{value:"Deployment to the cluster",id:"deployment-to-the-cluster",level:5},{value:"Service configuration details",id:"service-configuration-details",level:5},{value:"Cluster Private Ingress with Public Certs",id:"cluster-private-ingress-with-public-certs",level:4},{value:"Final Word",id:"final-word",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"scope",children:"Scope"}),"\n",(0,s.jsx)(n.p,{children:"Once the initial release of ChatGPT happened at the end of 2022, a new wave of optimism and excitement started to sweep\nthrough Enterprises. Artificial Intelligence, more specifically generative AI, finally arrived in the mainstream.\nCompany Executives pretty much everywhere in the world are trying to understand how it can be used to help their\nworkforce and businesses be more productive and efficient. It was quickly realized that the data Enterprises own\nis very valuable and important. The large language models will help them greatly in their day-to-day decisions on\nwhether to drive efficiency, lower costs on the supply chain or understand customer behavior and their consumption\npatterns to name a few. One thing is very clear, data security is of paramount importance not just at rest but in\ntransit as well."}),"\n",(0,s.jsxs)(n.p,{children:["In this article, I will show how ",(0,s.jsx)(n.a,{href:"https://openziti.io/docs/learn/introduction/",children:"OpenZiti"})," Overlay Network can secure the data forwarded between applications and users across the Internet. One will learn how two different personas within the same company (i.e. DevOps Engineering and Apps Consumers) can manage the infrastructure or just access the privately hosted Application through the same OpenZiti Overlay without opening any network ports on the service side and segmenting their access through different OpenZiti ",(0,s.jsx)(n.a,{href:"https://openziti.io/docs/learn/core-concepts/services/overview",children:"Services"})," and ",(0,s.jsx)(n.a,{href:"https://openziti.io/docs/learn/core-concepts/security/authorization/policies/overview",children:"Service/Access Policies"}),". The architecture section will further highlight the differences before and after OpenZiti. We all know a diagram is worth 10,000 words."]}),"\n",(0,s.jsxs)(n.p,{children:["Microsoft has been putting out various examples to educate potential users on how to deploy chat GPT-like applications in recent months. I found a couple of interesting ones that I wanted to use as a case study for OpenZti Overlay. These two examples are located in the following repos - ",(0,s.jsx)(n.a,{href:"https://github.com/Azure-Samples/container-apps-openai",children:"container-apps-openai"})," and ",(0,s.jsx)(n.a,{href:"https://github.com/Azure-Samples/aks-openai-terraform",children:"aks-openai-terraform"}),". Both used a private Azure OpenAI\xa0service offering on the backend with the Python-based Chat/Doc Applications deployed in the Azure Managed Container Service or AKS Cluster Service respectively. I forked the former repo as my base since I like the fact that showed two OpenAI applications. I modified it to host applications in the AKS Private Cluster as in the latter example instead of the Azure Managed Container Service."]}),"\n",(0,s.jsxs)(n.p,{children:["One quick note before we get started. I used CloudZiti for this article, which is powered by OpenZiti Overlay Network but hosted and managed by ",(0,s.jsx)(n.a,{href:"https://netfoundry.io/",children:"NetFoundry"}),". One can host the OpneZiti in his/her Private Virtual Cloud, and it is an excellent option as well. I wanted to focus on the service layer and access policies rather than on network deployment details. Links are provided to both Network Deployment Options later in this blog."]}),"\n",(0,s.jsx)(n.h2,{id:"architectures",children:"Architectures"}),"\n",(0,s.jsx)(n.h3,{id:"before-openziti-overlay",children:"Before OpenZiti Overlay"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"container-apps-openai example"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(59941).A+"",width:"880",height:"496"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"aks-openai-terraform example"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(40689).A+"",width:"681",height:"748"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"with-openziti-overlay",children:"With OpenZiti Overlay"}),"\n",(0,s.jsx)(n.h4,{id:"option-i",children:"Option I"}),"\n",(0,s.jsx)(n.p,{children:"It depicts the access to the hosted applications through the Ziti Tunnel deployed in the cluster at a node level set to the hosted mode (similar to ingress controller-like access). In this scenario, one does not have to manage the TLS Certs, since the authentication and encryption are already built-in to the Overlay."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(92122).A+"",width:"880",height:"901"})}),"\n",(0,s.jsx)(n.h4,{id:"option-ii",children:"Option II"}),"\n",(0,s.jsx)(n.p,{children:"It depicts the access to the hosted applications through the Ziti Edge Router using the Private Ingress Nginx Proxy and TLS termination (i.e. Publicly signed Certs with Private IP Address). In this scenario, the ingress nginx manages the TLS termination and the Built-in End-to-End Overlay Encryption can be used for 2 layers of security or disabled."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(94853).A+"",width:"880",height:"901"})}),"\n",(0,s.jsx)(n.h2,{id:"infrastructure-deployment",children:"Infrastructure Deployment"}),"\n",(0,s.jsxs)(n.p,{children:["I cloned the repo ",(0,s.jsx)(n.a,{href:"https://github.com/Azure-Samples/container-apps-openai",children:"container-apps-openai"})," (a link to my forked ",(0,s.jsx)(n.a,{href:"https://github.com/dariuszSki/container-apps-openai/tree/secure-aichatbot-overziti",children:"repo and branch"}),"). Then, I updated the terraform plan to add the Private AKS Service to the deployment based on the details from the second example. Here are the details."]}),"\n",(0,s.jsx)(n.h4,{id:"aks-module",children:"AKS Module"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ini",children:'module "aks_identity" {\n  source                       = "./modules/managed_identity"\n  name                         = "${var.name_prefix}aksid"\n  resource_group_name          = azurerm_resource_group.rg.name\n  location                     = var.location\n  openai_id                    = module.openai.id\n  acr_id                       = module.container_registry.id\n  tags                         = var.tags\n}\n\nmodule "aks" {\n  source                                       = "Azure/aks/azurerm"\n  version                                      = "7.3.2"\n  cluster_name                                 = lower("${var.name_prefix}akscluster")\n  prefix                                       = lower("${var.name_prefix}akscluster")\n  resource_group_name                          = azurerm_resource_group.rg.name\n  location                                     = var.location\n  identity_ids                                 = [module.aks_identity.id]\n  identity_type                                = "UserAssigned"\n  oidc_issuer_enabled                          = true\n  workload_identity_enabled                    = true\n  vnet_subnet_id                               = module.virtual_network.subnet_ids[var.aca_subnet_name]\n  net_profile_service_cidr                     = "10.0.20.0/22"\n  net_profile_dns_service_ip                   = "10.0.20.2"\n  rbac_aad                                     = false\n  network_contributor_role_assigned_subnet_ids = {\n    vnet_subnet = module.virtual_network.subnet_ids[var.aca_subnet_name]\n  }\n  private_cluster_enabled                      = true\n  network_plugin                               = "azure"\n  network_policy                               = "azure"\n  os_disk_size_gb                              = 60\n  sku_tier                                     = "Standard"\n  depends_on                                   = [ azurerm_resource_group.rg ]\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"edge-router",children:"Edge Router"}),"\n",(0,s.jsx)(n.p,{children:"The important detail is to be able to manage the AKS Cluster after it is deployed. The kubectl access will be done through this router. The idea is that after the infrastructure plan is executed and completed successfully, the DevOps Users will have instance access through the Overlay Network to all the deployed infrastructure. There will be no need to have a bastion host deployed."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ini",children:'module "edge-router" {\n  source                        = "Azure/compute/azurerm"\n  version                       = "5.3.0"\n  resource_group_name           = azurerm_resource_group.rg.name\n  location                      = var.location\n  vnet_subnet_id                = module.virtual_network.subnet_ids[var.aca_subnet_name]\n  network_security_group        = {\n    id = azurerm_network_security_group.edge_router_nsg.id\n  }\n  allocation_method              = "Static"\n  public_ip_sku                  = "Standard"\n  admin_username                 = "ziggy"\n  ssh_key                        = var.ziti_router_ssh_pub\n  custom_data                    = "#cloud-config\\nruncmd:\\n- [/opt/netfoundry/router-registration, ${var.ziti_router_reg_key}]"\n  delete_os_disk_on_termination  = true\n  enable_ip_forwarding           = true\n  is_marketplace_image           = true\n  vm_hostname                    = lower("${var.name_prefix}zitirouter")\n  vm_os_offer                    = "ziti-edge-router"\n  vm_os_publisher                = "netfoundryinc"\n  vm_os_sku                      = "ziti-edge-router"\n  vm_os_version                  = "latest"\n  vm_size                        = "Standard_DS1_v2"\n'})}),"\n",(0,s.jsx)(n.h4,{id:"extras---helmkubernetes-providers-kubectl-config",children:"Extras - helm/kubernetes providers, kubectl config"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ini",children:'resource "local_sensitive_file" "kubeconfig" {\n  depends_on   = [module.aks]\n  filename     = pathexpand("~/.kube/config")\n  content      = module.aks.kube_config_raw\n  file_permission = 0600\n}\nprovider "kubernetes" {\n  host                   = module.aks.host\n  client_key             = base64decode(module.aks.client_key)\n  client_certificate     = base64decode(module.aks.client_certificate)\n  cluster_ca_certificate = base64decode(module.aks.cluster_ca_certificate)\n}\n\n\nprovider "helm" {\n  debug   = true\n  kubernetes {\n    host                   = module.aks.host\n    client_key             = base64decode(module.aks.client_key)\n    client_certificate     = base64decode(module.aks.client_certificate)\n    cluster_ca_certificate = base64decode(module.aks.cluster_ca_certificate)\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"configuration-snippets-for-the-overlay-network",children:"Configuration Snippets for the Overlay Network"}),"\n",(0,s.jsx)(n.p,{children:"Before the terraform plan can be run, one needs to have the Overlay Network stood-up, services and access policies configured."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://nfconsole.io/signup?selfServicePlan=teams&stepName=chosePlan&stepNum=1",children:"Get Free Cloud Ziti Network"})," or ",(0,s.jsx)(n.a,{href:"https://openziti.io/docs/category/public-cloud-deployment",children:"Open Ziti Hosted in Your Cloud Account"})]}),"\n",(0,s.jsx)(n.p,{children:"Service configuration Option like wildcard domains allows DevOps Users to use one service to access multiple Azure Services and also to terminate/create the test environment multiple times to save on infrastructure cost if not used during evaluation without modifying the service every time."}),"\n",(0,s.jsx)(n.h4,{id:"hostv1-service-config",children:"Host.v1 service config"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "allowedAddresses": [\n    "*.azurecr.io",\n    "*.privatelink.blob.core.windows.net",\n    "*.eastus.azmk8s.io",\n    "*.privatelink.vaultcore.azure.net",\n    "*.privatelink.openai.azure.net",\n    "*.openai.azure.com",\n    "*.openai.azure.net"\n  ],\n  "allowedPortRanges": [\n    {\n      "high": 443,\n      "low": 443\n    }\n  ],\n  "forwardAddress": true,\n  "forwardPort": true,\n  "protocol": "tcp"\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"interceptv1-service-config",children:"Intercept.v1 service config"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "addresses": [\n    "*.azurecr.io",\n    "*.privatelink.blob.core.windows.net",\n    "*.eastus.azmk8s.io",\n    "*.privatelink.vaultcore.azure.net",\n    "*.privatelink.openai.azure.net",\n    "*.openai.azure.com",\n    "*.openai.azure.net"\n  ],\n  "portRanges": [\n    {\n      "high": 443,\n      "low": 443\n    }\n  ],\n  "protocols": [\n    "tcp"\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"edge-router-policy",children:"Edge Router Policy"}),"\n",(0,s.jsx)(n.p,{children:"The important part is that the Ziti Identity\u2019s group tag (#k8s) is assigned in identityRoles and Edge Router\u2019s name tag (@aks-azure-router01) is assigned in\xa0 edgeRouterRolesDisplay. One can also assign a group tag and have more routers that this endpoint can connect to, which don't have to be necessarily in the same resource group."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "edgeRouterRoles": [\n    "@RL2zF2SFY"\n  ],\n  "edgeRouterRolesDisplay": [\n    {\n      "name": "@aks-azure-router01",\n      "role": "@RL2zF2SFY"\n    }\n  ],\n  "identityRoles": [\n    "#k8s"\n  ],\n  "identityRolesDisplay": [\n    {\n      "name": "#k8s",\n      "role": "#k8s"\n    }\n  ],\n  "isSystem": false,\n  "name": "aks_policy",\n  "semantic": "AnyOf"\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"zde-test-client",children:"ZDE Test Client"}),"\n",(0,s.jsxs)(n.p,{children:["Test/DevOps Client for testing and setting up part of the infrastructure.\xa0I used the Windows clients. The installed WZDE can be downloaded from ",(0,s.jsx)(n.a,{href:"https://github.com/openziti/desktop-edge-win/releases",children:"this repo"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"service-policy",children:"Service Policy"}),"\n",(0,s.jsx)(n.p,{children:"Here is the service policy used that ties my client to the service created in the previous steps"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "identityRoles": [\n     "#clients"\n    ,\n    "identityRolesDisplay": [\n    {\n      "name": "#clients",\n      "role": "#clients"\n     }\n      \n  ],\n  "serviceRoles": [\n    "#aks"\n  ],\n  "serviceRolesDisplay": [\n    {\n      "name": "#aks",\n      "role": "#aks"\n    }\n  ],\n  "type": "Dial"\n}\n\n\n# Relevent Service Configuration data\n{\n  "data": [\n    {\n      "configs": [\n        "7aMiQw8wZY9D23dodHHKSQ",\n        "e9lfsIHqqOAZv2hirv46p"\n      ],\n      "encryptionRequired": true,\n      "name": "AKS-API-01",\n      "permissions": [\n        "Bind",\n        "Dial"\n      ],\n      "roleAttributes": [\n        "aks"\n      ],\n      "terminatorStrategy": "smartrouting"\n    }\n  ],\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"plan-deployment",children:"Plan Deployment"}),"\n",(0,s.jsx)(n.p,{children:"Once the service, all the policies, edge router, aks endpoint and Windows client are all configured on the CloudZiti Network, we are ready to install the Windows client\xa0 (if not done so already) and run our terraform plan."}),"\n",(0,s.jsx)(n.p,{children:"Update terraform.tfvars file. The reg key can be retrieved from the CloudZiti Console and make sure you have the SSH public key in your path under ~/.ssh/id_rsa.pub or change the path."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'name_prefix         = "Dariusz"\nlocation            = "eastus"\nziti_router_reg_key = "7MBY8KWYPU"\nziti_router_ssh_pub = "~/.ssh/id_rsa.pub"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Then, run this script to deploy the infrastructure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"bash deploy.sh\n"})}),"\n",(0,s.jsx)(n.h3,{id:"openai-apps-deployment",children:"OpenAI Apps Deployment"}),"\n",(0,s.jsx)(n.p,{children:"First, you need to build the app images,\xa0 push them to the private registry in your RG, and finally deploy the apps."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"cd into `src/` folder and modify `Blue` to your `prefix` in 00-variables.sh"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"bash 01-build-docker-images.sh"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["bash 03-push-docker-image.sh (note: may need to run ",(0,s.jsx)(n.code,{children:"az account set --subscription <name or id>"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'Update the service account with your workload identity details and\xa0env settings if needed in the app deployment file. The workload identity name is added in the AKS Module section and is "${var.name_prefix}aksid"'}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  annotations:\n    azure.workload.identity/client-id: ${CLIENT_ID}\n    azure.workload.identity/tenant-id: ${TENANT_ID}\n  \n# apply it  \nkubectl apply -f apps-deployment.yml\n\n# pods status after deployment\nkubectl get all -n chatbot\nNAME                           READY   STATUS    RESTARTS   AGE\npod/chatapp-78895b949d-lng5l   1/1     Running   0          5m38s\npod/docapp-776c4d44f5-ddsxm    1/1     Running   0          5m38s\n\nNAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE\nservice/chatapp   ClusterIP   10.0.23.7     <none>        80/TCP    5m39s\nservice/docapp    ClusterIP   10.0.22.202   <none>        80/TCP    5m38s\n\nNAME                      READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/chatapp   1/1     1            1           5m39s\ndeployment.apps/docapp    1/1     1            1           5m39s\n\nNAME                                 DESIRED   CURRENT   READY   AGE\nreplicaset.apps/chatapp-78895b949d   1         1         1       5m39s\nreplicaset.apps/docapp-776c4d44f5    1         1         1       5m39s\n"})}),"\n",(0,s.jsx)(n.h3,{id:"application-reachability",children:"Application Reachability"}),"\n",(0,s.jsx)(n.p,{children:"As stated in the scope, I am trying to show two ways. I will go through the service details for the End Users access now."}),"\n",(0,s.jsx)(n.h4,{id:"ziti-endpoint-in-the-cluster",children:"Ziti Endpoint in the cluster"}),"\n",(0,s.jsx)(n.p,{children:"Deploying a Ziti Endpoint in the cluster and hosting HTTP service on it to reach the local cluster private DNS app names. You can ignore the padlock warning on your web browser since the end-to-end encryption is done by the Ziti Overlay Network. This simplifies deployment, where one does not have to create public certificates and deploy an ingress in the cluster."}),"\n",(0,s.jsxs)(n.p,{children:["Sample code to deploy Ziti Edge Tunnel along with the snippet of the service configuration details needed. First, you need to create an identity on the Ziti Network and download its identity's jwt. Link to ",(0,s.jsx)(n.a,{href:"https://github.com/openziti/ziti/releases",children:"OpenZiti CLI"})," or ",(0,s.jsx)(n.a,{href:"https://hub.docker.com/r/openziti/ziti-cli",children:"Dockertized Cli"})]}),"\n",(0,s.jsx)(n.h5,{id:"deployment-to-the-cluster",children:"Deployment to the cluster"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"ziti edge enroll --jwt /tmp/k8s-zet-host.jwt --out /tmp/k8s-zet-host.json\n"})}),"\n",(0,s.jsx)(n.p,{children:"or docker"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"docker run -v /tmp:/tmp openziti/ziti-cli edge enroll \\\n           --jwt /tmp/k8s-zet-host.jwt --out /tmp/k8s-zet-host.json\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"helm install k8s-zet-host openziti/ziti-host \\\n                --set-file zitiIdentity=/tmp/k8s-zet-host.json \\\n                --create-namespace --namespace ziti\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl get all -n ziti\nNAME                                          READY   STATUS    RESTARTS   AGE\npod/k8s-zet-host-ziti-host-67cb9f8668-4lkql   1/1     Running   0          2m3s\nNAME                                     READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/k8s-zet-host-ziti-host   1/1     1            1           2m3s\nNAME                                                DESIRED   CURRENT   READY   AGE\nreplicaset.apps/k8s-zet-host-ziti-host-67cb9f8668   1         1         1       2m3s\n"})}),"\n",(0,s.jsx)(n.h5,{id:"service-configuration-details",children:"Service configuration details"}),"\n",(0,s.jsx)(n.p,{children:'Second app, just replace\xa0 "docapp.ziti" and \u201cdocapp.chatbot.svc" respectively.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'{\n  "addresses": [\n    "chatapp.ziti"\n  ],\n  "portRanges": [\n    {\n      "high": 80,\n      "low": 80\n    }\n  ],\n  "protocols": [\n    "tcp"\n  ]\n}\n{\n  "address": "chatapp.chatbot.svc",\n  "allowedPortRanges": [\n    {\n      "high": 80,\n      "low": 80\n    }\n  ],\n  "allowedProtocols": [\n    "tcp"\n  ],\n  "forwardPort": true,\n  "forwardProtocol": true\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Both apps are now private and can be accessed through the overlay and all ports are closed. The HTTPS is not enabled between the web browser and apps, but the end-to-end encryption is provided by the overlay network."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"http://chatapp.ziti",children:"http://chatapp.ziti"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(75965).A+"",width:"1056",height:"493"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"http://docapp.ziti",children:"http://docapp.ziti"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(92414).A+"",width:"1053",height:"995"})}),"\n",(0,s.jsx)(n.h4,{id:"cluster-private-ingress-with-public-certs",children:"Cluster Private Ingress with Public Certs"}),"\n",(0,s.jsx)(n.p,{children:"One can create public certs that resolve to the cluster external private IP using these annotations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'\nhelm install nginx-ingress ingress-nginx/ingress-nginx\\\n  --create-namespace \\\n  --namespace ingress \\\n  --set controller.nodeSelector."kubernetes\\.io/os"=linux \\\n  --set controller.replicaCount=1 \\\n  --set defaultBackend.nodeSelector."kubernetes\\.io/os"=linux \\\n  --set controller.service.annotations."service\\.beta\\.kubernetes\\.io/azure-load-balancer-health-probe-request-path"=/healthz \\\n  --set controller.service.annotations."service\\.beta\\.kubernetes\\.io/azure-load-balancer-internal"=true \\\n  --set controller.service.loadBalancerIP="10.0.0.122"\n'})}),"\n",(0,s.jsx)(n.p,{children:"One Ingress for each of the apps:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: chatapp-ingress\n  namespace: chatbot\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - chatapp.dariuszski.dev\n    secretName: chatapp\n  rules:\n  - host: "chatapp.dariuszski.dev"\n    http:\n      paths:\n      - pathType: Prefix\n        path: /\n        backend:\n          service:\n            name: chatapp\n            port:\n              number: 80\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: docapp-ingress\n  namespace: chatbot\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - docapp.dariuszski.dev\n    secretName: docapp\n  rules:\n  - host: "docapp.dariuszski.dev"\n    http:\n      paths:\n      - pathType: Prefix\n        path: "/"\n        backend:\n          service:\n            name: docapp\n            port:\n              number: 80\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f ingress.yml\ningress.networking.k8s.io/chatapp-ingress created\ningress.networking.k8s.io/docapp-ingress created\n"})}),"\n",(0,s.jsx)(n.p,{children:"Create certs using the Let's Encrypt bot and upload them manually or use the cert-manager to automate the process. It was more convenient for me to create certs using Certbot and upload them manually to the secrets' store."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"docker run \\\n  -v '/var/lib/letsencrypt:/var/lib/letsencrypt' \\\n  -v '/etc/letsencrypt:/etc/letsencrypt' \\\n  --cap-drop=all \\\n  ghcr.io/aaomidi/certbot-dns-google-domains:latest \\\n  certbot certonly \\\n  --authenticator 'dns-google-domains' \\\n  --dns-google-domains-credentials '/var/lib/letsencrypt/dns_google_domains_credentials.ini' \\\n  --server 'https://acme-v02.api.letsencrypt.org/directory' \\\n  -d 'chatapp.dariuszski.dev' -m ynwa.lfc@dariuszski.dev --agree-tos\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'kubectl create secret tls chatapp --cert "/etc/letsencrypt/live/chatapp.dariuszski.dev/cert.pem" --key  "/etc/letsencrypt/live/chatapp.dariuszski.dev/privkey.pem" -n chatbot\nkubectl create secret tls docapp --cert "/etc/letsencrypt/live/docapp.dariuszski.dev/cert.pem" --key  "/etc/letsencrypt/live/docapp.dariuszski.dev/privkey.pem" -n chatbot\n'})}),"\n",(0,s.jsx)(n.p,{children:"To show DNS lookup details."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ nslookup chatapp.dariuszski.dev\nServer:         127.0.0.53\nAddress:        127.0.0.53#53\n\nNon-authoritative answer:\nName:   chatapp.dariuszski.dev\nAddress: 10.0.0.122\n\n$ nslookup docapp.dariuszski.dev\nServer:         127.0.0.53\nAddress:        127.0.0.53#53\n\nNon-authoritative answer:\nName:   docapp.dariuszski.dev\nAddress: 10.0.0.122\n"})}),"\n",(0,s.jsx)(n.p,{children:"Once the certs are loaded and the ingress controller set up,\xa0 the web browser shows the padlock for both apps."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://chatapp.dariuszski.dev/",children:"https://chatapp.dariuszski.dev/"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(86946).A+"",width:"1081",height:"792"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docapp.dariuszski.dev/",children:"https://docapp.dariuszski.dev/"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(21351).A+"",width:"1089",height:"794"})}),"\n",(0,s.jsx)(n.h3,{id:"final-word",children:"Final Word"}),"\n",(0,s.jsxs)(n.p,{children:["I went over a couple of options for accessing Applications deployed in AKS Clusters. There are technically two more. The third would be at the pod level, where Ziti Host can be deployed as ",(0,s.jsx)(n.a,{href:"https://openziti.io/docs/guides/kubernetes/workload-tunneling/kubernetes-sidecar",children:"a sidecar."})," The fourth is using Openziti Python SDK to embed the HTTP listener in both Python applications. Here is the link to the Ziti Python SDK ",(0,s.jsx)(n.a,{href:"https://github.com/openziti/ziti-sdk-py/blob/main/README.md",children:"source code"})," and ",(0,s.jsx)(n.a,{href:"./openziti-python-sdk-introduction",children:"introduction blog"}),". Probably good content to go over on the follow-up to this blog, unless there are brave souls - I mean developers - out there that can beat me to it. Challenge accepted?! By the way, I am not an application developer by trade. Surely you must have realized it by now, especially after I mentioned SDK as the last but certainly not least option :). Please let me know if you want me to dive into these other options in a future article in the comment section. Looking forward to your responses and feedback."]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},59941:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/c223b85b-44fc-4529-b068-d1cc5c48891e-8651cd82113e391078dd2033fb95cb0f.png"},40689:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/abbc91cf-4430-4af6-8f3c-5f7cea75d19e-8d54fc2cf9772e79dc84a9d424e27e40.png"},86946:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/470957ae-b818-4b02-9303-983f32fa7a1e-4da610350a7306d77a16ab22ca454e18.png"},21351:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/c827e209-ee04-4f68-9996-9e5ada4442e7-dc7fe8626272dc6487ebba5c25fd3835.png"},75965:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/27790c9b-ba1b-4b9d-bec1-d2c473d80ccd-eca9303e853e13b74423cdf3fa509c0d.png"},92414:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/494519a6-064f-4138-a5a2-aecb81bb76d2-4dbc1a6e887e8d983acf729e3bf12289.png"},92122:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/db3b5722-fa5a-409e-9e27-2828350ae0be-d9b7877de44a83c92780392bfbf1a24c.png"},94853:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/aa55c58b-bcac-4ba9-89b4-46682c7053a7-75ed8b4b99ecfda2ec647bbb2c41729c.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},36501:e=>{e.exports=JSON.parse('{"permalink":"/docs/openziti/blog/securing-azure-openai-applications-with-openziti","source":"@site/blog/securing-azure-openai-applications-with-openziti.md","title":"Securing Azure OpenAI Applications with OpenZiti","description":"Scope","date":"2023-10-15T23:07:06.000Z","tags":[{"inline":false,"label":"OpenAI","permalink":"/docs/openziti/blog/tags/openai","description":"OpenAI content"},{"inline":false,"label":"Application Security","permalink":"/docs/openziti/blog/tags/application-security","description":"Application security"},{"inline":false,"label":"AKS","permalink":"/docs/openziti/blog/tags/aks","description":"Azure Kubernetes Service"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Workload Identity","permalink":"/docs/openziti/blog/tags/workload-identity","description":"Workload Identity in AKS"}],"readingTime":12.53,"hasTruncateMarker":true,"authors":[{"name":"Dariusz Sliwinski","title":"Author","url":"https://github.com/dariuszSki","imageURL":"https://avatars.githubusercontent.com/dariuszSki","key":"DariuszSliwinski","page":null}],"frontMatter":{"title":"Securing Azure OpenAI Applications with OpenZiti","date":"2023-10-15T23:07:06.000Z","cuid":"clns2tgr1000309jwfpyngao7","slug":"securing-azure-openai-applications-with-openziti","authors":["DariuszSliwinski"],"image":"@site/blogs/openziti/v1697652544795/ec49e795-33bd-4a09-aa16-96f4c80d2dc6.jpeg","imageDark":"@site/blogs/openziti/v1697652544795/ec49e795-33bd-4a09-aa16-96f4c80d2dc6.jpeg","ogimage":"/blogs/openziti/v1697652407252/6a647546-7930-4b48-bd16-e85779dbf127.jpeg","tags":["openai","application-security","aks","zerotrust","workload-identity"]},"unlisted":false,"prevItem":{"title":"The zrok OAuth Public Frontend","permalink":"/docs/openziti/blog/the-zrok-oauth-public-frontend"},"nextItem":{"title":"OpenZiti Zero Trust IoT Wi-Fi Gateway","permalink":"/docs/openziti/blog/openziti-zero-trust-iot-wi-fi-gateway"}}')}}]);