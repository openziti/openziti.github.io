"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[21116],{90034:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"introducing-zrok-10","metadata":{"permalink":"/docs/openziti/blog/introducing-zrok-10","source":"@site/blog/introducing-zrok-1-0.md","title":"Introducing zrok 1.0","description":"What does version 1.0 mean?","date":"2025-04-09T19:48:24.000Z","tags":[{"inline":false,"label":"Software Development","permalink":"/docs/openziti/blog/tags/software-development","description":"Software development practices"},{"inline":false,"label":"Tools","permalink":"/docs/openziti/blog/tags/tools","description":"Tools and utilities"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Developer","permalink":"/docs/openziti/blog/tags/developer","description":"Developer topics"},{"inline":false,"label":"Announcement","permalink":"/docs/openziti/blog/tags/announcement","description":"Announcements"}],"readingTime":9.9,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"Introducing zrok 1.0","date":"2025-04-09T19:48:24.000Z","cuid":"cm9acdmkq000e08jr6pyc0zj7","slug":"introducing-zrok-10","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1744209956458/656a2fe0-41e5-4628-bd06-a9b3267df001.png","imageDark":"@site/blogs/openziti/v1744209956458/656a2fe0-41e5-4628-bd06-a9b3267df001.png","tags":["software-development","tools","security","developer","announcement"]},"unlisted":false,"nextItem":{"title":"zrok Unleashed: Top 10 Uses Explored","permalink":"/docs/openziti/blog/zrok-unleashed-top-10-uses-explored"}},"content":"## What does version 1.0 mean?\\n\\nIt\u2019s always a big deal when a project releases \u201cversion 1.0\u201d. Our version 1.0 release validates all of the good things \\nabout zrok while improving a few areas that needed it, and also brings several exciting new features.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe initial release of 1.0 includes major new features like:\\n\\n* A new polished API console (web interface)\\n    \\n* A new \u201czrok Agent\u201d designed to streamline the management of your zrok resources and provide a web interface making zrok accessible to users who aren\u2019t command-line natives\\n    \\n* The \u201czrok Canary\u201d a new suite of tests designed to focus on both performance and reliability for production zrok environment\\n    \\n\\nWe\u2019re going to take a look at these highlights of zrok 1.0 in this blog post. For those of you who prefer videos, I recently did a zrok Office Hours covering this same information:\\n\\n%[https://www.youtube.com/watch?v=cIqkbnv-xAQ] \\n\\n# History\\n\\nI keep a detailed journal of my work. I like to save screenshots documenting interesting points in the development of the projects that I work on. Sometimes it\u2019s fun to go back and look at them. Here\u2019s a little look into zrok screenshots over the years.\\n\\nFirst, starting in 2022, here is a `v0.2` screenshot. `v0.2` predates [zrok.io](https://zrok.io/) and the hosted service. This is the very first version of zrok that had a \u201cconsole\u201d and integrated metrics:\\n\\n![](/blogs/openziti/v1744133087807/9da95d37-6436-49c6-967a-21f74f292e92.png)\\n\\n`v0.2` also predates `private` sharing in zrok. This was just a proof-of-concept exercise to see what a secure public reverse proxy solution on top of OpenZiti might look like.\\n\\nThen we developed `v0.3`, which added private sharing and introduced the concept of a \u201cbackend mode\u201d:\\n\\n![](/blogs/openziti/v1744133265428/52aa2f76-017c-4336-8a54-b1775041c49b.gif)\\n\\nThe \u201cvisualizer\u201d concept was first introduced in `v0.3`. This version of the visualizer is similar to what we ended up with in `v0.4`.\\n\\nThe main goal of the `v0.4` series was to develop zrok into a platform that could support a zrok as a service ([zrok.io](https://zrok.io/)). A lot of refinement and polish went into making `v0.4` usable and useful for a wider range of users:\\n\\n![](/blogs/openziti/v1744133390425/30237eb1-fa20-483c-86e9-25b1be9a8b68.png)\\n\\nEvery time there is a major refresh of the zrok user interface, I feel like the new version feels like a substantial leap forward.\\n\\nThis brings us to the first major feature of zrok `v1.0`, which is the updated API console.\\n\\n# The New API Console\\n\\nThe new zrok API console (the primary \u201cweb interface\u201d) has received a major refresh for `v1.0`. In addition to new branding, the technology under the covers has been streamlined as well. Here are some screenshots so you can get the vibes:\\n\\n![](/blogs/openziti/v1744134630638/d2d3ba1c-f4e7-4f93-b094-1e9c013c7052.png)\\n\\nThese things are subjective, but I very much look at this new user interface and feel the same way about it that I\u2019ve felt about previous iterations\u2026 it looks like a substantial improvement in polish and usability versus the previous version.\\n\\nUnder the covers the API console has been re-developed in Typescript using Vite. It\u2019s still a React application, but the stack has been radically cleaned up and simplified. This new stack will give us a solid platform to extend and build on going forward.\\n\\nThe new API console retains the same visual approach to navigating your zrok resources as the previous release\u2026 but in addition, the new API console provides a \u201ctabular\u201d mode to easily filter and sort the contents of your account:\\n\\n![](/blogs/openziti/v1744134838383/6ac1f878-3e82-4fef-b862-c6ca674c14ce.png)\\n\\nWhen sorted by activity, the tabular mode operates kind of like a \u201ctop\u201d command for your zrok account.\\n\\nFor users with large, active accounts, the sorting and filtering features can help you to zero in on the specific resources you\u2019re looking for. The selection state is maintained between the visualizer and tabular modes, allowing you to search and then quickly visualize.\\n\\nThe forms and dialogs have also received a lot of attention and polish:\\n\\n![](/blogs/openziti/v1744134927112/36f17c1f-ebc7-4d88-8537-7d5dcc6d7eca.png)\\n\\nWe\u2019re excited about the new streamlined look-and-feel, too.\\n\\n# zrok Agent\\n\\nIf you\u2019re a zrok power user who has ever used more than a single `zrok share` or `zrok access`, you\u2019ve surely run into the issue where you\u2019ve needed to manage a number of zrok processes. Some of them might go in `systemd`. Some of them might sit in terminal windows. You might even `nohup` some of them into the background.\\n\\nzrok v1.0 introduces a new \u201czrok Agent\u201d to make this situation much simpler. The Agent is a kind of intelligent \u201cprocess manager\u201d for all of your zrok shares and accesses. It\u2019s designed to work well for both end-user environments (for developers and end-users) and also for headless production environments.\\n\\nWhen you\u2019re not running the zrok Agent, the v1.0 command-line works the way it always has\u2026 If you run a `zrok share`, you\u2019ll end up with a single process for that share, like this:\\n\\n![](/blogs/openziti/v1744135682541/8178eb22-1424-4dfb-8f32-4bea6987dc6b.png)\\n\\nBut when I start the new zrok Agent using the `zrok agent start` command, we get a different operating mode. With the zrok Agent running, if I do a `zrok share`, I get a different result:\\n\\n![](/blogs/openziti/v1744135820048/21f79d74-b5bd-4cfe-becf-4d1454bcf487.png)\\n\\nNotice that the `zrok share public` command above returned immediately, displaying the share token and the URL for my new share. When I ran `zrok share public` with the Agent running, the Agent was detected and the process for my new share was managed by the Agent automatically.\\n\\nWith the zrok Agent you\u2019ll have a single process to manage. You can put your `zrok agent start` command into `systemd` using the `zrok-agent` package for Linux. You can `nohup` it. You can just stash it away in a terminal window somewhere. You can run it as a Windows service. But once you\u2019ve managed that single process, your whole zrok experience becomes simpler.\\n\\nYou might also notice the `zrok agent status` command in the terminal above. That command is used to display the shares and accesses being managed by the Agent.\\n\\nThere are additional commands under the `zrok agent` tree for managing shares and accesses:\\n\\n![](/blogs/openziti/v1744135943261/4141ac00-4a3d-4801-aa52-6d6d0c19b6bf.png)\\n\\nAnd the `zrok agent release share` command can direct the agent to release the share.\\n\\nThe zrok Agent also includes a `localhost` web interface, which can be used to create and remove shares from the agent\u2026 yes, when you\u2019re running the zrok Agent you can create new shares *without using the command-line* interface!\\n\\n![](/blogs/openziti/v1744136149257/08b3caad-b8c5-4741-9e95-ec497afd5fff.png)\\n\\nThe zrok \u201cAgent console\u201d is an early preview and a work-in-progress. There are currently a limited subset of share types that can be created through the Agent console, but we expect to elaborate this into a first-class interface over the next handful of releases.\\n\\nWe expect the zrok Agent console to grow into a super useful desktop assistant for managing your local zrok shares and accesses. This will be especially helpful for non-CLI users.\\n\\n## Remote Agent Administration\\n\\nWe\u2019re not quite there yet, but we\u2019re very excited about one of the features we\u2019re actively developing for the zrok Agent\u2026 opt-in \u201cremote administration\u201d. Imagine you have a headless system somewhere with an enabled zrok environment running a zrok Agent. Sure, you could `ssh` into that system to create and manage shares. But what if you could simply enroll your zrok Agent so that it can be managed from the central zrok API console\u2026 from anywhere?\\n\\nThis kind of remote administration would allow you to create and release shares and accesses on remote environments through the zrok API console. Need to get into a remote system without direct access? This could be a way to make that very simple. This also allows you to shut down shares and accesses when you\u2019re not using them, increasing security.\\n\\nRemote administration will be completely opt-in and will be the kind of capability you can enable only when you need it. If you do not enroll your Agent, then that Agent is an island unto itself that you can only access locally. You\u2019ll be in control.\\n\\n# zrok Canary\\n\\nWe take the reliability and performance of zrok very seriously. So seriously that we\u2019re developing a set of performance and reliability tooling into zrok that we collectively refer to as the \u201czrok Canary\u201d.\\n\\nFor the initial 1.0 release, we\u2019ve re-worked the old `zrok test loop public` infrastructure into a more polished set of tools underneath `zrok test canary`.\\n\\nWe expect to continue elaborating these tools into a wide suite of monitors and tests to properly validate all of the major operating conditions of a zrok instance. And we expect to be rolling these tools out across [zrok.io](https://zrok.io/) as they\u2019re available to give us deeper and better visibility into how zrok is operating.\\n\\n# Switching to 1.0\\n\\nTo switch to 1.0, simply obtain a zrok binary at `v1.0.2` or later, and your existing environments will automatically be migrated to the new version, transparently.\\n\\n# The Medium-term Roadmap\\n\\nThere are a lot of exciting new features and capabilities lined up for the `v1.0.x` release series!\\n\\n## zrok for OpenZiti Networks\\n\\nHave an existing OpenZiti network? Want to quickly and easily add zrok capabilities to your OpenZiti network on-demand? We\u2019re taking a good look at how best to add and remove zrok as a capability of an existing OpenZiti network.\\n\\n## Remote Agent Administration\\n\\nEnroll your zrok Agent for remote administration through the zrok API console. Un-enroll the instant you\u2019re done. All communications between your zrok Agent and the zrok instance will be handled securely through the OpenZiti overlay.\\n\\n## A Complete zrok Agent Console\\n\\nDo everything through the zrok Agent console that you can do through the command-line. Keep this interface on your desktop and never touch the zrok CLI again.\\n\\n## Reserved Namespace Improvements\\n\\nEveryone wants the same names for their reserved shares: `staging`, `testing`, etc. We\u2019ll be taking a good hard look at how to give users better, more specific namespaces allowing them to use the names that they want to use.\\n\\n## More zrok Drives; Making Drives More Useful\\n\\nMagic wormholes. Drive-by upload boxes. Ephemeral downloads. We\u2019ll be looking at ways to build on the proof-of-concept that is the current zrok Drives implementation, making it useful for all kinds of data-in-motion use cases.\\n\\n## API Console Timeline and Notifications\\n\\nSee how your zrok resources have changed over time. Answer questions like \u201cwhen exactly did I remove that share?\u201d We\u2019ll also be looking at notifications and working on providing better mechanisms for communicating with users.\\n\\n## OpenZiti HA Control Plane Integration\\n\\nOpenZiti has an HA control plane and we\u2019re going to teach zrok how best to take advantage of that. zrok is one of our examples of best practices around \u201cZiti Native Applications\u201d and we\u2019re going to continue and expand that tradition to include HA.\\n\\n# Thank you!\\n\\nThank you for supporting zrok. We\u2019re really looking forward to seeing where the 1.0 roadmap takes us.\\n\\nIf you like zrok, it\u2019s always very much appreciated if you take a moment to drop a star onto the [zrok repository on GitHub](https://github.com/openziti/zrok). We literally see and appreciate every repository star.\\n\\nIf zrok is an important part of your workflow, maybe you would consider getting a subscription on [zrok.io](https://zrok.io/)? Those subscriptions are an incredibly helpful signal that we\u2019re on the right track.\\n\\nIf there is anything we can do to improve zrok or if you\u2019ve run into anything we can help with, please reach out to us at our [OpenZiti Discourse forum](https://openziti.discourse.group/c/zrok/24). There is a [zrok category](https://openziti.discourse.group/c/zrok/24), and we\u2019re standing by ready to help."},{"id":"zrok-unleashed-top-10-uses-explored","metadata":{"permalink":"/docs/openziti/blog/zrok-unleashed-top-10-uses-explored","source":"@site/blog/zrok-unleashed-top-10-uses-explored.md","title":"zrok Unleashed: Top 10 Uses Explored","description":"As we roll into 2025, we\u2019re entering into an exciting time for the world of zrok. We\u2019ve just recently","date":"2025-03-05T14:23:33.000Z","tags":[{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":4.99,"hasTruncateMarker":true,"authors":[{"name":"Mike Guthrie","title":"Author","url":"https://github.com/mguthrie88","imageURL":"https://avatars.githubusercontent.com/mguthrie88","key":"MikeGuthrie","page":null}],"frontMatter":{"title":"zrok Unleashed: Top 10 Uses Explored","seoTitle":"Top 10 Uses of zrok","seoDescription":"Top 10 Uses of zrok as a service explored","date":"2025-03-05T14:23:33.000Z","cuid":"cm7w0d1v100020al7041bczp2","slug":"zrok-unleashed-top-10-uses-explored","authors":["MikeGuthrie"],"image":"@site/blogs/openziti/v1741184699506/3d770cf5-535b-4f7d-8bc7-9ebbba03ebcd.png","imageDark":"@site/blogs/openziti/v1741184699506/3d770cf5-535b-4f7d-8bc7-9ebbba03ebcd.png","ogimage":"/blogs/openziti/v1741182634716/ac0a43f9-bcaa-492b-abde-5bb558a07181.png","tags":["zrok"]},"unlisted":false,"prevItem":{"title":"Introducing zrok 1.0","permalink":"/docs/openziti/blog/introducing-zrok-10"},"nextItem":{"title":"Securing Ziti Identities with HSM/TPM","permalink":"/docs/openziti/blog/securing-ziti-identities-with-hsmtpm"}},"content":"As we roll into 2025, we\u2019re entering into an exciting time for the world of zrok. We\u2019ve just recently \\nadded [support for custom domains](./zrok-custom-domains.md), and with the 1.0 release right \\naround the corner, zrok is more powerful than it has ever been. We thought this was a good time to zoom out and \\ntake a look at how users are actually using our [hosted zrok as a service](https://myzrok.io).\\n\\n\x3c!-- truncate --\x3e\\n\\nAs part of the larger open source [OpenZiti project](https://github.com/openziti/zrok/), zrok uses an [OpenZiti overlay network](https://openziti.io/docs/learn/introduction/) for any secure communications. When you start an instance of zrok, zrok will create a secure zero trust connection to the OpenZiti overlay. This connection is also how zrok can provide truly end-to-end encrypted tunnels with the `--tcpTunnel` [backend mode](https://docs.zrok.io/docs/getting-started#share-backend-modes). Given its nature, it\u2019s difficult to know what services zrok is providing, but we were able to run some statistics based on the terminating port and make some inferences on whether or not the port was exposed as a public or private share. Here\u2019s the list that we came up with. I found some of these use cases particularly cool, and I discovered some use cases in the process I\u2019d never actually thought of. We\u2019re hoping this post gives you some fresh eyes with zrok and you discover some new possibilities for how powerful it can be for resource sharing!\\n\\n## #1. Local Development Servers\\n\\n*Ports: 80,8000,8080,3000,3001,5173*\\n\\nNo surprise here! This is probably the original use case that zrok was built around, and zrok just makes it so easy to share your local environment and alleviates the need to stand up an entire shared environment just to be able to show off a local demo, collaborate on a pre-release, or share resources in a distributed developer environment. Whether you\u2019re running apache, nginx, nodejs, or Vite, zrok allows you to easily share any of these technologies.\\n\\n`zrok share public 8080`\\n\\n## #2. Minecraft Servers\\n\\n*Port: 25565*\\n\\nStill one of the best games of all time, and considering how easy it is to run your own server and add custom mods, zrok provides an easy way to share a private game server with your friends without having to open up your firewall ports to the world.\\n\\nSee [this tutorial](./minecraft-over-zrok) for full details on how to run your minecraft server over zrok!\\n\\n## #3. AWS Sagemaker Notebooks\\n\\n*Port: 7860*\\n\\nAbout a year ago we had a huge amount of buzz from the community that outlined how to integrate zrok with [AWS Sagemaker](https://aws.amazon.com/sagemaker/) notebooks. [Pogs Cafe](https://www.youtube.com/@pogscafe) put together some great video content that shows zrok integrated with their launcher for ephemeral AI image generation. [See zrok in action here](https://youtu.be/Tl5eHI_AMmw?si=c9JEfWi0T-Gord2s&t=56), or check out their [blog post](https://www.pogs.cafe/software/tunneling-sagemaker-kaggle).\\n\\n## #4. BlueBubbles\\n\\n*Port: 1234*\\n\\nBlueBubbles is a free, open-source app ecosystem that allows users to send and receive iMessages on non-Apple devices. [BlueBubbles leverages zrok](https://newreleases.io/project/github/BlueBubblesApp/bluebubbles-server/release/v1.9.6) as one of its built-in proxy services so that you can run BlueBubbles server without the need for port-forwarding.\\n\\n## #5. IRC - Internet Relay Chat\\n\\n*Port: 6666*\\n\\nThe original chat server, has been alive since 1988. zrok provides a way for you to easily put modern security around your chat server with end-to-end encryption, and private access tokens with the use of [private TCP shares](https://docs.zrok.io/docs/concepts/tunnels/).\\n\\n## #6. SSH\\n\\n*Port: 22*\\n\\nWho needs a Bastion anyway? That\u2019s so 2010! Just leave 22 closed to the world and put a zrok private TCP share on the host and call it a day. No open ports. Simply fire up a [zrok share as a systemd service](https://docs.zrok.io/docs/guides/linux-user-share/)\\n\\n## #7 - Jupyter Notebooks / AI Notebooks\\n\\n*Port: 8188*\\n\\nThis one was a little bit ambiguous because there are multiple AI Notebook tools that all rely on this same default port. We know that [Jupyter Notebooks](https://jupyter.org/) is one of the biggest uses in this bucket, and some cloud providers like Google Cloud AI and Hauwei Cloud AI also make use of these tools.\\n\\n## #8. Squid Proxy\\n\\n*Port: 3128*\\n\\n[Squid proxy](https://www.squid-cache.org/) is an easy-to-use caching and proxy server that can be used to give greater control over outbound traffic whether you\u2019re testing compatibility with a corporate proxy for your application, or you need funnel traffic through a remote server\u2019s address, zrok gives you an easy way to set this up. Just create a share that terminates on your proxy service and set your HTTP\\\\_PROXY/HTTPS\\\\_PROXY variables in your environment, and all http-based traffic will now filter through your zrok proxy.\\n\\n## #9. FoundryVTT\\n\\n*Port: 30000*\\n\\nProbably my personal favorite use case for zrok. [FoundryVTT is a virtual table top game server](https://foundryvtt.com/), and zrok provides a fantastic way to host a virtual game night from your own PC while still protecting your home network. Check out this [YouTube tutorial here!](https://www.youtube.com/watch?v=x-3PODwEdDM)\\n\\n## #10. NoMachine Remote Desktop\\n\\n*Port 4000*\\n\\nRemote desktop is incredibly handy, but it\u2019s also something you would never want to expose as an open port on the internet. [NoMachine is a free multi-platform remote desktop tool](https://www.nomachine.com/). With the use of [private TCP shares](https://docs.zrok.io/docs/concepts/tunnels/), zrok enables you to maintain secure remote access from anywhere without ever exposing a port to the internet.\\n\\n## #??? - You Tell Us!!\\n\\n*Port: ???*\\n\\nGot a killer idea for zrok that we missed? Post it in the comments! We always love to hear new use cases for how people are using zrok so that we can make this technology better. And if you haven\u2019t already, help us spread the word about zrok by [giving us a star on github!](https://github.com/openziti/zrok)"},{"id":"securing-ziti-identities-with-hsmtpm","metadata":{"permalink":"/docs/openziti/blog/securing-ziti-identities-with-hsmtpm","source":"@site/blog/securing-ziti-identities-with-hsm-tpm.md","title":"Securing Ziti Identities with HSM/TPM","description":"Regular readers of this blog know that OpenZiti provides secure overlay networking between Ziti identities.","date":"2025-02-26T15:27:28.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Hardware","permalink":"/docs/openziti/blog/tags/hardware","description":"Hardware-related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"HSM","permalink":"/docs/openziti/blog/tags/hsm","description":"Hardware Security Modules"},{"inline":false,"label":"TPM","permalink":"/docs/openziti/blog/tags/tpm","description":"Trusted Platform Module"}],"readingTime":3.66,"hasTruncateMarker":true,"authors":[{"name":"Eugene Kobyakov","title":"Author","url":"https://github.com/ekoby","imageURL":"https://avatars.githubusercontent.com/ekoby","key":"EugeneKobyakov","page":null}],"frontMatter":{"title":"Securing Ziti Identities with HSM/TPM","date":"2025-02-26T15:27:28.000Z","cuid":"cm7m2kag7000009l5ahicajw9","slug":"securing-ziti-identities-with-hsmtpm","authors":["EugeneKobyakov"],"image":"@site/blogs/openziti/v1740433372226/36a74b0f-3dfc-496f-8907-00e6fb0aabfd.jpeg","imageDark":"@site/blogs/openziti/v1740433372226/36a74b0f-3dfc-496f-8907-00e6fb0aabfd.jpeg","tags":["security","hardware","zerotrust","hsm","tpm"]},"unlisted":false,"prevItem":{"title":"zrok Unleashed: Top 10 Uses Explored","permalink":"/docs/openziti/blog/zrok-unleashed-top-10-uses-explored"},"nextItem":{"title":"zrok Custom Domains","permalink":"/docs/openziti/blog/zrok-custom-domains"}},"content":"Regular readers of this blog know that OpenZiti provides secure overlay networking between Ziti identities. \\nYou can improve security of your OpenZiti edge identities by using hardware-based private keys. \\nThis guide provides step-by-step instructions on integrating hardware security with OpenZiti. \\nIt uses Linux built-in TPM as a hardware security device. Similar steps will also work with other HSM devices.\\n\\n\x3c!-- truncate --\x3e\\n\\n## This is How I (en)Roll\\n\\nOn my Linux(Ubuntu) laptop I check that the kernel detected TPM hardware and created a device for it.\\n\\n```bash\\nziggy@hermes:~$ ls -l /dev/tpm*\\ncrw-rw---- 1 tss root  10,   224 Apr 26 14:41 /dev/tpm0\\ncrw-rw---- 1 tss tss  253, 65536 Apr 26 14:41 /dev/tpmrm0\\n```\\n\\nDevice `/dev/tpmrm0` is there, so I can proceed.\\n\\nAdd my user to the `tss` group so that the TPM device can be accessed. You will probably need to restart your login shell for that to take effect, check your groups with `id` command.\\n\\n```bash\\nziggy@hermes:~$ sudo usermod -G tss -a ziggy\\n```\\n\\nInstall some useful software packages to interact with the TPM device\\n\\n* `libtpm2-pkcs11-tools` - includes `tmp2_ptool` to initialize PKCS#11 token on TPM device\\n    \\n* `libtpm2-pkcs11-1` - TPM PKCS#11 library\\n    \\n* `opensc` - includes `pkcs11-tool` for interacting with PKCS#11 token. This is not needed for OpenZiti enrollment but is useful for inspecting tokens\\n    \\n\\n```bash\\nziggy@hermes:~$ sudo apt install libtpm2-pkcs11-tools libtpm2-pkcs11-1 opensc\\n```\\n\\nNow that I have access to the device and the needed software I can initialize the token and test PKCS#11 driver access to it\\n\\n```bash\\nziggy@hermes:~$ tpm2_ptool init\\naction: Created\\nid: 1\\n\\nziggy@hermes:~$ tpm2_ptool addtoken --pid 1 --sopin 1111 --userpin ziggy1 --label ziggy-tpm\\n\\nziggy@hermes:~/ziti$ pkcs11-tool --module /usr/lib/x86_64-linux-gnu/pkcs11/libtpm2_pkcs11.so --list-slots\\nWARNING: Getting tokens from fapi backend failed.\\nAvailable slots:\\nSlot 0 (0x1): ziggy-tpm\\n  token label        : ziggy-tpm\\n  token manufacturer : Infineon\\n  token model        : SLB9665\\n  token flags        : login required, rng, token initialized, PIN initialized\\n  hardware version   : 1.16\\n  firmware version   : 5.62\\n  serial num         : 0000000000000000\\n  pin min/max        : 0/128\\nSlot 1 (0x2): \\n  token state:   uninitialized\\n```\\n\\nNote: fapi backend warning can be [ignored](https://github.com/tpm2-software/tpm2-pkcs11/issues/655#issuecomment-781500908).\\n\\nTo enroll I need to get an enrollment token from my Ziti controller. Once I have that I can enroll. Let\u2019s enroll with `ziti-edge-tunnel`\\n\\n```bash\\n\\n# enroll identity with ziti-edge-tunnel\\nziggy@hermes:~$ ziti-edge-tunnel enroll -j ./ziggy.jwt -i ziggy.json -k \'pkcs11:///usr/lib/x86_64-linux-gnu/pkcs11/libtpm2_pkcs11.so?label=ziggy-key&pin=ziggy1\'\\n(1676722)[        0.000]    INFO ziti-sdk:utils.c:198 ziti_log_set_level() set log level: root=3/INFO\\n(1676722)[        0.000]    INFO ziti-sdk:utils.c:167 ziti_log_init() Ziti C SDK version 1.5.0 @ga39db85(HEAD) starting at (2025-02-24T15:21:31.292)\\n(1676722)[        0.000]    INFO ziti-sdk:ziti_enroll.c:112 ziti_enroll() Ziti C SDK version 1.5.0 @ga39db85(HEAD) starting enrollment at (2025-02-24T15:21:31.294)\\n(1676722)[        0.000]    INFO ziti-sdk:ziti_enroll.c:221 start_enrollment() pkcs11 key not found. trying to generate\\n```\\n\\nZIti identity is stores in the JSON file -- `ziggy.json` in my case. Let take a look\\n\\n```json\\n{\\n  \\"ztAPI\\": \\"https://<my-controller-address>:443\\",\\n  \\"id\\": {\\n    \\"cert\\": \\"-----BEGIN CERTIFICATE-----....\\",\\n    \\"key\\": \\"pkcs11:///usr/lib/x86_64-linux-gnu/libtpm2_pkcs11.so?label=ziggy-key&pin=ziggy1\\",\\n    \\"ca\\": \\"-----BEGIN CERTIFICATE-----....\\"\\n   }\\n}\\n```\\n\\nAs you can see the .id.key is referencing the private key stored in my laptop\'s TPM hardware. I can inspect it using `pkcs11-tool`\\n\\n```bash\\nziggy@hermes:~$ pkcs11-tool --module /usr/lib/x86_64-linux-gnu/pkcs11/libtpm2_pkcs11.so --list-objects --pin ziggy1          1 \u21b5\\nUsing slot 0 with a present token (0x1)\\nPublic Key Object; EC  EC_POINT 384 bits\\n  EC_POINT:   04610442fa885e120e9c63227aa7c53aeb84a52400264f3452fcf4dc4dbf4ade9ca46e7e15c4d37cc7a317edd860887ccd5746eea70cdea1d106b36b59297ecb93d43c57f4e8aef7029fa55f52cd740292d8de92fbce35c7788d3cc00f528cac2d0e4d\\n  EC_PARAMS:  06052b81040022 (OID 1.3.132.0.34)\\n  label:      ziggy-key\\n  ID:         dad9d0f20cc1d9ec\\n  Usage:      encrypt, verify, wrap\\n  Access:     local\\nPrivate Key Object; EC\\n  label:      ziggy-key\\n  ID:         dad9d0f20cc1d9ec\\n  Usage:      decrypt, sign, unwrap\\n  Access:     sensitive, always sensitive, never extractable, local\\n  Allowed mechanisms: ECDSA,ECDSA-SHA1,ECDSA-SHA256,ECDSA-SHA384,ECDSA-SHA512\\n```\\n\\nAs you can see my TPM token `ziggy-tpm` now has two objects private, and public keys with same label and id. OpenZiti SDK will use that hardware key to provide identity.\\n\\nNow I can start `ziti-edge-tunnel` with that identity:\\n\\n```plaintext\\nziggy@hermes:~$ sudo -E ziti-edge-tunnel run -i ziggy.json\\n```\\n\\nNote: `-E` flag is required since I initialized TPM token as user `ziggy` and there are some support files created in the user\u2019s `$HOME` directory."},{"id":"zrok-custom-domains","metadata":{"permalink":"/docs/openziti/blog/zrok-custom-domains","source":"@site/blog/zrok-custom-domains.md","title":"zrok Custom Domains","description":"With the latest release of myzrok.io we are excited to announce the introduction of","date":"2025-02-12T20:17:23.000Z","tags":[{"inline":false,"label":"DNS","permalink":"/docs/openziti/blog/tags/dns","description":"DNS topics"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"},{"inline":false,"label":"myzrok","permalink":"/docs/openziti/blog/tags/myzrok","description":"MyZrok custom tag"}],"readingTime":5.01,"hasTruncateMarker":true,"authors":[{"name":"Nick Pieros","title":"Author","url":"https://github.com/nf-npieros","imageURL":"https://avatars.githubusercontent.com/nf-npieros","key":"NickPieros","page":null}],"frontMatter":{"title":"zrok Custom Domains","seoDescription":"Introducing zrok custom domains: Use your own domain for zrok shares, boosting brand identity and share visibility for Pro plan users","date":"2025-02-12T20:17:23.000Z","cuid":"cm72cr7mq000408la89h44kh2","slug":"zrok-custom-domains","authors":["NickPieros"],"image":"@site/blogs/openziti/v1739389834988/18400a05-53fc-45ca-b458-c4c56b7b4b81.png","imageDark":"@site/blogs/openziti/v1739389834988/18400a05-53fc-45ca-b458-c4c56b7b4b81.png","tags":["dns","zrok","myzrok"]},"unlisted":false,"prevItem":{"title":"Securing Ziti Identities with HSM/TPM","permalink":"/docs/openziti/blog/securing-ziti-identities-with-hsmtpm"},"nextItem":{"title":"Golang Aha! Moments: OOP","permalink":"/docs/openziti/blog/golang-aha-moments-oop"}},"content":"With the latest release of [myzrok.io](http://myzrok.io) we are excited to announce the introduction of \\n[custom domains](https://docs.zrok.io/docs/myzrok/custom-domains/)!\\n\\n\x3c!-- truncate --\x3e\\n\\n## TL;DR\\n\\nYou can now use your own domain when creating [zrok](https://zrok.io) shares! With a zrok custom domain you\u2019ll be able to create shares like `<token>.your.domain.com` instead of `<token>.share.zrok.io`. You\u2019ll need to bring your own domain and have a [myzrok.io](http://myzrok.io) Pro plan to get started. Creating a zrok custom domain via myzrok will create a zrok frontend for you. This will allow you to create [ephemeral shares](https://docs.zrok.io/docs/concepts/sharing-public/) or [reserved shares](https://docs.zrok.io/docs/concepts/sharing-reserved/) using your domain name instead of zrok\u2019s!\\n\\n## What is myzrok?\\n\\n[myzrok](http://myzrok.io) is the self-service billing portal for your zrok account. This is where you can upgrade your zrok to the different plans outlined on our [pricing page](https://zrok.io/pricing/) to receive increased data, share, and environment limits based on your needs. This is also where you will now be able to create and manage custom domains if you have a Pro plan!\\n\\n## Why Custom Domains?\\n\\nUp to this point, all [zrok](https://zrok.io) hosted shares have been created using the `share.zrok.io` domain. This is great when you want to get something hosted quickly and easily. However, there are situations where it would be really nice to host a share on your own domain to make it identifiably yours. This is where custom domains come into play.\\n\\n## How Does it Work?\\n\\nYou can set up your custom domain in just a few easy steps:\\n\\n1. Bring your own custom domain name\\n    \\n2. Create DNS records for certificate validation and traffic routing\\n    \\n3. Wait for zrok to validate your records and finalize configuration\\n    \\n4. Start sharing!\\n    \\n\\nYou only need to do this once, after that you can create your shares like normal but utilize your domain instead of zrok\u2019s!\\n\\nCan\u2019t wait to get started? Check out the step by step instructions in our [guide here](https://docs.zrok.io/docs/myzrok/custom-domains/)!\\n\\n## Custom Domains in Action\\n\\nLet\u2019s take a look at how custom domains make zrok even more useful. Let\u2019s say that I own a company `acme-corp` and I\u2019ve got an upcoming convention I would really like to demo my latest software at. Rather than deploying to an environment, I could run my demo locally and use zrok to create a reverse proxy, which would allow others to access it. This works great, but by sharing my demo via a `zrok share` command, I would end up with a share link like `https://sjy8zgif4s8w.share.zrok.io/`. While this is nice and simple, the link generated doesn\u2019t really identify my company, making it harder to leave a lasting impact. This is where a zrok custom domain comes in!\\n\\nTo do this I first create a zrok custom domain `demo.acme-corp.com` using the `acme-corp.com` domain.\\n\\n![](/blogs/openziti/v1739205451276/20f27da7-7f4e-4f77-90da-eb3ec06b4cd8.png)\\n\\nOnce the custom domain is created, I simply create a few DNS records for `acme-corp.com`. Within a few minutes I\u2019m able to use the `demo.acme-corp.com` domain in my zrok shares!\\n\\n![](/blogs/openziti/v1739205561400/54eb0324-fcfa-4fff-9ef4-afc54bd352c8.png)\\n\\nBy creating a custom domain, I have also created a [zrok frontend](https://docs.zrok.io/docs/guides/self-hosting/personalized-frontend/). This will create shares in the form of `<token>.demo.acme-corp.com`. This is much more identifiable to my company however, it still leaves me with the share token at the start of my share. I can improve this by creating a [reserved share](https://docs.zrok.io/docs/concepts/sharing-reserved/). This will reserve a unique identifier for me to use in place of my share token. Not only can I make my share even more branded towards my specific use case, but I can also start and stop it and still maintain the same link!\\n\\nI\u2019ll first set my frontend as the default for my environment, then I\u2019ll create a reserved share for the resource I want to share. In this case it\u2019s a demo app running on localhost:4000\\n\\n```bash\\nzrok config set defaultFrontend demo-acme-corp_YS6RyLSod\\nzrok configuration updated\\n\\n\\nzrok reserve public --unique-name \\"summit\\" http://localhost:4000\\n[   0.388]    INFO main.(*reserveCommand).run: your reserved share token is \'summit\'\\n[   0.388]    INFO main.(*reserveCommand).run: reserved frontend endpoint: https://summit.demo.acme-corp.com\\n\\nzrok share reserved \\"summit\\"\\n```\\n\\nI can then have people visit `summit.demo.acme-corp.com` to check my demo\\n\\n![](/blogs/openziti/v1739206842262/d9f16273-9aa1-4d66-bbce-eb4f744a36f2.png)\\n\\nSuccess!\\n\\n![](/blogs/openziti/v1739206905400/6c6c4029-af97-4ece-9f7a-d95d4fab185e.png)\\n\\nThis is a relatively simple example of how custom domains can be used to enhance your zrok experience. There are many times where I might want to share something a bit more permanent than a demo, such as a production app. This is where I could take advantage of [zrok frontdoor](https://docs.zrok.io/docs/guides/frontdoor/) alongside my custom domain. A zrok frontdoor would allow me to run zrok alongside my production app, enabling me to publicly expose access to it via a reserved share!\\n\\n## Wrapping Up\\n\\nIf you\u2019re ready to dive in and create your own custom domain head over to [myzrok.io](http://myzrok.io), sign up for a Pro plan and navigate to the custom domains page ( icon). For a more in-depth look at how to setup a custom domain you can [check out the guide here](https://docs.zrok.io/docs/myzrok/custom-domains/).\\n\\nIf you find this interesting and like what we\u2019re doing, [consider starring the project on GitHub](https://github.com/openziti/zrok)! zrok is open source and built on [OpenZiti](https://github.com/openziti/ziti), which is another great project to check out and star if you haven\u2019t done so already!\\n\\nIf you want to show us how zrok or ziti have been improving your workflow or have feedback you\u2019d like to share with the team we\u2019d love to hear from you over at\xa0 [X](https://twitter.com/openziti), [reddit](https://www.reddit.com/r/openziti/), or at our [Discourse](https://openziti.discourse.group/)!"},{"id":"golang-aha-moments-oop","metadata":{"permalink":"/docs/openziti/blog/golang-aha-moments-oop","source":"@site/blog/golang-aha-moments-oop.md","title":"Golang Aha! Moments: OOP","description":"Moving to Go as my primary development language was a surprisingly easy transition. Coming from a language with strong OOP roots, like Java, I quickly found many analogs for the OOP constructs I was used to, but also had to adjust my thinking.","date":"2024-11-01T14:05:06.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Java","permalink":"/docs/openziti/blog/tags/java","description":"Java content"},{"inline":false,"label":"Object Oriented Programming","permalink":"/docs/openziti/blog/tags/object-oriented-programming","description":"OOP content"},{"inline":false,"label":"golang-aha","permalink":"/docs/openziti/blog/tags/golang-aha","description":"Golang Ahas!"}],"readingTime":12.33,"hasTruncateMarker":true,"authors":[{"name":"Paul Lorenz","title":"Author","url":"https://github.com/plorenz","imageURL":"https://avatars.githubusercontent.com/plorenz","key":"PaulLorenz","page":null}],"frontMatter":{"title":"Golang Aha! Moments: OOP","date":"2024-11-01T14:05:06.000Z","cuid":"cm2yt3p2r000109kzfpv88qvp","slug":"golang-aha-moments-oop","authors":["PaulLorenz"],"image":"@site/blogs/openziti/v1730383460910/9b2d0062-8b76-47c6-b68d-24810fca9f8b.webp","imageDark":"@site/blogs/openziti/v1730383460910/9b2d0062-8b76-47c6-b68d-24810fca9f8b.webp","tags":["golang","java","object-oriented-programming","golang-aha"]},"unlisted":false,"prevItem":{"title":"zrok Custom Domains","permalink":"/docs/openziti/blog/zrok-custom-domains"},"nextItem":{"title":"The safest way to make Portainer Internet accessible","permalink":"/docs/openziti/blog/the-safest-way-to-make-portainer-internet-accessible"}},"content":"Moving to Go as my primary development language was a surprisingly easy transition. Coming from a language with strong OOP roots, like Java, I quickly found many analogs for the OOP constructs I was used to, but also had to adjust my thinking.\\n\\nThis article walks through some of Go\u2019s object oriented features and also discusses how some patterns common in other languages can be written in a way that\u2019s closer to idiomatic Go. It also covers some features of Go that surprised and (in some cases) delighted me.\\n\\n\x3c!-- truncate --\x3e\\n\\n# Is Go Object Oriented?\\n\\nGo allows you to group data into structs, and to associate logic to those structs.\\n\\n```go\\ntype Beans struct {\\n    Count int\\n}\\n\\nfunc (beans *Beans) Spill(n int) {\\n    beans.Count = beans.Count - n\\n    fmt.Printf(\\"spilled %d beans\\\\n\\", n)\\n}\\n```\\n\\nSince Go supports these simple features, it meets certain bare-minimum standard for object oriented coding.\\n\\nHowever, as we\u2019ll cover below, many features like inheritance, method overriding, and abstract types work differently or not at all.\\n\\n### Inheritance vs Composition\\n\\nEven in languages with a strong object oriented bias, people often give the advice to favor composition over inheritance. Large complicated type hierarchies can lead to fragile designs and unexpected behavior.\\n\\nGo is strongly biased towards composition. This, in my experience, leads to cleaner, simpler designs, that are easier to refactor and have less surprising behavior.\\n\\n**Note:** Most of the patterns explored below aren\u2019t exclusive to Go. Go just encourages them more than other languages may.\\n\\n### Fun with functions: Nil Receivers\\n\\nOne difference from languages like Java, is that a nil receiver is allowed and can be handled in Go code. This is the equivalent of being able to call a method on a `null` object in Java without a `NullPointerException` and have the method check if `this` is null.\\n\\n```go\\ntype Beans struct {\\n    Count int\\n}\\n\\nfunc (beans *Beans) Spill(n int) {\\n    if beans == nil {\\n        fmt.Printf(\\"you\'ve got no beans to spill!\\\\n\\")\\n     } else {    \\n        beans.Count = beans.Count - n\\n        fmt.Printf(\\"spilled %d beans\\\\n\\", n)\\n    }\\n}\\n```\\n\\n# What do we want to do?\\n\\nRather than just look at language features, we\u2019re going to look at what we\u2019re trying to accomplish. Then we can see how to achieve our goals in Go, and how that might be different than a pure object-oriented approach.\\n\\n## Handle different types with a common set of methods\\n\\nFor polymorphic types, Go uses interfaces.\\n\\n```go\\ntype Spillable interface {\\n    Spill(amount int)\\n}\\n\\ntype Beans struct {\\n    Count int\\n}\\n\\nfunc (beans *Beans) Spill(n int) {\\n    beans.Count = beans.Count - n\\n    fmt.Printf(\\"spilled %d beans\\\\n\\", n)\\n}\\n\\ntype Tea struct {\\n    Volume int\\n}\\n\\nfunc (t *Tea) Spill(n int) {\\n    t.Volume = t.Volume - n\\n    fmt.Printf(\\"spilled %d ml of tea\\\\n\\", n)\\n}\\n```\\n\\nYou may have noticed that the types don\u2019t have to declare that they are `Spillable`.\\n\\n### Duck(-ish) Typing\\n\\nUnlike many other languages, Go types do not have to explicitly state which interfaces they implement. If the type has the correct methods, it can be used as that interface type.\\n\\nI\u2019m not sure if it\u2019s accurate to call this duck typing, since you still need to define interfaces. But from where I\u2019m standing, it looks a lot like duck typing and sounds like duck typing, so I\u2019m going to call it duck typing.\\n\\nThis focuses the attention on where the interface is used, not where it\u2019s implemented. In cases where a type is used in multiple contexts, Go pushes you towards multiple interfaces, one for each context. In other languages, I\u2019ve seen types end up with one massive interface, covering all the possible contexts where it might be needed.\\n\\nConsider an HR application. It might have various entities\\n\\n```go\\npackage employees\\n\\ntype Employee struct {\\n    // has name, email, address, salary, etc\\n}\\n```\\n\\n```go\\npackage vendors\\n\\ntype Vendor struct {\\n   // has company name, email, address\\n}\\n```\\n\\nYou might have a couple of modules, one for sending out email notifications and another for payroll.\\n\\n```go\\npackage emailer\\n\\ntype Contact interface {\\n   Email() string\\n   Name() string\\n}\\n\\nfunc SendEmail(contact Contact, subj, body string) error { ... }\\n```\\n\\n```go\\npackage payroll\\n\\ntype Payee interface {\\n    Name() string\\n    HomeAddress() string\\n    Salary() float32\\n}\\n\\nfunc SendPaychecks(payee Payee) error { ... }\\n```\\n\\nNote that the payroll and email packages don\u2019t know anything about the employee and vendor packages.\\n\\n### Package Coherency\\n\\nGo encourages keeping interfaces in the package where they are consumed. Let\u2019s try adding an `Email` method to `Employee`.\\n\\n```go\\nfunc (emp* Employee) Email(string subj, string body) error {\\n    return email.Email(emp.EmailAddress, subj, body)\\n}\\n```\\n\\nIf the `Contact` interface was defined in the `employee` package, we\u2019d end up with a circular package dependency error. If the `emailer` package didn\u2019t have a `Contact` interface, and was able to take `Employee` instances directly, that would also cause a circular package dependency error.\\n\\nI found circular package dependency errors to be very frustrating when I first started with Go. Now however, having gotten more comfortable with Go style interfaces, I\u2019ve realized the following:\\n\\n1. It\u2019s OK to have smaller, highly specific interfaces per package. There may be some overlap, but each package will end up with exactly what\u2019s needed. This makes the use clearer for developers using the package.\\n    \\n2. Having the interfaces in the package will also decouple the package from other packages, eliminating circular dependency issues.\\n    \\n\\nI\u2019m still occasionally annoyed by circular dependency errors, but overall feel that the limitation promotes package decoupling and coherency.\\n\\n### Requiring Type Interface Conformance\\n\\nIn most cases, if your type doesn\u2019t match up with your interface, you\u2019ll get a compile error. In some cases, where you may be doing runtime checks before converting, you might not notice that your type no longer fits the interface.\\n\\nIf you wish to guarantee at compile time that a specific type implements a given interface, you can do this as follows:\\n\\n```go\\nvar _ Spillable = (*Tea)(nil)\\n```\\n\\n### Fun with functions: Function Vs Interface\\n\\nSometimes you may have an API that only requires a single method. Something like:\\n\\n```go\\ntype MessageHandler interface {\\n    Handle(msg []byte) error\\n}\\n\\ntype MessageHandlers interface {\\n    AddHandler(msgType string, handler MessageHandler)\\n}\\n```\\n\\nThis could also be implemented using a function type.\\n\\n```go\\ntype MessageHandler func (msg []byte) error\\n\\ntype MessageHandlers interface {\\n    AddHandler(msgType string, handler MessageHandler)\\n}\\n```\\n\\nWhich to use? For some library consumers a function may be more convenient. For others, an interface to implement would be better. Fortunately Go lets you handle both. In Go a function type can have methods defined on it.\\n\\nThis broke my brain slightly when I first encountered it, but it works well to allow both kinds of API.\\n\\n```go\\ntype MessageHandler interface {\\n    Handle(msg []byte) error\\n}\\n\\ntype MessageHandlerF func (msg []byte) error\\n\\nfunc (f MessageHandlerF) Handle(msg []byte) error {\\n    f(msg)\\n}\\n\\n// example use\\nhandlers.AddHandler(MessageHandlerF(func (msg []byte) error {\\n    return nil\\n}))\\n```\\n\\n### Extending Interfaces\\n\\nGo interfaces can extend other interfaces. The classic examples are the types in the `io` package.\\n\\n```go\\ntype Closer interface {\\n    Close() error\\n}\\n\\ntype Reader interface {\\n    Read(b []byte) (n, error)\\n}\\n\\ntype ReadCloser() {\\n   Closer\\n   Reader\\n}\\n```\\n\\nOlder versions of Go used to complain if you extended multiple interfaces that had overlapping method signatures. Recent versions of Go no longer have this limitation, as long as method signatures with the same name match exactly.\\n\\n### Anonymous Interfaces\\n\\nThere may be times when you want to invoke a method on a variable, but the method isn\u2019t on the interface you\u2019ve got. You can use an anonymous interface to check if the method exists, and if it does, invoke it.\\n\\nI\u2019m not sure there\u2019s ever a strong reason to use an anonymous interface over declaring a named interface. I\u2019ve used this feature when an interface was only used in a single method.\\n\\nIn this example we\u2019re looking for a non-standard close method.\\n\\n```go\\nfunc CloseIt(v any) error {\\n    if closeable, ok := v.(interface{ CloseMe() error }); ok {\\n        return closeable.CloseMe()\\n    }\\n    return nil\\n}\\n```\\n\\n## We Want to Share Functionality Across Types\\n\\nIn object-oriented languages, extending a type (or sometimes multiple types) to create a new type is very common. Go does not allow structs to extend other structs in exactly the same way as most object oriented languages.\\n\\nWhat it does offer is type composition that can look something like inheritance. We\u2019ll look at how it works, and the potential pitfalls from this approach.\\n\\nGo allows embedding both structs and interfaces.\\n\\n```go\\ntype Knocker interface {\\n    Knock()\\n}\\n\\ntype Door struct {\\n    lock sync.Mutex\\n    knocker Knocker\\n}\\n```\\n\\nThe Door type has a lock and knocker. As they are, they are just struct members. Since they are private, they won\u2019t be accessible outside the package. If you try to `Lock` the door or `Knock` at the door, the compiler will complain.\\n\\nA door isn\u2019t a lock or a knocker, it has a lock and and a knocker. However, it still makes sense to be able to Lock or Knock the door itself. We can do that as follows.\\n\\n```go\\n type Knocker interface {\\n    Knock()\\n}\\n\\ntype Door struct {\\n    sync.Mutex\\n    Knocker\\n}\\n```\\n\\nWhen we embed types in our struct this way, the methods and fields of the embedded types become accessible at the top-level of the struct. The embedded types can still be referenced individually using the type name.\\n\\n```go\\ndoor := &Door{\\n    Knocker : &BrassKnocker{},\\n}  \\n\\ndoor.Mutex.Lock()\\ndoor.Unlock()\\ndoor.Knocker.Knock()\\ndoor.Knock()\\n```\\n\\nNote that we could also embed a pointer type.\\n\\n```go\\ntype Door struct {\\n    *sync.Mutex\\n    Knocker\\n}\\n```\\n\\n### Method Overriding vs Method Shadowing\\n\\nMethods from embedded types can\u2019t be overridden, in an OO sense, but they can be shadowed. Here\u2019s an example to highlight the difference.\\n\\n```go\\ntype A struct {}\\n\\nfunc (a *A) String() string {\\n    return a.Name() \\n}\\n\\nfunc (a *A) Name() string {\\n   return \\"A\\"\\n}\\n\\ntype B struct {\\n    A\\n}\\n\\nfunc (b *B) Name() string {\\n    return b.A.Name() + \\" or B\\"\\n}\\n\\nfunc main () {\\n    a := &A{}\\n    b := &B{}\\n    fmt.Println(a.Name())    // output: \\"A\\"\\n    fmt.Println(a.String())  // output: \\"A\\"\\n    fmt.Println(b.Name())    // output: \\"A or B\\"\\n    fmt.Println(b.String())  // output: \\"A\\"      <-- Maybe unexpected\\n}\\n```\\n\\nBecause `A` doesn\u2019t know that it\u2019s embedded by `B`, it won\u2019t call `B`\'s versions of methods that have been overridden. As long as you use type embedding with a composition mindset instead of an inheritance mindset, you should be OK.\\n\\n### I Want Abstract Types!\\n\\nAbstract types can be a very useful way of providing some base functionality that relies on methods to be supplied by a sub-type. When I first started using Go, I was generally happy and productive with the language. Two things I missed from Java were generics and abstract data types. Generics have since come to [Go in version 1.18](https://go.dev/blog/intro-generics), and I\u2019ve since learned patterns better suited to Go to replace abstract data types.\\n\\nHere\u2019s a java example of an abstract data type:\\n\\n```java\\npublic abstract class AbstractDataStore<T> {\\n    \\n    public abstract T LoadEntity(Row r);\\n    \\n    public List<T> ListEntities(Database db, String query) {\\n         Cursor c = db.ExecuteQuery(query);\\n         List<T> result = new ArrayList<T>(); \\n         while (c.HasNext()) {\\n             Row row = c.Next();\\n             T entity = this.LoadEntity(row);\\n             result.Add(entity);\\n         }\\n         return result;\\n    }\\n}\\n```\\n\\nWe\u2019ve got a data store that\u2019s got some generic functionality to iterate over database results and build an entity list. Each concrete implementation would manage the details specific to that entity type.\\n\\n### The Wrong Way\\n\\nThe first time I tried modeling something like this in Go, I came up with a pattern similar to abstract types, but significantly worse because the underlying abstractions weren\u2019t there to support it.\\n\\nThe idea was that if you defined the full API as an interface, the abstract type could keep a reference to the concrete type, and call it as necessary.\\n\\n```go\\ntype DataStore[T any] interface {\\n    LoadEntity(r *Row) T\\n    ListEntities(db Database, query string) []T\\n}\\n\\ntype BaseStore[T any] struct {\\n    impl DataStore[T]\\n}\\n\\nfunc (store *BaseStore[T]) ListEntities(db Database, query string) []T {\\n    cursor = db.ExecuteQuery(query)\\n    var result []T\\n    for cursor.HasNext() {\\n        row := cursor.Next()\\n        entity := store.impl.LoadEntity(r)\\n        result = append(result, entity)\\n    }\\n    return result\\n}\\n```\\n\\nWhile this does work, it has a downside. If you treat it as an actual abstract type and try to override any of the base methods in the embedding type, they will only be shadowed. If you then ever forget to call the concrete version on the embedded `impl`, you\u2019ll get the default version. This kind of bug can be easy to miss and hard to track down.\\n\\nSubjectively, it also doesn\u2019t feel right. It feels like we\u2019re working against the language, rather than with it.\\n\\n### A Better Way\\n\\nThe solution above is not that far off from something that feels more in line with Go\u2019s ethos.\\n\\nWhat is it we\u2019re trying to accomplish? We\u2019ve got a core set of functionality that needs to delegate some logic. There\u2019s another pattern that fits this description:\\n\\n#### Strategies\\n\\nInstead of trying to implement abstract types, we can use strategies. Let\u2019s look at what a strategy oriented version of the above code would look like:\\n\\n```go\\ntype EntityLoader[T any] interface {\\n    LoadEntity(r *Row) T\\n}\\n\\ntype Store[T any] struct {\\n    entityLoader EntityLoader[T]\\n}\\n\\nfunc (store *Store[T]) ListEntities(db Database, query string) []T {\\n    cursor = db.ExecuteQuery(query)\\n    var result []T\\n    for cursor.HasNext() {\\n        row := cursor.Next()\\n        entity := store.entityLoader.LoadEntity(r)\\n        result = append(result, entity)\\n    }\\n    return result\\n}\\n```\\n\\nIt looks very similar, but the intent is different. This is a composition-oriented approach. Rather than extending a BaseStore, then overriding pieces, we compose the various strategies we might need.\\n\\nThis approach also lends itself to sharing functionality in a clean way. You might have three or four different strategies. Some of them might have default implementations that are rarely replaced. Some might have only a small set of implementations that are used across many instances. Some might be different for every instance.\\n\\nRather than trying to shape these as overrides in a convoluted type hierarchy, each instance can mix and match as needed.\\n\\n# Conclusion\\n\\nEvery language has some inbuilt preferences. If you\u2019re coming from a heavily object-oriented language, it can take time to adapt how you design your data types in Go. However, I think Go pushes you towards code that is less fragile and cleaner. If I were to write Java code again, it would be positively influenced by the habits I\u2019ve picked up from Go.\\n\\n## About OpenZiti\\n\\n[OpenZiti](http://github.com/openziti/ziti) is an open-source platform for providing secure and reliable access to network applications. It does this using strong, certificate-based identities, end-to-end encryption, mesh networking, policy-based access control, and app-embedded SDKs. If you find this interesting, please consider [**starring us on GitHub**](https://github.com/openziti/ziti/). It helps to support the project! And if you haven\'t seen it yet, check out [**zrok.io**](https://zrok.io). It\'s a free sharing platform built on OpenZiti! It uses the OpenZiti Go SDK since it\'s a ziti-native application. It\'s also [**all open source too!**](https://github.com/openziti/zrok/)\\n\\nTell us how you\'re using OpenZiti on [**X**](https://twitter.com/openziti)**<s>Twitter</s>**, [**Reddit**](https://www.reddit.com/r/openziti/), or over at our [**Discourse**](https://openziti.discourse.group/). Or you can check out [**our content on YouTube**](https://youtube.com/openziti) if that\'s more your speed. Regardless of how, we\'d love to hear from you."},{"id":"the-safest-way-to-make-portainer-internet-accessible","metadata":{"permalink":"/docs/openziti/blog/the-safest-way-to-make-portainer-internet-accessible","source":"@site/blog/the-safest-way-to-make-portainer-internet-accessible.md","title":"The safest way to make Portainer Internet accessible","description":"If you run Portainer, and you seek a modern, flexible recipe for how to make it secure while also providing flexible","date":"2024-10-03T16:15:23.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Web Security","permalink":"/docs/openziti/blog/tags/web-security","description":"Web security content"},{"inline":false,"label":"Portainer","permalink":"/docs/openziti/blog/tags/portainer","description":"Portainer container management"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Ziti","permalink":"/docs/openziti/blog/tags/ziti","description":"Ziti related posts"}],"readingTime":7.79,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"title":"The safest way to make Portainer Internet accessible","date":"2024-10-03T16:15:23.000Z","cuid":"cm1thzk20000908jq6fic8x00","slug":"the-safest-way-to-make-portainer-internet-accessible","authors":["CurtTudor"],"image":"@site/blogs/openziti/v1727532608880/5fb5b813-b9cf-4fe7-9d36-ffb921cda67a.jpeg","imageDark":"@site/blogs/openziti/v1727532608880/5fb5b813-b9cf-4fe7-9d36-ffb921cda67a.jpeg","tags":["security","web-security","portainer","zerotrust","ziti"]},"unlisted":false,"prevItem":{"title":"Golang Aha! Moments: OOP","permalink":"/docs/openziti/blog/golang-aha-moments-oop"},"nextItem":{"title":"Multifactor Zero Trust ssh","permalink":"/docs/openziti/blog/multifactor-zero-trust-ssh"}},"content":"If you run Portainer, and you seek a modern, flexible recipe for how to make it secure while also providing flexible \\naccess to your authorized users, this article is for you.\\n\\nA question that sometimes gets asked is: *What types of companies, self-hosters, or general use cases, will gain the greatest benefit from using* [*OpenZiti BrowZer*](./introducing-openziti-browzer.md)?\\n\\n\x3c!-- truncate --\x3e\\n\\nTo help answer the \u201c*who benefits*\u201d question, much like I did in a [previous article](./effortless-docker-management-with-private-web-access), this article will frame the answer in the context of a web application named [Portainer](https://www.portainer.io/) (a web-accessible container management platform) when it needs to be internet-facing.\\n\\n`NOTE: Upcoming articles will describe how similar techniques employing BrowZer can be used to protect and secure other popular web applications. So be sure to subscribe to this blog to be notified when those articles are published.`\\n\\n# Why is Portainer interesting?\\n\\nPortainer can be used to manage Docker, Kubernetes, and other container environments. It is primarily a web-based management interface, designed to be accessed via a browser. The web-based approach provides convenient access and centralized management, allowing users to interact with their container infrastructure \u2026***from anywhere***.\\n\\nCompanies benefiting from Portainer include teams with limited in-house container management expertise, those with rapid deployment requirements, those having resource constraints/constrained IT budgets, or teams with members of varying skills, technical and non-technical. It also benefits those with a security and compliance focus.\\n\\nHobbyists and IT enthusiasts can also benefit from Portainer to manage containerized services for personal projects, home automation, media servers, and more.\\n\\nNeed to check on something in your docker fleet\u2026 while you are standing in line at the coffee shop? Just open a browser on your phone, and surf to your Portainer instance. Easy. Convenient. Powerful.\\n\\nHowever\u2026as the old saying goes: *Don\u2019t run with scissors*.\\n\\nPortainer is an exceptionally privileged piece of software, and it has near root-level access to your Container infrastructure, so you had better make sure your Portainer instance is safe from malicious actors.\\n\\n# How to secure Portainer (without BrowZer)\\n\\nGetting Portainer up and running is very straightforward using their standard deployment scripts.\\n\\nWhen I decided to kick the tires, I used the following code in a `docker compose` file:\\n\\n```yaml\\n  portainer:\\n    image: portainer/portainer-ce:2.21.0\\n    restart: unless-stopped\\n    ports:\\n      - \\"8000:8000\\"\\n      - \\"8080:9000\\"\\n    volumes:\\n      - /var/run/docker.sock:/var/run/docker.sock\\n      - ./portainer_data:/data\\n```\\n\\nBut when you\'ve decided to allow access to Portainer from the public internet, things require more work.\\n\\nVarious [writeups](https://www.portainer.io/blog/how-to-correctly-secure-portainer-when-presented-on-the-internet) have been [published](https://www.portainer.io/blog/how-to-secure-your-portainer-installation) by the friendly folks on the Portainer team to provide advice on how to secure Portainer. While not wrong, the instructions are (in my opinion) inflexible and antiquated.\\n\\nThey mention `port forwarding` the Portainer UI ports (http:9000/https:9443) from a public IP to Portainer.\\n\\n> This implies you must open some ports to the internet. Having ports open to the internet is something we on the [OpenZiti project](https://openziti.io/), as well as all zero-trust advocates in general, will advise against.\\n\\nThey strongly recommend network ACLs on your firewall, so you only allow access from known trusted IP addresses.\\n\\n> This is painful and tedious to set up correctly. It is technically out of reach for many. And, it is also incredibly brittle and inflexible (recall my coffee shop reference \u2014 this use case would be precluded in this scenario).\\n\\nThey even question if you want to expose it to the internet directly at all, and instead, suggest you set up a VPN.\\n\\n> VPN deployment and configuration is a non-starter for many because of complexity, and inflexibility.\\n\\nThey assert that Portainer\'s internal authentication system should **never** be used when presenting Portainer to the internet, but instead you should configure an authentication system to use a suitably secure external mechanism, such as \\"LDAP\\" or \\"OAuth\\" (the latter of which supports 2FA/MFA).\\n\\n> Again, this is getting to be a heavy lift for many teams.\\n\\nUnderstandably, they suggest you force/enable the **HTTPS only** option, and upload your own x509 certificates.\\n\\n> Many would have given up before this :(\\n\\n# How to secure Portainer (with BrowZer)\\n\\nA better topology is one where Portainer resides in a [**VPC**](https://en.wikipedia.org/wiki/Virtual_private_cloud), and the host has NO ports open to the internet. In this kind of deployment, Portainer will be completely invisible to the internet.\\n\\nI hear you thinking: *How do I access Portainer over the web if it\u2019s invisible*?\\n\\nThe answer is via a zero-trust overlay network that requires authentication before you (or anyone) can connect to it.\\n\\n### How to Easily Deploy a Zero-Trust Overlay Network\\n\\nThe component that implements the zero-trust overlay network solution is OpenZiti.\\n\\n[**OpenZiti**](https://openziti.io/) is an open-source project that brings zero-trust networking principles directly into any application. The project provides all the pieces required to implement a zero-trust overlay network and provides all the tools necessary to integrate zero trust into your existing solutions.\\n\\n### BrowZer\\n\\nThe next component involved in the solution is `BrowZer`.\\n\\nThe `Z` in this component\'s name (within the word normally spelled \\"*browser*\\") is not a typo. It is a purposeful indication that this solution, unique in today\'s technology offerings for securing browser-based applications, is built as part of the [**OpenZiti project**](https://github.com/openziti/).\\n\\nBrowZer enables you and your organization, enterprises, and self-hosting enthusiasts alike, in the cloud or at home, to operate private-to-the-internet web applications while still easily providing secure access for your authorized internet-based remote users.\\n\\nI previously published a lengthy article that introduced the [**concept of browZer**](./introducing-openziti-browzer.md). I recommend giving it a read.\\n\\nThere is a vast amount of documentation, as well as [**quick starts for BrowZer**](https://openziti.io/docs/learn/quickstarts/browzer/example/), on the OpenZiti site.\\n\\nThere is also some related ZitiTV content:\\n\\n%[https://www.youtube.com/watch?v=ZPkOQbVEnW0&t=816s] \\n\\nNOTE: If you like what you read about OpenZiti, or what you saw in the above ZitiTV episode, but prefer not to self-host it yourself, [**we**](https://netfoundry.io/) also offer a [zero-trust networking platform](https://netfoundry.io/). If that interests you, [**reach out to us for more discussion.**](https://netfoundry.io/lets-talk/)\\n\\nHere is a diagram that describes at a high level how browZer operates:\\n\\n![](/blogs/openziti/v1727968501738/3fa80598-cf57-48f0-9fe3-c3dae201a33d.png)\\n\\n### Example of Accessing Portainer over BrowZer\\n\\nHere is what a user would experience using browZer to access a private-to-the-internet instance of Portainer:\\n\\n![](/blogs/openziti/v1727804563586/4b5e5d9a-5a4f-461a-8bb7-cfe4232d091a.gif)\\n\\nHere\'s what happens above:\\n\\n* Brave web browser hits the public URL representing the protected instance of Portainer. This is where the BrowZer Bootstrapper runs.\\n    \\n* The BrowZer runtime is loaded into Brave by the BrowZer Bootstrapper\\n    \\n* Brave is redirected by BrowZer runtime to Auth0, then federated to Google (with 2FA) for authentication\\n    \\n* Using the OIDC auth token received from Auth0, the BrowZer runtime then (transparently) authenticates onto the Ziti overlay network and then bootstraps the necessary x509 certs into the Brave tab, and the BrowZer runtime then loads the Portainer web app over the [mTLS](https://en.wikipedia.org/wiki/Mutual_authentication#mTLS)\\\\-based zero-trust overlay network from the Portainer server which is invisible to the internet.\\n    \\n* User is presented with Portainer login screen, and user authenticates using Portainer\u2019s internal authentication system (no need to integrate or setup an external \\"LDAP\\" or \\"OAuth\\" system)\\n    \\n* User clicks on BrowZer button, looks at various BrowZer settings, HTTP throughput chart, BrowZer changelog, BrowZer feedback form, etc\\n    \\n* User is presented with Portainer GUI welcome screen showing that 2 Containers are running (one is Portainer, the other is an instance of the BrowZer Bootstrapper for a staging environment)\\n    \\n* User clicks around, looks at logs for a running container, also removes an old Docker image, and then logs out\\n    \\n\\n# The BrowZer Difference\\n\\nIn the above section, we discussed how difficult it can be to properly secure Portainer using \u201c*traditional techniques*\u201d.\\n\\nBrowZer uses more modern, game-changing techniques that can not only properly secure your Portainer, but do it more easily, more flexibly, and more thoroughly.\\n\\nWith BrowZer there is:\\n\\n* no need to expose Portainer ports to the internet or mess around with port forwarding.\\n    \\n* no need to fuss with network ACLs on your firewall, or only allow access from statically configured IP addresses.\\n    \\n* no need to install VPN software on clients.\\n    \\n* remote access from ANY device that has a browser.\\n    \\n* remote access from ANY location on the internet.\\n    \\n* no need to alter Portainer AT ALL (use it off the shelf).\\n    \\n* retained ability to use Portainer\u2019s built-in auth system.\\n    \\n* 2FA/MFA for free (use whatever IdP you want)\\n    \\n* not only is there HTTPS/TLS, but also automatic mTLS, and even end-to-end XChaCha20-Poly1305 encryption ***before*** data hits the mTLS wire.\\n    \\n\\n# **Wrap up**\\n\\nDo you host a web app (like Portainer) and want to be invisible to malicious intruders?\\n\\nDo you want your users to have easy access from anywhere with no additional software on their client devices?\\n\\nDo you want to do all this without making any modifications to the web app?\\n\\nIf so, then we hope you\'ll [**reach out for a conversation**](https://netfoundry.io/lets-talk/) about BrowZer."},{"id":"multifactor-zero-trust-ssh","metadata":{"permalink":"/docs/openziti/blog/multifactor-zero-trust-ssh","source":"@site/blog/multifactor-zero-trust-ssh.md","title":"Multifactor Zero Trust ssh","description":"The previous post revisited the zssh project and demonstrated how to implement a simple ssh client using the extended modules provided by the Golang project. It also modified that simple program and showed what it takes to incorporate OpenZiti, creating a zero trust ssh client. This post focuses on another aspect of zssh and OpenZiti: multi-factor authentication.","date":"2024-09-09T00:10:41.000Z","tags":[{"inline":false,"label":"SSH","permalink":"/docs/openziti/blog/tags/ssh","description":"SSH topics"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"Zero Trust Security","permalink":"/docs/openziti/blog/tags/zero-trust-security","description":"Zero Trust Security Topics"}],"readingTime":6.57,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Multifactor Zero Trust ssh","seoTitle":"Zero Trust SSH with Multifactor Authentication","seoDescription":"Explore multifactor authentication for zero trust SSH clients with OpenZiti. Learn and download `zssh` today!","date":"2024-09-09T00:10:41.000Z","cuid":"cm0u8yhfd000008kzezx739qf","slug":"multifactor-zero-trust-ssh","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1725453901119/410a39f8-eaf7-4c9f-bbba-ae547eb78d94.webp","imageDark":"@site/blogs/openziti/v1725453901119/410a39f8-eaf7-4c9f-bbba-ae547eb78d94.webp","tags":["ssh","openziti","zero-trust","zero-trust-security"]},"unlisted":false,"prevItem":{"title":"The safest way to make Portainer Internet accessible","permalink":"/docs/openziti/blog/the-safest-way-to-make-portainer-internet-accessible"},"nextItem":{"title":"Zero Trust *ssh.Client","permalink":"/docs/openziti/blog/zero-trust-sshclient"}},"content":"[The previous post](./zero-trust-ssh-client.md) revisited the `zssh` project and demonstrated how to implement a simple ssh client using the extended modules provided by the Golang project. It also modified that simple program and showed what it takes to incorporate OpenZiti, creating a zero trust ssh client. This post focuses on another aspect of `zssh` and OpenZiti: multi-factor authentication.\\n\\n\x3c!-- truncate --\x3e\\n\\n[OpenZiti](https://openziti.io/docs/learn/introduction/) has a powerful and flexible authentication system. It allows an OpenZiti overlay network operator to decide what authentication mechanisms any given identity must satisfy before being authenticated to the overlay network. OpenZiti is a zero trust overlay network; authentication is only half of the equation. Once authenticated, identities still require authorization before accessing services secured by the overlay following the zero trust pillar of \\"least privilege\\".\\n\\n## Certificate-based Authentication\\n\\nPerhaps the most common type of authentication, OpenZiti supports authentication to the the OpenZiti overlay network using certificates. It might not be obvious, but a `zssh` user using an [enrolled an OpenZiti identity](https://openziti.io/docs/learn/core-concepts/identities/enrolling/) to authenticate to the overlay network **is already implicitly** using multi-factor authentication. The first authentication factor is OpenZiti itself. OpenZiti requires connections to be both authenticated and authorized before being allowed to connect to the target service. Once authenticated and authorized, `zssh` can connect to `sshd` and attempt to authenticate. Just by using `zssh`, users are protected with two factors of authentication but `zssh` (and OpenZiti) offers other factors of authentication as well.\\n\\nWhen [enrolling an identity](https://openziti.io/docs/learn/core-concepts/identities/enrolling/), the output of the enrollment flow will be an OpenZiti identity file containing a certificate, key, and CA bundle. This identity can then be used to authenticate connections to the target OpenZiti overlay network. If you are interested in learning how this process works, you can read about it in [Andrew\'s five-part series about bootstrapping trust](./bootstrapping-trust-part-1.md). Using `zssh` with an identity file and certificate-based authentication looks something like this (examples are taken [directly from the GitHub repo](https://github.com/openziti-test-kitchen/zssh?tab=readme-ov-file#identity-based-certificate-authentication)):\\n\\n![](/blogs/openziti/v1725132017881/75590748-1fb6-4616-bf1a-4fc59b31975b.png)\\n\\n```go\\nzssh \\\\\\n  -i \\"${private_key}\\" \\\\\\n  -s \\"${service_name}\\" \\\\\\n  -c \\"${client_identity}.json\\" \\\\\\n  \\"${user_id}@${server_identity}\\"\\n```\\n\\nIn this example, `zssh` is accepting the ssh key to use to authenticate to `sshd` (`-i`), the OpenZiti service to dial (`-s`), the OpenZiti identity file (`-c`). Somewhat hidden within this example is the OpenZiti target identity that is binding the service. All `zssh` connections are made with the expectation that the target identity is provided to the `zssh` command where one would normal \'host\' would be. This allows the OpenZiti overlay network operator to have a single service usable by any identity looking to provide ssh access.\\n\\n## OIDC-based Authentication Only\\n\\nThe `zssh` executable was recently enhanced to support OIDC-only-based authentication. Using [external JWT signers](https://openziti.io/docs/learn/core-concepts/security/authentication/external-jwt-signers/), you can configure an OpenZIti overlay network to trust JWTs from configured IdPs as authentication tokens. This allows the operator to create [authentication policies](https://openziti.io/docs/learn/core-concepts/security/authentication/authentication-policies/) allowing for external, OIDC-based integrations. This is interesting because it allows you to authenticate to the OpenZiti overlay network without needing to enroll the client ahead of time. Instead, `zssh` users complete an [Authorization Code Flow with PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce). In this scenario, the user will see the familiar flow of a browser window popping up and asking the user to authenticate to an identity provider configured to be trusted by OpenZiti. When the flow completes, the `zssh` binary will have a JWT that can be used to authenticate to the OpenZiti controller.\\n\\n![](/blogs/openziti/v1725132084008/92208900-0593-410c-9305-b4b3b63821ce.png)\\n\\n```go\\nzssh \\\\\\n  -i \\"${private_key}\\" \\\\\\n  -s \\"${service_name}\\" \\\\\\n  -o \\\\\\n  -a \\"${oidc_issuer}\\" \\\\\\n  -n openziti-client \\\\\\n  --oidcOnly \\\\\\n  --controllerUrl https://localhost:1280 \\\\\\n  \\"${user_id}@${server_identity}\\"\\n```\\n\\nIn this example, `zssh` is given the same `-i` and `-s` parameters as the certificate-based example above as well as the `userid@identity` but there are a few others supplied. The `-o` flag is passed to indicate `zssh` should obtain a JWT from the specified (`-a`) OIDC provider. In this example, Keycloak is used as a federated IdP to federate authentication to GitHub. To authenticate to Keycloak, a client id (`-n`) will need to be provided. This Keycloak client minimally needs to be configured with URLs it\'s allowed to redirect to after successful authentication. This example uses the `--oidcOnly` flag, indicating no OpenZiti certificate will be used for authentication. An identity will need to exist in the controller and [a matching auth-policy](https://github.com/openziti-test-kitchen/zssh?tab=readme-ov-file#create-an-external-jwt-signer-and-auth-policies) to allow the identity to authenticate. Finally, as no OpenZiti identity is used in this example, `zssh` must be told where to send the authentication request with the `--controllerUrl` flag.\\n\\n## Certificate-based + OIDC-based Authentication\\n\\nOpenZiti can also be configured to support OIDC as a secondary form of authentication. Accordingly, the `zssh` binary can be configured to use certificate-based authentication as a primary authentication source and an OIDC-based flow for secondary authentication. In the scenario, connecting to the OpenZiti overlay itself would require multiple forms of authentication. These mechanisms are a great way to prove there\'s both a human and a device. The device provides the certificate, while the human interacts with Keycloak/GitHub\'s OIDC to verify a human is indeed in the loop.\\n\\n![](/blogs/openziti/v1725132167930/c0f03fe3-0d55-4046-846c-0a8df3715e50.png)\\n\\n```go\\nzssh \\\\\\n  -i \\"${private_key}\\" \\\\\\n  -s \\"${service_name}\\" \\\\\\n  -o \\\\\\n  -a \\"${oidc_issuer}\\" \\\\\\n  -n openziti-client \\\\\\n  -c \\"${client_identity}.json\\" \\\\\\n  \\"${user_id}@${server_identity}\\"\\n```\\n\\nIn this example, `zssh` is given the all the same parameters as the OIDC-only example but because it specifies an OpenZiti identity with `-c`, the `--controllerUrl` and `--oidcOnly` flags are not necessary.\\n\\n## TOTP Instead of OIDC\\n\\nAlso added in this release was support for OpenZiti\'s [TOTP-based](https://en.wikipedia.org/wiki/Time-based_one-time_password) authentication. Users can now be required to enter their TOTP code before making a connection, allowing for multi-factor authentication to the OpenZiti overlay without using an IdP. Or, if using the OIDC-only based flow with an IdP that doesn\'t support TOTP (for reasons), OpenZiti\'s TOTP can be used as a secondary form of authentication to the overlay. For TOTP example usage have a look at [the readme on the repository](https://github.com/openziti-test-kitchen/zssh?tab=readme-ov-file#adding-totp). There, you\u2019ll find the commands shown in the example gif below.\\n\\n![](/blogs/openziti/v1725543173600/84bb2bc3-e5ba-45d4-9f3c-dccc08e6b0d6.gif)\\n\\n## Download zssh/zscp\\n\\nIf you are interested in trying out `zssh` and it\'s partner `zscp`, you can download the latest releases from GitHub at [https://github.com/openziti-test-kitchen/zssh/releases/latest](https://github.com/openziti-test-kitchen/zssh/releases/latest), right next to the source code for the project.\\n\\n## Share the Project\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png?auto=compress,format&format=webp)\\n\\nIf you find this interesting, please consider [**starring the projects on GitHub**](https://github.com/openziti/ziti/). It really does help to support the project! And if you haven\'t seen it yet, check out [**https://zrok.io**](https://github.com/openziti/ziti/). It\'s a totally free sharing platform built on OpenZiti and uses the OpenIti SDK! It uses the OpenZiti Go SDK since it\'s a ziti-native application. It\'s also [**all open source too!**](https://github.com/openziti/zrok/)\\n\\nTell us how you\'re using OpenZiti on [**X <s>twitter</s>**](https://twitter.com/openziti), [**reddit**](https://www.reddit.com/r/openziti/), or over at our [**Discourse**](https://openziti.discourse.group/). Or, if you prefer, check out [**our content on YouTube**](https://youtube.com/openziti) if that\'s more your speed. Regardless of how, we\'d love to hear from you."},{"id":"zero-trust-sshclient","metadata":{"permalink":"/docs/openziti/blog/zero-trust-sshclient","source":"@site/blog/zero-trust-ssh-client.md","title":"Zero Trust *ssh.Client","description":"A few years ago, the OpenZiti project developed and published two client tools to","date":"2024-09-09T00:09:12.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"SSH","permalink":"/docs/openziti/blog/tags/ssh","description":"SSH topics"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":4.83,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Zero Trust *ssh.Client","seoTitle":"Zero Trust SSH Client Explained","seoDescription":"Learn how to implement a zero trust ssh client using OpenZiti and Go for enhanced security and simplicity","date":"2024-09-09T00:09:12.000Z","cuid":"cm0u8wknc000109mk6xivbmlq","slug":"zero-trust-sshclient","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1725370192508/92d59b16-3273-4213-9918-01a0dc5ba343.png","imageDark":"@site/blogs/openziti/v1725370192508/92d59b16-3273-4213-9918-01a0dc5ba343.png","tags":["golang","ssh","zero-trust","openziti"]},"unlisted":false,"prevItem":{"title":"Multifactor Zero Trust ssh","permalink":"/docs/openziti/blog/multifactor-zero-trust-ssh"},"nextItem":{"title":"Effortless Docker Management","permalink":"/docs/openziti/blog/effortless-docker-management-with-private-web-access"}},"content":"A few years ago, the [OpenZiti project](https://github.com/openziti/ziti) developed and published two client tools to \\nmake ssh and scp available over an OpenZiti overlay network without requiring the sshd port to be exposed to the \\ninternet. If interested, read the original posts [about zssh](./zitifying-ssh.md) and \\n[zscp](./zitifying-scp.md). Continuing with the belief that security-related code should be open \\nsource and auditable, the project is [available on GitHub](https://github.com/openziti-test-kitchen/zssh).\\n\\n\x3c!-- truncate --\x3e\\n\\n![](/blogs/openziti/v1725040827487/7810a66b-c739-43d9-b7a8-fd607adb04e6.gif)\\n\\nThe [OpenZiti](https://openziti.io/docs/learn/introduction/) project provides SDKs that developers can use to create secure connections. The `zssh` client demonstrates that adopting an OpenZiti SDK into an application is no harder than developing any application that uses traditional IP-based, underlay connectivity.\\n\\nSecondly, though uncommon, there are still vulnerabilities found in `ssh`. Just this year (2024) [RegreSSHion](https://en.wikipedia.org/wiki/RegreSSHion) was discovered and was given a staggering [CVSS score](https://www.first.org/cvss/) of 9.8. Scores greater than 9 are generally deemed a \\"patch this as soon as possible\\" type of CVE. Yes, today\'s `ssh` clients are incredibly robust, but if it\'s easy to remove a substantial portion of attackers from attacking a service by using a zero trust overlay network like OpenZiti, why wouldn\'t you?\\n\\n## Using `*ssh.Client`\\n\\nThe go ecosystem provides extended packages from the `golang.org/x/*` modules. One of these modules is `golang.org/x/crypto`. Within this module, there is an `ssh` package that provides everything needed to make a functional ssh client. In there is `ssh.Client`, the main thing you\'ll interact with. This struct, along with `ssh.NewClientConn` and the Golang standard library, provides all the functionality needed to create a simple ssh client.\\n\\nShown below is all the code needed to make a very contrived ssh example. Any errors are ignored, and all values are hard-coded or expected as arguments to the program to keep the example small. In total, there are fewer than 30 total lines. Hopefully, the example is straightforward enough to understand.\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\"golang.org/x/crypto/ssh\\"\\n\\t\\"os\\"\\n)\\n\\nfunc main() {\\n\\tkey, _ := os.ReadFile(os.Args[1])\\n\\tsigner, _ := ssh.ParsePrivateKey(key)\\n\\tconfig := &ssh.ClientConfig{\\n\\t\\tUser:            \\"ubuntu\\",\\n\\t\\tAuth:            []ssh.AuthMethod{ssh.PublicKeys(signer)},\\n\\t\\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\\n\\t}\\n\\tsshClient, _ := ssh.Dial(\\"tcp\\", os.Args[2], config)\\n\\tdefer sshClient.Close()\\n\\tsession, _ := sshClient.NewSession()\\n\\tdefer session.Close()\\n\\tsession.RequestPty(\\"xterm\\", 80, 40, ssh.TerminalModes{})\\n\\tsession.Stdout = os.Stdout\\n\\tsession.Stderr = os.Stderr\\n\\tsession.Stdin = os.Stdin\\n\\tsession.Shell()\\n\\tsession.Wait()\\n}\\n```\\n\\nTry it out! That\'s really all there is to it. You\'ll be able to ssh to any machine that uses key-based authentication. Although it\'s not a robust example, it demonstrates the overall idea and shows off how amazing the go ecosystem can be. Note that `ssh.InsecureIgnoreHostKey` is used for the `HostKeyCallback`, to keep the example short. See [`zssh`\'s implementation](https://github.com/openziti-test-kitchen/zssh/blob/main/zsshlib/ssh.go#L471) if interested\\n\\n## Layering in Zero Trust Connectivity\\n\\nThe Golang standard library is well thought out. The [abstractions in place make it amazing for building applications embedding zero trust](./go-is-amazing-for-zero-trust). Adapting an application that uses normal IP-based connectivity (like the ssh example shown above that uses \\"tcp\\") to use an OpenZiti SDK is generally straightforward. From the example above, a single line needs to be changed: the line that creates the `ssh.Client`. This line:\\n\\n```go\\n\\tsshClient, _ := ssh.Dial(\\"tcp\\", host, config)\\n```\\n\\nCreating the `sshClient` needs to be adapted away from using IP-based underlay networking. Instead of \\"tcp\\" and \\"remote-machine-name:22\\", it needs to use a zero trust connection provided by the OpenZiti Golang SDK. Below is a simplified function that uses an OpenZiti identity file to create an OpenZiti context and dial an OpenZiti service, creating a Golang `net.Conn` that can be used to create an `ssh.Client`. Again, the example omits error handling and robustness for simplicity\'s sake, and looks like this:\\n\\n```go\\nfunc obtainZitiConn() net.Conn {\\n\\tcfg, _ := ziti.NewConfigFromFile(os.Args[3])\\n\\tctx, _ := ziti.NewContext(cfg)\\n\\tdialOptions := &ziti.DialOptions{\\n\\t\\tIdentity:       host,\\n\\t}\\n\\tc, _ := ctx.DialWithOptions(\\"zsshSvc\\", dialOptions)\\n\\treturn c\\n}\\n```\\n\\nWith the IP-based underlay `net.Conn` connection replaced with a zero trust connection, an `ssh.Client` can be created by replacing the call to `ssh.Dial`, and instead using a call to `ssh.NewClientConn` combined with a call to `ssh.NewClient`. With the `ssh.Dial` line adapted, it looks like this:\\n\\n```go\\n\\t//adapted sshClient, _ := ssh.Dial(\\"tcp\\", host, config)\\n\\tc, chans, reqs, _ := ssh.NewClientConn(obtainZitiConn(), \\"\\", config)\\n\\tsshClient := ssh.NewClient(c, chans, reqs)\\n```\\n\\nEverything else in the example remains identical; these are the only lines that need to change! The full source for `zssh` is available on GitHub at [https://github.com/openziti-test-kitchen/zssh](https://github.com/openziti-test-kitchen/zssh). You\'ll find the examples shown above in that repo as individual, compilable go files available in [the `example` folder](https://github.com/openziti-test-kitchen/zssh/tree/main/zssh/example).\\n\\nIf you\'re interested in `zssh`, the OpenZiti project and zero trust in general, check out [the next article](./multifactor-zero-trust-ssh). It focuses on using `zssh` and using OpenZiti\'s OIDC-based authentication mechanisms and uses [Keycloak](https://www.keycloak.org/) for federated authentication to GitHub or Google.\\n\\n## Share the Project\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png?auto=compress,format&format=webp)\\n\\nIf you find this interesting, please consider [**starring the projects on GitHub**](https://github.com/openziti/ziti/). It really does help to support the project! And if you haven\'t seen it yet, check out [**https://zrok.io**](https://github.com/openziti/ziti/). It\'s a totally free sharing platform built on OpenZiti and uses the OpenZiti Golang SDK and is also [**all open source!**](https://github.com/openziti/zrok/)\\n\\nTell us how you\'re using OpenZiti on [**X <s>twitter</s>**](https://twitter.com/openziti), [**reddit**](https://www.reddit.com/r/openziti/), or over at our [**Discourse**](https://openziti.discourse.group/). Or, if you prefer, check out [**our content on YouTube**](https://youtube.com/openziti) if that\'s more your speed. Regardless of how, we\'d love to hear from you."},{"id":"effortless-docker-management-with-private-web-access","metadata":{"permalink":"/docs/openziti/blog/effortless-docker-management-with-private-web-access","source":"@site/blog/effortless-docker-management.md","title":"Effortless Docker Management","description":"If you\'re involved with software creation or deployment, you likely use Docker. If so, the following saga probably rings some bells with you:","date":"2024-09-05T15:00:56.000Z","tags":[{"inline":false,"label":"Docker","permalink":"/docs/openziti/blog/tags/docker","description":"Docker content"},{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Web Security","permalink":"/docs/openziti/blog/tags/web-security","description":"Web security content"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":8.35,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"title":"Effortless Docker Management","seoDescription":"How to use OpenZiti BrowZer to securely access and manage Docker containers. Streamline container management and enhance security.","date":"2024-09-05T15:00:56.000Z","cuid":"cm0pezxy3000p0alch287g2lt","slug":"effortless-docker-management-with-private-web-access","authors":["CurtTudor"],"image":"@site/blogs/openziti/v1725481068115/9bc5870f-011f-4890-8487-23369499b5da.jpeg","imageDark":"@site/blogs/openziti/v1725481068115/9bc5870f-011f-4890-8487-23369499b5da.jpeg","tags":["docker","opensource","security","web-security","openziti"]},"unlisted":false,"prevItem":{"title":"Zero Trust *ssh.Client","permalink":"/docs/openziti/blog/zero-trust-sshclient"},"nextItem":{"title":"zrok is Growing Up","permalink":"/docs/openziti/blog/zrok-is-growing-up"}},"content":"If you\'re involved with software creation or deployment, you likely use Docker. If so, the following *saga* probably rings some bells with you:\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n### A common, painful scenario\\n\\nYou become aware that something\'s not working in your Docker fleet. Maybe a service is down? You `ssh` to the the host where the containers run, and do a `docker compose ps`. Yep, it\'s that buggy microservice that has crashed.\\n\\nNo problem, I\'ll restart it: `docker compose restart`. Okay now let\'s try again. Hmm... The issue is still there. `docker compose ps` again. Sigh... the service must have just crashed immediately after starting.\\n\\nI probably would have known what was happening had I been reading the log stream, but there is a lot of clutter from other services. I could get the logs for just that one service via `docker compose logs --follow myservice` but that dies every time the service dies so I\'d need to run that command every time I restart the service.\\n\\nI could alternatively run `docker compose up myservice` and in that terminal window if the service is down I could just `up` it again, but now I\'ve got one service hogging a terminal window even after I no longer care about its logs.\\n\\nI guess when I want to reclaim the terminal real estate I can `ctrl+P,Q`, but... wait, that\'s not working for some reason. Should I use `ctrl+C` instead? I can\'t remember if that closes the foreground process or kills the actual service...\\n\\n---\\n\\nOK. You get the picture. Ugh... What a headache!\\n\\nOf course, it makes no sense to manage a large scale Docker deployment by connecting to each container individually or restarting processes (an orchestrator like K8S will serve that large scale use case much better). But if you\'ve got a few containers running in a self-hosted (home?) network, the above story probably sounds familiar.\\n\\n### A Better way\\n\\nMemorizing docker commands is hard. Memorizing `alias`\'s isn\'t much easier. Keeping track of your containers across multiple terminal windows is untenable.\\n\\nBut hang on. What if you had all the information you needed in a single *magical* terminal window where every common docker command was one keypress away?\\n\\nPicture this:\\n\\n![](/blogs/openziti/v1725034531527/33cfddf1-4849-4995-a5c4-18ee4df9e8a8.gif)\\n\\nIf that got your attention, Now, imagine if you could access the *magical* terminal window by simply opening a web browser, on any laptop or mobile device, and then navigating to a URL representing the remote host where your containers run. Everything is right there in the browser tab.\\n\\nBye-bye `ssh`.\\n\\nIntrigued?\\n\\nAs nice as that is, It gets even better. Now, imagine the URL was internet-accessible, but ***only*** visible to you, invisible to others, thus protecting your containers from malicious actors.\\n\\nThis is not a fever dream. In this article, I\'ll show you how all this is possible today.\\n\\nI\'ll discuss the following components that collectively implement the solution:\\n\\n* Isaiah\\n    \\n* OpenZiti\\n    \\n* BrowZer\\n    \\n\\n# The Isaiah Service\\n\\nOne component involved in the solution is Isaiah. [Isaiah](https://github.com/will-moss/isaiah) is a relatively new open-source project (*it first appeared in early 2024*). It is a self-hostable service that enables you to manage all your Docker resources on a remote server. It is an attempt at recreating the `lazydocker` command-line application while making everything available as a ***web application***.\\n\\nThe screencap in the above \\"better way\\" section shows Isaiah in action.\\n\\n### Isaiah Deployment\\n\\nYou run Isaiah on the host where your containers execute -- the host you would previously `ssh` to in the \'*painful scenario*\' described at the top of this article.\\n\\n*(NOTE: Ensure that Docker 23.0.0+ is installed on your host before proceeding)*\\n\\nThere are several ways to deploy Isaiah, but perhaps the easiest is via `docker compose`. Here is a `compose.yml` file you can use:\\n\\n```yaml\\nservices:\\n  isaiah:\\n    image: mosswill/isaiah:latest\\n    restart: unless-stopped\\n    ports:\\n      - \\"80:80\\"\\n    volumes:\\n      - /var/run/docker.sock:/var/run/docker.sock:ro\\n    environment:\\n      SERVER_PORT: \\"80\\"\\n      AUTHENTICATION_SECRET: \\"some-very-long-and-mysterious-secret\\"\\n```\\n\\nThen simply run `docker compose up -d`\\n\\n*(NOTE: if you already have a compose file on your host, you can simply add the above* `isaiah` *section to the existing* `services` *section of your compose file)*\\n\\nAs you can see, this compose file will have Isaiah listening on HTTP, without TLS, on your LAN or perhaps even on the open internet. This is certainly sub-optimal from a security standpoint, but read on and I\'ll describe how to lock things down.\\n\\nIf the `AUTHENTICATION_SECRET` env var is configured, it tells Isaiah to require visitors to enter the secret when they arrive, like this:\\n\\n![](/blogs/openziti/v1725117677807/06d61b16-4a94-4116-b9f3-87466ad91d82.png)\\n\\nBut even with the `AUTHENTICATION_SECRET` in place, and HTTP visitors hitting your host being prompted as shown above...this is still not as secure as we need it to be.\\n\\nA better topology is one where your Docker host, and Isaiah, reside in a [VPC](https://en.wikipedia.org/wiki/Virtual_private_cloud), and the host has NO ports open to the internet. In this kind of deployment, the host will be completely invisible to the internet. The best (most secure) way to access the host is via a zero-trust overlay network.\\n\\n# How to Easily Deploy a Zero-Trust Overlay Network\\n\\nThe next component involved in the solution is OpenZiti. [OpenZiti](https://openziti.io/) is an open-source project focused on bringing zero trust networking principles directly into any application. The project provides all the pieces required to implement a zero trust overlay network and provides all the tools necessary to integrate zero trust into your existing solutions.\\n\\nThere is a vast amount of documentation, as well as [quick starts](https://openziti.io/docs/learn/quickstarts/), on the OpenZiti site, so I will not replicate it here.\\n\\nIf you like what you read about OpenZiti, but you prefer not to self-host it yourself, [we](https://netfoundry.io/) also offer a zero trust networking platform. If that interests you, [reach out to us for more discussion.](https://netfoundry.io/lets-talk/)\\n\\n# BrowZer\\n\\nThe next component involved in the solution is `BrowZer`.\\n\\nThe `Z` in this component\'s name (within the word normally spelled \\"*browser*\\") is not a typo. It is a purposeful indication that this solution, unique in today\'s technology offerings for securing browser-based applications, is built as part of the [**OpenZiti** project](https://github.com/openziti/).\\n\\nBrowZer enables you and your organization, enterprises and self-hosting enthusiasts alike, in the cloud or at home, to operate private-to-the-internet web applications while still easily providing secure access for your authorized internet-based remote users.\\n\\nI previously published a lengthy article that introduced the [concept of browZer](./introducing-openziti-browzer.md). I recommend giving it a read.\\n\\n## Forward Proxy Authentication / Trusted SSO\\n\\nWith OpenZiti and BrowZer now in your mind, I want to return to Isaiah for a moment.\\n\\nIsaiah has a feature known as *Forward Proxy Authentication*. This feature enables you to log in to an authentication portal, and then connect to Isaiah without having to type your `AUTHENTICATION_SECRET` every time.\\n\\nIn this mode, you protect Isaiah using your authentication portal rather than a cleartext / hashed password.\\n\\nTo use this mechanism, configure Isaiah using the following variables:\\n\\n* Set `FORWARD_PROXY_AUTHENTICATION_ENABLED` to `true`.\\n    \\n* Set `FORWARD_PROXY_AUTHENTICATION_HEADER_KEY` to the name of the forwarded authentication header your auth proxy sends to Isaiah.\\n    \\n* Set `FORWARD_PROXY_AUTHENTICATION_HEADER_VALUE` to the value of the header that Isaiah should expect (or use `*` if all values are accepted).\\n    \\n\\nBy the way, by default, Isaiah is configured to work with [Authelia](https://www.authelia.com/) out of the box. So if you are using the Authelia IdP as your auth proxy, you can just set `FORWARD_PROXY_AUTHENTICATION_ENABLED` to `true` and be done with it (no need to configure the other variables).\\n\\n## Trusted SSO Between BrowZer and Isaiah\\n\\nMuch like Authelia, BrowZer also works with Isaiah\'s *Forward Proxy Authentication* out of the box.\\n\\nAs you read in the browZer article linked above, browZer requires you to authenticate with an IdP before connecting to your zero-trust overlay network. A common setup is to use Auth0 as the browZer IdP and have Auth0 federate to Google. You can read about how to do this in our [browZer IdP documentation](https://openziti.io/docs/identity-providers-for-browZer-auth0).\\n\\nOnce you have set up your Ziti overlay network, and have set up browZer to enable web access to Isaiah, you are then using browZer as your auth proxy.\\n\\nNow you can configure Isaiah with:\\n\\n* `FORWARD_PROXY_AUTHENTICATION_ENABLED` to `true`, and\\n    \\n* `FORWARD_PROXY_AUTHENTICATION_HEADER_VALUE` to the value of your Google email address.\\n    \\n\\nFor example:\\n\\n```yaml\\nservices:\\n  isaiah:\\n    image: mosswill/isaiah:latest\\n    restart: unless-stopped\\n    ports:\\n      - \\"80:80\\"\\n    volumes:\\n      - /var/run/docker.sock:/var/run/docker.sock:ro\\n    environment:\\n      SERVER_PORT: \\"80\\"\\n      FORWARD_PROXY_AUTHENTICATION_ENABLED: \\"true\\"\\n      FORWARD_PROXY_AUTHENTICATION_HEADER_VALUE: \\"you@gmail.com\\"\\n```\\n\\nHere is what it looks like to use browZer to access a private-to-the-internet instance of Isaiah:\\n\\n![](/blogs/openziti/v1725469319491/f2d0112a-e120-41da-8030-95624e4ff713.gif)\\n\\nHere\'s what happens above:\\n\\n* Brave web browser hits the URL representing the protected instance of Isaiah\\n    \\n* Brave is redirected by BrowZer to Auth0, then federated to Google (with 2FA) for authentication\\n    \\n* BrowZer bootstraps the necessary OpenZiti software into Brave tab, and the OpenZiti software loads the Isaiah web app over the zero-trust overlay network\\n    \\n* Isaiah sees that BrowZer has done the proper SSO by passing necessary info from Google to Isaiah, so no login prompt is rendered by Isaiah\\n    \\n* User is presented with Isaiah GUI welcome screen showing that \\"2 Containers\\" are running (one is Isaiah, the other is an instance of the BrowZer Bootstrapper for a staging environment)\\n    \\n* User clicks around, looks at logs for a running container, also removes an old Docker image\\n    \\n\\n# Wrap up\\n\\nDo you host a web app (like Isaiah) and want to be invisible to malicious intruders?\\n\\nDo you want your users to have easy access from anywhere with no additional software on their client devices?\\n\\nDo you want to do all this without making any modifications to the web app?\\n\\nIf so, then we hope you\'ll [reach out for a conversation](https://netfoundry.io/lets-talk/) about BrowZer."},{"id":"zrok-is-growing-up","metadata":{"permalink":"/docs/openziti/blog/zrok-is-growing-up","source":"@site/blog/zrok-is-growing-up.md","title":"zrok is Growing Up","description":"zrok has been growing pretty steadily throughout 2024. As we\'ve grown, we\'ve started having to deal with abuse,","date":"2024-08-02T20:07:40.000Z","tags":[{"inline":false,"label":"Network","permalink":"/docs/openziti/blog/tags/network","description":"Network related posts"},{"inline":false,"label":"Browsers","permalink":"/docs/openziti/blog/tags/browsers","description":"Web browsers"},{"inline":false,"label":"Web Development","permalink":"/docs/openziti/blog/tags/web-development","description":"Web development content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"WebDev","permalink":"/docs/openziti/blog/tags/webdev","description":"Web development shorthand"}],"readingTime":2.47,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"zrok is Growing Up","date":"2024-08-02T20:07:40.000Z","cuid":"clzd4zgd4000109l58wnp7wue","slug":"zrok-is-growing-up","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1722357921994/c2ddeddd-f52e-41a9-ace8-26ce7bb0259c.png","imageDark":"@site/blogs/openziti/v1722357921994/c2ddeddd-f52e-41a9-ace8-26ce7bb0259c.png","tags":["network","browsers","web-development","security","webdev"]},"unlisted":false,"prevItem":{"title":"Effortless Docker Management","permalink":"/docs/openziti/blog/effortless-docker-management-with-private-web-access"},"nextItem":{"title":"Easy Steps to Install a Private VPN on Linux with zrok","permalink":"/docs/openziti/blog/zrok-vpn-linux-service"}},"content":"zrok has been growing pretty steadily throughout 2024. As we\'ve grown, we\'ve started having to deal with abuse, \\nphishing, and other similar types of issues showing up on the service at zrok.io.\\n\\n\x3c!-- truncate --\x3e\\n\\nOver the last weeks, the team has worked together to figure out the best compromise to continue offering our users the best free sharing solution possible, while also offering a reasonable level of protection against abuse. We\'ve batted around a number of different ideas.\\n\\nThe solution we\'ve settled on is to introduce an \\"interstitial page\\" for free-tier accounts using public sharing. The interstitial page will be shown the first time an internet user visits a zrok public share (with a timer resetting every week). The page is there to make sure that the user visiting your share is very clear that the web resource they\'re visiting is shared through zrok, and very likely *not* a financial institution (or at least that they should be careful with personal information).\\n\\n![](/blogs/openziti/v1722361596170/898a7bec-d03b-4aef-80bc-5860547001ef.png)\\n\\nThe interstitial page is designed to only be displayed to interactive clients (web browsers presenting with a `User-Agent` header starting with `Mozilla/5.0`). Other clients like `curl`, or HTTP clients from various programming langues will bypass the interstitial page.\\n\\nzrok users who upgrade to any paid tier (see [pricing](https://zrok.io/pricing/)) will not have an interstitial page presented on their shares. The interstitial pages feature does not impact private zrok sharing in any way. When you `zrok access private` a share and create a private frontend, that frontend does not present interstitial pages. In those cases, we\'re pretty confident the user understands what they\'re accessing.\\n\\nWe\'re also actively working on bringing some additional capabilities to the zrok paid offerings, including \\"bring your own domain\\" support, which will allow users to create public shares using their own domain name. So, we\'re kind of hoping you might want to consider one of those options outside of removing the interstitial page.\\n\\n<div data-node-type=\\"callout\\">\\n<div data-node-type=\\"callout-emoji\\">\ud83d\udca1</div>\\n<div data-node-type=\\"callout-text\\">We\'re expecting to enable the interstitial pages feature globally for all free-tier zrok users starting on Thursday, August 8th.</div>\\n</div>\\n\\nIf you\'re a self-hoster, you\'ll have extensive options to customize the interstitial page configuration. Each public frontend can enable or disable interstitial support, and interstitial pages can be disabled on a per-account basis.\\n\\nI recently did a short zrok Office Hours video about the interstitial pages feature:\\n\\n%[https://www.youtube.com/watch?v=NYjec5mIXTE&list=PLMUj_5fklasLuM6XiCNqwAFBuZD1t2lO2&index=24] \\n\\nWe appreciate every zrok user. Thank you for your support and attention. If you appreciate what we\'re doing with zrok, it always means a lot when you can drop a star on the [zrok repo on GitHub](https://github.com/openziti/zrok).\\n\\nIf you have any questions or concerns, feel free to reach out on the [OpenZiti discourse using the zrok topic](https://openziti.discourse.group/c/zrok/24)."},{"id":"zrok-vpn-linux-service","metadata":{"permalink":"/docs/openziti/blog/zrok-vpn-linux-service","source":"@site/blog/easy-steps-to-install-a-private-vpn-on-linux-with-zrok.md","title":"Easy Steps to Install a Private VPN on Linux with zrok","description":"The great thing about the zrok-share.service is that it comes with the zrok binary and is always on in the background, so it\'s a good fit for a reliable VPN connection. Let\'s install the service and configure it to auto-start after a reboot.","date":"2024-08-02T17:10:31.000Z","tags":[{"inline":false,"label":"VPN","permalink":"/docs/openziti/blog/tags/vpn","description":"VPN related content"}],"readingTime":2.81,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"Easy Steps to Install a Private VPN on Linux with zrok","seoTitle":"Install Private VPN on Linux with zrok","seoDescription":"Learn easy steps to install, configure, and join a private VPN on Linux using zrok.","date":"2024-08-02T17:10:31.000Z","cuid":"clzcynn3a000009kwfowoela4","slug":"zrok-vpn-linux-service","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1722617478239/b985c30b-aae1-42c1-a450-b3fd255b14a3.avif","imageDark":"@site/blogs/openziti/v1722617478239/b985c30b-aae1-42c1-a450-b3fd255b14a3.avif","tags":["vpn"]},"unlisted":false,"prevItem":{"title":"zrok is Growing Up","permalink":"/docs/openziti/blog/zrok-is-growing-up"},"nextItem":{"title":"Jitsi, meet zrok","permalink":"/docs/openziti/blog/jitsi-meet-zrok"}},"content":"The great thing about the `zrok-share.service` is that it comes with the `zrok` binary and is always on in the background, so it\'s a good fit for a reliable VPN connection. Let\'s install the service and configure it to auto-start after a reboot.\\n\\n\x3c!-- truncate --\x3e\\n\\n```bash\\ncurl -sSLf https://get.openziti.io/install.bash | sudo bash -s zrok-share\\n```\\n\\nEdit `/opt/openziti/etc/zrok/zrok-share.env`.\\n\\n```bash\\n# env\\nZROK_ENABLE_TOKEN=\\"w9pEuX3Gb750\\"  # account token from the console\\nZROK_ENVIRONMENT_NAME=\\"my zrok vpn service on hostname\\"\\n\\n# share\\nZROK_UNIQUE_NAME=\\"mysecretsharetoken\\"\\nZROK_BACKEND_MODE=\\"vpn\\"\\nZROK_TARGET=\\"172.21.71.1/24\\"  # allocate ip in some private subnet\\nZROK_FRONTEND_MODE=\\"reserved-private\\"\\n```\\n\\nYou can control access to your VPN by keeping `ZROK_UNIQUE_NAME` a secret (the share token) or adding the following to restrict zrok accounts by email. Only your account can use the share in closed mode if you don\'t add grants.\\n\\n```bash\\nZROK_PERMISSION_MODE=\\"closed\\"\\nZROK_ACCESS_GRANTS=\\"alice@example.com bob@example.org\\"\\n```\\n\\nGrant kernel capability `NET_ADMIN` to the service.\\n\\n```bash\\nsudo sed -Ei \'s/.*AmbientCapabilities=CAP_NET_ADMIN/AmbientCapabilities=CAP_NET_ADMIN/\' /etc/systemd/system/zrok-share.service.d/override.conf\\nsudo systemctl daemon-reload\\n```\\n\\nStart the service now and auto-start after a reboot.\\n\\n```bash\\nsudo systemctl enable --now zrok-share.service\\n```\\n\\nCheck the logs.\\n\\n```bash\\nsudo journalctl -lfu zrok-share.service\\n```\\n\\nThe logs should look like this, confirming this device is allocated 172.21.71.1 on the VPN.\\n\\n```json\\nAug 02 16:33:08 ubuntu zrok-share.bash[6243]: {\\"level\\":\\"info\\",\\"ts\\":1722616388.2556849,\\"msg\\":\\"interface created tun0\\"}\\nAug 02 16:33:08 ubuntu zrok-share.bash[6243]: {\\"level\\":\\"info\\",\\"ts\\":1722616388.255752,\\"msg\\":\\"exec /sbin/ip [link set dev tun0 mtu 16384]\\"}\\nAug 02 16:33:08 ubuntu zrok-share.bash[6243]: {\\"level\\":\\"info\\",\\"ts\\":1722616388.2595484,\\"msg\\":\\"exec /sbin/ip [addr add 172.21.71.1/24 dev tun0]\\"}\\nAug 02 16:33:08 ubuntu zrok-share.bash[6243]: {\\"level\\":\\"info\\",\\"ts\\":1722616388.2627363,\\"msg\\":\\"exec /sbin/ip [-6 addr add fd00:7a72:6f6b::1/64 dev tun0]\\"}\\nAug 02 16:33:08 ubuntu zrok-share.bash[6243]: {\\"level\\":\\"info\\",\\"ts\\":1722616388.2659466,\\"msg\\":\\"exec /sbin/ip [link set dev tun0 up]\\"}\\nAug 02 16:33:08 ubuntu zrok-share.bash[6243]: {\\"level\\":\\"info\\",\\"ts\\":1722616388.2711568,\\"msg\\":\\"interface configured tun0\\"}\\n```\\n\\n## Join the VPN from Another Device\\n\\nThe zrok console looks like this for an account with two environments, one per VPN peer, and one VPN share.\\n\\n![](/blogs/openziti/v1722617910042/3972fae3-e826-402f-82e9-9c3514f0bfe4.png)\\n\\nTo temporarily join the zrok VPN you only need to run this command.\\n\\n```bash\\nsudo -E zrok access private mysecretsharetoken\\n```\\n\\nYou will see zrok\'s terminal user interface (TUI) telling you what is happening. This second device will be allocated 172.21.71.2 and subsequent devices will get unique IP allocations when they join. This is a network-layer VPN. You can send ICMP, TCP, UDP, etc.\\n\\nNow, this second device is joined to the VPN, so it has a dashed line to the VPN share indicating a zrok \\"private access.\\"\\n\\n![](/blogs/openziti/v1722618841867/969509da-0a39-4a4b-ad76-0c0dc0a524c9.png)\\n\\n## Share the Project\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png?auto=compress,format&format=webp)\\n\\nIf you find this interesting, please [give zrok a star on GitHub](https://github.com/openziti/zrok)!\\n\\nLet us know if you found a good use for this or have an improvement or question in mind on [**X <s>twitter</s>**](https://twitter.com/openziti), in [/r/openziti](https://www.reddit.com/r/openziti/), or the [Discourse forum](https://openziti.discourse.group/). We upload and stream [**on YouTube**](https://youtube.com/openziti) too. We\'d love to hear from you!"},{"id":"jitsi-meet-zrok","metadata":{"permalink":"/docs/openziti/blog/jitsi-meet-zrok","source":"@site/blog/jitsi-meet-zrok.md","title":"Jitsi, meet zrok","description":"Jitsi Meet is an open-source video conferencing server. I\'ve wanted to run Jitsi behind zrok and someone asked about it today in the forum and we got it working! Here\'s how I conveniently self-host Jitsi with zrok.","date":"2024-07-31T18:25:02.000Z","tags":[{"inline":false,"label":"Self Hosted","permalink":"/docs/openziti/blog/tags/self-hosted","description":"Self-hosted setups"}],"readingTime":4.33,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"Jitsi, meet zrok","date":"2024-07-31T18:25:02.000Z","cuid":"clza6fr0v000608l2cnqjamv9","slug":"jitsi-meet-zrok","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1722450203675/ee7c2e5c-4ef2-46e7-a05d-767cf2e7ab58.png","imageDark":"@site/blogs/openziti/v1722450203675/ee7c2e5c-4ef2-46e7-a05d-767cf2e7ab58.png","tags":["self-hosted"]},"unlisted":false,"prevItem":{"title":"Easy Steps to Install a Private VPN on Linux with zrok","permalink":"/docs/openziti/blog/zrok-vpn-linux-service"},"nextItem":{"title":"Extend Access to a Private S3 Bucket Using Python","permalink":"/docs/openziti/blog/extend-access-to-a-private-s3-bucket-using-python"}},"content":"[Jitsi Meet](https://jitsi.github.io/handbook/) is an open-source video conferencing server. I\'ve wanted to run Jitsi behind zrok and [someone asked about it today in the forum](https://openziti.discourse.group/t/local-jitsi-meet-zrok/2900/4?u=qrkourier) and we got it working! Here\'s how I conveniently self-host Jitsi with zrok.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Why zrok?\\n\\n[zrok.io](https://zrok.io) makes it easy to self-host web applications while obscuring your real public IP and protecting your private network. Your visitors will see a trusted certificate with the name `*.share.zrok.io` provided by zrok.io as a service when they visit your Jitsi Meet instance\'s public URL.\\n\\nJitsi Meet requires a trusted certificate for WebRTC, so zrok.io also spares you the chore of issuing, renewing, and configuring a TLS server certificate for Jitsi.\\n\\n## Orientation\\n\\nYou only need Docker to follow this tutorial. There\'s nothing else to install. You can use this guide with a free account from [zrok.io](https://zrok.io) or a [self-hosted zrok instance](https://docs.zrok.io/docs/guides/self-hosting/docker/).\\n\\nJitsi Meet\'s Docker Compose project is pre-configured to publish the container ports to the Docker Host\'s external interfaces. Typically, that is necessary so they are reachable by clients.\\n\\nzrok works differently and does not need the ports to be published externally. Instead, zrok runs inside the Compose project on the `meet.jitsi` bridge network. zrok will proxy the traffic securely to the containers\' internal ports, so we\'ll override the forwarded, published ports, exposing them only inside the Compose project.\\n\\n## The Steps\\n\\n1. Follow [Jitsi\'s Docker Quickstart](https://jitsi.github.io/handbook/docs/devops-guide/devops-guide-docker/#quick-start) and wait to run `docker compose up`.\\n    \\n2. In your terminal, change to the directory where you have created these Jitsi quickstart files: `.env` and `docker-compose.yml`.\\n    \\n3. Download the zrok [public share compose example](https://docs.zrok.io/zrok-public-reserved/compose.yml) and save it as the filename `docker-compose.zrok.yml` in the same directory.\\n    \\n4. Add the following YAML as the filename `docker-compose.override.yml` in the same directory.\\n    \\n    ```yaml\\n    services:\\n      web:\\n        ports: !override []\\n      jicofo:\\n        ports: !override []\\n      jvb:\\n        ports: !override []\\n      zrok-share:\\n        networks:\\n          meet.jitsi:\\n    ```\\n    \\n5. Think of a name for your self-hosted Jitsi Meet instance. You will use it in the next step to define the unique name of the zrok share which is part of the public URL. The name must be 4-32 lowercase letters or numbers.\\n    \\n6. Save the following variable assignments as the filename `.env.zrok` in the same directory.\\n    \\n    ```bash\\n    PUBLIC_URL=\\"https://myjitsi.share.zrok.io\\"  # subdomain must match ZROK_UNIQUE_NAME\\n    ZROK_UNIQUE_NAME=\\"myjitsi\\"                  # must match PUBLIC_URL subdomain\\n    ZROK_ENABLE_TOKEN=\\"ix9XrvQt13Rf\\"            # zrok account token from console\\n    ZROK_ENVIRONMENT_NAME=\\"jitsi-zrok-compose\\"  # name for the environment in the console graph\\n    ZROK_API_ENDPOINT=\\"https://api.zrok.io\\"     # must be set to the zrok API you\'re using\\n    ZROK_TARGET=\\"https://web:443\\"               # this is correct for the web container\'s internal port\\n    ZROK_INSECURE=\\"--insecure\\"                  # let zrok skip cert verification for the internal web:443 target\\n    ```\\n    \\n7. Optionally, turn on OAuth for this Jitsi Meet instance with zrok. Add the following to the `.env.zrok` file ([Docker public share guide has more info](https://docs.zrok.io/docs/guides/docker-share/docker_public_share_guide/)).\\n    \\n    ```bash\\n    ZROK_OAUTH_PROVIDER=\\"google\\"  # google, github\\n    # space-separated list email patterns verified by the provider\\n    ZROK_OAUTH_EMAILS=\\"alice.example@gmail.com *@acme.example.com\\"\\n    ```\\n    \\n8. Save the following script as the filename `compose.bash` in the same directory. This script configures the compose project and environment files.\\n    \\n    ```bash\\n    \\n    export COMPOSE_FILE=\\"docker-compose.yml:docker-compose.zrok.yml:docker-compose.override.yml\\"\\n    export COMPOSE_ENV_FILES=\\".env,.env.zrok\\"\\n    \\n    docker compose  \\"${@}\\"\\n    ```\\n    \\n9. Ensure you have all the necessary files.\\n    \\n    1. `docker-compose.yml`\\n        \\n    2. `docker-compose.zrok.yml`\\n        \\n    3. `docker-compose.override.yml`\\n        \\n    4. `.env`\\n        \\n    5. `.env.zrok`\\n        \\n    6. `compose.bash`\\n        \\n10. Run Jitsi and zrok.\\n    \\n    ```bash\\n    bash ./compose.bash up\\n    ```\\n    \\n11. Open Jitsi in a web browser at the address from the `PUBLIC_URL` environment variable, e.g., `https://myjitsi.share.zrok.io` .\\n    \\n12. If you need to change the name, authentication, etc. you can delete the environment in the zrok web console and delete the Docker volumes like this to start over. It\'s also possible to make surgical changes if you don\'t want to start over. [Ask for help in Discourse](https://openziti.discourse.group/).\\n    \\n    ```bash\\n    bash ./compose.bash down --volumes\\n    ```\\n    \\n\\n## zrok frontdoor\\n\\nThis tutorial for Jitsi Meet is a great example of [zrok frontdoor](https://docs.zrok.io/docs/guides/frontdoor/?os=Docker). zrok frontdoor brings many advantages for self-hosters and is always enabled when using zrok.io as a service with a production-ready service like this zrok public share in Docker. zrok.io users enjoy additional shielding for their Jitsi Meet public URL.\\n\\n## Relatedly\\n\\nzrok is built with OpenZiti. Here\'s [another post about running an Asterisk PBX without published ports](https://medium.com/netfoundry/tunneling-voip-over-openziti-69d6487605e4), just as your Jitsi Meet instance has no open ports on the Docker Host\'s outward-facing interfaces.\\n\\n## Share the Project\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png?auto=compress,format&format=webp)\\n\\nIf you find this interesting, please consider [**starring us on GitHub**](https://github.com/openziti/ziti/). It helps. Let us know if you found a good use for this or have an improvement or question in mind on [**X <s>twitter</s>**](https://twitter.com/openziti), in [/r/openziti](https://www.reddit.com/r/openziti/), or the [Discourse forum](https://openziti.discourse.group/). We upload and stream [**on YouTube**](https://youtube.com/openziti) too. We\'d love to hear from you!"},{"id":"extend-access-to-a-private-s3-bucket-using-python","metadata":{"permalink":"/docs/openziti/blog/extend-access-to-a-private-s3-bucket-using-python","source":"@site/blog/extend-access-to-a-private-s3-bucket-using-python.md","title":"Extend Access to a Private S3 Bucket Using Python","description":"A private S3 bucket protects against a data leak by denying all public access. This approach moves access control from the public S3 API to the network layer. We can use OpenZiti\'s cryptographic identity and attribute-based policies to securely extend access to a trusted Python program at a remote site.","date":"2024-07-23T17:05:14.000Z","tags":[{"inline":false,"label":"Python","permalink":"/docs/openziti/blog/tags/python","description":"Python content"},{"inline":false,"label":"Boto3","permalink":"/docs/openziti/blog/tags/boto3","description":"Boto3 library"}],"readingTime":2.04,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"Extend Access to a Private S3 Bucket Using Python","date":"2024-07-23T17:05:14.000Z","cuid":"clyyo2bjs000909kybcio718z","slug":"extend-access-to-a-private-s3-bucket-using-python","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1721753949507/7351140d-d4d4-4531-b56d-c2bfa9f4bb17.png","imageDark":"@site/blogs/openziti/v1721753949507/7351140d-d4d4-4531-b56d-c2bfa9f4bb17.png","ogimage":"/blogs/openziti/v1721754283206/4a5bea22-a608-4c1d-b323-47b9067cbd1e.png","tags":["python","boto3"]},"unlisted":false,"prevItem":{"title":"Jitsi, meet zrok","permalink":"/docs/openziti/blog/jitsi-meet-zrok"},"nextItem":{"title":"Why We Verify GitHub Commits","permalink":"/docs/openziti/blog/why-we-verify-github-commits"}},"content":"A private S3 bucket protects against a data leak by denying all public access. This approach moves access control from the public S3 API to the network layer. We can use OpenZiti\'s cryptographic identity and attribute-based policies to securely extend access to a trusted Python program at a remote site.\\n\\n![](/blogs/openziti/v1721754674859/9428a427-5a2f-41f0-ac30-af0c83a09c69.png)\\n\\n\x3c!-- truncate --\x3e\\n\\nThe OpenZiti Python SDK (`import openziti`) makes it easy to use the AWS Python SDK (`import boto3`) through an OpenZiti tunnel using only Python. No sidecar, agent, or client proxy is needed!\\n\\nHere\'s an example of a bucket policy that allows any S3 bucket action for any AWS caller identity as long as the request arrives via the VPC endpoint (VPCE).\\n\\n```json\\n{\\n   \\"Version\\": \\"2012-10-17\\",\\n   \\"Id\\": \\"Policy1415115909152\\",\\n   \\"Statement\\": [\\n     {\\n       \\"Sid\\": \\"Access-to-specific-VPCE-only\\",\\n       \\"Principal\\": \\"*\\",\\n       \\"Action\\": \\"s3:*\\",\\n       \\"Effect\\": \\"Deny\\",\\n       \\"Resource\\": [\\"arn:aws:s3:::awsexamplebucket1\\",\\n                    \\"arn:aws:s3:::awsexamplebucket1/*\\"],\\n       \\"Condition\\": {\\n         \\"StringNotEquals\\": {\\n           \\"aws:SourceVpce\\": \\"vpce-1a2b3c4d\\"\\n         }\\n       }\\n     }\\n   ]\\n}\\n```\\n\\n*from* [*Restricting access to a specific VPC endpoint*](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies-vpc-endpoint.html#example-bucket-policies-restrict-accesss-vpc-endpoint)\\n\\nConsider this Python script that uploads a file to a private S3 bucket. This must run inside the trusted VPC to reach the private IP address of the VPCE (i.e., Privatelink Interface).\\n\\n```python\\nfrom boto3 import client\\n\\ns3 = client(service_name=\'s3\', endpoint_url=bucket_endpoint)\\n\\ns3.upload_file(file_path, bucket_name, file_name)\\n```\\n\\nWe can extend trust beyond the VPC to securely perform bucket actions from anywhere. This next example patches the S3 client to tunnel to the bucket endpoint with OpenZiti securely.\\n\\n```python\\nfrom boto3 import client\\n\\nimport openziti\\n\\ns3 = client(service_name=\'s3\', endpoint_url=bucket_endpoint)\\n\\nopenziti.load(ziti_identity_file)\\n\\nwith openziti.monkeypatch():\\n    s3.upload_file(file_path, bucket_name, file_name)\\n```\\n\\nThese Python snippets are representative of a functioning sample, `s3z.py` ([link to OpenZiti Python SDK](https://github.com/openziti/ziti-sdk-py/tree/main/sample/s3z#readme)). The README contains a list of the AWS and OpenZiti entities and configurations that make this possible.\\n\\n## Share the Project\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png?auto=compress,format&format=webp)\\n\\nIf you find this interesting, please consider [**starring us on GitHub**](https://github.com/openziti/ziti/). It helps. Let us know if you found a good use for this or have an improvement or question in mind on [**X <s>twitter</s>**](https://twitter.com/openziti), in [/r/openziti](https://www.reddit.com/r/openziti/), or the [Discourse forum](https://openziti.discourse.group/). We upload and stream [**on YouTube**](https://youtube.com/openziti) too. We\'d love to hear from you!"},{"id":"why-we-verify-github-commits","metadata":{"permalink":"/docs/openziti/blog/why-we-verify-github-commits","source":"@site/blog/why-we-verify-github-commits.md","title":"Why We Verify GitHub Commits","description":"Assigning the author on a commit is an essential feature of Git that allows you to send a commit on behalf of someone","date":"2024-05-24T16:00:14.000Z","tags":[{"inline":false,"label":"GitHub","permalink":"/docs/openziti/blog/tags/github","description":"GitHub content"},{"inline":false,"label":"Git","permalink":"/docs/openziti/blog/tags/git","description":"Git content"},{"inline":false,"label":"SDLC","permalink":"/docs/openziti/blog/tags/sdlc","description":"Software Development Lifecycle"},{"inline":false,"label":"GPG","permalink":"/docs/openziti/blog/tags/gpg","description":"GNU Privacy Guard content"}],"readingTime":3.47,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"Why We Verify GitHub Commits","date":"2024-05-24T16:00:14.000Z","cuid":"clwkvbmet00000ak6d5z5btad","slug":"why-we-verify-github-commits","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1716320888402/f7bcebeb-a9e6-4094-8e6c-fac73ce8a9c5.png","imageDark":"@site/blogs/openziti/v1716320888402/f7bcebeb-a9e6-4094-8e6c-fac73ce8a9c5.png","tags":["github","git","sdlc","gpg"]},"unlisted":false,"prevItem":{"title":"Extend Access to a Private S3 Bucket Using Python","permalink":"/docs/openziti/blog/extend-access-to-a-private-s3-bucket-using-python"},"nextItem":{"title":"Limitless zrok with Docker","permalink":"/docs/openziti/blog/limitless-zrok-with-docker"}},"content":"Assigning the author on a commit is an essential feature of Git that allows you to send a commit on behalf of someone \\nwhile preserving their authorship. I speculate this was the norm when the Linux Kernel authors, who also \\ncreated Git, still received many contributions via email.\\n\\n\x3c!-- truncate --\x3e\\n\\nGitHub automatically links the commit to the attributed author\'s and committer\'s GitHub profile(s). By default, there\'s no visible indication that a commit was attributed.\\n\\n## Attribution with Git\\n\\nFirst, we can see that bob@example.com is the currently-configured author email.\\n\\n```bash\\n$ git config --local user.name\\nBob\\n\\n$ git config --local user.email\\nbob@example.com\\n```\\n\\nNext, Bob configures Git to impersonate a known email address.\\n\\n```bash\\ngit config --local user.name bot\\ngit config --local user.email github-actions[bot]@users.noreply.github.com\\n```\\n\\nNext, Bob makes the commit locally and inspects the metadata.\\n\\n```bash\\ngit commit -am \\"who sent this commit?\\"\\ngit log -1 --format=fuller\\n```\\n\\n```text\\ncommit 114550a026fb4a106ad3911b2c585eda16d8dbfe (HEAD -> main, origin/main, origin/HEAD)\\nAuthor:     github-actions[bot] <github-actions[bot]@users.noreply.github.com>\\nAuthorDate: Tue May 21 09:52:06 2024 -0400\\nCommit:     github-actions[bot] <github-actions[bot]@users.noreply.github.com>\\nCommitDate: Tue May 21 09:52:06 2024 -0400\\n\\n    who sent this commit?\\n```\\n\\nIn the above example, Bob specifies the committer and author metadata of the next commit to match a known email address before pushing it to GitHub, which displays the commit as if that bot had sent it.\\n\\n![](/blogs/openziti/v1716492848880/f969b51e-be03-4a7a-923e-f3250601dc69.png)\\n\\nBob can also update the author and committer metadata on the last commit (`HEAD`, or any commit during a rebase) and push it to GitHub.\\n\\n```bash\\nGIT_COMMITTER_NAME=\\"github-actions[bot]\\"\\nGIT_COMMITTER_EMAIL=\\"${GIT_COMMITTER_NAME}@users.noreply.github.com\\"\\nexport GIT_COMMITTER_NAME GIT_COMMITTER_EMAIL\\n\\ngit commit \\\\\\n--amend \\\\\\n--no-edit \\\\\\n--no-gpg-sign \\\\\\n--author \\"${GIT_COMMITTER_NAME} <${GIT_COMMITTER_EMAIL}>\\"\\n```\\n\\n## How can I protect the sauce?\\n\\nWhile you can\'t disable attribution in GitHub, there are some things you can do.\\n\\n### Require Verified Commits\\n\\nA verified commit is authenticated by GitHub. GitHub [lets you require verified commits](https://docs.github.com/en/authentication/managing-commit-signature-verification/about-commit-signature-verification). Once enabled, GitHub will not accept unverified commits in the specified branches.\\n\\nCommits can be marked \\"verified\\" in several ways:\\n\\n1. The easiest way is to edit files in the GitHub UI. This allows GitHub to authenticate the commit with the browser session and sign the commit with [their web flow key](https://github.com/web-flow.gpg).\\n    \\n2. The most useful way is to sign commits locally with the `git` CLI and a GPG key. This allows GitHub and anyone to verify the signature on the commit.\\n    \\n    ```bash\\n    git verify-commit -v HEAD\\n    ```\\n    \\n    ```text\\n    tree 550accc6ea105ed9e407db481c99d45d3cb32cb1\\n    parent 408720459f8985dd01d4e36857d8e42f988539f9\\n    author Kenneth Bingham <kenneth.bingham@netfoundry.io> 1716477976 -0400\\n    committer Kenneth Bingham <kenneth.bingham@netfoundry.io> 1716477976 -0400\\n    \\n    document rolling back downstream\\n    gpg: Signature made Thu 23 May 2024 11:26:17 AM EDT\\n    gpg:                using RSA key 1EB5E833014594E4EDB0317331709281860130B6\\n    gpg:                issuer \\"kenneth.bingham@netfoundry.io\\"\\n    gpg: Good signature from \\"Kenneth Bingham <kenneth.bingham@netfoundry.io>\\"         \\n    [ultimate]\\n    Primary key fingerprint: F52F 87DD 444E 337F FA40  951A F3FC 641E F53D D900\\n         Subkey fingerprint: 1EB5 E833 0145 94E4 EDB0  3173 3170 9281 8601 30B6\\n    ```\\n    \\n\\n### Enable Vigilant Mode\\n\\n[Vigilant mode](https://docs.github.com/en/authentication/managing-commit-signature-verification/displaying-verification-statuses-for-all-of-your-commits) changes the way your commits are presented on GitHub.com.\\n\\nWithout vigilant mode, unverified commits do not have any verification status badge, so there\'s no visual difference between those sent by the committer and those attributed to another author.\\n\\nWith vigilant mode, all of your commits have a badge (\\"verified,\\" \\"unverified,\\" or \\"partially verified\\"). This raises awareness about the significance of verified commits and serves as a visual warning that a commit was not authenticated by GitHub.\\n\\n## What Doesn\'t this Prevent?\\n\\n### Hasty Review\\n\\nRequiring verified commits is not a substitute for a careful review of contributions. A malicious or otherwise unwanted commit can indeed be verified.\\n\\n### A Compromised GitHub Account\\n\\nIntruders can impersonate you and send verified malicious commits if your GitHub account is compromised.\\n\\n### The Long Game\\n\\nA patient actor can build credibility for their GitHub account and infiltrate a project. This may yield an opportunity to introduce verified malicious commits.\\n\\nReference: [The xz backdoor timeline](https://boehs.org/node/everything-i-know-about-the-xz-backdoor)"},{"id":"limitless-zrok-with-docker","metadata":{"permalink":"/docs/openziti/blog/limitless-zrok-with-docker","source":"@site/blog/limitless-zrok-with-docker.md","title":"Limitless zrok with Docker","description":"You can conveniently run a zrok instance on a Linux server. The Caddy option makes it easy to auto-renew a wildcard certificate to protect the zrok API and your public shares with TLS.","date":"2024-05-22T20:00:34.000Z","tags":[{"inline":false,"label":"Self Hosted","permalink":"/docs/openziti/blog/tags/self-hosted","description":"Self-hosted setups"},{"inline":false,"label":"Docker Compose","permalink":"/docs/openziti/blog/tags/docker-compose","description":"Docker Compose"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"},{"inline":false,"label":"Tunneling","permalink":"/docs/openziti/blog/tags/tunneling","description":"Network tunneling"}],"readingTime":1.82,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"Limitless zrok with Docker","date":"2024-05-22T20:00:34.000Z","cuid":"clwi90z8q000e09m6bzop4hr1","slug":"limitless-zrok-with-docker","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1716328568062/8df0ac72-be9a-471b-ac5e-3f03e21a8ae3.png","imageDark":"@site/blogs/openziti/v1716328568062/8df0ac72-be9a-471b-ac5e-3f03e21a8ae3.png","tags":["self-hosted","docker-compose","openziti","zrok","tunneling"]},"unlisted":false,"prevItem":{"title":"Why We Verify GitHub Commits","permalink":"/docs/openziti/blog/why-we-verify-github-commits"},"nextItem":{"title":"How to Prevent Path Traversal Attacks with OpenZiti BrowZer","permalink":"/docs/openziti/blog/how-to-prevent-path-traversal-attacks-with-openziti-browzer"}},"content":"You can conveniently run a zrok instance on a Linux server. The Caddy option makes it easy to auto-renew a wildcard certificate to protect the zrok API and your public shares with TLS.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What\'s This Good For?\\n\\n* [You can publicly share websites, files, etc.](https://docs.zrok.io/docs/concepts/sharing-public/), with auth from your computers without punching holes in their inbound firewalls. This is called reverse tunneling. Your Linux server is public and acts as a relay.\\n    \\n* [You can privately share TCP/UDP services or create a VPN](https://docs.zrok.io/docs/concepts/sharing-private/). You must give the other party an account on your instance. This is excellent for multi-player games, etc.\\n    \\n* **No limits** \u2014 Maximize the use of your available bandwidth and compute.\\n    \\n* **Data sovereignty** \u2014 Assuming you control your server, no third parties can access your data.\\n    \\n* **Availability** \u2014 You control upgrades and uptime...which can be a double-edged sword!\\n    \\n\\n## The Needful Things\\n\\n* [Install Docker on your Linux](https://docs.docker.com/engine/install/) server.\\n    \\n* Create a wildcard record in the zrok DNS zone for your Linux server\'s public IP address.\\n    \\n* to enable Caddy TLS, you\'ll need an API token from your DNS provider.\\n    \\n\\n## The Short Version\\n\\n```bash\\ncurl https://get.openziti.io/zrok-instance/fetch.bash | bash\\n```\\n\\nThen, configure your environment with an `.env` file\\n\\n```bash\\nZROK_DNS_ZONE=share.example.com\\n\\nZROK_USER_EMAIL=me@example.com\\nZROK_USER_PWD=zrokuserpw\\n\\nZITI_PWD=zitiadminpw\\nZROK_ADMIN_TOKEN=zroktoken\\n\\n# if you don\'t plan to enable Caddy TLS,\\n#  set this to publish insecure ports\\nZROK_INSECURE_INTERFACE=0.0.0.0\\n```\\n\\n...and start the containers.\\n\\n```bash\\ndocker compose up --build\\n```\\n\\n## Enable Caddy TLS\\n\\nIf you have an API token from your DNS provider, you can add these values to your `.env` file to configure Caddy to auto-renew a wildcard certificate for your zrok DNS zone.\\n\\n```bash\\nCADDY_DNS_PLUGIN=cloudflare\\nCADDY_DNS_PLUGIN_TOKEN=abcd1234\\n```\\n\\nEnable Caddy by renaming the extra compose file.\\n\\n```bash\\nmv caddy.compose.override.yml compose.override.yml\\n```\\n\\nRestart the containers.\\n\\n```bash\\ndocker compose up --build --force-recreate\\n```\\n\\n## The Longer Version\\n\\n<iframe width=\\"100%\\" height=\\"315\\" src=\\"https://www.youtube.com/embed/70zJ_h4uiD8\\"></iframe>\\n\\nHere\'s [a link to the full guide](https://docs.zrok.io/docs/guides/self-hosting/docker/) used in the video.\\n\\n## Get in Touch\\n\\nVisit us in [our Discourse community](https://openziti.discourse.group/) if you have any ideas or questions."},{"id":"how-to-prevent-path-traversal-attacks-with-openziti-browzer","metadata":{"permalink":"/docs/openziti/blog/how-to-prevent-path-traversal-attacks-with-openziti-browzer","source":"@site/blog/how-to-prevent-path-traversal-attacks-with-openziti-browzer.md","title":"How to Prevent Path Traversal Attacks with OpenZiti BrowZer","description":"The web has revolutionized how the world operates, enabling everything from banking and shopping to social media and general business transactions. However, as with all technological advancements, malicious actors quickly found ways to exploit the web for fraudulent activities. The anonymity provided by internet usage allowed criminals to deceive users and providers, leading to significant financial losses. In response, technologies like SSL/TLS and public trust architectures were developed to enhance security, helping users verify the servers they communicate with and feel more secure in their online interactions. Despite these measures, software is inherently fallible, as it is created by humans who can make mistakes.","date":"2024-05-22T18:49:58.000Z","tags":[{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"CVE","permalink":"/docs/openziti/blog/tags/cve","description":"Common Vulnerabilities and Exposures"}],"readingTime":5.09,"hasTruncateMarker":true,"authors":[{"name":"Mike Gorman","title":"Author","url":"https://github.com/mikegorman-nf","imageURL":"https://avatars.githubusercontent.com/mikegorman-nf","key":"MikeGorman","page":null}],"frontMatter":{"title":"How to Prevent Path Traversal Attacks with OpenZiti BrowZer","date":"2024-05-22T18:49:58.000Z","cuid":"clwi6i6r100040ajobbs12wyv","slug":"how-to-prevent-path-traversal-attacks-with-openziti-browzer","authors":["MikeGorman"],"image":"@site/blogs/openziti/v1716212854203/849ab21c-0082-49fb-9a05-a52dd554bb41.png","imageDark":"@site/blogs/openziti/v1716212854203/849ab21c-0082-49fb-9a05-a52dd554bb41.png","tags":["opensource","security","cve"]},"unlisted":false,"prevItem":{"title":"Limitless zrok with Docker","permalink":"/docs/openziti/blog/limitless-zrok-with-docker"},"nextItem":{"title":"zrok VPN","permalink":"/docs/openziti/blog/zrok-vpn"}},"content":"The web has revolutionized how the world operates, enabling everything from banking and shopping to social media and general business transactions. However, as with all technological advancements, malicious actors quickly found ways to exploit the web for fraudulent activities. The anonymity provided by internet usage allowed criminals to deceive users and providers, leading to significant financial losses. In response, technologies like SSL/TLS and public trust architectures were developed to enhance security, helping users verify the servers they communicate with and feel more secure in their online interactions. Despite these measures, software is inherently fallible, as it is created by humans who can make mistakes.\\n\\n\x3c!-- truncate --\x3e\\n\\nCriminals continually discover and exploit these vulnerabilities, using sophisticated techniques to steal information and steal or extort money. Rather than defraud users directly, they turned to stealing information by attacking the applications. BrowZer, part of the OpenZiti project, prevents one of the most common attack techniques listed in the [OWASP Top 10](https://owasp.org/www-project-top-ten/) and elsewhere, Broken Access Control.\\n\\n## The Threat of Path Traversal\\n\\nSome of the worst incidents occur when simple mistakes are made in software design, allowing vulnerabilities like path traversal attacks.\xa0 For those unfamiliar with the term, path traversal is a relatively simple attack strategy of appending paths to the URL of a website.\xa0 For example, one might usually go to [https://www.mywebsite.com](https://www.mywebsite.com).\xa0 One can append a path, like [https://www.mywebsite.com/users](https://www.mywebsite.com/users). In a vulnerable application, these requests or uploads will return data or take actions without the user having logged in.\\n\\nThere are 3 separate CWE\'s mapped to Broken Access Control specifically tied to path traversal, CWEs [22](https://cwe.mitre.org/data/definitions/22.html), [23](https://cwe.mitre.org/data/definitions/23.html), and [35](https://cwe.mitre.org/data/definitions/35.html). \xa0 Tools like [DirBuster](https://www.kali.org/tools/dirbuster/) and [ffuf](https://github.com/ffuf/ffuf) take in wordlists and can run thousands of paths against a site automatically, logging any path that receives something other than an error, and giving malicious actors a list of potentially exploitable paths.\xa0 Highly automated systems can do much more, scraping and analyzing the data for value, allowing the actor to scan large numbers of sites and receive a list of targets ranked by potential value.\xa0 More so, when particular exploits are located, these actors can scan the Web and automatically scrape data in known instances of the vulnerable sites.\\n\\n[![](/blogs/openziti/v1716216190969/7b88062c-3f06-47a2-95c8-25cc7696acb8.png)](https://www.hackingarticles.in/comprehensive-guide-on-path-traversal/)\\n\\nThese types of vulnerabilities and attacks they enable are not trivial.\xa0 As of 5/17/24, there are [4,846 CVEs](https://nvd.nist.gov/vuln/search/results?isCpeNameSearch=false&query=directory+traversal&results_type=overview&form_type=Basic&search_type=all&startIndex=0) in the CVE database referring to directory traversal.\xa0 These attacks are at the root of some of the largest incidents, [Equifax](https://www.infosecinstitute.com/resources/hacking/equifax-breach-exploit/), and [Synology NAS](https://www.exploit-db.com/exploits/30475) devices, as well as popular tools like [Jenkins](https://www.securityweek.com/poc-published-for-critical-fortra-code-execution-vulnerability/).\xa0 Even applications meant to protect corporate data, [Fortinet](https://nvd.nist.gov/vuln/detail/CVE-2018-13379) and [Pulse Secure VPNs](https://www.tenable.com/cve/CVE-2019-11510), fell victim to these types of attacks.\xa0\xa0\xa0 There have been vulnerabilities in frameworks, like Apache Struts, used to create web applications, meaning those built with these frameworks are likely to be vulnerable; this is the root vulnerability of the Equifax breach.\xa0\\n\\nAll the companies in the cases above have responded quickly to provide patches and other support to their customers to address the issues once discovered, but in many cases, the damage was done.\xa0 Zero day exploits travel through the hacker community much more quickly than the affected products can respond.\xa0 Even information for virtual patching, web application firewall rules to apply until the software can be updated and similar measures often arrive far too late.\\n\\nThe fundamental problem is that the authentication and authorization functions, those processes that make sure the user is who they say they are, and decide what they are allowed to do are part of the information system itself.\xa0 This allows an exploit to gain critical information from unauthenticated remote users. This of the worst kinds of vulnerabilities, as it is open to the entire network for potential exploitation, either publicly on an open site, or to malicious actors and APTs within enterprise environments.\xa0 [BrowZer](https://openziti.io/docs/learn/quickstarts/browzer/), a project of the OpenZiti project sponsored by NetFoundry, addresses this fundamental design issue by moving the authentication of the user completely outside of the actual information system only allowing authorized connections after authentication is complete.\\n\\n## Browzer Breaks the Path\\n\\nBrowZer allows a completely clientless connection to protected systems by dynamically loading into the web browser a package that creates a secure connection to assets protected by OpenZiti.\xa0 How is this different than Pulse Secure or Foritnet which also create secured tunnels?\xa0 The BrowZer agent is completely independent of the application it is placed in front of.\xa0 Once authenticated, using one of a multitude of authentication services, the system loads the client dynamically into the local browser and creates a new connection from that software to the OpenZiti network, which provides connectivity to the application.\xa0 This prevents any unauthenticated user from reaching the application in question.\xa0 Actors can\'t initiate a path traversal or other unauthenticated attack because it can\'t reach the actual application until the authentication and authorization have occurred.\\n\\n![](/blogs/openziti/v1716219804073/1292c372-d81a-45d7-896f-9c0b6f2ef782.png)\\n\\n[OpenZiti](https://openziti.io) is a software network overlay providing secure communication through a true network, with provisioning, monitoring, and highly granular communication permissions allowing microsegmentation and other Zero Trust features to be applied to networks and applications at a network connectivity level.\xa0 This allows for a common centralized platform to allow and monitor traffic throughout a dispersed network of applications, devices, users, and workloads.\xa0 BrowZer is one method of accessing the network\'s resources without having to control the system or application used to access it to load a client or embed into the software using the available SDKs."},{"id":"zrok-vpn","metadata":{"permalink":"/docs/openziti/blog/zrok-vpn","source":"@site/blog/zrok-vpn.md","title":"zrok VPN","description":"The latest version of zrok has a new capability -- host-to-host VPN tunnel.","date":"2024-05-21T15:17:50.000Z","tags":[{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":2.99,"hasTruncateMarker":true,"authors":[{"name":"Eugene Kobyakov","title":"Author","url":"https://github.com/ekoby","imageURL":"https://avatars.githubusercontent.com/ekoby","key":"EugeneKobyakov","page":null}],"frontMatter":{"title":"zrok VPN","date":"2024-05-21T15:17:50.000Z","cuid":"clwgjhize000d0ck18y703n52","slug":"zrok-vpn","authors":["EugeneKobyakov"],"image":"@site/blogs/openziti/v1716212137599/451cee0f-8d37-4ab2-8548-8a62b42656af.png","imageDark":"@site/blogs/openziti/v1716212137599/451cee0f-8d37-4ab2-8548-8a62b42656af.png","tags":["zerotrust","zrok"]},"unlisted":false,"prevItem":{"title":"How to Prevent Path Traversal Attacks with OpenZiti BrowZer","permalink":"/docs/openziti/blog/how-to-prevent-path-traversal-attacks-with-openziti-browzer"},"nextItem":{"title":"Deploy OpenZiti in Kubernetes with Ease Using k3d","permalink":"/docs/openziti/blog/deploy-openziti-in-kubernetes-with-ease-using-k3d"}},"content":"The latest version of [`zrok`](https://zrok.io/) has a new capability -- host-to-host VPN tunnel.\\n\\n\x3c!-- truncate --\x3e\\n\\n## TL;DR version\\n\\nOn VPN *host*\\n\\n```plaintext\\n$ sudo -E zrok share private --headless --backend-mode vpn\\n[   0.542]    INFO sdk-golang/ziti.(*listenerManager).createSessionWithBackoff: {session token=[589d443c-f59d-4fc8-8c48-76609b7fb402]} new service session\\n[   0.705]    INFO main.(*sharePrivateCommand).run: allow other to access your share with the following command:\\nzrok access private 3rq7torslq3n\\n[   0.705]    INFO zrok/endpoints/vpn.(*Backend).Run: started\\n```\\n\\nOn VPN *client*\\n\\n```plaintext\\n$ sudo -E zrok access private --headless 3rq7torslq3n\\n[   0.201]    INFO main.(*accessPrivateCommand).run: allocated frontend \'50B5hloP1s1X\'\\n[   0.662]    INFO main.(*accessPrivateCommand).run: access the zrok share at the following endpoint: VPN:\\n[   0.662]    INFO main.(*accessPrivateCommand).run: 10.122.0.1 -> CONNECTED Welcome to zrok VPN\\n[   0.662]    INFO zrok/endpoints/vpn.(*Frontend).Run: connected:Welcome to zrok VPN\\n```\\n\\nAt this point your VPN host and client are connect with VPN -- you can access host resources via host IP address (10.122.0.1), client IP will be from 10.122.0.0/16 block.\\n\\n## Longer Read\\n\\nIf you just want to learn more and what options are available the best place to start is on zrok [doc page](https://docs.zrok.io/docs/guides/vpn/). Also check out a ZitiTV episode where I discuss zrok VPN with the host, Clint.\\n\\n%[https://www.youtube.com/live/OG9z1_8FbDg?si=FNXqs8SYAMPMLggn] \\n\\n## Why? What took so long?\\n\\nBoth fair questions, so a little background. We ([OpenZiti](https://openziti.io) project) and me personally do not consider VPN solutions particularly zero-trust-worthy. There a number of reasons for that:\\n\\n* VPNs operate at the network packet level not application level. This means that they will forward any matching packet into the private network whether or not there is a legitimate target for it.\\n    \\n* VPNs have no concept of application access control -- meaning everyone connecting to a private network gets the same access to network resources.\\n    \\n\\nFor those reasons we built OpenZiti on the foundation of [strong zero-trust principals](https://openziti.io/docs/learn/introduction/features).\\n\\n...But people still *want* an easy way of remote access to home or office with *good enough* security that VPN gives them.\\n\\nSo, you want a VPN I\'ll build you a VPN. How hard can it really be??\\n\\n## Enter zrok\\n\\nIf you have not yet tried or heard about zrok, I invite you to read the [zrok series](./tags/zrok) on this very blog.\\n\\nThe reasons we chose to implement VPN as part of [zrok](https://zrok.io/) are the following:\\n\\n* super easy to start and use\\n    \\n* well established share/access pattern: both side are in sync on what mode is used\\n    \\n* easy to add another `backend` mode\\n    \\n\\n## VPN implementation\\n\\nUnder the hood, the zrok framework already has all the necessary components for creating shares, accessing them, and establishing connections between the `access` and `share` sides. So all I needed to do to implement VPN mode:\\n\\n* open virtual network device (tun)\\n    \\n* configure network addresses and routes\\n    \\n* read packets and forward them\\n    \\n* ... Wait ... that was it? Took me a few hours. What was the fuss about?\\n    \\n\\n## zrok VPN future\\n\\nThe initial zrok VPN release is somewhat simple and minimal. It currently provides only a host-to-host VPN functionality. We have some ideas how we want to continue improving it: better routing support, DNS, VPN mesh, mobile client -- are just some of them.\\n\\nPlease give it a try and let us know how you like it, what features you want to see, and, of course, any bugs that you encounter.\\n\\n* Reach us on [Discourse](https://openziti.discourse.group/)\\n    \\n* Check out (and star!) our repos: [zrok](https://github.com/openziti/zrok), [ziti](https://github.com/openziti/ziti), and [more](https://github.com/openziti)"},{"id":"deploy-openziti-in-kubernetes-with-ease-using-k3d","metadata":{"permalink":"/docs/openziti/blog/deploy-openziti-in-kubernetes-with-ease-using-k3d","source":"@site/blog/deploy-openziti-in-kubernetes-with-ease-using-k3d.md","title":"Deploy OpenZiti in Kubernetes with Ease Using k3d","description":"k3d is a Kubernetes distribution for Docker that makes it easy to replicate a production-like environment in a local container environment. It\'s great for local development and familiarizing yourself with OpenZiti\'s deployment options.","date":"2024-05-17T19:13:03.000Z","tags":[{"inline":false,"label":"Docker","permalink":"/docs/openziti/blog/tags/docker","description":"Docker content"},{"inline":false,"label":"Kubernetes","permalink":"/docs/openziti/blog/tags/kubernetes","description":"Kubernetes content"},{"inline":false,"label":"Self Hosted","permalink":"/docs/openziti/blog/tags/self-hosted","description":"Self-hosted setups"},{"inline":false,"label":"k3d","permalink":"/docs/openziti/blog/tags/k3d","description":"Lightweight Kubernetes in Docker"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Overlay Networking","permalink":"/docs/openziti/blog/tags/overlaynetworking","description":"Overlay networking"}],"readingTime":5.04,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"Deploy OpenZiti in Kubernetes with Ease Using k3d","date":"2024-05-17T19:13:03.000Z","cuid":"clwb24maj00010amp786bh8gw","slug":"deploy-openziti-in-kubernetes-with-ease-using-k3d","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1715957663205/30f837ad-feba-47f8-9678-09a0b08ae781.png","imageDark":"@site/blogs/openziti/v1715957663205/30f837ad-feba-47f8-9678-09a0b08ae781.png","tags":["docker","kubernetes","self-hosted","k3d","zerotrust","overlaynetworking"]},"unlisted":false,"prevItem":{"title":"zrok VPN","permalink":"/docs/openziti/blog/zrok-vpn"},"nextItem":{"title":"Signing Executables From GitHub Actions","permalink":"/docs/openziti/blog/signing-executables-from-github-actions"}},"content":"k3d is a Kubernetes distribution for Docker that makes it easy to replicate a production-like environment in a local container environment. It\'s great for local development and familiarizing yourself with [OpenZiti\'s deployment options](https://openziti.io/docs/category/deployments).\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Plan\\n\\n1. Create a k3d cluster.\\n    \\n2. Install the OpenZiti controller.\\n    \\n3. Install the OpenZiti router.\\n    \\n\\n## Create a Cluster\\n\\nPrerequisite: [`k3d`](https://k3d.io/#install-script) CLI\\n\\nWe need a cluster with forwarded ports for the controller and a router. Run `k3d` to create a cluster.\\n\\n```bash\\nk3d cluster create ziti-local \\\\\\n--port 1280:1280@loadbalancer \\\\\\n--port 6262:6262@loadbalancer \\\\\\n--port 3022:3022@loadbalancer \\\\\\n--port 10080:10080@loadbalancer\\n```\\n\\n### Ports Breakdown\\n\\n* controller\\n    \\n    * `1280` - client API web listener\\n        \\n    * `6262` - control plane for routers\\n        \\n* router\\n    \\n    * `3022` - edge listener for identities\\n        \\n    * `10080` - link listener for other routers\\n        \\n\\n*A note about why everything\'s port-separated in this tutorial: It\'s simpler. OpenZiti uses mTLS extensively, so the cluster must pass through TLS to the controller and router pods. This tutorial uses LoadBalancer services because they provide a raw TCP proxy and are convenient with Traefik in k3d. OpenZiti can also separate services sharing a port by ALPN identifier, and Ingress/Gateway controllers can separate them by SNI.*\\n\\n## Find the Node Address\\n\\nPrerequisite: [`kubectl`](https://kubernetes.io/docs/tasks/tools/#kubectl) CLI\\n\\nRun `kubectl` to set a shell environment variable `NODE_IP` to the LoadBalancer address. This gives us an IP address that\'s routable inside and outside our k3d cluster. We\'ll use it to invent a DNS name in a magic wildcard zone (e.g., `sslip.io`, `nip.io`).\\n\\n### Windows\\n\\nFor Docker Desktop on Windows, use the WSL2 VM interface address and run the rest of the commands with BASH in WSL2.\\n\\n```bash\\nNODE_IP=$(getent hosts host.docker.internal | awk \'{ print $1 }\')\\n```\\n\\n### macOS\\n\\nFor Docker Desktop on macOS, use the default host interface address.\\n\\n```bash\\nNODE_IP=$(ipconfig getifaddr $(route get default | awk \'/interface: / { print $2 }\'))\\n```\\n\\n### Linux\\n\\nFor Docker daemon on Linux, use the IP of the load balancer container.\\n\\n```bash\\nNODE_IP=$(docker inspect k3d-ziti-local-serverlb|jq -r \'.[].NetworkSettings.Networks[].IPAddress\')\\n```\\n\\n## Install the Controller Chart\\n\\nPrerequisite: [`helm`](https://helm.sh/docs/intro/install/) CLI\\n\\nRun `helm` to add the OpenZiti charts repo.\\n\\n```bash\\nhelm repo add \\"openziti\\" https://openziti.io/helm-charts\\nhelm repo update \\"openziti\\"\\n```\\n\\nInstall the [Cert Manager](https://cert-manager.io/docs/) and [Trust Manager](https://cert-manager.io/docs/trust/trust-manager/) Custom Resource Definitions so we can install them as subcharts.\\n\\n```bash\\nkubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.crds.yaml\\nkubectl apply -f https://raw.githubusercontent.com/cert-manager/trust-manager/v0.7.0/deploy/crds/trust.cert-manager.io_bundles.yaml\\n```\\n\\nInstall and configure the controller to advertise the node address (i.e., the LoadBalancer address).\\n\\n```bash\\nhelm upgrade --install \\"ziti-controller\\" openziti/ziti-controller \\\\\\n--namespace \\"ziti\\" --create-namespace \\\\\\n--set clientApi.advertisedHost=\\"client.ziti.${NODE_IP}.sslip.io\\" \\\\\\n--set clientApi.advertisedPort=1280 \\\\\\n--set clientApi.service.type=LoadBalancer \\\\\\n--set ctrlPlane.advertisedHost=\\"ctrl.ziti.${NODE_IP}.sslip.io\\" \\\\\\n--set ctrlPlane.advertisedPort=6262 \\\\\\n--set ctrlPlane.service.type=LoadBalancer \\\\\\n--set trust-manager.app.trust.namespace=ziti \\\\\\n--set trust-manager.enabled=true \\\\\\n--set cert-manager.enabled=true\\n```\\n\\n### Input Values Breakdown\\n\\n* `clientApi`\\n    \\n    * `advertisedHost`: FQDN that identities will connect to the control plane\\n        \\n    * `advertisedPort`: port on the FQDN identities will connect to\\n        \\n    * `service.type`: K8s Service type\\n        \\n* `ctrlPlane`\\n    \\n    * `advertisedHost`: FQDN that routers will connect to the control plane\\n        \\n    * `advertisedPort`: port on the FQDN routers will connect to\\n        \\n    * `service.type`: K8s service type\\n        \\n* [`trust-manager`](http://trust-manager.app.trust)\\n    \\n    * `app.trust.namespace`: K8s Namespace where Trust Manager is allowed to read K8s Secrets to serve bundles of trusted root CA certificates\\n        \\n    * `enabled`: install Trust Manager sub chart in the same namespace\\n        \\n* `cert-manager`\\n    \\n    * `enabled`: install Cert Manager sub chart in the same namespace\\n        \\n\\n## Log in to the OpenZiti Controller\\n\\nWait for the controller deployment to become ready.\\n\\n```bash\\nkubectl wait deployments \\"ziti-controller\\" \\\\\\n    --namespace ziti \\\\\\n    --for condition=Available=True \\\\\\n    --timeout 240s\\n```\\n\\nPrerequisite: [`ziti`](https://openziti.io/docs/downloads?os=Linux) CLI\\n\\nGet the admin\'s password and log in\\n\\n```bash\\nkubectl get secrets \\"ziti-controller-admin-secret\\" \\\\\\n--namespace \\"ziti\\" \\\\\\n--output go-template=\'{{index .data \\"admin-password\\" | base64decode }}\' \\\\\\n| xargs -rl ziti edge login client.ziti.${NODE_IP}.sslip.io:1280 \\\\\\n--yes --username \\"admin\\" \\\\\\n--password\\n```\\n\\nWhat does this gnarly one-liner do? It\'s three commands. The first, `kubectl`, gets the admin password from K8s. The second command, `xargs` , tacks the password onto the end of the third, `ziti edge login`.\\n\\n## Create an OpenZiti Router\\n\\nYou must administratively create a Ziti router. The `-t` option is short for `--tunneler-enabled` and enables the built-in tunneler to be used as a reverse proxy for cluster-internal services. This will be convenient when you create your first OpenZiti service.\\n\\n```bash\\nziti edge create edge-router \\"router1\\" -t -o ./router1.jwt\\n```\\n\\nExpected Output\\n\\n```bash\\nNew edge router router1 created with id: OdiqYOi9RW\\nEnrollment expires at 2024-05-17T20:50:59.142Z\\n```\\n\\n## Install the Router Chart\\n\\nThe token allows the router to bootstrap itself with a renewable identity from the controller.\\n\\n```bash\\nhelm upgrade --install \\"ziti-router\\" openziti/ziti-router \\\\\\n--namespace \\"ziti\\" \\\\\\n--set-file enrollmentJwt=./router1.jwt \\\\\\n--set edge.advertisedHost=\\"router1.edge.ziti.${NODE_IP}.sslip.io\\" \\\\\\n--set edge.advertisedPort=3022 \\\\\\n--set edge.service.type=LoadBalancer \\\\\\n--set linkListeners.transport.advertisedHost=\\"router1.link.ziti.${NODE_IP}.sslip.io\\" \\\\\\n--set linkListeners.transport.advertisedPort=10080 \\\\\\n--set linkListeners.transport.service.type=LoadBalancer \\\\\\n--set tunnel.mode=host \\\\\\n--set ctrl.endpoint=\\"ctrl.ziti.${NODE_IP}.sslip.io:6262\\"\\n```\\n\\n### Input Values Breakdown\\n\\n* `enrollmentJwt`: This is the path to the token file you got from administratively creating the router.\\n    \\n* `edge`\\n    \\n    * `advertisedHost`: FQDN identities will connect to the data plane\\n        \\n    * `advertisedPort`: Port on the FQDN identities will connect to\\n        \\n    * `service.type`: K8s service type\\n        \\n* `linkListeners`\\n    \\n    * `transport`\\n        \\n        * `advertisedHost`: FQDN routers will connect to the data plane\\n            \\n        * `advertisedPort`: port on the FQDN where routers will connect\\n            \\n        * `service.type`: K8s service type\\n            \\n* `ctrl`\\n    \\n    * `endpoint`: control plane address for this router to connect to\\n        \\n\\n### Ensure router1 is Online.\\n\\n```bash\\nziti edge list edge-routers\\n```\\n\\nExpected Output\\n\\n```bash\\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\\n\u2502 ID         \u2502 NAME    \u2502 ONLINE \u2502 ALLOW TRANSIT \u2502 COST \u2502 ATTRIBUTES \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502 OdiqYOi9RW \u2502 router1 \u2502 true   \u2502 true          \u2502    0 \u2502            \u2502\\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\\nresults: 1-1 of 1\\n```\\n\\n## That\'s It!\\n\\nNow, you can add identities and connect them with services and policies.\\n\\nRecommended: [Kubernetes service tutorial](https://openziti.io/docs/learn/quickstarts/services/kubernetes-service/).\\n\\nPop into the forum if you have any ideas or issues: [https://openziti.discourse.group/](https://openziti.discourse.group/).\\n\\n## Related\\n\\n* [This other Kubernetes Quickstart](https://openziti.io/docs/learn/quickstarts/network/local-kubernetes) uses Minikube instead of k3d"},{"id":"signing-executables-from-github-actions","metadata":{"permalink":"/docs/openziti/blog/signing-executables-from-github-actions","source":"@site/blog/signing-executables-from-github-actions.md","title":"Signing Executables From GitHub Actions","description":"Hopefully, by now, we all know that we shouldn\'t download and run random, untrusted executables from the internet.","date":"2024-05-15T02:28:38.000Z","tags":[{"inline":false,"label":"Digital Signature","permalink":"/docs/openziti/blog/tags/digital-signature","description":"Digital signature topics"},{"inline":false,"label":"AWS KMS","permalink":"/docs/openziti/blog/tags/aws-kms","description":"AWS Key Management Service"},{"inline":false,"label":"GitHub Actions","permalink":"/docs/openziti/blog/tags/github-actions","description":"GitHub Actions automation"},{"inline":false,"label":"Signtool","permalink":"/docs/openziti/blog/tags/signtool","description":"Windows signtool"}],"readingTime":9.88,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Signing Executables From GitHub Actions","date":"2024-05-15T02:28:38.000Z","cuid":"clw77d8aa00070ammccc55jhc","slug":"signing-executables-from-github-actions","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1715610928648/e1bf8444-484c-440c-ad00-4669c493ff94.jpeg","imageDark":"@site/blogs/openziti/v1715610928648/e1bf8444-484c-440c-ad00-4669c493ff94.jpeg","tags":["digital-signature","aws-kms","githubactions","signtool"]},"unlisted":false,"prevItem":{"title":"Deploy OpenZiti in Kubernetes with Ease Using k3d","permalink":"/docs/openziti/blog/deploy-openziti-in-kubernetes-with-ease-using-k3d"},"nextItem":{"title":"The NodeJS zrok SDK","permalink":"/docs/openziti/blog/the-nodejs-zrok-sdk"}},"content":"Hopefully, by now, we all know that we shouldn\'t download and run random, untrusted executables from the internet. \\nUsers want to feel good that the code they are executing is authentic and free from malware. \\n[Windows Defender](https://en.wikipedia.org/wiki/Microsoft_Defender_Antivirus) is one of the better things Microsoft \\nhas done to keep the world safe. Defender is a free anti-virus application that scans executables for malicious code. \\nOften criticized for its intrusiveness (among other reasons), it\'s still a vital tool for millions of Windows users \\naround the globe. While it\'s not the only anti-virus/endpoint protection tool around, it comes with Windows by \\ndefault so making sure it doesn\'t tell your users your application is suspicious by popping up some scary modal \\ndialog is important!\\n\\n\x3c!-- truncate --\x3e\\n\\n[Signing an executable](https://en.wikipedia.org/wiki/Code_signing) is a cryptographic process that embeds information into the executable, allowing users to verify the software\'s author and ensure that the software has not been modified/tampered with after the author created and published it. Once signed, inside the file, there will be one or more digital signatures that contain an encrypted version of the file\'s hash. For a Windows executable, [calculating the file\'s hash](https://github.com/openziti/desktop-edge-win/blob/release-next/ZitiUpdateService/checkers/PeFile/SignedFileValidator.cs) is [too complex to outline here](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format), but the important point is that one must be able to calculate the same hash for a given file before and after signatures are added, which the PE32 format accounts for.\\n\\n> using an EV cert with an online build tool like GitHub can be a bit of a pain\\n\\nThe easiest, fastest, and, of course, most expensive way to make it so Windows Defender SmartScreen doesn\'t tell your users the executable is questionable, is to sign your executables using an [extended validation certificate (EV)](https://en.wikipedia.org/wiki/Extended_Validation_Certificate). You can save money and develop your reputation organically through users running your executable, but until the needed reputation is established, new users will be greeted by a scary modal from Windows. Using an EV cert will immediately establish the necessary trust. The OpenZiti project is sponsored by NetFoundry, so we are fortunate to have the means to purchase one of these EV certificates and use it for signing but using an EV cert with an online build tool like GitHub can be a bit of a pain.\\n\\nStarting June 1, 2023, you are now required to store your primary key inside a [FIPS 140 Level 2](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf) module. A level 2 module is one that builds on the level 1 requirements by adding the need for additional security measures such as tamper-evident seals or coatings. As of May 2024, GitHub secrets do not meet this requirement. Previously, we had placed the key and certificate into GitHub as secrets and pulled them out as needed to sign executables but with the new rules, this is no longer adequate. We had to upgrade the mechanism we use to sign executables. Looking around the internet, for a long time, the only cloud-friendly tooling example with something like GitHub Actions I could find was a [great blog from Sudara](https://melatonin.dev/blog/how-to-code-sign-windows-installers-with-an-ev-cert-on-github-actions/), but it leveraged Azure exclusively and required a different tool. I wanted to use AWS since that\'s where all our dev-related tooling was already. During my search, I discovered that [AWS KMS is FIPS-140 Level 3 certified](https://aws.amazon.com/about-aws/whats-new/2023/05/aws-kms-hsm-fips-security-level-3/). Since it\'s level 3 is a superset of level 2, we can use it for EV Certificate signing.\\n\\n## Microsoft SignTool\\n\\nMicrosoft provides a tool to sign executables called `signtool`. Getting Signtool is straightforward. It is included with the Microsoft Windows Software Development Kit but it\'s also installed by default when you install Visual Studio. If you have Visual Studio installed, you\'ll have `signtool`.\\n\\n> you no longer need to keep the private key on the machine running signtool\\n\\nAt some point in the past, signtool [was upgraded](https://learn.microsoft.com/en-us/windows/win32/seccrypto/signtool#sign-command-options) to allow for the digest to be generated out-of-band from the overall signing process. Signing the digest out-of-band makes the overall process of signing an executable only slightly more complex, but has a big benefit. With this process, **you will no longer need to keep the private key on the machine running signtool**. This is *particularly* valuable when signing files from a cloud CI/CD pipeline like GitHub\'s Actions. Recently, I upgraded the process of how the [OpenZiti project signs](https://github.com/openziti/desktop-edge-win/blob/release-next/Installer/build.ps1#L10-L33) the [Ziti Desktop Edge for Windows](https://github.com/openziti/desktop-edge-win/releases/tag/2.1.16) to leverage detached digest signing.\\n\\n![](/blogs/openziti/v1715622984201/de8bf432-8f2e-412c-b200-a3125c7d39bd.jpeg)\\n\\n### AWS KMS Prerequisites\\n\\nTo implement detached digest signing with signtool I needed a few things:\\n\\n* A private key in AWS KMS\\n    \\n* A certificate from our CA (we use [GlobalSign](https://www.globalsign.com/en)) with key usage of \\"Digital Signature\\" and enhanced key usage of \\"Code Signing (1.3.6.1.5.5.7.3.3)\\".\\n    \\n* A new IAM user with access the following permissions so it can list and sign data: \\"kms:ListKeys\\", \\"kms:DescribeKey\\", \\"kms:Sign\\"\\n    \\n* Configured the AWS CLI with this new user\\n    \\n\\nThe first step is to create or import a private key into AWS KMS. With the key in AWS KMS, I had to create a certificate signing request (CSR) using that private key so that I could submit it to our CA (we use [GlobalSign](https://www.globalsign.com/en)) for processing. After going through their vetting process, they created the necessary signing certificate which has the key usage of \\"Digital Signature\\" and enhanced key usage of \\"Code Signing (1.3.6.1.5.5.7.3.3)\\" I could download and test out.\\n\\nI also created a new IAM user in AWS with access only to the AWS KMS key. Since I knew I was going to be transferring this process to [a GitHub action](https://github.com/openziti/desktop-edge-win/blob/release-next/.github/workflows/installer.build.yml#L88), I did all my testing with the AWS CLI credentials of this user to ensure once I set the secrets in GitHub, I\'d know the process would work.\\n\\n## Detached Digest Signing With Signtool\\n\\nWith AWS CLI configured for the new user, the private key in AWS KMS, and with the EV signing cert in hand, I was ready to put a process in place to sign the executables built from the action using AWS KMS and signtool.\\n\\nIt really isn\'t significantly more difficult to use a detached digest signing with signtool but I couldn\'t find a single guide with examples that outlined the exact process. There are basically three steps you need to complete:\\n\\n* produce the digest to sign\\n    \\n* sign the digest\\n    \\n* incorporate the digest into the signature and attach the signature to the file\\n    \\n\\n### Producing the Digest\\n\\nTo produce the digest you simply need to run signtool with the `/dg` parameter to indicate you want to emit the digest of the file that needs to be signed. You must also specify `/fd` (the file digest algorithm to use for creating file signatures) and `/f` (the path to the signing certificate). The exact command to generate the digest to be signed looks like this.\\n\\n```powershell\\n& \\"$SIGNTOOL\\" sign /dg $digestLoc /fd sha256 /f $signingCert $exePath\\n```\\n\\nHere you can see the path to signtool is represented with the Powershell variable `$SIGNTOOL`. The `$digestLoc` represents the *directory* you want to emit the digest into. The file name will be the executable name + `.dig`. Don\'t be confused by that param. Personally, I opted to keep the digest file in the same directory as the executable so they are adjacent to one another. The signing certificate path is specified by the `/f` flag and the final parameter is the path to the executable path you want to sign. This command also creates a `.p7u` file in the `$digestLoc` that is used in the final step.\\n\\n### Signing the Digest\\n\\nWith the digest generated, next, you need to sign the digest.\\n\\n```powershell\\n$tosign = Get-Content \\"${exePath}.dig\\" -Raw\\n$signedData = aws kms sign `\\n    --message $tosign `\\n    --message-type DIGEST `\\n    --signing-algorithm \\"RSASSA_PKCS1_V1_5_SHA_256\\" `\\n    --key-id $env:AWS_KEY_ID `\\n    --output text `\\n    --query \\"Signature\\"\\nSet-Content -Path \\"${exePath}.dig.signed\\" -Value $signedData\\n```\\n\\nThe digest file to sign is read into a variable called `$tosign` and is read in using `-Raw` to ensure no spaces nor additional bytes are injected into the digest mistakenly (spaces, newlines, etc). Even one byte will cause the process to fail, as the SHA256 (or whatever algorithm you choose) created will change. This content is provided as the `--message` parameter.\\n\\nHere we are sending only the digest to AWS KMS to be signed so we **must** specify the `--message-type DIGEST` and since I am using SHA256 in these examples, so I\'ve asked for the corresponding `signing-algorithm`.\\n\\nFinally, I\'ve used an environment variable injected by [the GitHub action](https://github.com/openziti/desktop-edge-win/blob/release-next/.github/workflows/installer.build.yml#L23) to specify which key is to be used to sign the data (the digest). All this content is then read into the `$signedData` variable and then written to disk as `${exePath}.dig.signed`. This file should be in the same directory as the `.dig` and executable you wish to sign.\\n\\n### Incorporating the Signed Digest\\n\\nThe last step is to use the signed data file produced in the last step, incorporate it into the signature, and attach the signature to the file.\\n\\n```powershell\\n& \\"$SIGNTOOL\\" sign /di $digestLoc $exePath\\n& \\"$SIGNTOOL\\" timestamp /tr \\"http://timestamp.digicert.com\\" /td sha256 $exePath\\n```\\n\\nNotice that to ingest the signed digest into the file you only need to provide the path to the signed digest (and `p7u` file generated in the first step) and the executable itself. When these steps finish, you\'ll have a signed binary!\\n\\n![](/blogs/openziti/v1715626991639/0ca65ace-4ee1-4656-b90d-c745eaba593f.png)\\n\\nIt\'s a good idea to add a timestamp to your signed binary using a Time Stamping Authority (TSA) of your choice. Normally, a digital signature is only considered valid as long as the signing certificate is valid. Once the certificate expires, the signature can no longer be verified. However, if the signature includes a timestamp, it shows that the code was signed while the certificate was still valid, extending the trustworthiness of the signature beyond the certificate\'s expiration date.\\n\\n## Summary\\n\\nUsing EV certificates isn\'t for everyone, it\'s expensive. However, using an EV cert will gain you instant reputation with Defender and for some people, that price is worth it. Even if you\'re not using an EV cert, using AWS KMS to sign your binaries has the added benefit of keeping your private key safer. Yes, you still need to give GitHub credentials to list the key and sign data, but if there\'s a catastrophic bug with GitHub actions, you can feel good that it\'s impossible to extract the key!\\n\\n## Share the Project\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png?auto=compress,format&format=webp)\\n\\nIf you find this interesting, please consider [**starring us on GitHub**](https://github.com/openziti/ziti/). It really does help to support the project! And if you haven\'t seen it yet, check out [**https://zrok.io**](https://github.com/openziti/ziti/). It\'s totally free sharing platform built on OpenZiti! It uses the OpenZiti Go SDK since it\'s a ziti-native application. It\'s also [**all open source too!**](https://github.com/openziti/zrok/)\\n\\nTell us how you\'re using OpenZiti on [**X <s>twitter</s>**](https://twitter.com/openziti), [**reddit**](https://www.reddit.com/r/openziti/), or over at our [**Discourse**](https://openziti.discourse.group/). Or you prefer, check out [**our content on YouTube**](https://youtube.com/openziti) if that\'s more your speed. Regardless of how, we\'d love to hear from you."},{"id":"the-nodejs-zrok-sdk","metadata":{"permalink":"/docs/openziti/blog/the-nodejs-zrok-sdk","source":"@site/blog/the-nodejs-zrok-sdk.md","title":"The NodeJS zrok SDK","description":"You may be familiar with zrok, the open-source solution built on OpenZiti, which makes it very","date":"2024-05-06T20:51:11.000Z","tags":[{"inline":false,"label":"Web Development","permalink":"/docs/openziti/blog/tags/web-development","description":"Web development content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"NodeJS","permalink":"/docs/openziti/blog/tags/nodejs","description":"NodeJS content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":5.39,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"title":"The NodeJS zrok SDK","seoTitle":"The NodeJS zrok SDK","date":"2024-05-06T20:51:11.000Z","cuid":"clvvfsgjz00040ak37yl2b0xf","slug":"the-nodejs-zrok-sdk","authors":["CurtTudor"],"image":"@site/blogs/openziti/v1712869619931/10e487f3-ddb6-4d9e-ab48-0774a3bbfb2a.jpeg","imageDark":"@site/blogs/openziti/v1712869619931/10e487f3-ddb6-4d9e-ab48-0774a3bbfb2a.jpeg","tags":["web-development","security","nodejs","zrok"]},"unlisted":false,"prevItem":{"title":"Signing Executables From GitHub Actions","permalink":"/docs/openziti/blog/signing-executables-from-github-actions"},"nextItem":{"title":"No Listening Ports?","permalink":"/docs/openziti/blog/no-listening-ports"}},"content":"You may be familiar with `zrok`, the open-source solution built on [OpenZiti](https://openziti.io), which makes it very \\neasy to securely share resources over the internet. If you are already a `zrok` fan, that\'s great news -- Thank you for \\nbeing part of our community!\\n\\n\x3c!-- truncate --\x3e\\n\\nIf `zrok` is new to you, please check out this post [**introducing**`zrok`](./introducing-zrok.md).\\n\\n`zrok` is built to enable developers to seamlessly and securely share their applications (we previously released our [`zrok` Golang SDK](./the-zrok-sdk.md), and our [`zrok` Python SDK](./the-python-zrok-sdk)). Using just a little code enables you to share your app through `zrok`\'s robust network.\\n\\nToday we are excited to expand our `zrok` SDK philosophy by introducing a NodeJS SDK (available as of `zrok` `0.4.30`), and that is what we\'ll discuss in this article.\\n\\nThe package is published as [`@openziti/zrok`](https://www.npmjs.com/package/@openziti/zrok)\\n\\nWe will be spinning up a local HTTP server to be served via `zrok`!\\n\\nIf you want to follow along you\'ll need to have a `zrok` environment set up. If you don\'t want to self-host you can sign up for a free account at [**https://zrok.io**](https://zrok.io/).\\n\\nCheck out the [**Getting Started**](https://docs.zrok.io/docs/getting-started/) guide for more information.\\n\\n![File:Node.js logo.svg - Wikipedia](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Node.js_logo.svg/2560px-Node.js_logo.svg.png)\\n\\n## Expanding into NodeJS\\n\\nHere is all it takes to spin up a `zrok`\\\\-enabled web server using Express:\\n\\n```typescript\\nlet root = zrok.Load()\\n\\nawait zrok.init( root ).catch(( err: Error ) => \\n    { console.error(err); return process.exit(1) });\\n\\nlet shr = await zrok.CreateShare(root, \\n    new zrok.ShareRequest(\\n        zrok.PROXY_BACKEND_MODE, zrok.PRIVATE_SHARE_MODE, \\n        \\"http-server\\", [\\"public\\"])\\n);\\nconsole.log(`access remotely using: \'zrok access private ${shr.Token}\'`)\\n\\nlet app = zrok.express( shr.Token );\\n\\napp.get(\'/\', function(_: Request, res: any){\\n  res.write(`Hello zrok!`)\\n  res.end()\\n});\\n\\napp.listen(undefined, () => {\\n  console.log(\\n    `private HTTP Server is now listening for incoming requests`\\n  )\\n})\\n```\\n\\nLet\'s quickly go over what\'s happening here:\\n\\nFirst, we use the `zrok` object to load the root config and initialize, and then we\'re off to the races.\\n\\nWe create a private `zrok` share, and then we call `zrok.express` using the share token we just created.\\n\\nThis `zrok.express` call spins up a NodeJS Express server, ***however***, the Express server is transparently instrumented by the `zrok` SDK (and its embedded [Ziti SDK for NodeJS](./securing-nodejs-applications)) to enable the Express web server to \\"bind\\" (i.e. host) the Ziti Service represented by the `zrok` share.\\n\\nIn other words, the NodeJS Express web server does ***NOT*** listen on an open TCP port as traditional NodeJS Express servers do (*because that\'s way too insecure*).\\n\\nInstead, a `zrok`\\\\-enabled NodeJS Express server listens ***ONLY*** for incoming Ziti connections to the private `zrok` share (*because zero-trust connections are now considered best practice, and this is how the most robust security is done these days*).\\n\\nThe `SIGINT` handler at the end just handles a CTRL-C event, and tears down the `zrok` share.\\n\\nThe above example employs a `private` share. You can opt to use a `public` share if you like; in that case, you can find it [here](./the-zrok-oauth-public-frontend).\\n\\nTo expand this example from here you would simply declare any routes your app wants to expose and it\'s just like producing a typical Express server. No additional complications!\\n\\n## Why **Though**?\\n\\nThe primary reason is we want this to be easy.\\n\\nSharing what you make should be painless. You develop the application -- let `zrok` handle all the security complications.\\n\\nPlus you can deploy your application anywhere. As long as the environment can reach the `zrok` host controller, it can run wherever you want it to.\\n\\nIt can live in a container, cloud-hosted, or even run nicely on a home server, or dev laptop.\\n\\n## Coming Attractions (zrok+BrowZer)\\n\\nSince the above example talks about sharing an Express web server over `zrok`, I would be remiss if I didn\'t mention something exciting we will release soon that will alleviate a few friction points.\\n\\nTo illustrate, today if you want to spin up a web server on your laptop and then [share it privately with someone](https://docs.zrok.io/docs/getting-started/#private-shares), the person you are sharing it with will need to:\\n\\n* download the `zrok` binary, then\\n    \\n* execute a specific `zrok` command (which starts a local HTTP listener), then\\n    \\n* point their browser at that HTTP listener (typically running at `http://127.0.0.1:9191`)\\n    \\n\\nThe above technology certainly works in many scenarios, but there are use cases where it may not...\\n\\nFor example, it\'s possible that the person you are sharing your local web server with is not tech-savvy (e.g. my grandmother) and they can\'t successfully obtain and/or run the `zrok` commands on their client.\\n\\nAnother use case is when the remote person can\'t install new tooling on their machine due to a lack of permission (e.g. IT restrictions). Or they can, but they elect not to.\\n\\nAnother use case is when you want to share your web app with someone who wants to access it on their mobile phone (where `zrok` binaries simply can\'t be installed).\\n\\nThe above use cases could be supported perfectly if only you could share a (*magic*) URL with the people you want to share your private web server with. This is because every laptop and mobile phone already has a ubiquitous web browser, so your friends, family, and colleagues already have what they need...except the URL...\\n\\nSo what\'s this magic URL, and what makes it \\"magic\\"?\\n\\nThe URL you will share with people will resemble this: `https://<SOME_SHARE_TOKEN>/zrok.browzer.cloudziti.io`\\n\\n(`SOME_SHARE_TOKEN` is produced by your `zrok share private` command)\\n\\n[OpenZiti BrowZer provides the magic](./introducing-openziti-browzer.md) that ties everything together. We are currently testing this new `zrok+BrowZer` functionality and we will release it soon.\\n\\nOnce it has been shipped, we will be back here posting articles that discuss all the details, so be sure to subscribe to this blog\'s newsletter so you don\'t miss the announcements.\\n\\n## Moving Forward\\n\\nMoving forward we want `zrok` to be as accessible as possible, both in options and ease of use. Support for more languages is coming! If you want to talk about languages to support or friction points, please reach out on [Discourse](https://openziti.discourse.group/c/zrok/24)!\\n\\n[  \\n](https://openziti.discourse.group/c/zrok/24)Also if you like `zrok` or OpenZiti and want to support it, we would very much appreciate you dropping a star on both [Github (zrok)](https://github.com/openziti/zrok) / [Github (OpenZiti)](https://github.com/openziti/ziti).\\n\\nIt means a lot!"},{"id":"no-listening-ports","metadata":{"permalink":"/docs/openziti/blog/no-listening-ports","source":"@site/blog/no-listening-ports.md","title":"No Listening Ports?","description":"Not too long ago, I authored a post about why Go is Amazing for Zero Trust. In that post, I write about one of OpenZiti\'s superpowers that allows your applications to have no listening ports by integrating an OpenZiti SDK into it. It\'s always interesting writing content that makes perfect sense to you but after you publish it, someone immediately asks a question that\'s so obvious, you wonder how it is you, and everyone that reviewed it missed it. I published that blog post, and the first (well-deserved) response was:","date":"2024-04-26T00:38:15.000Z","tags":[{"inline":false,"label":"AppSec","permalink":"/docs/openziti/blog/tags/appsec","description":"Application security"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Zero Trust Security","permalink":"/docs/openziti/blog/tags/zero-trust-security","description":"Zero Trust Security Topics"}],"readingTime":8.05,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"No Listening Ports?","date":"2024-04-26T00:38:15.000Z","cuid":"clvfy2395000009jr8jb1hy8b","slug":"no-listening-ports","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1702587204755/fa35d4ba-8bea-412b-91be-298e9db9d73b.png","imageDark":"@site/blogs/openziti/v1702587204755/fa35d4ba-8bea-412b-91be-298e9db9d73b.png","tags":["appsec","zerotrust","zero-trust-security"]},"unlisted":false,"prevItem":{"title":"The NodeJS zrok SDK","permalink":"/docs/openziti/blog/the-nodejs-zrok-sdk"},"nextItem":{"title":"Announcing OpenZiti v1.0","permalink":"/docs/openziti/blog/announcing-openziti-v1"}},"content":"Not too long ago, I authored a post about why [Go is Amazing for Zero Trust](./go-is-amazing-for-zero-trust.md). In that post, I write about one of OpenZiti\'s superpowers that allows your applications to have no listening ports by integrating an OpenZiti SDK into it. It\'s always interesting writing content that makes perfect sense to you but after you publish it, someone immediately asks a question that\'s so obvious, you wonder how it is you, and everyone that reviewed it missed it. I published that blog post, and the first (well-deserved) [response was](https://www.reddit.com/r/golang/comments/18hykre/comment/kdb2ftb/?utm_source=reddit&utm_medium=web2x&context=3):\\n\\n\x3c!-- truncate --\x3e\\n\\n![](/blogs/openziti/v1702558877739/79b66b3b-bf99-49eb-88ec-d30ffa66a808.png)\\n\\nThis question is very common because it sounds totally impossible that a server could have no listening ports. It\'s not impossible, and it\'s not something novel; it uses a technique where your clients and servers securely connect to an intermediary server that **does listen** on the IP-based underlay network and brokers the connection. (OpenZiti calls these edge routers)\\n\\nInstead of a classic architecture that looks like this, with an open port in your firewall and a listening port on your network\'s IP-based network:\\n\\n![](/blogs/openziti/v1714093416860/2e64e723-83c0-4e40-b3b3-51b9432128be.png)\\n\\nyou leverage an OpenZiti overlay network where the server and client both dial outbound and connect to the OpenZiti mesh, deployed on the internet.\\n\\n![](/blogs/openziti/v1714092838970/ee29aef7-e29c-461a-bb00-a68ccb2d40e3.png)\\n\\n## Network Programming Overview/Review\\n\\n> *If you\'re a seasoned pro and understand enough about network computing, skip this section.*\\n\\nIf you are not familiar with network programming (and honestly, how many of us **really** are), one of the guides that makes its way around social media routinely is [Beej\'s Guide to Network Programming](https://beej.us/guide/bgnet/html/). It really is a great slice of the internet, and well worth your time. I think it\'s useful to be modestly familiar with network programming in general. We won\'t be diving into the depths of sockets here but that link will teach you an amazing amount about network programming. This post covers, from a high level, how two processes on two different computers can communicate with each other.\\n\\nI don\'t know it for a fact, I just know it\'s true; the vast majority of networking applications written, are written using [\\"Internet Protocol\\" (IP)](https://en.wikipedia.org/wiki/Internet_Protocol). IP is so pervasive and has been so successful every operating system implements it, every programming language has standard library calls for it, and we use it every day. You\'re using it right now, to read this blog post. [HTTP](https://en.wikipedia.org/wiki/HTTP), the way your browser got this post\'s content, is built on [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol). TCP is built on IP.\\n\\nYour browser opened a connection to a server \\"listening\\" somewhere on the open internet. You\'ve seen diagrams like this a million times, it looks something like this:\\n\\n![](/blogs/openziti/v1702561537782/039ce6d7-0a6e-4bd9-9487-6427dc422550.png)\\n\\nSo, what does it mean for the server to be \\"listening\\"? When that server started, it made a system call using whatever language the server was written in. You can start your own server right now if you have [Python](https://www.python.org/) installed. Change to any folder and run: `python3 -m http.server 9000`. Bam! That server just \\"listened\\" on a port. Under the hood, python asked the operating system to create a socket and then \\"bound\\" port 9000 to that socket. If the operating system obliges, a new entry will be tracked by the operating system for your running server.\\n\\nPython, by default, thinks you probably intend to be able to access this server from **any** other computer on your network, so Python used a special IP, `0.0.0.0` when doing the bind. This special IP address means \\"any IP address assigned to any network interfaces on the host\\", not one specific IP address. This allows any network packets that arrive at the computer\'s network interface to be routed to the server we just started. When packets arrive at the computer via any IP assigned to that host, the operating system uses the destination port of the incoming request (9000 in this example) to locate the socket to send the packet to. In this case, network packets are sent to the Python program we just started for processing. This is how you\'re able to navigate to [http://localhost:9000](http://localhost:9000) and see a directory listing of whatever folder you were in when you started the server.\\n\\n![](/blogs/openziti/v1702586347425/27860954-2476-4cf4-a94a-4878dccbfa2e.png)\\n\\n### Network Tooling\\n\\nBut how do we **know** the port is listening? Every operating system provides tooling for inspecting open sockets. One common tool to look at open sockets that ships with most operating systems is [`netstat`](https://en.wikipedia.org/wiki/Netstat) . If you ran the Python, you can now try running `netstat`. Open a shell and type: `netstat -lnt`. You\'ll see something like:\\n\\n![](/blogs/openziti/v1702562979059/1cef7371-7707-4dbb-9798-952b1f923879.png)\\n\\nNotice we have a `LISTEN`ing socket, bound to `0.0.0.0`, on port `:9000`. Cool! Now any tooling that is IP-aware can connect to this server. For example, your browser, `curl` or any tool that is IP-aware (which is pretty much any networking tool).\\n\\n## No Listening Ports\\n\\nOk, with the primer out of the way, usually when I say or write \\"OpenZiti allows your server process to have no listening ports,\\" this is the immediate reaction.\\n\\n![](/blogs/openziti/v1702563443920/8f6d633b-8553-4791-9ec5-b486f6548125.gif)\\n\\nIt\'s normal. I get it. How can there be a connection, if there\'s no listening port? There\'s **definitely** a listening port **somewhere**, right? Surely there must be and it\'s true, there are ports somewhere listening because we live in a world dominated by IP. The question becomes where that listening port is, and where it is **NOT**. When you start a process with an [OpenZiti SDK](https://openziti.io) and instruct that process to \\"bind\\" a service with OpenZiti, you\'re not actually asking the operating system to create a socket and you\'ll also notice there\'s no port needed when \\"binding.\\"\\n\\nInstead of a program binding to a socket with a port, it \\"binds\\" the program to an OpenZiti concept called a terminator. A terminator is a logical representation that informs the OpenZiti mesh network where to send packets. It\'s similar to the idea of the IP tuple of `source address:source port:destination address:destination port` but it\'s a listener on the OpenZiti overlay network, not a socket:port combination on the local machine.\\n\\n> What\'s important is that the server does **not** open a socket on the operating system that is routable to the program. This is the critical point: *There are****no listening sockets/ports****at the IP layer of that operating system.*\\n\\nI\'ve revised the diagram shown above and added the OpenZiti SDK and the OpenZiti overlay components. Here\'s what a server listening on an OpenZiti overlay looks like:\\n\\n![](/blogs/openziti/v1702565484739/9d9bc59d-3a3f-4b31-bb02-406f47562997.png)\\n\\nIt looks remarkably similar to the previous diagram for a good reason; we want the eperience of binding a server to the OpenZiti overlay to feel very similar to binding ports on an IP-based underlay network. Notice the OpenZiti overlay shown above has three routers deployed, all on the internet. **That is where listening ports are located**. There are no listening ports in the private network space and no listening ports on the server. Connecting to the OpenZiti routers requires a strong, cryptographically verifiable identity (X509 certificate, JWT, etc), and all connections in an OpenZiti overlay are always [mutually authenticated](https://en.wikipedia.org/wiki/Mutual_authentication) and connections from a client to a server are always end-to-end encrypted.\\n\\nA server process listening on an OpenZiti overlay network is **unattackable and undiscoverable** through classic IP-based tooling, because there are no open ports to connect to and probe and attack. The only way to attack the process is through the OpenZiti overlay network itself. Getting onto the OpenZiti overlay requires clients to be authenticated using that strong identity but they also need to be **authorized** to send traffic to the HTTP server! Just having a strong identity associated to the overlay network is not enough.\\n\\nThe OpenZiti mesh network is responsible for delivering the packets from an OpenZiti-aware client to the OpenZiti-enabled server, similar to how underlay routers would deliver packets on IP-based networks. Traffic still traverses the underlay network; IP isn\'t removed from the equation. Instead, the traffic is sent via the overlay network, with all the additional security the OpenZiti zero trust overlay network provides. The overlay network itself will have listening ports, but crucially, not your server.\\n\\nSo the next time you see or read, \\"your server has no listening server ports,\\" hopefully, it will make more sense!\\n\\n## Share the Project\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png?auto=compress,format&format=webp)\\n\\nIf you find this interesting, please consider [**starring us on GitHub**](https://github.com/openziti/ziti/). It really does help to support the project! And if you haven\'t seen it yet, check out [**https://zrok.io**](https://github.com/openziti/ziti/). It\'s totally free sharing platform built on OpenZiti! It uses the OpenZiti Go SDK since it\'s a ziti-native application. It\'s also [**all open source too!**](https://github.com/openziti/zrok/)\\n\\nTell us how you\'re using OpenZiti on [**X <s>twitter</s>**](https://twitter.com/openziti), [**reddit**](https://www.reddit.com/r/openziti/), or over at our [**Discourse**](https://openziti.discourse.group/). Or you prefer, check out [**our content on YouTube**](https://youtube.com/openziti) if that\'s more your speed. Regardless of how, we\'d love to hear from you."},{"id":"announcing-openziti-v1","metadata":{"permalink":"/docs/openziti/blog/announcing-openziti-v1","source":"@site/blog/announcing-openziti-v1-0.md","title":"Announcing OpenZiti v1.0","description":"We created\xa0OpenZiti\xa0so that anyone can implement distributed applications over the Internet, incorporating the principles of zero-trust networking for free into almost anything and for any use case.","date":"2024-04-11T01:11:05.000Z","tags":[{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":4.92,"hasTruncateMarker":true,"authors":[{"name":"Dave Hart","title":"Author","url":"https://github.com/smilindave26","imageURL":"https://avatars.githubusercontent.com/smilindave26","key":"DaveHart","page":null}],"frontMatter":{"title":"Announcing OpenZiti v1.0","date":"2024-04-11T01:11:05.000Z","cuid":"cluujmixu000108jlcumufydf","slug":"announcing-openziti-v1","authors":["DaveHart"],"image":"@site/blogs/openziti/v1712766359966/2d5059cd-e7d7-4aa0-bc79-4a428a90710e.png","imageDark":"@site/blogs/openziti/v1712766359966/2d5059cd-e7d7-4aa0-bc79-4a428a90710e.png","tags":["opensource","zerotrust"]},"unlisted":false,"prevItem":{"title":"No Listening Ports?","permalink":"/docs/openziti/blog/no-listening-ports"},"nextItem":{"title":"Pixy Dust For Web Applications","permalink":"/docs/openziti/blog/pixy-dust-for-web-applications-pkce"}},"content":"We created\xa0[OpenZiti](https://openziti.io)\xa0so that anyone can implement distributed applications over the Internet, incorporating the principles of zero-trust networking for free into almost anything and for any use case.\\n\\nWe started the [OpenZiti\xa0 GitHub org](https://github.com/openziti/ziti/) back in May 2020. One of the most common questions we get today is, \\"Why haven\'t you bumped the version to 1.0 yet?\\" It\'s a fair question. OpenZiti boasts a robust feature set and sees widespread use in mission-critical applications, including Fortune 50 environments, with billions of sessions annually.\\n\\nSo, why the long wait? Well, making secure connectivity simple at scale is non-trivial, and we\u2019ve held ourselves to a high standard.\\n\\nWe\u2019ve proved, and our users have proved, that OpenZiti stands up to large-scale production use. But one of the most important things we wanted to do before flipping to v1.0 was show off OpenZiti in action in its most potent use case: as a foundation for what we call \u201cziti-native apps.\u201d These are applications built from the ground up with security, privacy, and resilience designed in.\\n\\n\x3c!-- truncate --\x3e\\n\\nzrok - a peer-to-peer sharing application - is the first ziti-native app we built.\xa0 It\u2019s completely open source, and we\u2019ve made it available as a [free service](https://zrok.io). zrok has been a tremendous success in its own right, but it also serves as a reference application. Check it out on [GitHub](https://github.com/openziti/zrok) to see how we did it and for inspiration on how you could use OpenZiti in your applications.\\n\\nWe\'re excited to announce v1.0. It\'s a milestone marking our commitment to users for system quality, stability, and compatibility throughout major release cycles. It\'s a proven foundation for the next generation of distributed applications featuring security as a first-class design goal.\\n\\n## Background: Some OpenZiti use cases\\n\\nOpenZiti approaches networking from a software perspective. Solutions can \u2018embed\u2019 full mesh, zero trust overlay networks as software for use cases such as:\\n\\n1. Developing next-generation network applications with built-in security, privacy, and reliability, using a clean, modern software-first abstraction. (ala [zrok](https://github.com/openziti/zrok))\\n    \\n2. Remotely manage your software, devices, or machines in security-conscious sites such as OT environments via your own private, high-performance network without requiring your customers to open inbound firewall ports or provide VPN/bastion-type solutions.\\n    \\n3. Enable users or customers to consume private APIs, use private websites, and access private databases without requiring those users or customers to be on the same administrative domain, network, or VPN.\\n    \\n4. Enable operations teams to lock down environments such as Kubernetes.\xa0 For example, kubectl becomes completely \u2018dark\u2019 in an OpenZiti architecture.\\n    \\n\\nThese are just examples, and you can see more [here](https://github.com/openziti/ziti/blob/release-next/ADOPTERS.md). Secure networking is now software you control. You can use it as you wish.\\n\\n## Background: What does OpenZiti provide to enable secure networking as software?\\n\\nOne way to think about OpenZiti is to ask: If I assume the networks I run on are already compromised, how would I design my application?\\n\\nOpenZiti answers with the following:\\n\\n1. **Strong identities** are essential to ensure that all entities on your network are who they claim to be. Validating the identity before allowing it to connect to any protected services is critical. Identities in OpenZiti implement [mutual authentication](https://en.wikipedia.org/wiki/Mutual_authentication) to authenticate both sides of a connection. Logical entities inside the OpenZiti Controller map an X509 certificate to each named identity.\\n    \\n2. **Protection from port scanning**. Port scanning is a common attack vector searching for vulnerabilities.\xa0 A level of darkness and invisibility mitigates against such attacks, leaving no open inbound ports to your endpoints available for attack. Your applications listen on the OpenZiti overlay, not on the open Internet. There is no need to open inbound ports on the firewall protecting your application.\\n    \\n3. A **least privileged access** model to help mitigate against lateral attacks. If an identity is compromised, or a user we chose to trust turns out to be a bad actor, OpenZiti helps limit the damage.\xa0 Access is only allowed to what is needed and when it\u2019s needed.\\n    \\n4. **Continuous authorization:** Sometimes things change, and what was once appropriate access needs to be revoked. OpenZiti supports posture checks and continuously validates them throughout each session.\\n    \\n5. **End-to-end encryption** OpenZiti helps ensure privacy when running over the Internet. Only your endpoints and applications can access your data, regardless of intermediate waypoints across the Internet. In addition to mTLS across each OpenZiti link, end-to-end encryption (ChaCha20-Poly1305) is provided between endpoints.\\n    \\n6. **Visibility** Auditing, compliance, and forensics support are built-in through advanced metrics and logging, helping support the zero-trust ethos of \u201calways verify.\\"\\n    \\n7. **Permissive (Apache v2.0) open source.** OpenZiti is available to everyone, including the top security experts worldwide who can validate our network security and have the option to find issues and help us improve.\\n    \\n8. **Software SDKs, agents, and containers** easily integrate with your applications and networking solutions. The most secure implementations embed the network directly in your code.\\n    \\n\\n## We\u2019re Not Done...\\n\\nFar from it! We continue to evolve OpenZiti, including:\\n\\n* Advancing our core [overlay fabric](https://github.com/orgs/openziti/projects/13t) and [distributed control](https://github.com/orgs/openziti/projects/9)\\n    \\n* Adding [BrowZer](https://github.com/orgs/openziti/projects/21) support for agent-less access to the overlay for web apps\\n    \\n* Continued evolution of the [zrok project](https://github.com/orgs/openziti/projects/16)\\n    \\n* Refreshed tunneling application UIs\\n    \\n* Additional deployment models\\n    \\n* Additional ziti-native apps beyond zrok (more to come very soon!)\\n    \\n\\nAnd more!\\n\\nThank you all, especially those in the community who have helped advance OpenZiti to this point. If you haven\u2019t yet, [try it](https://openziti.io/docs/learn/quickstarts/) and let us know how it goes!\xa0And a star on the [main repo](https://github.com/openziti/ziti) is always appreciated."},{"id":"pixy-dust-for-web-applications-pkce","metadata":{"permalink":"/docs/openziti/blog/pixy-dust-for-web-applications-pkce","source":"@site/blog/pixy-dust-for-web-applications.md","title":"Pixy Dust For Web Applications","description":"PKCE, which stands for \u201cProof of Key Code Exchange\u201d, and is pronounced \u201cpixy,\u201d is an extension of the OAuth 2.0 protocol that provides an additional security layer helping to prevent intercept attacks.","date":"2024-04-04T16:38:22.000Z","tags":[{"inline":false,"label":"Web","permalink":"/docs/openziti/blog/tags/web","description":"Web content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"PKCE","permalink":"/docs/openziti/blog/tags/pkce","description":"OAuth PKCE flow"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Ziti","permalink":"/docs/openziti/blog/tags/ziti","description":"Ziti related posts"}],"readingTime":10.07,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"title":"Pixy Dust For Web Applications","seoTitle":"Pixy Dust For Web Applications (PKCE)","seoDescription":"What is PKCE, and how does it enhance web app security? Read how OpenZiti BrowZer will automatically provide it for you.","date":"2024-04-04T16:38:22.000Z","cuid":"clulgo2ea000109lc1lnq3tkx","slug":"pixy-dust-for-web-applications-pkce","authors":["CurtTudor"],"image":"@site/blogs/openziti/v1707662249548/d6905ce3-a16a-4e08-8d81-5055a3da8bef.jpeg","imageDark":"@site/blogs/openziti/v1707662249548/d6905ce3-a16a-4e08-8d81-5055a3da8bef.jpeg","tags":["web","security","pkce","zerotrust","ziti"]},"unlisted":false,"prevItem":{"title":"Announcing OpenZiti v1.0","permalink":"/docs/openziti/blog/announcing-openziti-v1"},"nextItem":{"title":"Secure Remote Development with zrok and JetBrains","permalink":"/docs/openziti/blog/secure-remote-development-with-zrok-and-jetbrains"}},"content":"[PKCE](https://datatracker.ietf.org/doc/html/rfc7636), which stands for \u201c**P**roof of **K**ey **C**ode **E**xchange\u201d, and is pronounced \u201c***pixy***,\u201d is an extension of the OAuth 2.0 protocol that provides an additional security layer helping to prevent intercept attacks.\\n\\nArticles about [OpenZiti](https://openziti.io/) often discuss application and network security, and this article will follow that trend.\\n\\n\x3c!-- truncate --\x3e\\n\\nHere I discuss how PKCE enhances the security of authorization code grant flows used in web applications. I will explore some benefits, best practices, and challenges of working with PKCE.\\n\\nPerhaps best of all, I will also highlight how OpenZiti [BrowZer](./introducing-openziti-browzer.md) automatically brings you the power of PKCE... and how BrowZer facilitates an easy way to put a web-based cloak of invisibility around your application, further protecting it from malicious threat actors.\\n\\n## Auth code grant flow security vulnerabilities\\n\\nBefore we discuss how PKCE works, let\'s first describe vulnerabilities that can be exploited in the authorization code grant flow.\\n\\nWhen an authorization request is made, the authorization code grant type requires the authorization server (your preferred [IDP](https://en.wikipedia.org/wiki/Identity_provider)) to generate an authorization code, which is returned to the client application via a redirect URL. This code can then be exchanged for an access token, which can be used to access the user\u2019s data.\\n\\nAn attacker can potentially intercept the authorization code that is sent back to the client and exchange it for an access token, which can cause serious data leaks or breaches.\\n\\nOne popular method malicious actors use to intercept authorization codes is by registering a malicious application on the user\u2019s device (e.g. a browser extension). This malicious application will register and use the same custom URL scheme as the client application, allowing it to intercept redirect URLs on that URL scheme and extract the authorization code:\\n\\n![](/blogs/openziti/v1707663725015/8e0798d9-2992-493b-9d28-34bcf57da8e8.png)\\n\\n## How does PKCE work?\\n\\nPKCE addresses the above vulnerability by introducing a new flow and three new parameters:\\n\\n* `code verifier`\\n    \\n* `code challenge`\\n    \\n* `code challenge method`\\n    \\n\\nBefore an authorization request is made, the client creates and stores a secret called the `code verifier`. The `code verifier` is a cryptographically random string that the client uses to identify itself when exchanging an authorization code for an access token. It has a minimum length of 43 characters and a maximum length of 128 characters.\\n\\nThe client also generates a `code challenge`, which is a transformation of the `code verifier`. The `code challenge` is sent with the initial authorization request, along with a `code challenge method`. The `code challenge method` is the transformation mode used to generate the `code challenge`.\\n\\nThere are two code challenge methods that PKCE supports: `plain` and `S256`.\\n\\n* `plain`**:**  \\n    In `plain` mode, the code challenge is equal to the code verifier; nothing changes.\\n    \\n* `S256`**:**  \\n    In `S256` mode, the SHA-256 hash of the code verifier is encoded using the BASE64URL encoding. The `S256` method is recommended by the specification and much preferred over the `plain` method.\\n    \\n\\nNext, the `code challenge` is securely stored by the IDP, and an authorization code is returned with the redirect URL as usual.\\n\\nWhen the client wants to exchange this authorization code for the access token, it sends a request that includes the initial `code verifier`. The server then hashes the `code verifier` using SHA-256 (*if it supports a*`code challenge methodS256`) and encodes the hashed value as a BASE64URL. The corresponding value is then compared to the `code challenge`. If they match, an access token is issued. Otherwise, an error message is returned.\\n\\nThis flow ensures that a malicious third party cannot exchange an authorization code for an access token, since the malicious application ***does not have the code verifier***.\\n\\nIntercepting the `code challenge` is also useless because SHA256 is a one-way hashing algorithm and cannot be decrypted.\\n\\nThe following diagram represents the PKCE protocol flow:\\n\\n![](/blogs/openziti/v1707664593271/95f591a4-717d-4626-a880-94e5a0657219.png)\\n\\n## PKCE Benefits\\n\\nPKCE offers many security benefits that have made it a widely adopted standard among developers that implement OAuth 2.0. These benefits include:\\n\\n* **Eradication of code interception attacks:**  \\n    Without PKCE, an attacker who intercepts the authorization code can potentially exchange it for an access token. PKCE prevents this attack method by requiring a `code verifier` with every exchange, ensuring that only the original client that started the flow can obtain the token.\\n    \\n* **Backward compatibility:**  \\n    PKCE can be used with any IdP that supports it, while still being compatible with servers that do not. This is because PKCE is simply an extension of OAuth.\\n    \\n* **Standardization and wide adoption:**  \\n    PKCE has seen wide adoption, especially on mobile and [SPA\'s](https://en.wikipedia.org/wiki/Single-page_application), due to its tremendous security benefits.\\n    \\n* **Dynamic secrets:**  \\n    PKCE uses a dynamic secret that\u2019s generated for each authorization request, which reduces the risk associated with a compromised client secret.\\n    \\n\\n## PKCE Best Practices\\n\\nIf you are implementing a PKCE protocol flow, you should adhere to the following best practices to ensure that your application is properly secured:\\n\\n* **Generate unique code verifiers:**  \\n    Each authorization request should contain a unique and dynamically generated `code verifier`. Always generating a new `code verifier` helps ensure that the `code challenge` is not predictable and helps prevent [replay attacks](https://en.wikipedia.org/wiki/Replay_attack).\\n    \\n    <mark>OpenZiti BrowZer always generates a dynamic/unique </mark> `code verifier` <mark> for you automatically.</mark>\\n    \\n* **Use high-entropy code verifiers:**  \\n    A `code verifier` should be generated using a cryptographically secure random generator, making it impossible to guess. It should have a minimum length of 43 characters and a maximum length of 128 characters.\\n    \\n    <mark>OpenZiti BrowZer uses a cryptographically strong random number generator to generate 32 random bytes and then encodes them to produce a 110-character </mark> `code verifier` <mark> for you automatically.</mark>\\n    \\n* **Use SHA-256 hashing:**  \\n    The `plaincode challenge method` should *only* be used if the client is unable to support the `S256` method. `S256` is a one-way hash, which further ensures that ***only*** the client that has the `code verifier` can exchange an authorization code for an access token.\\n    \\n    <mark>OpenZiti BrowZer implements </mark> `S256` <mark> code challenges for you automatically.</mark>\\n    \\n* **Implement time limits:** A `code verifier` and the transformed `code challenge` should have a short lifespan, which prevents them from being reused repeatedly.\\n    \\n    <mark>OpenZiti BrowZer implements unique, per-auth-attempt, ephemeral auth flows, and no security-related data is stored outside of session storage. The data only exists in session storage during the PKCE protocol flow (</mark>*<mark>typically less than one second</mark>*<mark>).</mark>\\n    \\n\\n## PKCE Implementation Challenges\\n\\nPKCE offers numerous benefits, but it still presents many challenges you should note if you attempt to implement it. These challenges include:\\n\\n* **Algorithm compatibility:**  \\n    Different IDPs might support different hash algorithms for transforming a `code verifier` into a `code challenge`. This can make it difficult to ensure compatibility across different components.\\n    \\n    <mark>OpenZiti BrowZer manages this automatically (</mark>*<mark>and is compatible with many IDPs</mark>*<mark>).</mark>\\n    \\n* **Complexity:**  \\n    To be done correctly, PKCE certainly introduces additional complexity to the authorization code flow implementation. You must manage `code verifier` and `code challenge` data correctly as well as handle their transformations and comparisons securely.\\n    \\n    <mark>OpenZiti BrowZer manages this for you automatically.</mark>\\n    \\n* **Code verifier storage:**  \\n    PKCE requires the client to store the original `code verifier` until the authorization code is exchanged later in the protocol flow. Ensuring secure storage and retrieval of the `code verifier` can be challenging, especially for public clients (which all web browsers are).\\n    \\n    <mark>OpenZiti BrowZer manages this for you automatically (</mark>*<mark>in short-lived session storage</mark>*<mark>).</mark>\\n    \\n* **Security misconfiguration:**  \\n    Implementing PKCE incorrectly or failing to properly validate your `code challenge` will introduce the risk of security vulnerabilities. For instance, if the `code challenge` is not validated, attackers can forge counterfeit challenges and bypass security measures.\\n    \\n    <mark>OpenZiti BrowZer manages the </mark> `code challenge` <mark> data for you automatically.</mark>\\n    \\n* **Risk of overconfidence:**  \\n    While PKCE provides a strong security layer, it doesn\u2019t eliminate the need for other security measures, such as secure communication (HTTPS), and proper access control.\\n    \\n    Relying solely on PKCE alone can lead to security gaps.\\n    \\n    <mark>In addition to </mark> ***<mark>everything</mark>*** <mark> discussed above, OpenZiti BrowZer allows you to make your web application </mark> ***<mark>completely invisible to threat actors</mark>*** <mark> while still giving your authorized users easy access.</mark>\\n    \\n    <mark>Authorized users who succeed with PKCE-based access to the overlay network that hosts your web app will also enjoy end-to-end encryption (</mark>**<mark>xchacha20poly1305</mark>**<mark>) of all data that transits between the browser and the web server, even before the data hits the wire. Once on the wire, the data will also have two more layers of encryption.</mark>\\n    \\n\\n# **The Web *Cloak of Invisibility***\\n\\nThe tie-in between OpenZiti BrowZer and PKCE is how this kind of authorization flow is used to enable your authorized users (who exist out on the internet) to simply use a browser, and a couple of clicks, to gain visibility, and access, to a web application that is otherwise **completely invisible** to everyone else (notably, malicious actors).\\n\\nYou may recall that [BrowZer\'s zero-trust capabilities](./introducing-openziti-browzer.md#authentication-in-a-browzer-environment) enforce an \\"*authenticate before connect*\\" flow. Users of your web app must first perform a successful **single sign-on** (SSO) that provides a strong assertion of the user\'s identity.\\n\\nThe Identity Provider (IDP) you associate with your network is up to you. It could be a cloud-based instance of AzureAD, Okta, or Auth0 (and these IDPs could even federate out to Google, GitHub, or dozens of other providers)...\\n\\n![image.png](/blogs/openziti/v1662733522760/XoZApNB43.png)\\n\\n...Alternatively, you can also self-host an open-source IDP instance of Keycloak, Authentik, ...whatever. If the IDP is OIDC-compliant, browZer will work with it.\\n\\nBrowZer will automatically use all the PKCE mechanisms discussed earlier in this article when interacting with your IDP. You don\'t need to modify your web app in any way.\\n\\nWhen the PKCE flow completes, the IDP delivers the access token, and BrowZer stores it locally in the browser\'s session storage.\\n\\ne.g.:\\n\\n![](/blogs/openziti/v1712246242470/0217910c-ed58-4963-a7b3-f76b1811ba30.png)\\n\\nThis access token is subsequently used to authenticate the user onto the Ziti Overlay network where your web app resides.\\n\\nNote that although the user may have successfully authenticated with the IDP, the user represented by the IDP access token must *still* be known by the Ziti network.\\n\\nIf the user is not known by the Ziti network, the network authentication attempt will be rejected, and no access to the protected web app will occur.\\n\\n\\"Authenticate before connect\\" literally means that a successful network authentication must occur before any web app connect attempts can succeed. If the Ziti network doesn\'t know who you are, the web app is invisible to you.\\n\\n### Secure handling of the Access Token\\n\\nFor security reasons, the IDP access token is ***never*** persisted by BrowZer. The access token never leaves the browser\'s memory and is thus *ephemeral*.\\n\\nThe instant the browser Tab is closed, all session storage is purged by the browser, and the access token is gone forever. This makes the access token more secure and unavailable to bad actors who might somehow gain access to the user\'s laptop or mobile phone.\\n\\nAccess tokens also have an expiration time that IDP admins can configure to their preference (an hour, a day, etc). So even in the rare case where a user left a browser Tab open, and then somehow lost their device, the access token would eventually expire, BrowZer would detect this, and Ziti network access would immediately end.\\n\\n# Wrap up\\n\\nDo you host a web app and want to be invisible to malicious intruders?\\n\\nDo you want your users to have easy access from anywhere with no additional software on their client devices?\\n\\nDo you want to do all this without making any modifications to your web app?\\n\\nIf you are nodding yes, then we hope you\'ll [start a conversation with us about BrowZe](https://openziti.discourse.group/)r."},{"id":"secure-remote-development-with-zrok-and-jetbrains","metadata":{"permalink":"/docs/openziti/blog/secure-remote-development-with-zrok-and-jetbrains","source":"@site/blog/secure-remote-development-with-zrok-and-jetbrains.md","title":"Secure Remote Development with zrok and JetBrains","description":"I took this photo while working remote. Can you guess the location?If you can secure your remote work, you, too, can work anywhere.","date":"2024-04-01T13:14:45.000Z","tags":[{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":9.05,"hasTruncateMarker":true,"authors":[{"name":"Russell Allen","title":"Author","url":"https://github.com/Russell-Allen","imageURL":"https://avatars.githubusercontent.com/Russell-Allen","key":"RussellAllen","page":null}],"frontMatter":{"title":"Secure Remote Development with zrok and JetBrains","seoTitle":"Secure JetBrains Remote Development with zrok","seoDescription":"Step by step instructions using zrok to secure ssh access to your home workstation for remote development with a JetBrains IDE.","date":"2024-04-01T13:14:45.000Z","cuid":"clugz2njn000008l5e2nv3w3a","slug":"secure-remote-development-with-zrok-and-jetbrains","authors":["RussellAllen"],"image":"@site/blogs/openziti/v1711649779549/c013ad52-1fb9-4943-9d47-3b65d4a12c03.png","imageDark":"@site/blogs/openziti/v1711649779549/c013ad52-1fb9-4943-9d47-3b65d4a12c03.png","tags":["zrok"]},"unlisted":false,"prevItem":{"title":"Pixy Dust For Web Applications","permalink":"/docs/openziti/blog/pixy-dust-for-web-applications-pkce"},"nextItem":{"title":"zrok Permission Modes","permalink":"/docs/openziti/blog/zrok-permission-modes"}},"content":"![](/blogs/openziti/v1711594239215/cf4f8574-25e1-4c7f-8f0d-54496b93f579.jpeg)\\n\\n<center>I took this photo while working remote. Can you guess the location?<br />If you can secure your remote work, you, too, can work anywhere.</center>\\n\\nI love working remotely, and sometimes, \u2018remote\u2019 is truly out there. I\u2019ve worked from faraway islands and foreign countries to your local coffee shop and campground. Regardless of where I\u2019m at, I need one thing in particular: a secure connection to my workstation and development environment at home.\\n\\n\x3c!-- truncate --\x3e\\n\\nGetting connected is easy. There\u2019s open internet access just about everywhere I go, and when there\u2019s not, I can point a Starlink terminal towards the sky. The less obvious but tremendously important part is securing that connection. Can you imagine the personal and professional harm it would cause if I took this work-from-anywhere privilege for granted and I was the engineer whose access was used to compromise my employer or our clients? That\u2019s nightmare fuel.\\n\\nFortunately, a set of easy-to-use tools allows me to gallivant around the world and remain confident in my connection and its security. Namely,\xa0[zrok.io](http://zrok.io/)\xa0and JetBrains\xa0[remote development](https://www.jetbrains.com/remote-development/).\\n\\n![](/blogs/openziti/v1711650045396/40aad101-90ed-4d21-8a67-2178b6a43a22.png)\\n\\nI combine these tools to ensure I can always connect securely from my laptop to my development workstation at home without an open port on my home network, a static IP, or a domain name to call back to. My home network\xa0*does not listen*\xa0for connections from the Internet and\xa0*is dark*.\\n\\n[zrok.io](http://zrok.io/) \xa0makes that possible by dialing out from my workstation and registering a \u201cprivate share\u201d on a hidden zero-trust network overlay. That may sound like word salad, but the gist is this: There is a software-level network out there that you can\u2019t talk to unless you authenticate first. Without the correct certificate, it simply ignores your TCP packets. My home workstation and laptop are pre-authenticated with certificates allowing them to talk to each other over this hidden zero-trust network (*which, BTW, also applies end-to-end encryption.*) If you\u2019re curious to learn more, I encourage you to contact the\xa0[OpenZiti team](https://openziti.io/)\xa0that created the network or\xa0[NetFoundry.io](http://netfoundry.io/) for B2B inquiries.\\n\\nIf, on the other hand, you just want to secure your remote development before your next adventure, I have you covered. Here are three easy steps to do it.\\n\\n## Step 1 - zrok Install & Setup\\n\\n[Install the zrok command](https://docs.zrok.io/docs/getting-started/#installing-the-zrok-command)\xa0onto each device that you want to be able to connect to or from.\\n\\nThere are installers for Windows, Linux, and Mac, and they all result in a single new command: `zrok`\\n\\n[Get invited](https://docs.zrok.io/docs/getting-started/#generating-an-invitation)\xa0to the hidden network. It may sound glamorous, but it\u2019s actually easy. From any one of your devices, run: `zrok invite`\\n\\nIt will ask you to enter your email address, and then you will receive an email to activate your account. Click the link in the email, set a password, and you are now logged into the zrok web portal, from which you can control your private corner of the hidden zero-trust network overlay.\\n\\n[Register your devices](https://docs.zrok.io/docs/getting-started/#enabling-your-zrok-environment). Remember how I said my home workstation and laptop were pre-authenticated with certificates to talk to the hidden zero-trust network? This is how that happens, and it\u2019s dead simple.\\n\\nSelect \u201cEnable Your Environment\u201d from your account menu (click your email address) on the zrok web portal. The portal will display a zrok command like `zrok enable l2Ndsa92r7j3`, which you must copy and run on one of your devices. Repeat this process of generating and running the command for each device you intend to use.\\n\\n## Step 2 - Sharing is Caring\\n\\nNow that your devices are registered, you must create a \u201cshare\u201d on the device hosting your project files. Execute the following in a terminal on that device:\\n\\n`zrok reserve private --backend-mode tcpTunnel 127.0.0.1:22`\\n\\nThis tells zrok that you intend to expose a TCP tunnel to local port 22, which you may recognize as the common ssh port and is what JetBrains uses for remote development.\\n\\nThe reserve command will output a \u201cshare token\u201d, like this: `your reserved share token is \'5adagwfl888k\'`. Write this token value down. You will use it whenever you need to start, stop, or connect to this share.\\n\\nNext, start the share on the device hosting your project files with the following command:\\n\\n`zrok share reserved 5adagwfl888k`*(replace*`5adagwfl888k`*with your token)*\\n\\nThis starts the share as a foreground process. You can stop it by pressing `ctrl-c`, and restart it by running the command again. It\'s ephemeral; easy to create, destroy, and repeat.\\n\\nOn your roaming device, where you intend to run your IDE front-end, run the zrok access command with your share token:\\n\\n`zrok access private 5adagwfl888k`*(replace*`5adagwfl888k`*with your token)*\\n\\nJust like the sharing (hosting) side, this creates a foreground process that you can `ctrl-c` to stop and which can be rerun at will to reconnect.\\n\\nBoth the share and access side display information about the connection, including connection setup details in case you\u2019ve forgotten the commands. On your roaming device where the `zrok access` command is running, it will print a local url where the tunnel is listening, like: `tcp://127.0.0.1:9191 -> 5adagwfl888k` We\'ll use that in our JetBrains IDE during the next and final step.\\n\\n## Step 3 - JetBrains Remote Development\\n\\n[JetBrains](https://jetbrains.com) support for [remote development](https://jetbrains.com/remote-development/) is one of those features that you don\u2019t realize how much you need until you start using it. And to JetBrains\u2019 credit, it is intuitive and easy to set up no matter how you plan to structure it. Take my advice and just try it first; don\u2019t worry about which software runs where, if you need a JetBrains gateway, or anything else. Just start this way, and you can adjust from there.\\n\\nThe following assumes your project files are on the \u201chosting\u201d device and that you want to run your JetBrains IDE as a front-end on your \u201cremote\u201d device. I\u2019ll also assume you have installed a copy of your JetBrains IDE on both devices.\\n\\nStart your IDE on the remote device. If it opens straight into an existing local project, that\u2019s okay; select `Remote Development` from the `File` menu. Either way, you should see a dialog similar to these:\\n\\n![](/blogs/openziti/v1711597369268/a1cdc724-1b4c-447e-825c-5c5aca08029a.png)\\n\\nUnder SSH, click to create a new connection or a new project. You will be prompted for a username, host, and port.\\n\\n![](/blogs/openziti/v1711597438003/6b05aa72-afef-4b21-a3da-fcf7123870e7.png)\\n\\nFor the host IP and Port, enter the values from the local zrok access, which is shown at the top of the terminal window while it is running. In my case, that URL is shown as `tcp://127.0.0.1:9191`, so I\'ve entered the Host as `127.0.0.1` and the Port as `9191`. This tells JetBrains to talk to the local zrok tunnel as if it were the remote SSH host.\\n\\nClick \u201cCheck Connection and Continue\u201d and after a minute of setup, you\u2019ll be prompted to select a project to open.\\n\\n![](/blogs/openziti/v1711597557843/e073a36b-ba4c-4628-a4de-76dbce900613.png)\\n\\nThe project directory you choose from is on the remote hosting device where, as the name implies, you are hosting your project files. Select the root directory of an existing project and click the Start IDE and Connect button.\\n\\nAnd BAM! You are now in your familiar IDE in the project you love to work on, yet all the working files remain on the remote workstation. Edits, building, and running all happen on the remote workstation. You can even open a shell on the remote workstation with a click of a button.\\n\\nWhen you start your IDE in the future, JetBrains will remember and offer all the remote projects you\u2019ve connected to in the past, saving you from repeating the connection setup.\\n\\n![](/blogs/openziti/v1711597634947/bcd07285-2c28-47ca-92e4-0f82a7a7ad0b.png)\\n\\nA single click on the project launches the IDE for that project. Clicking the terminal icon at the top right opens a terminal on the remote machine. Clicking the + icon allows you to add new projects to the remote host from this device.\\n\\n---\\n\\nJetBrains has made it easy to work on projects remotely, whether because of project size, securing the source, or any number of other reasons. With remote development, it\'s possible to separate the IDE front-end from the back-end that manages project files, builds, commits, etc.\\n\\nzrok has made it easy to extend that remote link wherever needed and, critically, to do so securely. My employer, like most, dictates how I obtain and maintain secure access to code and services. However, if I extend that access so that I can work from anywhere, I become responsible for securing that extension. zrok solves that by providing a transient, encrypted, zero-trust tunnel that I can spin up and tear down in seconds.\\n\\n---\\n\\nI\'ve skimmed over a lot of technical details in this blog, instead focusing on how easy (and important) it is to secure a JetBrains [remote development](https://www.jetbrains.com/remote-development/) connection using zrok. However, if you\'re more than just a casual user and want to understand how and why this works, I invite you to explore the underlying technologies by following the links below.\\n\\nzrok is an [open-source](https://github.com/openziti/zrok) sharing solution, and [zrok.io](https://zrok.io/) is a managed cloud instance with a free tier ideally suited for this personal remote development use case.\\n\\nzrok.io manages an [open-source](https://github.com/openziti) zero-trust network built on [OpenZiti](https://openziti.io/). An OpenZiti network requires authentication before connection, and it extends the secure edge into the software, into the `zrok` command running on your devices. These are tenants of zero-trust networking, a network security best practice [mandated by the US government](https://www.whitehouse.gov/wp-content/uploads/2022/01/M-22-09.pdf).\\n\\nAll of this goodness is brought to us by [NetFoundry](https://netfoundry.io/), of whom I am a zitizen. I help build NetFoundry\'s managed network platform so that other businesses can enjoy all the benefits of a secure software-defined zero-trust network without the hassle of managing it.\\n\\nI speak for all of us when I say, please contact us if you have questions. And if you want to say how cool this stuff is, please smash that like button, or is it a star? Ok, I admit it, I\'m new to social media. But I know it means a lot to the team to hear and see your support. A star on the [zrok repo](https://github.com/openziti/zrok) is especially appreciated."},{"id":"zrok-permission-modes","metadata":{"permalink":"/docs/openziti/blog/zrok-permission-modes","source":"@site/blog/zrok-permission-modes.md","title":"zrok Permission Modes","description":"zrok is a powerful platform for sharing. The latest releases of zrok allow you to get granular about which other","date":"2024-03-28T15:38:17.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"Permissions","permalink":"/docs/openziti/blog/tags/permissions","description":"Permission management"},{"inline":false,"label":"Access Control","permalink":"/docs/openziti/blog/tags/access-control","description":"Access control"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":2.95,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"zrok Permission Modes","date":"2024-03-28T15:38:17.000Z","cuid":"clubeftvl000208jtghim4481","slug":"zrok-permission-modes","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1710955657342/eeab3265-3689-45b5-983b-83b06ee7fdb7.png","imageDark":"@site/blogs/openziti/v1710955657342/eeab3265-3689-45b5-983b-83b06ee7fdb7.png","tags":["security","networking","permissions","access-control","zrok"]},"unlisted":false,"prevItem":{"title":"Secure Remote Development with zrok and JetBrains","permalink":"/docs/openziti/blog/secure-remote-development-with-zrok-and-jetbrains"},"nextItem":{"title":"The zrok SOCKS Backend","permalink":"/docs/openziti/blog/the-zrok-socks-backend"}},"content":"zrok is a powerful platform for sharing. The latest releases of zrok allow you to get granular about which other \\nzrok accounts are allowed to privately access your shares.\\n\\n\x3c!-- truncate --\x3e\\n\\nIn all current zrok versions, the `zrok share private` command will allocate an ephemeral share. The allocated share is accessible by any user on that zrok service instance (zrok.io, for example) as long as they know the share token. This model is now referred to as the \\"open permission mode\\". This will remain the default behavior for a while still (probably until the `v0.5` release of zrok).\\n\\nAs of `v0.4.26`, zrok provides a `--closed` option to the `zrok share` (and `zrok reserve`) commands, which by default restricts access to the share to only environments owned by the zrok account that created the share. We call this the \\"closed permission mode\\".\\n\\nAlong with `--closed`, the `zrok share` and `zrok reserve` commands include a `--access-grant` option, which allows you to specify which additional zrok accounts are allowed to access the share. For example:\\n\\n```plaintext\\n# allocate a closed, private, ephemeral share\\n$ zrok share private --closed --backend-mode web /home/public_html\\n\\n# allocate a closed, private, reserved share\\n$ zrok reserve --closed --backend-mode web --unique-name public \\\\\\n    /home/public_html\\n\\n# allocate a closed, private, ephemeral share granting access to \\n# additional users\\n\\n$ zrok share private --closed --access-grant user@somewhere.com \\\\\\n    --access-grant anotheruser@somewhereelse.com --backend-mode web \\\\\\n    /home/public_html\\n```\\n\\nThe closed permission mode allows you to control which users are allowed to access your shares using `zrok access private`. This applies to both public and private shares. When you create a public share, it is *also* a private share and can be accessed using `zrok access private`.\\n\\nIf you happen to create a share (ephemeral or reserved) and you need to either add or remove users to the grant list, you can use the new `zrok modify share` command:\\n\\n```plaintext\\n# add additional users to a share\\n$ zrok modify share --add-access-grant user2@zrok.io \\\\\\n    --add-access-grant user3@zrok.io \\\\\\n    4qzdf22h67qn\\n\\n# remove a user from a share\\n$ zrok modify share --remove-access-grant user@somewhere.com \\\\\\n    4qzdf22h67qn\\n```\\n\\nKeep in mind that for now, `--remove-access-grant` does not *terminate* any established `zrok access private` listeners, it just prevents the user from creating new listeners. This behavior will be updated in a future release.\\n\\nIf you\'d like to see a video tour of these features, I did a [zrok Office Hours](https://www.youtube.com/playlist?list=PLMUj_5fklasLuM6XiCNqwAFBuZD1t2lO2) video on it a few weeks ago:\\n\\n%[https://www.youtube.com/watch?v=xQ2uHxuaAb0&pp=ygUdenJvayBvZmZpY2UgaG91cnMgcGVybWlzc2lvbnM%3D] \\n\\nThis is just a preview of the permission mode functionality to come. You might notice that there isn\'t currently a way to *list* the access grants on a share. We wanted to get the basic closed permission mode out in the wild as quickly as possible, and improving the user experience around share metadata (including the access grants) is a little bit of a bigger job. It\'s coming. We suspect that simply adding `--closed` to a `zrok share` or `zrok reserve` command is probably what most users are looking for.now\\n\\nIf you run into any issues or need assistance, feel free to reach out on the the [OpenZiti Discourse](https://openziti.discourse.group/c/zrok/24). There\'s a great community there to help you.\\n\\nIt always means a lot to the folks working on zrok when you\'re take a minute to drop a star on the [zrok\'s GitHub repository](https://github.com/openziti/zrok). It helps us to know that the work we\'re doing on zrok is important to you."},{"id":"the-zrok-socks-backend","metadata":{"permalink":"/docs/openziti/blog/the-zrok-socks-backend","source":"@site/blog/the-zrok-socks-backend.md","title":"The zrok SOCKS Backend","description":"zrok provides a number of powerful tools for sharing private resources.","date":"2024-03-20T15:26:19.000Z","tags":[{"inline":false,"label":"Privacy","permalink":"/docs/openziti/blog/tags/privacy","description":"Privacy related"},{"inline":false,"label":"Internet","permalink":"/docs/openziti/blog/tags/internet","description":"Internet related"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"Geolocation","permalink":"/docs/openziti/blog/tags/geolocation","description":"Geolocation topics"},{"inline":false,"label":"Secure","permalink":"/docs/openziti/blog/tags/secure","description":"Security enhancements"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":4.76,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"The zrok SOCKS Backend","date":"2024-03-20T15:26:19.000Z","cuid":"cltzyhmeo000408l66jxqc3do","slug":"the-zrok-socks-backend","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1710175565287/a8245615-e2da-4e08-a8d8-494cc919ff40.png","imageDark":"@site/blogs/openziti/v1710175565287/a8245615-e2da-4e08-a8d8-494cc919ff40.png","tags":["privacy","internet","networking","geolocation","secure","zrok"]},"unlisted":false,"prevItem":{"title":"zrok Permission Modes","permalink":"/docs/openziti/blog/zrok-permission-modes"},"nextItem":{"title":"The Python zrok SDK","permalink":"/docs/openziti/blog/the-python-zrok-sdk"}},"content":"zrok provides a number of powerful tools for [sharing private resources](https://docs.zrok.io/docs/getting-started). \\nIn addition to our multiple flavors of proxy support, web hosting, low level TCP and UDP sharing, and network drives \\nsupport, zrok now includes the ability to hide or alter your IP address.\\n\\n\x3c!-- truncate --\x3e\\n\\nzrok facilitates this type of privacy by layering on another type of tunneling callled SOCKS. SOCKS is a protocol that was developed in the mid-1990\'s, and according to Wikipedia \\"is a de facto standard for circuit-level gateways (level 5 gateways).\\"\\n\\n> The circuit/session level nature of SOCKS make it a versatile tool in forwarding any TCP (or UDP since SOCKS5) traffic, creating an interface for all types of routing tools. It can be used as:\\n> \\n> * A circumvention tool, allowing traffic to bypass Internet filtering to access content otherwise blocked, e.g., by governments, workplaces, schools, and country-specific web services.[<sup>[13]</sup>](https://en.wikipedia.org/wiki/SOCKS#cite_note-13) Since SOCKS is very detectable, a common approach is to present a SOCKS interface for more sophisticated protocols:\\n>     \\n>     * The [Tor](https://en.wikipedia.org/wiki/Tor_(anonymity_network)) onion proxy software presents a SOCKS interface to its clients.[<sup>[14]</sup>](https://en.wikipedia.org/wiki/SOCKS#cite_note-14)\\n>         \\n> * Providing similar functionality to a [virtual private network](https://en.wikipedia.org/wiki/Virtual_private_network), allowing connections to be forwarded to a server\'s \\"local\\" network:\\n>     \\n>     * Some SSH suites, such as [OpenSSH](https://en.wikipedia.org/wiki/OpenSSH), support dynamic port forwarding that allows the user to create a local SOCKS proxy.[<sup>[15]</sup>](https://en.wikipedia.org/wiki/SOCKS#cite_note-15) This can free the user from the limitations of connecting only to a predefined remote port and server.\\n>         \\n\\nThe zrok implementation of SOCKS (v5) allows you to split the sharing and access portions of the SOCKS tunnel between two different zrok environments. This means you can run a `zrok share` on a host in the cloud, or in some other location on the planet, and then use that share as a secure tunnel, allowing you to access the internet from that location.\\n\\nIn practice, it looks like this:\\n\\n![](/blogs/openziti/v1710945991755/f045989c-aed6-4840-8f37-f55adb84c4bf.png)\\n\\nIf the environment running the `zrok share private -b socks` were running on a host in Japan, and the `zrok access private` was running on a host in the United States, and the user\'s web browser (in the United States) is configured to use the local SOCKS access (on `127.0.0.1`), then the end user will appear to be browsing from the host in Japan.\\n\\n*Like all zrok shares, the SOCKS share can be set up in seconds and removed just as easily when it is no longer needed.*\\n\\nAll modern web browsers support SOCKS. There is tooling available for all modern operating systems that allow most applications to be \\"wrapped\\" with SOCKS, such that all of their network traffic can be intercepted and re-routed through the SOCKS proxy.\\n\\nHere is a recent [zrok Office Hours](https://www.youtube.com/watch?v=5Vi8GKuTi_I&list=PLMUj_5fklasLuM6XiCNqwAFBuZD1t2lO2) video that illustrates the `socks` backend in action:\\n\\n%[https://www.youtube.com/watch?v=j0dcQGjgQMM] \\n\\nBe aware that fully securing your traffic using SOCKS can be tricky in some cases. Modern web browsers allow you to configure a SOCKS host and also allow you to configure whether or not DNS resolution is also routed through SOCKS:\\n\\n![](/blogs/openziti/v1710865302956/4f7889c8-4334-45b6-ab0f-48e20f44757f.png)\\n\\nNotice that Firefox includes a checkbox to enable \\"Proxy DNS when using SOCKS v5\\". Like any security or tunneling solution, you\'ll want to be sure that you understand the implications of various configuration options and audit that they\'re working correctly in your environment.\\n\\nThis is the basic approach for creating and using the `socks` backend:\\n\\n1. Create a zrok environment (using `zrok enable`) on a host with network locality that you would like to share (in a foreign country, for example)\\n    \\n2. In the environment with the remote network locality, run `zrok share private --backend-mode socks` (consider adding `--closed`) to share that network locality as a SOCKS share\\n    \\n3. Ensure that your local environment (where you want to access the remote network locality) is enabled using `zrok enable`\\n    \\n4. Run `zrok access private <token>` in your local environment. `<token>` is given to you from the `zrok share private` command above and can also be retrieved from the zrok web console\\n    \\n5. By default, the `zrok access` command above will create a SOCKS listener at the address `127.0.0.1:9191`. Use that address to configure your web browser (or `tsocks`, or SocksCap) to enable to SOCKS-based connectivity\\n    \\n\\nThere are numerous inexpensive VPS and VM solutions that would be very effective for siting a `zrok share private -b socks` SOCKS share. This is a simple way to locate your network access on a different host on the internet. A lot of VPS and VM providers allow you to allocate a host for a short period of time, and then dispose of it when you no longer need it. Kind of a \\"burner phone\\" for the internet.\\n\\nThe shared zrok infrastructure in your self-hosted environment, or on zrok.io has no way to observe your actual traffic. That traffic is all end-to-end encrypted through the OpenZiti overlay. zrok is just acting as a secure transport.\\n\\nIf you run into any issues or need assistance, feel free to reach out on the the [OpenZiti Discourse](https://openziti.discourse.group/c/zrok/24). There\'s a great community there to help you.\\n\\nIt always means a lot to the folks working on zrok when you\'re take a minute to drop a star on the [zrok\'s GitHub repository](https://github.com/openziti/zrok). It helps us to know that the work we\'re doing on zrok is important to you."},{"id":"the-python-zrok-sdk","metadata":{"permalink":"/docs/openziti/blog/the-python-zrok-sdk","source":"@site/blog/the-python-zrok-sdk.md","title":"The Python zrok SDK","description":"If you are reading this, hopefully, you are familiar with zrok: an open source solution for easy and secure sharing","date":"2024-02-29T20:30:28.000Z","tags":[{"inline":false,"label":"Python","permalink":"/docs/openziti/blog/tags/python","description":"Python content"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":3.18,"hasTruncateMarker":true,"authors":[{"name":"Cameron Otts","title":"Author","url":"https://github.com/camotts","imageURL":"https://avatars.githubusercontent.com/camotts","key":"CameronOtts","page":null}],"frontMatter":{"title":"The Python zrok SDK","date":"2024-02-29T20:30:28.000Z","cuid":"clt7ojqne000009l55fwz4dgu","slug":"the-python-zrok-sdk","authors":["CameronOtts"],"image":"@site/blogs/openziti/v1701893161134/a2cd088f-0260-4ce7-9ea2-26a1a97a23db.webp","imageDark":"@site/blogs/openziti/v1701893161134/a2cd088f-0260-4ce7-9ea2-26a1a97a23db.webp","tags":["python","openziti","zrok"]},"unlisted":false,"prevItem":{"title":"The zrok SOCKS Backend","permalink":"/docs/openziti/blog/the-zrok-socks-backend"},"nextItem":{"title":"Securing a Dedicated  Palworld Server For My Family with zrok","permalink":"/docs/openziti/blog/securing-dedicated-palworld-server-with-zrok"}},"content":"If you are reading this, hopefully, you are familiar with `zrok`: an open source solution for easy and secure sharing \\nbuilt on OpenZiti. If not you can check out this post [introducing `zrok`](./introducing-zrok.md). \\nIf you have then that\'s great news! You might be familiar with the Golang SDK that was \\n[recently released](./the-zrok-sdk.md).\\n\\n\x3c!-- truncate --\x3e\\n\\n`zrok` is built to enable developers to seamlessly and securely share their applications. We are expanding that philosophy by supporting a Python SDK. Using just a little code enables you to share your app through `zrok`\'s robust network.\\n\\nToday we\'ll be talking about the exciting news of the `zrok` python SDK! We will be spinning up an http server using flask and waitress to be served up via `zrok`! If you want to follow along you\'ll need to have a `zrok` environment set up. If you don\'t want to self host you can sign up for a free account at [https://zrok.io](https://zrok.io).\\n\\nCheck out the [Getting Started](https://docs.zrok.io/docs/getting-started/) guide for more information.\\n\\n![](/blogs/openziti/v1701893410612/3adab72c-f78a-4cfc-b4e3-d4c645a70376.png)\\n\\n## Expanding into Python\\n\\nHere is all it takes to spin up a `zrok` enabled server using flask and waitress:\\n\\n```python\\nfrom flask import Flask\\nimport sys\\nimport zrok\\nfrom zrok.model import ShareRequest\\nimport atexit\\n\\napp = Flask(__name__)\\nzrok_opts = {}\\nbindPort = 18081\\n\\n\\n@zrok.decor.zrok(opts=zrok_opts)\\ndef runApp():\\n    from waitress import serve\\n    # the port is only used to integrate Zrok with frameworks that expect a \\"hostname:port\\" combo\\n    serve(app, port=bindPort)\\n\\n\\n@app.route(\'/\')\\ndef hello_world():\\n    print(\\"received a request to /\\")\\n    return \\"Look! It\'s zrok!\\"\\n\\n\\nif __name__ == \'__main__\':\\n    root = zrok.environment.root.Load()\\n    try:\\n        shr = zrok.share.CreateShare(root=root, request=ShareRequest(\\n            BackendMode=zrok.model.TCP_TUNNEL_BACKEND_MODE,\\n            ShareMode=zrok.model.PUBLIC_SHARE_MODE,\\n            Frontends=[\'public\'],\\n            Target=\\"http-server\\"\\n        ))\\n        shrToken = shr.Token\\n        print(\\"Access server at the following endpoints: \\", \\"\\\\n\\".join(shr.FrontendEndpoints))\\n\\n        def removeShare():\\n            zrok.share.DeleteShare(root=root, shr=shr)\\n            print(\\"Deleted share\\")\\n        atexit.register(removeShare)\\n    except Exception as e:\\n        print(\\"unable to create share\\", e)\\n        sys.exit(1)\\n\\n    zrok_opts[\'cfg\'] = zrok.decor.Opts(root=root, shrToken=shrToken, bindPort=bindPort)\\n\\n    runApp()\\n```\\n\\nJust a few calls and we\'re running! Let\'s quickly go over what\'s happening here:\\n\\nThe `zrok` decorator takes a config dictionary to allow users to easily input their own settings. Taking in the root config, share token, and the bind port and you\'re off to the races.\\n\\nWe create a share (and setup a callback to clean up after ourselves once the server closes) which we then use to populate our options struct for our decorator. Thats it! That share is then accessed via some sort of share. In this case we\'re using a public share which you can find if on [here](./the-zrok-oauth-public-frontend).\\n\\nTo expand from here you would declare any routes your app wants to expose and it\'s just like producing a typical web server. No additional complications!\\n\\n## Why **Though**?\\n\\nWell, the big reason is we want this to be easy above all else. Sharing what you make should be painless. You develop the application and let `zrok` handle the rest.\\n\\nPlus you can deploy your application anywhere. So long as the environment can reach out to the `zrok` host controller it can be wherever you need it to be. It can live in a container, cloud hosted, or even running nicely at home.\\n\\n## Moving Forward\\n\\nMoving forward we want `zrok` to be as accesible as possible, both in options and ease of use. Support for more languages is coming! If you would like to talk about languages to support, or friction points then please reach out to us on [Discourse](https://openziti.discourse.group/c/zrok/24)!\\n\\n[  \\n](https://openziti.discourse.group/c/zrok/24)Also if you like `zrok` or OpenZiti and want to support it then please drop a star on [Github (zrok)](https://github.com/openziti/zrok) / [Github (OpenZiti)](https://github.com/openziti/ziti). It really means a lot!"},{"id":"securing-dedicated-palworld-server-with-zrok","metadata":{"permalink":"/docs/openziti/blog/securing-dedicated-palworld-server-with-zrok","source":"@site/blog/securing-a-dedicated-palworld-server-for-my-family-with-zrok.md","title":"Securing a Dedicated  Palworld Server For My Family with zrok","description":"I like playing survival games, and my adult sons and I have been looking for a game we could play together. This","date":"2024-02-13T23:12:04.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"},{"inline":false,"label":"Palworld","permalink":"/docs/openziti/blog/tags/palworld","description":"Palworld game"}],"readingTime":4.13,"hasTruncateMarker":true,"authors":[{"name":"Edward Thompson","title":"Author","url":"https://github.com/ed4becky","imageURL":"https://avatars.githubusercontent.com/ed4becky","key":"EdwardThompson","page":null}],"frontMatter":{"title":"Securing a Dedicated  Palworld Server For My Family with zrok","date":"2024-02-13T23:12:04.000Z","cuid":"clskz9wz8000009ju1kt7e0ha","slug":"securing-dedicated-palworld-server-with-zrok","authors":["EdwardThompson"],"image":"@site/blogs/openziti/v1706800178582/3fa8b1ea-7c9f-4fcc-9245-375f5df55448.jpeg","imageDark":"@site/blogs/openziti/v1706800178582/3fa8b1ea-7c9f-4fcc-9245-375f5df55448.jpeg","tags":["security","openziti","zrok","palworld"]},"unlisted":false,"prevItem":{"title":"The Python zrok SDK","permalink":"/docs/openziti/blog/the-python-zrok-sdk"},"nextItem":{"title":"Fun with Adaptive Rate Limiting","permalink":"/docs/openziti/blog/fun-with-adaptive-rate-limiting"}},"content":"I like playing survival games, and my adult sons and I have been looking for a game we could play together. This \\nweekend, we discovered Palworld, a new MMO available as an early release on Steam.\\n\\n\x3c!-- truncate --\x3e\\n\\nWe wanted to play on a dedicated server. I recently purchased a gaming laptop, so I set up a dedicated server on the gaming PC I was no longer using. I won\'t get into setting up the dedicated server - I learned all about it by watching [this YouTube video.](https://www.youtube.com/watch?v=7Erzg2HcBHI&t=182s&ab_channel=TroubleChute) You can also checkout the developer\'s docs on setting one up [here](https://tech.palworldgame.com/)\\n\\nOne of my sons lives at home and can access the game over our LAN. The other son has his own house, so I had to open a port over the internet for him to play with us. Ugh.\\n\\nEnter [zrok](https://zrok.io).\\n\\n## Securing Palworld\\n\\nThe company I work for, [NetFoundry](https://netfoundry.io), created zrok, but I hadn\'t had a chance to use it in the wild yet. I read an article by Clint Dovholuk explaining how to use zrok to secure a Minecraft server - you can read that article [here](./minecraft-over-zrok). I followed the steps as a zrok \\"newbie\\" to do the same for Palworld.\\n\\n*The instructions below are for setting up zrok and Palworld on a PC. zrok can be run in Windows/Mac/Linux, but Palworld is a PC game.*\\n\\n### Install zrok\\n\\n1. Download zrok from [zrok.io](https://github.com/openziti/zrok/releases) and unzip the executable. I copied the executable file \\"zrok.exe\\" to my home directory.\\n    \\n2. Open a Windows Powershell on the machine where you plan to run the **server** and navigate to where you installed zrok.\\n    \\n3. At this point, you can follow the [zrok Getting Started Guide](https://docs.zrok.io/docs/getting-started/):\\n    \\n\\n```powershell\\n~/zrok invite\\n```\\n\\nFollow the rest of the guide to the point of enabling your zrok network:\\n\\n```powershell\\n~/zrok enable <your enable token>\\n```\\n\\n1. Repeat the process on all the computers needing secure game access. It\'s important to note that you need unique email addresses for each person.\\n    \\n\\n### Configure the Server Machine\\n\\nIn this tutorial we will be implementing a \\"reserved share\\" for our bridge.\\n\\n> You can use a `reserved` share to persist your *share token* across multiple runs of the `zrok share` bridge. When you use a `reserved` share, the share token will not be deleted between multiple runs of `zrok share`. - [docs.zrok.io](https://docs.zrok.io/docs/concepts/sharing-reserved/)\\n\\n1. From a Powershell on the machine running the dedicated server:\\n    \\n\\n```powershell\\nzrok reserve private 127.0.0.1:8211 \\\\\\n  --backend-mode udpTunnel \\\\\\n  --unique-name mypalworldserver\\n```\\n\\nBy default, the game runs on port 8211. We set the --backend-mode to **udpTunnel** because the game communicates using UDP, not TCP. --unique-name makes it easier to reference the connection. The [Getting Started Guide](https://docs.zrok.io/docs/getting-started/) explains what it means to create a private connection and the meaning of \\"reserve.\\"\\n\\n1. Next, we share the connection.\\n    \\n\\n```powershell\\nzrok share reserved mypalworldserver\\n```\\n\\nImportant: do not close the resulting terminal window!\\n\\nThat\'s it for the server machine.\\n\\n### Configure the Client Machine\\n\\nIn my case, the client machine was my son\'s gaming laptop.\\n\\n1. In the PowerShell you previously enabled, enter:\\n    \\n\\n```powershell\\nzrok access private mypalworldwerver --bind 127.0.0.1:8211\\n```\\n\\nThis command tells your laptop to access the server connection at 127.0.0.1:8211, which happens to be the default for Palworld.\\n\\n### Important: do not close the resulting terminal windows!\\n\\nThat leaves us with this: start the game, select Join Multiplayer, enter 127.0.0.1:8211, and connect! You are now playing over a secure network connection that no one can hijack.\\n\\n![](/blogs/openziti/v1706798561233/fbea7523-6653-45cb-8353-04070b5fd207.png)\\n\\n![](/blogs/openziti/v1707865105231/af7b7fc8-2852-4d41-abac-dc05eec59f97.png)\\n\\n## Summary\\n\\nIn this tutorial, I tried to demonstrate how you can create a secure connection between a Palworld server and your gaming laptop, and you didn\'t need to forward any ports through to your home network!. To do this,\\n\\n1. We installed and enabled zrok on the server and the client.\\n    \\n2. We created and shared a secure connection from the server that the game would recognize.\\n    \\n3. We accessed the connection from the client, in this case, the gaming laptop.\\n    \\n4. We pointed the game to a port on the local machine (not the server)\\n    \\n\\nOf course, I only did this for the laptop playing the game over the internet - laptops playing over my in-house LAN were fine.\\n\\nI hope you found this tutorial helpful and see how you might use zrok to secure other games that provide dedicated servers. If you have any questions, feel free to leave comments below.\\n\\nIf you find this useful please consider giving the [zrok](https://github.com/openziti/zrok) (and [openziti](https://github.com/openziti/ziti), the software zrok uses to provide secure connectivity) a star on [github](https://github.com/openziti/zrok). I know the developers would appreciate it."},{"id":"fun-with-adaptive-rate-limiting","metadata":{"permalink":"/docs/openziti/blog/fun-with-adaptive-rate-limiting","source":"@site/blog/fun-with-adaptive-rate-limiting.md","title":"Fun with Adaptive Rate Limiting","description":"We recently had an issue where an OpenZiti network was overwhelmed with client requests when a user change unintentionally caused the request rate to spike. The fundamental problem was that if a request took too long, the client gave up, but the request was still processed. The system ended up doing work that was ignored while causing new requests to wait until they also timed out. Once the requests hit a certain threshold the system didn\'t degrade gracefully.","date":"2024-01-26T17:44:12.000Z","tags":[{"inline":false,"label":"Performance","permalink":"/docs/openziti/blog/tags/performance","description":"Performance optimization"},{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"APIs","permalink":"/docs/openziti/blog/tags/apis","description":"API development"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":8.1,"hasTruncateMarker":true,"authors":[{"name":"Paul Lorenz","title":"Author","url":"https://github.com/plorenz","imageURL":"https://avatars.githubusercontent.com/plorenz","key":"PaulLorenz","page":null}],"frontMatter":{"title":"Fun with Adaptive Rate Limiting","date":"2024-01-26T17:44:12.000Z","cuid":"clruxmy03000408gr7rdb2mk3","slug":"fun-with-adaptive-rate-limiting","authors":["PaulLorenz"],"image":"@site/blogs/openziti/v1706152812055/f1c7ece1-5bee-41f9-864a-1cabc710bb41.png","imageDark":"@site/blogs/openziti/v1706152812055/f1c7ece1-5bee-41f9-864a-1cabc710bb41.png","tags":["performance","golang","security","apis","openziti"]},"unlisted":false,"prevItem":{"title":"Securing a Dedicated  Palworld Server For My Family with zrok","permalink":"/docs/openziti/blog/securing-dedicated-palworld-server-with-zrok"},"nextItem":{"title":"The zrok Drives CLI Preview","permalink":"/docs/openziti/blog/the-zrok-drives-cli-preview"}},"content":"We recently had an issue where an [OpenZiti network](http://openziti.io) was overwhelmed with client requests when a user change unintentionally caused the request rate to spike. The fundamental problem was that if a request took too long, the client gave up, but the request was still processed. The system ended up doing work that was ignored while causing new requests to wait until they also timed out. Once the requests hit a certain threshold the system didn\'t degrade gracefully.\\n\\nI had a fun day solving the problem, and while I\'m sure that nothing here is new, I thought others might be interested in where I landed and some ideas that were rejected along the way.\\n\\n\x3c!-- truncate --\x3e\\n\\n# Starting Point\\n\\nA rate limiter seems like an obvious answer. Better to reject requests that you know you won\'t be able to service than to do extra work that will just be discarded.\\n\\n![small robot on beach holding a stop sign](/blogs/openziti/v1706157396114/16e07758-817e-4992-b12b-9fb9c41c5749.png)\\n\\nThe requests take a relatively consistent amount of time to process. We also know when we\'ve taken too long, as writing the response back to the client will fail. These two characteristics will shape our implementation.\\n\\nOther notes:\\n\\n* The article will use windows size instead of queue size for the number of requests that are allowed to be queued.\\n    \\n* There are [rate-limiting](https://pkg.go.dev/golang.org/x/time/rate)[packages](https://github.com/didip/tollbooth) available for Go. However, these are more focused on enforcing static limits per user, rather than on minimizing wasted work and maximizing throughput across all requests.\\n    \\n\\n# Implementations\\n\\n## Static\\n\\n![](/blogs/openziti/v1706194973630/6f4db0d5-b664-45bf-aebf-981cdcc975cb.png)\\n\\nI started with a statically sized queue, just to get an initial implementation in place and working. However, a static rate limiter doesn\'t work well for this use case. Crucially, if you pick a window size that\'s too large, the application can fail in the same way as if there were no rate limiter. Picking the correct size is very difficult. You have to account for different hardware and other tasks in the application will change how many requests can be processed, so any number you pick won\'t be optimal. It would be better if we could adapt to the circumstances.\\n\\n## Basic Adaptability\\n\\n![](/blogs/openziti/v1706194987127/25e26525-808a-4093-afc5-f3e130d271ff.gif)\\n\\nThe first step was allowing requests to report their success or failure back to the rate limiter.\\n\\n```go\\ntype AdaptiveRateLimiter interface {\\n\\tRunRateLimited(f func() error) (RateLimitControl, error)\\n}\\n\\ntype RateLimitControl interface {\\n\\tSuccess()\\n\\tTimeout()\\n}\\n```\\n\\nUsing the API looks something like this:\\n\\n```go\\nctrl, err := ae.AuthRateLimiter.RunRateLimited(func() error {\\n\\tsessionId, err := ae.Managers.ApiSession.Create(changeCtx.NewMutateContext(), newApiSession, sessionCerts)\\n\\tsessionIdHolder.Store(sessionId)\\n\\treturn err\\n})\\n// ... skipping error handling, creating a response object, etc\\nwriteOk := rc.RespondWithProducer(rc.GetProducer(), envelope, http.StatusOK)\\nif writeOk {\\n\\tctrl.Success()\\n} else {\\n\\tctrl.Timeout()\\n}\\n```\\n\\nWe can react to failures by shrinking the window size. Here\'s a simplified implementation, which shrinks the window size by 10 on failure, down to a configurable minimum.\\n\\n```go\\nfunc (self *adaptiveRateLimiter) Timeout() {\\n\\tcurrent := self.currentWindow.Load()\\n\\tnextWindow := current - 10\\n\\tif nextWindow < self.minWindow {\\n\\t\\tnextWindow = self.minWindow\\n\\t}\\n\\tself.currentWindow.Store(nextWindow)\\n    self.successCounter.Store(0) // reset the success counter\\n}\\n```\\n\\nWe also need to allow the window size to grow if the load shrinks or we start too conservatively. We can do this after a certain number of sequential successes, capped at a configurable maximum. A simplified version of the success handler, which bumps the window size every 10 successes, could look something like this:\\n\\n```go\\nfunc (self *adaptiveRateLimiter) Success() {\\n\\tif self.successCounter.Add(1)%10 == 0 {\\n\\t\\tif nextVal := self.currentWindow.Add(1); nextVal > self.maxWindow {\\n\\t\\t\\tself.currentWindow.Store(self.maxWindow)\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nI wrote a [couple of tests](https://github.com/openziti/ziti/blob/v0.32.0/controller/command/rate_limiter_test.go) to evaluate how well different rate limiters worked. One test uses a synthetic workload, so I could get quick feedback on how the algorithm performed. This test was all one process, where the work done by the rate limiter was just a short sleep. The goal was to accept as much work as possible without doing any work that would be thrown away.\\n\\nA second test exercises the code in the actual context it will be used. Here I ran the OpenZiti controller and then spun up a hundred goroutines all running auth requests at the same time. I also added a delay in the controller to make authentication slower, to simulate the controller under heavy load.\\n\\nThis first implementation worked but didn\'t respond smoothly to failed work. Once it got one failure, it would usually get many more, since anything that had been queued for too long would fail. This would cause the window size to drop to the minimum very quickly. It would then slowly recover until it hit the threshold again, at which point the cycle would repeat.\\n\\n## Smarter Adaptability\\n\\nTo try and improve this, I made a few changes. First, new requests were tagged with their initial position in the queue. If a request was added to position 100 in the queue, and then the request timed out, that tells us that a window size of 100 is currently too big. We can then shrink the window size to something slightly smaller than 100. If a request comes to the head of the queue with a position bigger than the window size it can also be discarded immediately since it\'s likely that it has already timed out.\\n\\nThe [implementation](https://github.com/openziti/ziti/blob/v0.32.0/controller/command/rate_limiter.go#L198) is included in [OpenZiti v0.32.0](https://github.com/openziti/ziti/releases/tag/v0.32.0).\\n\\nThe [success callback](https://github.com/openziti/ziti/blob/v0.32.0/controller/command/rate_limiter.go#L254) didn\'t need to change.\\n\\nThe [failure callback](https://github.com/openziti/ziti/blob/v0.32.0/controller/command/rate_limiter.go#L269) now takes the initial queue position into account:\\n\\n```go\\nfunc (self *adaptiveRateLimiter) failure(queuePosition int32) {\\n\\t// min window size check and locking stripped for brevity\\n\\tcurrent := self.currentWindow.Load()\\n\\tnextWindow := queuePosition - 10\\n\\tif nextWindow < current {\\n\\t\\tif nextWindow < self.minWindow {\\n\\t\\t\\tnextWindow = self.minWindow\\n\\t\\t}\\n\\t\\tself.currentWindow.Store(nextWindow)\\n\\t}\\n}\\n```\\n\\nFinally, when [work is dequeued](https://github.com/openziti/ziti/blob/v0.32.0/controller/command/rate_limiter.go#L329), the starting queue position is now checked again, in case the window size has shrunk:\\n\\n```go\\nselect {\\ncase work := <-self.queue:\\n\\t// if we\'re likely to discard the work because things have been timing out,\\n\\t// skip it, and return an error instead\\n\\tif work.queuePosition > self.currentWindow.Load()+10 {\\n\\t\\twork.result <- apierror.NewTooManyUpdatesError()\\n\\t\\tclose(work.result)\\n\\t\\tcontinue\\n\\t}\\n```\\n\\nThis algorithm works well. In both tests, it was able to withstand a flood of requests. The vast majority were rejected, but the system successfully processed as many as it could handle and wasted work was minimal.\\n\\nFor example, here are some metrics from the synthetic test:\\n\\n```plaintext\\nqueueFulls: 422820875\\ntimedOut: 147\\ncompleted: 4481\\nwindowSize: 207\\n```\\n\\nUnder heavy load, only about 1 in 30 processed requests ended up timing out and the window size was relatively stable, bouncing between 190 and 220.\\n\\nIn the (closer to) real-world test, the application now gracefully rejected requests that were likely to timeout. Since clients retry, this ended up allowing the clients to eventually succeed.\\n\\n### Future Possibilities\\n\\nOne possibility I considered but haven\'t tried yet is to service the newest requests first. Since the newest requests are the least likely to time out, it seems reasonable to try prioritizing them. You wouldn\'t need a window size, you could just use a reasonably large fixed-size stack. If a request timed out, then anything older than that in the stack could be discarded. If the stack size was hit, the oldest entries in the stack would be discarded to make room for newer entries.\\n\\nBecause I already had an implementation I was happy with, I didn\'t end up trying this out. If anyone has tried this, I\'d be curious to hear how it worked out.\\n\\n# OpenZiti Specific Notes\\n\\nThis rate limiter was added specifically for authentication requests. OpenZiti already had a different rate limiter for model updates ([source code](https://github.com/openziti/ziti/blob/v0.32.0/controller/command/rate_limiter.go#L115), if you\'re curious). Because the highest frequency updates are also idempotent, a statically sized rate limiter is fine. If the request times out and retries, the work is already done and we can return a success code.\\n\\nIn the longer term, authentication is moving to a JWT-based model. Since JWTs are independently verifiable, we won\'t need to store anything in the data store. This will remove the data store as a bottleneck and will make a request flood less catastrophic. Having a rate limiter will still be desirable, as it will provide a better experience to clients.\\n\\n# Feedback\\n\\nIf anyone has feedback, I\'m curious to hear it. Do you have a favorite rate-limiting strategy or library? Do you only think of rate limiting in a per-user context or also in a global application context? How has your rate-limiting approach changed as your application scaled up?\\n\\nThanks!\\n\\n## About OpenZiti\\n\\n[OpenZiti](http://github.com/openziti/ziti) is an open-source platform for providing secure and reliable access to network applications. It does this using strong, certificate-based identities, end-to-end encryption, mesh networking, policy-based access control, and app-embedded SDKs. If you find this interesting, please consider [**starring us on GitHub**](https://github.com/openziti/ziti/). It helps to support the project! And if you haven\'t seen it yet, check out [**https://zrok.io**](https://github.com/openziti/ziti/). It\'s a free sharing platform built on OpenZiti! It uses the OpenZiti Go SDK since it\'s a ziti-native application. It\'s also [**all open source too!**](https://github.com/openziti/zrok/)\\n\\nTell us how you\'re using OpenZiti on [**X**](https://twitter.com/openziti)**<s>Twitter</s>**, **Reddit**, or over at our [**Discourse**](https://openziti.discourse.group/). Or you can check out [**our content on YouTube**](https://youtube.com/openziti) if that\'s more your speed. Regardless of how, we\'d love to hear from you.\\n\\n![](/blogs/openziti/v1706218321488/06727c10-f73d-4425-9bd9-32561df17a02.png)"},{"id":"the-zrok-drives-cli-preview","metadata":{"permalink":"/docs/openziti/blog/the-zrok-drives-cli-preview","source":"@site/blog/the-zrok-drives-cli-preview.md","title":"The zrok Drives CLI Preview","description":"With the release of v0.4.23, zrok now includes a set of CLI commands that simplifies the management of zrok virtual","date":"2024-01-25T20:08:29.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"Storage","permalink":"/docs/openziti/blog/tags/storage","description":"Storage topics"},{"inline":false,"label":"Peer-to-Peer","permalink":"/docs/openziti/blog/tags/peer-to-peer","description":"Peer-to-peer networking"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":4,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"The zrok Drives CLI Preview","date":"2024-01-25T20:08:29.000Z","cuid":"clrtncncs000809lg42ombo9g","slug":"the-zrok-drives-cli-preview","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1706115688489/7aef0bb7-51e7-45e2-bc95-f65ec3149116.png","imageDark":"@site/blogs/openziti/v1706115688489/7aef0bb7-51e7-45e2-bc95-f65ec3149116.png","tags":["security","networking","storage","peer-to-peer","zrok"]},"unlisted":false,"prevItem":{"title":"Fun with Adaptive Rate Limiting","permalink":"/docs/openziti/blog/fun-with-adaptive-rate-limiting"},"nextItem":{"title":"Minecraft Over zrok","permalink":"/docs/openziti/blog/minecraft-over-zrok"}},"content":"With the release of `v0.4.23`, zrok now includes a set of CLI commands that simplifies the management of zrok virtual \\ndrives. This is an early preview of the full set of zrok Drives tools.\\n\\n\x3c!-- truncate --\x3e\\n\\nIf this is your first time enountering zrok, check out the [entire zrok series](./tags/zrok) here on the [OpenZiti blog](./). Also take a look at the [Getting Started guide](https://docs.zrok.io/docs/getting-started).\\n\\n## zrok Drives\\n\\nBack in November, we rolled out an early preview of the new zrok `drive` backend, which introduced our first preview of secure, simple, peer-to-peer virtual network drives functionality.\\n\\nThe short version of the story is that the zrok drives feature introduces the ability to turn any folder on any computer, anywhere on the network, into a secure virtual network drive. The current implementation is based on WebDAV, but we\'ve got additional implementations in the pipeline, including an S3-compatible interface.\\n\\nThe first preview of zrok drives allowed a zrok drives share to be accessed by any software or system that can work with WebDAV. This includes Windows Explorer, macOS Finder, and various Linux graphical desktops including Gnome Nautilus.\\n\\nCheck out the previous [blog post](./zrok-drives-an-early-preview) for more details about [zrok Drives](./zrok-drives-an-early-preview).\\n\\n## The New CLI\\n\\nThe new CLI tools released with `v0.4.23` include a set of commands that should be familiar to most Linux shell users.. `zrok cp`, `zrok ls`, `zrok rm`, and `zrok mkdir`. These commands let you copy files to, from and between virtual network drives.\\n\\nThese commands allow you to work with any combination of:\\n\\n* the local filesystem\\n    \\n* non-zrok WebDAV implementations\\n    \\n* zrok public drives\\n    \\n* zrok private drives\\n    \\n\\nThe current implementation is a preview and likely contains bugs. Getting the ergonomics and semantics to work perfectly, consistently across all of the types of storage that are supported is tricky. We\'ll get it right in time. So, if you run into something, file an issue at the [zrok GitHub repository](https://github.com/openziti/zrok).\\n\\nLet\'s take a look at what kinds of things these tools can do.\\n\\nFirst we create a virtual drive like this:\\n\\n```plaintext\\n$ mkdir /tmp/junk\\n$ zrok share private --headless --backend-mode drive /tmp/junk\\n[   0.124]    INFO sdk-golang/ziti.(*listenerManager).createSessionWithBackoff: {session token=[cf640aac-2706-49ae-9cc9-9a497d67d9c5]} new service session\\n[   0.145]    INFO main.(*sharePrivateCommand).run: allow other to access your share with the following command:\\nzrok access private wkcfb58vj51l\\n```\\n\\nYou can use the new CLI commands to easily copy files to and from zrok drives like this:\\n\\n```plaintext\\n$ zrok copy LICENSE zrok://wkcfb58vj51l\\n[   0.119]    INFO zrok/drives/sync.OneWay: => /LICENSE\\ncopy complete!\\n\\n$ zrok ls zrok://wkcfb58vj51l\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 TYPE \u2502 NAME    \u2502 SIZE    \u2502 MODIFIED                      \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502      \u2502 LICENSE \u2502 11.3 kB \u2502 2024-01-19 12:16:46 -0500 EST \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n$ zrok mkdir zrok://wkcfb58vj51l/stuff\\n$ zrok ls zrok://wkcfb58vj51l\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 TYPE \u2502 NAME    \u2502 SIZE    \u2502 MODIFIED                      \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502      \u2502 LICENSE \u2502 11.3 kB \u2502 2024-01-19 12:16:46 -0500 EST \u2502\\n\u2502 DIR  \u2502 stuff   \u2502         \u2502                               \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```\\n\\nCopying to and from zrok drives and manipulating files and folders is very similar to the usual shell commands that most technical computer users are already familiar with.\\n\\nThe new CLI also supports a convenient one-way synchronization tool that is useful for ensuring that entire file trees are synchronized:\\n\\n```plaintext\\n$ ls -l util/\\ntotal 20\\n-rw-rw-r-- 1 michael michael 329 Jul 21 13:17 email.go\\n-rw-rw-r-- 1 michael michael 456 Jul 21 13:17 headers.go\\n-rw-rw-r-- 1 michael michael 609 Jul 21 13:17 proxy.go\\n-rw-rw-r-- 1 michael michael 361 Jul 21 13:17 size.go\\n-rw-rw-r-- 1 michael michael 423 Jan  2 11:57 uniqueName.go\\n\\n$ zrok copy util/ zrok://wkcfb58vj51l/stuff\\n[   0.123]    INFO zrok/drives/sync.OneWay: => /email.go\\n[   0.194]    INFO zrok/drives/sync.OneWay: => /headers.go\\n[   0.267]    INFO zrok/drives/sync.OneWay: => /proxy.go\\n[   0.337]    INFO zrok/drives/sync.OneWay: => /size.go\\n[   0.408]    INFO zrok/drives/sync.OneWay: => /uniqueName.go\\ncopy complete!\\n\\n$ zrok ls zrok://wkcfb58vj51l/stuff\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502 TYPE \u2502 NAME          \u2502 SIZE  \u2502 MODIFIED                      \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502      \u2502 email.go      \u2502 329 B \u2502 2024-01-19 12:26:45 -0500 EST \u2502\\n\u2502      \u2502 headers.go    \u2502 456 B \u2502 2024-01-19 12:26:45 -0500 EST \u2502\\n\u2502      \u2502 proxy.go      \u2502 609 B \u2502 2024-01-19 12:26:45 -0500 EST \u2502\\n\u2502      \u2502 size.go       \u2502 361 B \u2502 2024-01-19 12:26:45 -0500 EST \u2502\\n\u2502      \u2502 uniqueName.go \u2502 423 B \u2502 2024-01-19 12:26:45 -0500 EST \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n$ zrok copy util/ zrok://wkcfb58vj51l/stuff --sync\\ncopy complete!\\n```\\n\\nI recently put out an office hours video showing these tools in action:\\n\\n%[https://www.youtube.com/watch?v=4Moyt2IWpCk] \\n\\nWe also get into a little bit of golang code in the process. It\'s a fairly short watch at 20 minutes.\\n\\n[A detailed guide](https://docs.zrok.io/docs/guides/drives/cli/) for these commands is available at the [zrok documentation site](https://docs.zrok.io/).\\n\\nIf you\'re a fan of zrok and you find these features useful, we always appreciate a star on the [zrok repository on GitHub](https://github.com/openziti/zrok)!"},{"id":"minecraft-over-zrok","metadata":{"permalink":"/docs/openziti/blog/minecraft-over-zrok","source":"@site/blog/minecraft-over-zrok.md","title":"Minecraft Over zrok","description":"In 2022, we showed you how to run a Minecraft server privately and securely using OpenZiti.","date":"2024-01-06T18:29:48.000Z","tags":[{"inline":false,"label":"Minecraft","permalink":"/docs/openziti/blog/tags/minecraft","description":"Minecraft content"},{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":4.63,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Minecraft Over zrok","seoTitle":"Play Minecraft with friends safely and securely","seoDescription":"Play Minecraft with friends securely without the need to open holes in your firewall!","date":"2024-01-06T18:29:48.000Z","cuid":"clr2egjw2000809jp0l2a50qy","slug":"minecraft-over-zrok","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1704562456124/51580b28-4e9f-4c26-9cc0-5f1a508f42cb.png","imageDark":"@site/blogs/openziti/v1704562456124/51580b28-4e9f-4c26-9cc0-5f1a508f42cb.png","tags":["minecraft","opensource","zerotrust","zrok"]},"unlisted":false,"prevItem":{"title":"The zrok Drives CLI Preview","permalink":"/docs/openziti/blog/the-zrok-drives-cli-preview"},"nextItem":{"title":"Go is Amazing for Zero Trust","permalink":"/docs/openziti/blog/go-is-amazing-for-zero-trust"}},"content":"In 2022, we showed you [how to run a Minecraft server privately and securely using OpenZiti](./set-up-a-secure-multiplayer-minecraft-server.md).\\n\\n\x3c!-- truncate --\x3e\\n\\nSince then, we have released `zrok`, a really cool service that\'s built on top of OpenZiti as a ziti-native application. We also made it a free service for the world to use. If this is your first time hearing about zrok, it has some really exciting features. Read more about `zrok` over at the main site [https://zrok.io](https://zrok.io) or by [checking out previous blog posts in the `zrok` series](./tags/zrok).\\n\\nWe\'re back with a new blog showing you how you can share your Minecraft server safely and securely using `zrok`. If you want, you can watch a video covering the process here.\\n\\n%[https://youtu.be/-dj_5UoL9Jw] \\n\\n## Overview\\n\\nYou want to play some [Minecraft](https://www.minecraft.net/) with our friends but our friends over the intenet, but you don\'t want to expose your [Minecraft server](https://www.minecraft.net/en-us/download/server) to the world because that\'s just not a good idea! You can run the server in your house or, as shown below, on some other server you have, and you want our friends to be able to connect and play in the same world! That looks like this:\\n\\n![](/blogs/openziti/v1704563710705/6dadcf5a-390f-4182-b543-75e4ed84a618.png)\\n\\nTo make this happen, you\'ll need to follow the docs [and install `zrok`](https://docs.zrok.io/docs/getting-started/#installing-the-zrok-command), then [invite yourself to the platform](https://docs.zrok.io/docs/getting-started/#generating-an-invitation), and finally, for every environment you want to share, you\'ll need to [enable that environment](https://docs.zrok.io/docs/getting-started/#enabling-your-zrok-environment). I\'m not going to cover all that here, but you need to do those things first before moving on.\\n\\n## Sharing the Minecraft Server\\n\\nOk, after enabling `zrok` on your computer, on your friend\'s computer, and on the machine that runs the Minecraft Server, the next step is to share the Minecraft server. If you watch the video, you\'ll see I started with a default share from `zrok` that creates an ephemeral share. This type of share is different every time you share it. If that\'s what you want, great, but in this blog, I\'m going to show you how to **reserve** a share instead. A [reserved share](https://docs.zrok.io/docs/concepts/sharing-reserved/) is not ephemeral, it\'s the same every time you access it. This makes it easy to remember how to access the share over and over since it will be the same.\\n\\nOnce the Minecraft server is running, log onto that machine and establish a `zrok` [reserved share](https://docs.zrok.io/docs/concepts/sharing-reserved/). Obviously, you\'ll need to change the unique-name shown below (mymcserverjan06). A couple of notes, these commands assume you are using `bash` and to make it easy to read, the commands are shown using the line-continuation character, `\\\\`. If the command doesn\'t work for you, it\'s probably easiest to just put the commands on one line. ALSO note that `zrok` won\'t let you use `_` characters nor `-` characters at this time, so you\'ll have to make do without those characters for now:\\n\\n```bash\\nzrok reserve private 127.0.0.1:25565 \\\\\\n  --backend-mode tcpTunnel \\\\\\n  --unique-name mymcserverjan06\\n```\\n\\nWith the reserved share created, you can now start sharing the Minecraft server using:\\n\\n```bash\\nzrok share reserved mymcserverjan06\\n```\\n\\n`zrok` will show you something that looks like this. Notice that you\'re running a \\"tcpTunnel\\" and the share is \\"private\\". Only people enabled on your `zrok` network will be able to access this server and they\'ll need to run `zrok` and [access](https://docs.zrok.io/docs/concepts/sharing-private/) the share using the share token. ***VERY COOL***!\\n\\n![](/blogs/openziti/v1704564787671/fc31256d-75d2-4652-8668-879a411484f3.png)\\n\\n## Accessing Your Minecraft Server\\n\\nYou\'ve successfully shared your Minecraft server, but it\'s useless without being able to acces it! To access the server, you just need to run the `zrok` command and `access` the share just like it shows:\\n\\n```bash\\nzrok access private mymcserverjan06 --bind 127.0.0.1:25565\\n```\\n\\nWhen running it on your local computer, `zrok` will show you something like this:\\n\\n![](/blogs/openziti/v1704565050740/0ead10fd-e0d1-4490-807c-b65b13456426.png)\\n\\nOnce you see that, you\'re ready to connect in Minecraft! Open up Minecraft, click on Multiplayer, choose \\"Direct Connection\\" and you\'re connected! (if you\'re wondering, the gif is limited to 10fps for size). You can also choose to edit/save the server, if you prefer to do that.\\n\\n![](/blogs/openziti/v1704565346389/46285049-0628-4e0d-9bf5-8b96f61e9029.gif)\\n\\n## Summary - Share the Project\\n\\nThat\'s all there is to it! Now you can run your Minecraft server wherever you like and have your friends join your game!\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png?auto=compress,format&format=webp)\\n\\nIf you find this interesting, please consider [giving the project a star on GitHub](https://github.com/openziti/zrok/). It really does help to support the project! And if you haven\'t seen it yet, check out [**https://openziti.io**](https://openziti.io). OpenZiti is also free and open source, and it\'s what powers `zrok` security. It\'s a zero trust overlay network and platform for building other secure-by-default applications. Consider giving [that project a star too](https://github.com/openziti/ziti)!\\n\\nTell us how you\'re using `zrok` and OpenZiti on [**X <s>twitter</s>**](https://twitter.com/openziti), [**reddit**](https://www.reddit.com/r/openziti/), or over at our [**Discourse**](https://openziti.discourse.group/). Or you can check out [**our content on YouTube**](https://youtube.com/openziti) if that\'s more your speed. Regardless of how, we\'d love to hear from you."},{"id":"go-is-amazing-for-zero-trust","metadata":{"permalink":"/docs/openziti/blog/go-is-amazing-for-zero-trust","source":"@site/blog/go-is-amazing-for-zero-trust.md","title":"Go is Amazing for Zero Trust","description":"I have the privilege of working on the OpenZiti project. OpenZiti is a free, open-source overlay network and platform focused on making it easy to implement the principles of zero trust. OpenZiti believes zero trust belongs inside applications by adopting an SDK, not bolted onto the network after the application is developed. With zero trust built into the application, it becomes secure-by-default. Since OpenZiti is primarily written in GoLang, naturally, we offer an SDK based on Go to allow you to secure your applications. But Go isn\'t the only SDK offered; the project also has numerous SDKs in various other languages. With one of these SDKs, you can build zero-trust principles into an application and make it secure-by-default.","date":"2023-12-14T02:45:46.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"AppSec","permalink":"/docs/openziti/blog/tags/appsec","description":"Application security"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":9.64,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Go is Amazing for Zero Trust","seoTitle":"Go + OpenZiti are a natural fit for zero trust","seoDescription":"OpenZiti has numerous SDKs for creating secure-by-default applications. The OpenZiti Go SDK is an amazing option for developing secure applications.","date":"2023-12-14T02:45:46.000Z","cuid":"clq4llx30000108jp8lhp7iy8","slug":"go-is-amazing-for-zero-trust","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1702331268646/98f54fa9-a33d-4fa9-91bf-ad88d936ed5a.jpeg","imageDark":"@site/blogs/openziti/v1702331268646/98f54fa9-a33d-4fa9-91bf-ad88d936ed5a.jpeg","ogimage":"/blogs/openziti/v1702331780840/80987396-5227-4fd6-8544-dc7c67a6e331.jpeg","tags":["golang","appsec","zerotrust"]},"unlisted":false,"prevItem":{"title":"Minecraft Over zrok","permalink":"/docs/openziti/blog/minecraft-over-zrok"},"nextItem":{"title":"zrok frontdoor","permalink":"/docs/openziti/blog/zrok-frontdoor"}},"content":"I have the privilege of working on [the OpenZiti project](https://openziti.io). OpenZiti is a free, open-source overlay network and platform focused on making it easy to implement the principles of [zero trust](https://en.wikipedia.org/wiki/Zero_trust_security_model). OpenZiti believes zero trust belongs **inside applications** by adopting an SDK, not bolted onto the network after the application is developed. With zero trust built into the application, it becomes secure-by-default. Since OpenZiti is primarily written in [GoLang](https://go.dev/), naturally, we offer an [SDK based on Go](https://github.com/openziti/sdk-golang/) to allow you to secure your applications. But Go isn\'t the only SDK offered; the project also [has numerous](https://github.com/openziti/ziti-sdk-c) [SDKs](https://github.com/openziti/ziti-sdk-jvm) [in various](https://github.com/openziti/ziti-sdk-py/) [other languages](https://openziti.io/docs/reference/developer/sdk/). With one of these SDKs, you can build zero-trust principles into an application and make it secure-by-default.\\n\\nRecently, I used our [SDK based on Go](https://github.com/openziti/sdk-golang/) and built an \\"Appetizer Demo\\" to give the world an idea of how easy it can be to secure applications by adopting an OpenZiti SDK. We want to make it trivial for people to experience frictionless zero trust in action. Using code, the demo shows you what it takes to include an OpenZiti SDK into an application to secure data in motion.\\n\\nThe [Appetizer Demo doc page](https://openziti.io/appetizer) is live. You can go there and experience it now if you like or later after reading a bit more about it here. It\'ll hopefully take five minutes or less, depending on how fast you are! If you\'d prefer to look at the source from GitHub first, have a look at [the reflect server](https://github.com/openziti-test-kitchen/appetizer/blob/main/overlay/reflectServer.go) and/or the [reflect client](https://github.com/openziti-test-kitchen/appetizer/blob/main/clients/reflect.go).\\n\\n![[object Object]](https://openziti.io/img/appetizer/step4.svg)\\n\\n\x3c!-- truncate --\x3e\\n\\n## Go Standard Library - `package net`\\n\\nA year or two before the pandemic, OpenZiti began development with the premise that security should be embedded into, not bolted onto, applications. Naturally, this means the project would need SDKs for people to use. The project decided to migrate towards Go, which was relatively mature but still an \\"up-and-coming\\" language (and continues to gain popularity). Go was also gaining substantial traction in network-centric use cases. The team started to develop the SDK for Go and discovered the standard library contained the perfect abstractions necessary to implement zero-trust principles.\\n\\nSecurity and zero-trust principles become crucial the moment one application initiates communication with another. Most often, communicating with other applications is accomplished using an IP-based network using [sockets and ports](https://en.wikipedia.org/wiki/Network_socket). This is where the Go standard library enters. The Go standard library has an interface, `net.Conn` that represents a general network connection and declares the critical functions needed. Most importantly, the interface is used throughout the standard library as a point of abstraction. Other functions and interfaces related to network connectivity from other packages reference this interface. Because it\'s used throughout the standard library, it\'s been adopted far and wide, and its use has expanded throughout the rest of the Go ecosystem.\\n\\nProcesses that accept connections from other processes (\\"server\\" applications) have a similar interface: the `net.Listener`. It represents a process capable of handling remote connections and is used extensively throughout the Go standard library.\\n\\nWith the standard library using `net.Conn` and `net.Listener` throughout, third parties implemented their solutions using the pattern, as did OpenZiti. Let\'s look at what that means.\\n\\n## Go - Server Apps\\n\\n![](/blogs/openziti/v1702330009801/bf998c1a-90b6-43e7-8cb4-343bae8fc66f.png)\\n\\nIt doesn\'t take much code to update an existing application with an OpenZiti SDK and make it secure-by-default. Somewhere in the codebase, there will be a server. Go provides a great implementation in the standard library already, so it will often be an `http.Server`. You\'ll also frequently see `Server` instructed to `ListenAndServe` (or `ListenAndServeTLS`), starting a process that can handle HTTP connections on the IP-based underlay network. That code, at a basic level, will resemble something like the following:\\n\\n```go\\nfunc main() {\\n\\thttp.HandleFunc(\\"/hello\\", hello)\\n\\thttp.HandleFunc(\\"/add\\", add)\\n\\tif err := http.ListenAndServe(\\":8090\\", nil); err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n}\\n```\\n\\nThe code shown above is a greatly simplified HTTP server example, listening on port `:8090`. When it runs, it will allow HTTP connections from clients that can access the server\'s IP at port `:8090`. If authentication is needed, the server will accept a connection and then present the authentication challenge. Below, we\'ll see how that pattern changes when listening on the OpenZiti overlay instead.\\n\\n### After - Using OpenZIti\\n\\nWith that simple example in mind, compare the same server listening on an OpenZiti overlay, not the IP-based underlay (not shown is code that loads the strong identity, the handler function shown, nor the serviceName. For a full example see the GitHub repo):\\n\\n```go\\nfunc main() {\\n    // ... other setup-related code\\n    if ctx, err := ziti.NewContext(zitiCfg); err != nil {\\n        if listener, err := ctx.Listen(serviceName); err != nil { \\n            http.HandleFunc(\\"/hello\\", hello)\\n            http.HandleFunc(\\"/add\\", add)\\n            if err := http.Serve(listener, http.HandlerFunc(handler)); err != nil {\\n                log.Fatalf(\\"https serving failed: %v\\", err)\\n            }\\n        }\\n    }\\n}\\n```\\n\\nNot much difference, is there? So what changed?\\n\\n1. We needed to create an OpenZiti `Context`. We need to authenticate and authorize the process with the OpenZiti overlay. Only identities **authorized** to host a service are allowed to do so. Contrast that to the IP-based underlay. With IP-based servers, **any** process can be a listening server. This allows for attacks like [DNS poisoning](https://en.wikipedia.org/wiki/DNS_spoofing). With a zero trust overlay, this whole style of attack is impossible.\\n    \\n2. The OpenZiti context contains a function to return a `Listener` interface. When using `ListenAndServe`, the standard library assumes the server should be listening on the common, IP-based underlay network because that\'s how it\'s always been done, but this is not the case with OpenZiti. Now, your server has **no listening ports** on the underlay network. It\'s literally **unattackable** via conventional IP-based tooling. Seriously, stop and consider that for just a moment. By adopting an OpenZiti SDK into the server, **all conventional network threats** are immediately useless.\\n    \\n3. The same amazing Go standard library then uses the `Listener` and starts listening for connections from clients on the overlay network. Now, all clients need to be authenticated and authorized to the OpenZiti overlay to connect to the server. If the server itself also requires authentication (a password, for example), it no longer accepts connections from **unauthenticated** and **unauthorized** clients, making [0-day vulnerabilities](https://en.wikipedia.org/wiki/Zero-day_(computing)) far less threatening.\\n    \\n\\n## Go - Client Apps\\n\\n![](/blogs/openziti/v1702330101777/9650046c-b610-422c-ae99-a5636e4014c1.png)\\n\\nGo\'s standard library also fits clients perfectly. If you\'ve created a server that listens on the OpenZiti overlay, the next step will be to make a client that connects to that server. Perhaps it\'s from a CLI, or perhaps it\'s connecting to a microservice. Regardless of the use case, you\'ll need to be able to connect to the server somehow. As that server is listening on the OpenZiti overlay, we know that a regular IP-based connection isn\'t going to work!\\n\\nLet\'s examine what the code for a conventional IP-based client that makes an HTTP GET looks like:\\n\\n```go\\nclient := http.DefaultClient\\nresp, err := client.Get(\\"http://\\" + args.ServiceName)\\n```\\n\\nCool, only two lines to make an HTTP client. It\'s hard to get much better than that!\\n\\n### After - Using OpenZiti\\n\\nOnce you have an OpenZiti context, getting a client that is **authenticated** and **authorized** to connect to the HTTP server from above is also only two lines. The SDK provides a convenience function we can use to return an `http.Client`:\\n\\n```go\\nclient := sdk_golang.NewHttpClient(ctx, nil)\\nresp, err := client.Get(\\"http://\\" + args.ServiceName)\\n```\\n\\nBut if you don\'t want to use that function, Go\'s standard library has your back yet again! Looking [at that function](https://github.com/openziti/sdk-golang/blob/9061ebecd115841f6860bef38778590097e7b1a3/http_transport.go#L18-L22), you can see that the SDK only manipulates the Go standard library using yet another excellent abstraction. Here\'s the full implementation of that function:\\n\\n```go\\nfunc NewHttpClient(ctx ziti.Context, tlsConfig *tls.Config) *http.Client {\\n\\treturn &http.Client{\\n\\t\\tTransport: NewZitiTransport(ctx, tlsConfig),\\n\\t}\\n}\\n```\\n\\nOn display here is another great abstraction from the Go standard library: `http.Transport`. An [`http.Transport`](https://pkg.go.dev/net/http#Transport) is a struct that implements the [`http.RoundTripper`](https://pkg.go.dev/net/http#RoundTripper) interface that represents a request and response. What\'s really cool here is that `Transport` allows developers to provide a `DialContext` (a function that allows developers to override **how** a `net.Conn` is created). OpenZiti uses these amazing abstractions to insert into the normal flow and provide a **zero trust** implementation of `net.Conn` while still being idiomatic Go!\\n\\nIf you don\'t want to use the wrapper function, you can make your own `http.Client` and provide the `Dial` function as the `DialContext` on your own `http.Transport`. Check out just how flexible the Go standard library is while still allowing us to provide a zero trust connection:\\n\\n```go\\nfunc NewZitiClientFromContext(ctx ziti.Context) *http.Client {\\n\\tzitiDialContext := ZitiDialContext{context: ctx}\\n\\n\\tzitiTransport := http.DefaultTransport.(*http.Transport).Clone() // copy default transport\\n\\tzitiTransport.DialContext = zitiDialContext.Dial\\n\\treturn &http.Client{Transport: zitiTransport}\\n}\\n```\\n\\nThese abstractions are simple. They are flexible, easy to use, and all part of the standard library!\\n\\n## Wrapping Up\\n\\nIf you haven\'t explored these structs and interfaces from the Go standard library, check them out! Go has nailed these abstractions. Go\'s standard library really does make it a pleasure to use Go for applications that demand secure connectivity. Does your application need to have secure connectivity? What application doesn\'t, right?!\\n\\nUsing the [OpenZiti Go SDK](https://github.com/openziti/sdk-golang/), you can secure your server and client applications quickly and easily with minimal developer time.\\n\\n## Experience Zero Trust in Action\\n\\nTry it out. If you have Go installed, it will hopefully be just a monment to clone the repo and experience zero trust in action. [The appetizer demo](https://openziti.io/appetizer) is live and ready to accept your connections.\\n\\nYou might notice that this appetizer demo doesn\'t use HTTP. OpenZiti is not limited to HTTP requests. You, the developer, are in charge! This example uses a simplified \\"read\\" protocol. You send it some text and a line feed, and it will return the text you sent to be displayed on the screen. If you want to see an HTTP example, the appetizer has you covered there, too! There\'s [`curlz`](https://github.com/openziti-test-kitchen/appetizer/blob/main/clients/curlz.go), a copy of the [Go SDK `curlz` example](https://github.com/openziti/sdk-golang/tree/main/example/curlz) that illustrates making a very basic HTTP request. There\'s also [`math`](https://github.com/openziti-test-kitchen/appetizer/blob/main/clients/math.go), a very simple API-type example you can check out.\\n\\n## Share the Project\\n\\n![](/blogs/openziti/v1702330572628/7bb2b76c-af3f-45c6-83ab-d519f183024d.png)\\n\\nIf you find this interesting, please consider [starring us on GitHub](https://github.com/openziti/ziti/). It really does help to support the project! And if you haven\'t seen it yet, check out [https://zrok.io](https://zrok.io). It\'s totally free sharing platform built on OpenZiti! It uses the Go SDK **a lot** since it\'s a ziti-native application. It\'s also [all open source too!](https://github.com/openziti/zrok/)\\n\\nTell us how you\'re using OpenZiti on [X <s>twitter</s>](https://twitter.com/openziti), [reddit](https://www.reddit.com/r/openziti/), or over at our [Discourse](https://openziti.discourse.group/). Or you can check out [our content on YouTube](https://youtube.com/openziti) if that\'s more your speed. Regardless of how, we\'d love to hear from you."},{"id":"zrok-frontdoor","metadata":{"permalink":"/docs/openziti/blog/zrok-frontdoor","source":"@site/blog/zrok-frontdoor.md","title":"zrok frontdoor","description":"zrok frontdoor is the heavy-duty front door to your app or site. It makes your website or app available to your","date":"2023-12-04T03:00:12.000Z","tags":[{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":3.89,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"zrok frontdoor","date":"2023-12-04T03:00:12.000Z","cuid":"clpqbpz5r000h0al0gq673ks7","slug":"zrok-frontdoor","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1701362109736/d1421e32-6573-4cf4-933f-4878ce549965.png","imageDark":"@site/blogs/openziti/v1701362109736/d1421e32-6573-4cf4-933f-4878ce549965.png","ogimage":"/blogs/openziti/v1701631475557/a539001d-b5c9-4144-9307-9ee59adc4ce8.png","tags":["zrok"]},"unlisted":false,"prevItem":{"title":"Go is Amazing for Zero Trust","permalink":"/docs/openziti/blog/go-is-amazing-for-zero-trust"},"nextItem":{"title":"Business Rule Driven Just-in-Time Network Access","permalink":"/docs/openziti/blog/business-rule-driven-just-in-time-network-access"}},"content":"**zrok frontdoor** is the heavy-duty front door to your app or site. It makes your website or app available to your \\nonline audience through the shield of [zrok.io](http://zrok.io)\'s hardened, managed frontends.\\n\\n%[https://youtu.be/5Vi8GKuTi_I] \\n\\n\x3c!-- truncate --\x3e\\n\\n## More Than the zrok Command\\n\\nSuppose you\'ve enjoyed using zrok interactively as a command-line tool and web console. In that case, you\'ll notice that **zrok frontdoor** leverages another ability of zrok: bot mode. That is, securely sharing a production site or service as a system daemon (background process).\\n\\n> ***In case you\'re not sure what zrok is, take a look at the*** [***documentation site***](https://docs.zrok.io/)***. There is also a full playlist of***[***videos on YouTube***](https://www.youtube.com/playlist?list=PLMUj_5fklasLuM6XiCNqwAFBuZD1t2lO2)***.***\\n\\nzrok frontends are the components of a zrok instance that proxy incoming public web traffic to zrok backend shares via OpenZiti. When you use zrok with a [zrok.io](http://zrok.io) frontend, you\'re using [**zrok frontdoor**](https://zrok.io/frontdoor/). [zrok.io](http://zrok.io) is zrok-as-a-service by NetFoundry, the team behind OpenZiti. You need a free account to use [**zrok frontdoor**](https://zrok.io/frontdoor/).\\n\\n## The Art of \'Set It and Forget It\'\\n\\nDelegating the heavy lifting of internet hardening, high availability, and scaling for global delivery to **zrok frontdoor** lets you focus on crafting and developing your site or service.\\n\\nThe ingredients are:\\n\\n* the [zrok.io](http://zrok.io) frontend cloud proxies\\n    \\n* a zrok share background service running on your server\\n    \\n* a backend target, i.e., a web server or a directory of files you want to share\\n    \\n\\n## Awesome Features\\n\\n* **Controlled access**: You can require a shared password or allow specific email addresses or domains by enabling the Google or GitHub login option when you reserve your shared subdomain. The [zrok.io](http://zrok.io) frontends enforce your authentication policy before the traffic reaches your share.\\n    \\n* **Hardened entry point:** The managed [zrok.io](http://zrok.io) frontends automatically handle failover scenarios and filter and mitigate anonymous abuse from the web.\\n    \\n* **Secure backhaul**: The data link between the [zrok.io](http://zrok.io) frontends and your zrok share service is automatically encrypted. It can\'t be eavesdropped, impersonated, or manipulated.\\n    \\n* **Convenient deployment**: The lightweight zrok share service installs as a Linux package or a Docker Compose project. Scripts and Ansible playbook are published with [the **zrok frontdoor** guide](https://docs.zrok.io/docs/guides/frontdoor/).\\n    \\n* **Pretty visuals**: The zrok console beautifully visualizes usage metrics over useful time frames.\\n    \\n* **Activity Logs**: Every request your share service handles is logged on your server.\\n    \\n* **Self-hostable**: You can use [**zrok frontdoor**](https://zrok.io/frontdoor/) as a launch pad. The zrok source is open under the Apache 2.0 license, includes an SDK, and is a native application on the OpenZiti platform. It\'s ripe for customization at every level. If you build something on [**zrok frontdoor**](https://zrok.io/frontdoor/) you can change your mind later and take full control.\\n    \\n\\n## Share With Confidence\\n\\nYou can leverage any backend mode supported by the `zrok reserve public` command with **zrok frontdoor**.\\n\\n* **proxy** mode: zrok proxies a target web server that you specify as an HTTP/S URL.\\n    \\n* **web** mode: zrok runs a built-in web server to host a target directory of files, such as a website or index of downloads.\\n    \\n* **drive** mode: zrok serves a target directory as a virtual network drive with WebDAV.\\n    \\n* **caddy** mode: this is my personal favorite because it\'s so flexible. The sharing target in this mode is a Caddyfile leveraging zrok\'s built-in Caddy server. Now you can do almost anything with zrok that you can do with Caddy.\\n    \\n\\n## How Does zrok frontdoor Work?\\n\\nSetting up **zrok frontdoor** is a straightforward process.\\n\\n1. **Install the Service**: Choose between the Linux system service or Docker service.\\n    \\n2. **Token Configuration**: The first step involves pasting your zrok account token into the service\'s configuration file. This allows the service to manage a zrok environment tethered to your account.\\n    \\n3. **Specify the Share Target**: Next, you define what you want to share - it could be an HTTP/S URL for proxying or a directory of files you wish to share as a website or file index.\\n    \\n4. **Service Initiation**: Finally, start the service. The zrok service reserves a dedicated public subdomain, which appears in the zrok console as a new share dangling from the service\'s zrok environment.\\n    \\n\\n![](/blogs/openziti/v1701360384297/ee1315cc-809a-4c30-a1d6-67980d2ad44b.png)\\n\\n## What will you share today?\\n\\n**Jump to**[**the first step for your OS**](https://docs.zrok.io/docs/guides/frontdoor)**.**\\n\\nWe\'re curious. Tell us what you shared with **zrok frontdoor** in [the OpenZiti Discourse forum](https://openziti.discourse.group/) or hit us up at [@openziti](https://twitter.com/openziti)!\\n\\nLoving zrok? Spread the word and give zrok [a shiny gold star on GitHub](https://github.com/openziti/zrok)!"},{"id":"business-rule-driven-just-in-time-network-access","metadata":{"permalink":"/docs/openziti/blog/business-rule-driven-just-in-time-network-access","source":"@site/blog/business-rule-driven-just-in-time-network-access.md","title":"Business Rule Driven Just-in-Time Network Access","description":"One of the most incredible achievements of the late 20th century is the internet.\xa0 It has connected the world in ways never imagined and enabled businesses, organizations, and individuals to do incredible things efficiently and at a global scale.\xa0 One of the groups it has enabled, unfortunately, is criminals.\xa0 Since the first networks were connected, criminals and malicious users have exploited weaknesses in software and configuration to disrupt business and steal money, technology, and peace of mind.\xa0 The connectivity of the modern world is the greatest feature and the greatest weakness.\xa0 Recently, Zero Trust has become the new security model.\xa0 Zero Trust is an evolution of earlier models, addressing their weaknesses and giving a framework to deliver much more secure systems and networks.\xa0 NetFoundry, the sponsor of the free and open-source OpenZiti project, is at the forefront of this movement, providing many Zero Trust features, and enabling others.\xa0 The API-driven and software-embeddable nature of the OpenZiti project gives flexibility for simple solutions that have outsized impacts in reducing some of the most common risks seen in information systems today.","date":"2023-11-29T11:46:11.000Z","tags":[{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Just-in-Time","permalink":"/docs/openziti/blog/tags/just-in-time","description":"Just-in-time access"},{"inline":false,"label":"Privileged Access Management","permalink":"/docs/openziti/blog/tags/privileged-access-management","description":"PAM content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"Zero Trust Security","permalink":"/docs/openziti/blog/tags/zero-trust-security","description":"Zero Trust Security Topics"},{"inline":false,"label":"Business Rule Driven Access","permalink":"/docs/openziti/blog/tags/business-rule-driven-access","description":"Access controlled by business rules"}],"readingTime":9.97,"hasTruncateMarker":true,"authors":[{"name":"Mike Gorman","title":"Author","url":"https://github.com/mikegorman-nf","imageURL":"https://avatars.githubusercontent.com/mikegorman-nf","key":"MikeGorman","page":null}],"frontMatter":{"title":"Business Rule Driven Just-in-Time Network Access","seoDescription":"Business rule driven access can significantly reduce the risk of user access to production systems.","date":"2023-11-29T11:46:11.000Z","cuid":"clpjpb4q2000u09l75j1v8nn0","slug":"business-rule-driven-just-in-time-network-access","authors":["MikeGorman"],"image":"@site/blogs/openziti/v1698936177885/46a3121d-b2d2-4808-a98f-e182f841378e.png","imageDark":"@site/blogs/openziti/v1698936177885/46a3121d-b2d2-4808-a98f-e182f841378e.png","tags":["zerotrust","just-in-time","privileged-access-management","zero-trust","zero-trust-security","business-rule-driven-access"]},"unlisted":false,"prevItem":{"title":"zrok frontdoor","permalink":"/docs/openziti/blog/zrok-frontdoor"},"nextItem":{"title":"zrok Drives (an Early Preview)","permalink":"/docs/openziti/blog/zrok-drives-an-early-preview"}},"content":"One of the most incredible achievements of the late 20th century is the internet.\xa0 It has connected the world in ways never imagined and enabled businesses, organizations, and individuals to do incredible things efficiently and at a global scale.\xa0 One of the groups it has enabled, unfortunately, is criminals.\xa0 Since the first networks were connected, criminals and malicious users have exploited weaknesses in software and configuration to disrupt business and steal money, technology, and peace of mind.\xa0 The connectivity of the modern world is the greatest feature and the greatest weakness.\xa0 Recently, Zero Trust has become the new security model.\xa0 Zero Trust is an evolution of earlier models, addressing their weaknesses and giving a framework to deliver much more secure systems and networks.\xa0 NetFoundry, the sponsor of the free and open-source OpenZiti project, is at the forefront of this movement, providing many Zero Trust features, and enabling others.\xa0 The API-driven and software-embeddable nature of the OpenZiti project gives flexibility for simple solutions that have outsized impacts in reducing some of the most common risks seen in information systems today.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Problem\\n\\nThe connectedness of networks and applications is their reason for existing, but as mentioned, also a significant problem.\xa0 The point of Zero Trust is to ensure that whenever an information resource is accessed, the accessing entity is fully authorized to do so, and continuously so.\xa0 In many cases, this is difficult to do, especially to deploy widely.\xa0 Time has shown us that many attacks start in \\"smaller\\" systems;\xa0those that are not considered critical, but give attackers a foothold inside a network to pivot from.\xa0 There is also a major risk of malicious or accidental access by internal or other authorized users, or those posing as them after successfully infecting a device or stealing credentials.\xa0 Suppose network layer access, reachability at the socket level, can be tied dynamically to business rules. In that case, we can reduce risk by orders of magnitude, both from malicious actors, and accidental actions by authorized users.\xa0 I will describe one such solution we have developed here at NetFoundry for our use, the access to supported resources deployed as part of our service.\xa0 I have adjusted the numbers involved to make the math simpler.\\n\\nStandard support tickets flow in from customers, whether they are internal or external, to a support team, which then acts upon them. \xa0 In some cases, depending on the ticket type, support personnel will have to access the systems in question, often with elevated privileges, to triage, troubleshoot, and repair the problem at hand. \xa0 For a support team of 10 people, supporting 2500 devices, we can present a simplistic risk score in person hours of access and will assume the probability of malicious or accidental action is constant. \xa0 We will credit the existing system with only allowing work-hours access, though 24 hour remote access is also fairly common. Given those inputs we can see the weekly exposure is 40 (hours) *10 (engineers)* 2500 (devices) = 1,000,000 exposure units (person-device-hours). \xa0 Let\'s see how we can bring that down.\\n\\nA couple more numbers: average ticket time is 2.5 hours, with 20 tickets per day, and 4 average devices affected per ticket. \xa0 This means that if we can reduce the access to rule authorized users and devices, we change the exposure units calculation to 2.5 (hours) *20 (tickets)* 4 (devices) \\\\* 7 (days) = 1400 exposure units.\\n\\nWhile this is a purely hypothetical example, one can understand how it would affect their environment. By driving access only via active tickets, we have reduced the risk exposure by 99.9%+. Mileage will vary widely, but the numbers remain eye-popping regardless. And let\'s be clear, the risks in this kind of environment of friendly fire are at least equal to those of malicious action. Support organizations tend to have personnel at different levels of capabilities and may be supporting a wide range of devices and types. How many times has someone logged into the wrong device, or opened another production device for comparison and then made changes to that one instead of the one they intended? Any support manager will have a myriad of stories to tell you if you ask. In my own experience, a coworker once logged into a production router during a class by the vendor, and then accidentally ran the next lab exercise on the production device, causing a major outage via an honest mistake and a momentary lapse in judgment.\\n\\n## The Solution\\n\\nDetailed information regarding the details of this particular solution design is available in the [associated GitHub repo](https://github.com/netfoundry/EphemeralAccess). The ticketing system in this case is Zendesk.\xa0 Zendesk, like many support solutions, has several integration points, one of the most general is a webhook. \xa0 For those unfamiliar, a webhook is a method to send a message to an http/s endpoint delivering a data payload for processing or logging, similar to a machine-to-machine text message. \xa0 In our case, we use this method to send a few key pieces of information to a function hosted by AWS Lambda. \xa0 A few relevant data points are enclosed in the message, the ticket number, an identifier for the devices involved, a Network ID, the assigned engineer\'s name, and the status, along with a security key. \xa0 The ticket number is to reference back when we close the ticket and remove the access, as well as to make the actions human-readable to trace back actions through logs.\\n\\n### Process Flow\\n\\n![](/blogs/openziti/v1698861596567/070dd4cd-2849-4b95-a44e-604213c0c887.png)\\n\\nWhen a new ticket is opened, the Network ID is selected for the ticket when relevant. This list is updated every few hours by a separate Lambda function as the list is highly dynamic, and must be kept current. \xa0 The engineer that \\"caught\\" the ticket is assigned by the system when it is opened. When the ticket moves from a status of \\"New\\" to \\"Open\\", or a new user is assigned, the webhook is sent to the Lambda.\\n\\nThe Lambda function authenticates the message and then acts on the context of the data provided. \xa0 In our case, this uses the Network ID to look up all the nodes associated with that network. \xa0 It then builds a series of services in the Ziti network that allows access to SSH (port 22) on these nodes. \xa0 In this case, all nodes deployed have a security group rule to allow a specific address through for this purpose; until now, we have used the \\"[Dark Bastion](https://netfoundry.io/bastion-dark-mode/)\\" architecture, and this is an evolution to remove the bastion process itself. \xa0The policies are then applied to grant the authorization to the assigned engineer to those nodes. \xa0 While this seems like a lot of work and would be if it were done manually, the use of the available APIs of the CloudZiti network means that from ticket opening to the services being available to the engineer is usually less than 30 seconds. \xa0 The engineer then simply needs to open an SSH connection to the service name(s) created by the system.\\n\\nWhen the ticket status is changed to \\"Solved\\", the process is reversed. \xa0 The webhook is sent to the lambda with the ticket number and the new status. \xa0 The function then removes the services, policies, and attributes, removing the connectivity, again within 30 seconds or so.\\n\\nAll the creation and deletion events are logged by the system as change events, and utilization and other data is emitted as well as part of normal network operations. Every step of the process provided auditable logs for review and forensics.\\n\\n## The Benefits\\n\\nLooking at this process through a [MITRE ATT&CK](https://attack.mitre.org) lens, we can see that it disrupts many of the TTPs common to breaches, and some of the more intractable ones in concert with the rest of the environment.\xa0 [A recurring issue in breaches is the use of valid credentials](https://expertinsights.com/insights/50-identity-and-access-security-stats-you-should-know/).\xa0 Whether devices are lost or stolen with information on them, passwords are reused, or are successfully phished, once a malicious actor has those credentials, a great deal of damage can be done.\xa0 [The Continental Pipeline breach was of this sort, to the best of public knowledge](https://www.newsweek.com/colonial-pipeline-hackers-used-unprotected-vpn-access-network-report-1597842).\xa0 However, even having full control of a system in this state is meaningless if the connectivity itself is ephemeral and tied to additional business rules.\xa0 While it may not block 100% of risk, it can significantly reduce the blast radius of the worst compromises; full control of a privileged user.\xa0 When one deploys this sort of network, it is simple to only allow the inbound traffic to ssh or other management and administrative ports to a few devices, in our case, the Edge Router serving the services described here and our orchestration platform.\xa0 This disallows techniques like lateral movement, as the devices are not allowed to connect to one another\'s administrative ports, only a few dedicated devices.\xa0 This mitigates any presence established on these units and makes reviews much easier.\xa0 The logs provided by Ziti also allow a fine-grained level of information about who connected to what devices at what time and from where.\xa0 This makes any forensic investigation much easier, as well as allowing general log spot checking, or long-term storage for potential later investigations simple as well.\xa0 Many other TTPs are potentially interrupted by this architecture, depending on the design of the rest of the environment.\xa0 Zero Trust is about the whole, not a single product, and security in layers is still how one achieves it.\\n\\n## Conclusion\\n\\nThis process allows us to provide frictionless access to relevant resources for a support team in real-time while blocking access whenever the business rules don\'t allow it, dramatically reducing the potential risk of accidental or malicious actions. \xa0 This example is only that, an example, and while focused on a support ticketing process that we use at NetFoundry, it shows the flexibility of using features and functionality of common software packages, the APIs provided by Ziti (available in both CloudZiti and OpenZiti), and a little software \\"glue\\" to implement a very powerful process reducing risk and increasing the security posture.\xa0 A similar solution could include an additional human check, one could easily envision an operations manager receiving a request from an external contractor for access to a system, and authorizing a period via a mobile app.\xa0 Or having incident response specialists in a central group or a vendor that are granted network access to a business unit, or specific resources for forensic and other response functions only when driven by an incident, and requested by the responsible incident commander.\xa0\xa0 The logging and other features of the systems provide additional reviewability, especially in situations where end devices may not support full authentication and authorization feature sets, such as many industrial control systems, sensor nodes, or ancillary devices. \xa0 In a world plagued by security breaches, novel thinking about how we use existing features and functionality can be very powerful in protecting the information assets of people, organizations, and enterprises.\\n\\n## An Easy Experiment\\n\\nA simple entry point to this sort of just-in-time access is the [zrok](https://zrok.io) project.\xa0 Zrok is a solution built with OpenZiti and its original purpose was to provide an easily consumed solution for ephemeral access.\xa0 In the short time it has been available, it has already started to grow in some amazing directions, with new features and improvements to the user experience.\xa0 Available for free, users can set up and run public or private endpoint access to any system, from anywhere, in almost no time at all.\xa0 Very useful in its own right, zrok also evidences the capabilities of OpenZiti in this space very well, as the base network access is achieved using the available functions of the OpenZiti solution.\\n\\n![](/blogs/openziti/v1699626139236/f26e259c-9111-440c-b8ff-fa71768e2183.gif)"},{"id":"zrok-drives-an-early-preview","metadata":{"permalink":"/docs/openziti/blog/zrok-drives-an-early-preview","source":"@site/blog/zrok-drives-an-early-preview.md","title":"zrok Drives (an Early Preview)","description":"If you\'ve been following my","date":"2023-11-20T19:22:36.000Z","tags":[{"inline":false,"label":"Cloud","permalink":"/docs/openziti/blog/tags/cloud","description":"Cloud computing"},{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Storage","permalink":"/docs/openziti/blog/tags/storage","description":"Storage topics"},{"inline":false,"label":"Peer-to-Peer","permalink":"/docs/openziti/blog/tags/peer-to-peer","description":"Peer-to-peer networking"}],"readingTime":4.11,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"zrok Drives (an Early Preview)","date":"2023-11-20T19:22:36.000Z","cuid":"clp7anfg800070al4hqmwf29o","slug":"zrok-drives-an-early-preview","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1700235073954/cdeb4c90-ffed-461e-85f1-51340728e3cd.png","imageDark":"@site/blogs/openziti/v1700235073954/cdeb4c90-ffed-461e-85f1-51340728e3cd.png","tags":["cloud","golang","security","storage","peer-to-peer"]},"unlisted":false,"prevItem":{"title":"Business Rule Driven Just-in-Time Network Access","permalink":"/docs/openziti/blog/business-rule-driven-just-in-time-network-access"},"nextItem":{"title":"Put some Ziti in your Caddy","permalink":"/docs/openziti/blog/put-some-ziti-in-your-caddy"}},"content":"If you\'ve been following my \\n[\\"office hours\\" video series](https://www.youtube.com/watch?v=Edqv7yRmXb0&list=PLMUj_5fklasLuM6XiCNqwAFBuZD1t2lO2), you \\nknow that I\'ve been mentioning something called \\"zrok Drives\\" for weeks now. With the release of `v0.4.14`, \\nwe\'ve got our first look at some of the things that are to come.\\n\\n\x3c!-- truncate --\x3e\\n\\n> *In case you\'re not sure what zrok is, take a look at the* [*documentation site*](https://docs.zrok.io/)*. There is also a full playlist of* [*videos on YouTube*](https://www.youtube.com/playlist?list=PLMUj_5fklasLuM6XiCNqwAFBuZD1t2lO2)*.*\\n\\n## Secure Peer-to-Peer Network Storage\\n\\nzrok is all about making powerful, secure, peer-to-peer sharing work in a simple way. If you stop and think about it, it\'s pretty amazing that you can share something onto a zrok instance using a command like `zrok share private`, and then anyone with a network connection can establish *secure* peer-to-peer connectivity from anywhere in the world. zrok is built on top of [OpenZiti](https://openziti.io/), which is what gives its zero trust, peer-to-peer networking super powers.\\n\\nWe do this for network resources... your HTTP endpoints, your TCP and UDP endpoints; the low-level stuff of networking. We also let you share higher-level resources (files, websites, etc.) by building in our own sharing servers; you can use tools like the `web` backend to immediately stand up a fully-fledged secure web server (thanks to our friends over at Caddy).\\n\\nNow, as of `v0.4.14` we have a new `drive` backend. This is the start of a whole new round of storage sharing capabilities inside zrok. The `drive` backend exposes a folder on a filesystem from anywhere on your private network to public or private users anywhere in the world.\\n\\nThe first storage protocol offered by zrok Drives is powered by WebDAV. We\'re starting with WebDAV because it can be mounted as a virtual drive from just about any operating system. Windows, macOS, and Linux all allow you to mount WebDAV shares just like any other type of network storage. WebDAV is often used as the foundation for all manner of cloud storage services that you probably already use. You can interact with the files on a WebDAV share with any software on your system, not just through a web browser.\\n\\nMount zrok Drives storage directly through things like Windows Explorer, and interact with your files using any Windows applications:\\n\\n![A Windows Explorer window showing a mounted zrok drive.](/blogs/openziti/v1700503752861/77e81e88-28bb-4ec0-ab65-29592e4666e8.png)\\n\\nWe envision using these new zrok capabilities to augment and replace other complicated storage workflows using our own storage and our own resources. Like other zrok concepts, \\"Drives\\" is a primitive that can be used to build really clever and powerful storage sharing solutions.\\n\\nWith `v0.4.14`, we\'re only rolling out the tip of the zrok Drives iceberg; just the basic `drive` backend, which currently only supports WebDAV. This first release does not contain a whole host of other features we\'re currently building... single command synchronization, single-command uploads and downloads, super fast drop-boxes, and a large number of other powerful capabilities for working with your storage from literally anywhere, as if there weren\'t layers and layers of complexity in the middle.\\n\\n## Also for the Data Center\\n\\nWe\'re cooking up some interesting new tooling and use cases designed to support production workloads using zrok. It\'s 2023 and you don\'t want your application edge exposed directly to the internet... we\'ve got the start of a whole range of new tooling coming together that will make it just as easy to share your data center resources as it is to share things from your personal shell.\\n\\nLike all of the other zrok facilities, these new \\"Drives\\" storage capabilities will integrate into your data center workloads using all of these same new data center tools that we\'re developing.\\n\\n![](/blogs/openziti/v1700505083899/64e6a7af-6a14-4e4f-ab4e-af48a8c61791.png)\\n\\nComing next year will be an S3 storage model. We envision being able to simultaneously share your storage resources using WebDAV for end users, and S3 for your truly production workloads. Personally, I\'m starting to think of zrok Drives like a crazy, next-generation, \\"anywhere to anywhere\\" NAS-like system from the future.\\n\\nPut your application in the cloud and your storage wherever you want it.\\n\\n## Office Hours Video Featuring zrok Drives\\n\\nI did an Office Hours video giving a pretty quick tour through the new Drives preview:\\n\\n%[https://www.youtube.com/watch?v=Edqv7yRmXb0] \\n\\n## Try zrok!\\n\\nCheck out the [\\"getting started\\" guide](https://docs.zrok.io/docs/getting-started) to get started with zrok in no time. You can be up and sharing in 5 minutes with the free zrok instance at [zrok.io](https://zrok.io/).\\n\\nIf you decide you\'d like to self-host zrok, we\'ve got a [convenient guide for that](https://docs.zrok.io/docs/category/self-hosting/) as well.\\n\\nAnd if you like what we\'re build, we\'d always appreciate a star on the [zrok GitHub repo](https://github.com/openziti/zrok)."},{"id":"put-some-ziti-in-your-caddy","metadata":{"permalink":"/docs/openziti/blog/put-some-ziti-in-your-caddy","source":"@site/blog/put-some-ziti-in-your-caddy.md","title":"Put some Ziti in your Caddy","description":"In this post I\'ll continue showing the power of OpenZiti and its SDK. This time I\'ll show you how we zitified Caddy Server.","date":"2023-10-24T12:29:14.000Z","tags":[{"inline":false,"label":"Caddy","permalink":"/docs/openziti/blog/tags/caddy","description":"Caddy server"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Secure Networks","permalink":"/docs/openziti/blog/tags/securenetworks","description":"Secure networking"}],"readingTime":2.82,"hasTruncateMarker":true,"authors":[{"name":"Eugene Kobyakov","title":"Author","url":"https://github.com/ekoby","imageURL":"https://avatars.githubusercontent.com/ekoby","key":"EugeneKobyakov","page":null}],"frontMatter":{"title":"Put some Ziti in your Caddy","date":"2023-10-24T12:29:14.000Z","cuid":"clo4aztln000e08l82w2lb5fg","slug":"put-some-ziti-in-your-caddy","authors":["EugeneKobyakov"],"image":"@site/blogs/openziti/v1698150167579/59e96908-6587-4f29-b51b-73e523108133.png","imageDark":"@site/blogs/openziti/v1698150167579/59e96908-6587-4f29-b51b-73e523108133.png","tags":["caddy","openziti","zerotrust","securenetworks"]},"unlisted":false,"prevItem":{"title":"zrok Drives (an Early Preview)","permalink":"/docs/openziti/blog/zrok-drives-an-early-preview"},"nextItem":{"title":"The zrok OAuth Public Frontend","permalink":"/docs/openziti/blog/the-zrok-oauth-public-frontend"}},"content":"In this post I\'ll continue showing the power of OpenZiti and its SDK. This time I\'ll show you how we [zitified](https://openziti.io/docs/reference/glossary/#zitification-zitified-zitify) [Caddy Server](https://caddyserver.com/).\\n\\n\x3c!-- truncate --\x3e\\n\\nIf you\'re a regular reader of this blog, the concept of `zitification`, i.e. embedding OpenZiti SDK into you application, should be familiar to you. We\'ve covered this topic before -- here are some links if you\'re new to this blog, or missed them:\\n\\n* [Zitifying SSH](./zitifying-ssh.md)\\n    \\n* [Securing NodeJS Apps](./securing-nodejs-applications.md)\\n    \\n* [Secure Python Website](./got-5-minutes-secure-your-python-website-with-zero-trust.md)\\n    \\n\\nZitification allows you as a developer to achieve a true end-to-end secure overlay connectivity between your applications.\\n\\n# What is Caddy Server\\n\\n> Caddy 2 is a powerful, enterprise-ready, open source web server with automatic HTTPS written in Go \\n- Caddy simplifies your infrastructure. It takes care of TLS certificate renewals, OCSP stapling, static file serving, reverse proxying, Kubernetes ingress, and more. \\n- Its modular architecture means you can do more with a single, static binary that compiles for any platform.\\n\\nThese two bullet points are really important. I will show how zitifying Caddy Server simplifies your infrastructure, and how easy it was to do it with caddy server\'s approach to extensibility.\\n\\n# Simplifying Infrastructure\\n\\nTypically, if you have a website or a web application in a data center (or at home/office), and you want to protect it from outside traffic (no open Internet ports) you need to deploy some kind of proxy agent (like [Ziti Edge Tunnel](https://openziti.io/docs/reference/tunnelers/linux/)) that would connect to the overlay network, accept service connection requests and proxy them to your target server. This means that\\n\\n* you need to maintain another piece of networking machinery\\n    \\n* the last mile (or a few feet) of your connection goes over an unprotected overlay\\n    \\n\\n**common deployment with Ziti Edge Tunnel**\\n![Common OpenZiti Host Access deployment](/blogs/openziti/v1697632056486/244e5ebb-8767-4477-98ae-3350e99d68e0.png)\\n\\nBy embedding OpenZiti SDK into your server, you solve both problems at the same time.\\n\\n**app-embedded deployment**\\n![Zitified Caddyserver deployment](/blogs/openziti/v1697632190555/f8a81c74-df47-4870-8644-2082ebd8bfec.png)\\n\\n# Caddy Server plugin\\n\\nOpenZiti project published a [Caddy plugin](https://github.com/openziti-test-kitchen/ziti-caddy) that makes it all very easy.\\n\\nAll you have to do is [import](https://github.com/openziti-test-kitchen/ziti-caddy/blob/main/cmd/ziti-caddy/main.go#L8) `ziti-caddy` plugin in your Caddy Server main. Caddy Server plugin framework takes care of bootstrapping OpenZiti SDK (driven by configuration in `Caddyfile`)\\n\\nGithub project has a [sample configuration and bootstrap](https://github.com/openziti-test-kitchen/ziti-caddy/tree/main/sample), but in short steps are like this:\\n\\n* deploy an [OpenZiti network](https://openziti.io/docs/learn/quickstarts/)\\n    \\n* create [service](https://openziti.io/docs/learn/core-concepts/services/overview) and [identity](https://openziti.io/docs/learn/core-concepts/identities/overview)\\n    \\n* configure Caddy Server\\n    \\n\\n```bash\\nhttp:// {\\n\\t# ziti address format: ziti/<service_name>[/<terminator>]@<ziti_identity_file>\\n\\tbind ziti/caddy-service@caddy-host.json\\n\\n\\tfile_server {\\n\\t    root /usr/share/doc\\n\\t\\tbrowse\\n\\t}\\n}\\n```\\n\\nThere you have it, two lines of code -- one in the your Go file, and one in configuration -- and you website is only accessible on OpenZiti network.\\n\\n# Next Steps\\n\\nTry it out and give us feedback on [Discourse](https://openziti.discourse.group/).\\n\\nFurther reading:\\n\\n* [Securing Web APIs With OpenZiti](./securing-web-apis-with-openziti)\\n    \\n* [zrok with the Power of Caddy](./zrok-with-the-power-of-caddy)"},{"id":"the-zrok-oauth-public-frontend","metadata":{"permalink":"/docs/openziti/blog/the-zrok-oauth-public-frontend","source":"@site/blog/the-zrok-oauth-public-frontend.md","title":"The zrok OAuth Public Frontend","description":"With the v0.4.7 release we now support authenticating users of your public zrok shares using either Google or","date":"2023-10-20T13:42:46.000Z","tags":[{"inline":false,"label":"Proxy","permalink":"/docs/openziti/blog/tags/proxy","description":"Proxy content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"OAuth","permalink":"/docs/openziti/blog/tags/oauth","description":"OAuth authentication"},{"inline":false,"label":"Developer","permalink":"/docs/openziti/blog/tags/developer","description":"Developer topics"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"}],"readingTime":2.77,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"The zrok OAuth Public Frontend","date":"2023-10-20T13:42:46.000Z","cuid":"clnynuz3f000909l01il80lcy","slug":"the-zrok-oauth-public-frontend","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1697044959110/120ae30d-9a5b-470f-b7ca-7689135f300a.png","imageDark":"@site/blogs/openziti/v1697044959110/120ae30d-9a5b-470f-b7ca-7689135f300a.png","tags":["proxy","security","oauth","developer","networking"]},"unlisted":false,"prevItem":{"title":"Put some Ziti in your Caddy","permalink":"/docs/openziti/blog/put-some-ziti-in-your-caddy"},"nextItem":{"title":"Securing Azure OpenAI Applications with OpenZiti","permalink":"/docs/openziti/blog/securing-azure-openai-applications-with-openziti"}},"content":"With the `v0.4.7` release we now support authenticating users of your public `zrok` shares using either Google or \\nGitHub. This new authentication capability is in addition to the basic HTTP authentication functionality that was \\navailable in previous releases.\\n\\n\x3c!-- truncate --\x3e\\n\\nHere\'s an overview of where this new capability fits into the `zrok` architecture:\\n\\n![](/blogs/openziti/v1697129004226/c7204767-10dd-4d17-854f-3a25bea604b4.png)\\n\\nThe golden-colored boxes represent the *frontend* components where these new capabilities are implemented. This new authentication feature is primarily focused on authenticating anonymous users from the internet, requiring that they authenticate with Google or GitHub and potentially limiting allowed users to specific email address domains.\\n\\nFuture releases will incorporate other identity providers and potentially the ability to extend `zrok` to incorporate non-stock identity providers. These authentication features will grow to provide richer facilities for controlling which users are allowed to access your public resources.\\n\\nOAuth authentication for private shares will be addressed through another mechanism, in an upcoming release.\\n\\n## Using OAuth with Public Shares\\n\\nThe `zrok share public` command now includes new flags, which allow you to specify that the share should require OAuth authentication:\\n\\n```plaintext\\n$ zrok share public\\nError: accepts 1 arg(s), received 0\\nUsage:\\n  zrok share public <target> [flags]\\n\\nFlags:\\n  -b, --backend-mode string               The backend mode {proxy, web, caddy} (default \\"proxy\\")\\n      --basic-auth stringArray            Basic authentication users (<username:password>,...)\\n      --frontends stringArray             Selected frontends to use for the share (default [public])\\n      --headless                          Disable TUI and run headless\\n  -h, --help                              help for public\\n      --insecure                          Enable insecure TLS certificate validation for <target>\\n      --oauth-check-interval duration     Maximum lifetime for OAuth authentication; reauthenticate after expiry (default 3h0m0s)\\n      --oauth-email-domains stringArray   Allow only these email domains to authenticate via OAuth\\n      --oauth-provider string             Enable OAuth provider [google, github]\\n\\nGlobal Flags:\\n  -p, --panic     Panic instead of showing pretty errors\\n  -v, --verbose   Enable verbose logging\\n```\\n\\nThe `--oauth-provider` flag enables OAuth for the share using the specified provider. In version `v0.4.7` we currently support `google` and `github` for authentication. Future releases will incorporate additional providers and capabilities.\\n\\nThe `--oauth-email-domains` flag accepts a comma-separated list of authenticated email address domains that are allowed to access the share.\\n\\nThe `--oauth-check-interval` flag specifies how frequently the authentication must be checked and potentially re-authenticated.\\n\\nGiven this, the following command will create a public share using the `web` backend mode, and require that the user authenticate with a GitHub account that has an email address within the `zrok.io` domain:\\n\\n```plaintext\\n$ zrok share public --backend-mode web --oauth-provider github --oauth-email-domains zrok.io ~/public\\n```\\n\\nRequiring OAuth authentication for a public `zrok` share can be as simple as adding `--oauth-provider` to your `zrok share public` command line.\\n\\n## Self-hosting the OAuth Frontend\\n\\nThere is a [complete guide to setting up the OAuth frontend](https://docs.zrok.io/docs/guides/self-hosting/oauth/configuring-oauth/) available in the self-hosting section of the [documentation](https://docs.zrok.io/).\\n\\nThe most recent `zrok` Office Hours video includes a full tour through setting up the OAuth public frontend in a local development environment. This should also provide the details needed to set this up in a self-hosted environment.\\n\\n%[https://www.youtube.com/watch?v=mVQEizam4Uc] \\n\\nAs always, reach out to us through the Discourse forum or GitHub!\\n\\nAnd we always appreciate a star on the [zrok Repository](https://github.com/openziti/zrok)!"},{"id":"securing-azure-openai-applications-with-openziti","metadata":{"permalink":"/docs/openziti/blog/securing-azure-openai-applications-with-openziti","source":"@site/blog/securing-azure-openai-applications-with-openziti.md","title":"Securing Azure OpenAI Applications with OpenZiti","description":"Scope","date":"2023-10-15T23:07:06.000Z","tags":[{"inline":false,"label":"OpenAI","permalink":"/docs/openziti/blog/tags/openai","description":"OpenAI content"},{"inline":false,"label":"Application Security","permalink":"/docs/openziti/blog/tags/application-security","description":"Application security"},{"inline":false,"label":"AKS","permalink":"/docs/openziti/blog/tags/aks","description":"Azure Kubernetes Service"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Workload Identity","permalink":"/docs/openziti/blog/tags/workload-identity","description":"Workload Identity in AKS"}],"readingTime":12.53,"hasTruncateMarker":true,"authors":[{"name":"Dariusz Sliwinski","title":"Author","url":"https://github.com/dariuszSki","imageURL":"https://avatars.githubusercontent.com/dariuszSki","key":"DariuszSliwinski","page":null}],"frontMatter":{"title":"Securing Azure OpenAI Applications with OpenZiti","date":"2023-10-15T23:07:06.000Z","cuid":"clns2tgr1000309jwfpyngao7","slug":"securing-azure-openai-applications-with-openziti","authors":["DariuszSliwinski"],"image":"@site/blogs/openziti/v1697652544795/ec49e795-33bd-4a09-aa16-96f4c80d2dc6.jpeg","imageDark":"@site/blogs/openziti/v1697652544795/ec49e795-33bd-4a09-aa16-96f4c80d2dc6.jpeg","ogimage":"/blogs/openziti/v1697652407252/6a647546-7930-4b48-bd16-e85779dbf127.jpeg","tags":["openai","application-security","aks","zerotrust","workload-identity"]},"unlisted":false,"prevItem":{"title":"The zrok OAuth Public Frontend","permalink":"/docs/openziti/blog/the-zrok-oauth-public-frontend"},"nextItem":{"title":"OpenZiti Zero Trust IoT Wi-Fi Gateway","permalink":"/docs/openziti/blog/openziti-zero-trust-iot-wi-fi-gateway"}},"content":"### Scope\\n\\nOnce the initial release of ChatGPT happened at the end of 2022, a new wave of optimism and excitement started to sweep \\nthrough Enterprises. Artificial Intelligence, more specifically generative AI, finally arrived in the mainstream. \\nCompany Executives pretty much everywhere in the world are trying to understand how it can be used to help their \\nworkforce and businesses be more productive and efficient. It was quickly realized that the data Enterprises own \\nis very valuable and important. The large language models will help them greatly in their day-to-day decisions on \\nwhether to drive efficiency, lower costs on the supply chain or understand customer behavior and their consumption \\npatterns to name a few. One thing is very clear, data security is of paramount importance not just at rest but in \\ntransit as well.\\n\\n\x3c!-- truncate --\x3e\\n\\nIn this article, I will show how [OpenZiti](https://openziti.io/docs/learn/introduction/) Overlay Network can secure the data forwarded between applications and users across the Internet. One will learn how two different personas within the same company (i.e. DevOps Engineering and Apps Consumers) can manage the infrastructure or just access the privately hosted Application through the same OpenZiti Overlay without opening any network ports on the service side and segmenting their access through different OpenZiti [Services](https://openziti.io/docs/learn/core-concepts/services/overview) and [Service/Access Policies](https://openziti.io/docs/learn/core-concepts/security/authorization/policies/overview). The architecture section will further highlight the differences before and after OpenZiti. We all know a diagram is worth 10,000 words.\\n\\nMicrosoft has been putting out various examples to educate potential users on how to deploy chat GPT-like applications in recent months. I found a couple of interesting ones that I wanted to use as a case study for OpenZti Overlay. These two examples are located in the following repos - [container-apps-openai](https://github.com/Azure-Samples/container-apps-openai) and [aks-openai-terraform](https://github.com/Azure-Samples/aks-openai-terraform). Both used a private Azure OpenAI\xa0service offering on the backend with the Python-based Chat/Doc Applications deployed in the Azure Managed Container Service or AKS Cluster Service respectively. I forked the former repo as my base since I like the fact that showed two OpenAI applications. I modified it to host applications in the AKS Private Cluster as in the latter example instead of the Azure Managed Container Service.\\n\\nOne quick note before we get started. I used CloudZiti for this article, which is powered by OpenZiti Overlay Network but hosted and managed by [NetFoundry](https://netfoundry.io/). One can host the OpneZiti in his/her Private Virtual Cloud, and it is an excellent option as well. I wanted to focus on the service layer and access policies rather than on network deployment details. Links are provided to both Network Deployment Options later in this blog.\\n\\n## Architectures\\n\\n### Before OpenZiti Overlay\\n\\n* container-apps-openai example\\n    \\n\\n![](/blogs/openziti/v1696619268733/c223b85b-44fc-4529-b068-d1cc5c48891e.png)\\n\\n* aks-openai-terraform example\\n    \\n    ![](/blogs/openziti/v1696619803335/abbc91cf-4430-4af6-8f3c-5f7cea75d19e.png)\\n    \\n\\n### With OpenZiti Overlay\\n\\n#### Option I\\n\\nIt depicts the access to the hosted applications through the Ziti Tunnel deployed in the cluster at a node level set to the hosted mode (similar to ingress controller-like access). In this scenario, one does not have to manage the TLS Certs, since the authentication and encryption are already built-in to the Overlay.\\n\\n![](/blogs/openziti/v1697206053414/db3b5722-fa5a-409e-9e27-2828350ae0be.png)\\n\\n#### Option II\\n\\nIt depicts the access to the hosted applications through the Ziti Edge Router using the Private Ingress Nginx Proxy and TLS termination (i.e. Publicly signed Certs with Private IP Address). In this scenario, the ingress nginx manages the TLS termination and the Built-in End-to-End Overlay Encryption can be used for 2 layers of security or disabled.\\n\\n![](/blogs/openziti/v1697206121637/aa55c58b-bcac-4ba9-89b4-46682c7053a7.png)\\n\\n## Infrastructure Deployment\\n\\nI cloned the repo [container-apps-openai](https://github.com/Azure-Samples/container-apps-openai) (a link to my forked [repo and branch](https://github.com/dariuszSki/container-apps-openai/tree/secure-aichatbot-overziti)). Then, I updated the terraform plan to add the Private AKS Service to the deployment based on the details from the second example. Here are the details.\\n\\n#### AKS Module\\n\\n```ini\\nmodule \\"aks_identity\\" {\\n  source                       = \\"./modules/managed_identity\\"\\n  name                         = \\"${var.name_prefix}aksid\\"\\n  resource_group_name          = azurerm_resource_group.rg.name\\n  location                     = var.location\\n  openai_id                    = module.openai.id\\n  acr_id                       = module.container_registry.id\\n  tags                         = var.tags\\n}\\n\\nmodule \\"aks\\" {\\n  source                                       = \\"Azure/aks/azurerm\\"\\n  version                                      = \\"7.3.2\\"\\n  cluster_name                                 = lower(\\"${var.name_prefix}akscluster\\")\\n  prefix                                       = lower(\\"${var.name_prefix}akscluster\\")\\n  resource_group_name                          = azurerm_resource_group.rg.name\\n  location                                     = var.location\\n  identity_ids                                 = [module.aks_identity.id]\\n  identity_type                                = \\"UserAssigned\\"\\n  oidc_issuer_enabled                          = true\\n  workload_identity_enabled                    = true\\n  vnet_subnet_id                               = module.virtual_network.subnet_ids[var.aca_subnet_name]\\n  net_profile_service_cidr                     = \\"10.0.20.0/22\\"\\n  net_profile_dns_service_ip                   = \\"10.0.20.2\\"\\n  rbac_aad                                     = false\\n  network_contributor_role_assigned_subnet_ids = {\\n    vnet_subnet = module.virtual_network.subnet_ids[var.aca_subnet_name]\\n  }\\n  private_cluster_enabled                      = true\\n  network_plugin                               = \\"azure\\"\\n  network_policy                               = \\"azure\\"\\n  os_disk_size_gb                              = 60\\n  sku_tier                                     = \\"Standard\\"\\n  depends_on                                   = [ azurerm_resource_group.rg ]\\n}\\n```\\n\\n#### Edge Router\\n\\nThe important detail is to be able to manage the AKS Cluster after it is deployed. The kubectl access will be done through this router. The idea is that after the infrastructure plan is executed and completed successfully, the DevOps Users will have instance access through the Overlay Network to all the deployed infrastructure. There will be no need to have a bastion host deployed.\\n\\n```ini\\nmodule \\"edge-router\\" {\\n  source                        = \\"Azure/compute/azurerm\\"\\n  version                       = \\"5.3.0\\"\\n  resource_group_name           = azurerm_resource_group.rg.name\\n  location                      = var.location\\n  vnet_subnet_id                = module.virtual_network.subnet_ids[var.aca_subnet_name]\\n  network_security_group        = {\\n    id = azurerm_network_security_group.edge_router_nsg.id\\n  }\\n  allocation_method              = \\"Static\\"\\n  public_ip_sku                  = \\"Standard\\"\\n  admin_username                 = \\"ziggy\\"\\n  ssh_key                        = var.ziti_router_ssh_pub\\n  custom_data                    = \\"#cloud-config\\\\nruncmd:\\\\n- [/opt/netfoundry/router-registration, ${var.ziti_router_reg_key}]\\"\\n  delete_os_disk_on_termination  = true\\n  enable_ip_forwarding           = true\\n  is_marketplace_image           = true\\n  vm_hostname                    = lower(\\"${var.name_prefix}zitirouter\\")\\n  vm_os_offer                    = \\"ziti-edge-router\\"\\n  vm_os_publisher                = \\"netfoundryinc\\"\\n  vm_os_sku                      = \\"ziti-edge-router\\"\\n  vm_os_version                  = \\"latest\\"\\n  vm_size                        = \\"Standard_DS1_v2\\"\\n```\\n\\n#### Extras - helm/kubernetes providers, kubectl config\\n\\n```ini\\nresource \\"local_sensitive_file\\" \\"kubeconfig\\" {\\n  depends_on   = [module.aks]\\n  filename     = pathexpand(\\"~/.kube/config\\")\\n  content      = module.aks.kube_config_raw\\n  file_permission = 0600\\n}\\nprovider \\"kubernetes\\" {\\n  host                   = module.aks.host\\n  client_key             = base64decode(module.aks.client_key)\\n  client_certificate     = base64decode(module.aks.client_certificate)\\n  cluster_ca_certificate = base64decode(module.aks.cluster_ca_certificate)\\n}\\n\\n\\nprovider \\"helm\\" {\\n  debug   = true\\n  kubernetes {\\n    host                   = module.aks.host\\n    client_key             = base64decode(module.aks.client_key)\\n    client_certificate     = base64decode(module.aks.client_certificate)\\n    cluster_ca_certificate = base64decode(module.aks.cluster_ca_certificate)\\n  }\\n}\\n```\\n\\n### Configuration Snippets for the Overlay Network\\n\\nBefore the terraform plan can be run, one needs to have the Overlay Network stood-up, services and access policies configured.\\n\\n[Get Free Cloud Ziti Network](https://nfconsole.io/signup?selfServicePlan=teams&stepName=chosePlan&stepNum=1) or [Open Ziti Hosted in Your Cloud Account](https://openziti.io/docs/category/public-cloud-deployment)\\n\\nService configuration Option like wildcard domains allows DevOps Users to use one service to access multiple Azure Services and also to terminate/create the test environment multiple times to save on infrastructure cost if not used during evaluation without modifying the service every time.\\n\\n#### Host.v1 service config\\n\\n```json\\n{\\n  \\"allowedAddresses\\": [\\n    \\"*.azurecr.io\\",\\n    \\"*.privatelink.blob.core.windows.net\\",\\n    \\"*.eastus.azmk8s.io\\",\\n    \\"*.privatelink.vaultcore.azure.net\\",\\n    \\"*.privatelink.openai.azure.net\\",\\n    \\"*.openai.azure.com\\",\\n    \\"*.openai.azure.net\\"\\n  ],\\n  \\"allowedPortRanges\\": [\\n    {\\n      \\"high\\": 443,\\n      \\"low\\": 443\\n    }\\n  ],\\n  \\"forwardAddress\\": true,\\n  \\"forwardPort\\": true,\\n  \\"protocol\\": \\"tcp\\"\\n}\\n```\\n\\n#### Intercept.v1 service config\\n\\n```json\\n{\\n  \\"addresses\\": [\\n    \\"*.azurecr.io\\",\\n    \\"*.privatelink.blob.core.windows.net\\",\\n    \\"*.eastus.azmk8s.io\\",\\n    \\"*.privatelink.vaultcore.azure.net\\",\\n    \\"*.privatelink.openai.azure.net\\",\\n    \\"*.openai.azure.com\\",\\n    \\"*.openai.azure.net\\"\\n  ],\\n  \\"portRanges\\": [\\n    {\\n      \\"high\\": 443,\\n      \\"low\\": 443\\n    }\\n  ],\\n  \\"protocols\\": [\\n    \\"tcp\\"\\n  ]\\n}\\n```\\n\\n### Edge Router Policy\\n\\nThe important part is that the Ziti Identity\u2019s group tag (#k8s) is assigned in identityRoles and Edge Router\u2019s name tag (@aks-azure-router01) is assigned in\xa0 edgeRouterRolesDisplay. One can also assign a group tag and have more routers that this endpoint can connect to, which don\'t have to be necessarily in the same resource group.\\n\\n```json\\n{\\n  \\"edgeRouterRoles\\": [\\n    \\"@RL2zF2SFY\\"\\n  ],\\n  \\"edgeRouterRolesDisplay\\": [\\n    {\\n      \\"name\\": \\"@aks-azure-router01\\",\\n      \\"role\\": \\"@RL2zF2SFY\\"\\n    }\\n  ],\\n  \\"identityRoles\\": [\\n    \\"#k8s\\"\\n  ],\\n  \\"identityRolesDisplay\\": [\\n    {\\n      \\"name\\": \\"#k8s\\",\\n      \\"role\\": \\"#k8s\\"\\n    }\\n  ],\\n  \\"isSystem\\": false,\\n  \\"name\\": \\"aks_policy\\",\\n  \\"semantic\\": \\"AnyOf\\"\\n}\\n```\\n\\n### ZDE Test Client\\n\\nTest/DevOps Client for testing and setting up part of the infrastructure.\xa0I used the Windows clients. The installed WZDE can be downloaded from [this repo](https://github.com/openziti/desktop-edge-win/releases).\\n\\n### Service Policy\\n\\nHere is the service policy used that ties my client to the service created in the previous steps\\n\\n```json\\n{\\n  \\"identityRoles\\": [\\n     \\"#clients\\"\\n    ,\\n    \\"identityRolesDisplay\\": [\\n    {\\n      \\"name\\": \\"#clients\\",\\n      \\"role\\": \\"#clients\\"\\n     }\\n      \\n  ],\\n  \\"serviceRoles\\": [\\n    \\"#aks\\"\\n  ],\\n  \\"serviceRolesDisplay\\": [\\n    {\\n      \\"name\\": \\"#aks\\",\\n      \\"role\\": \\"#aks\\"\\n    }\\n  ],\\n  \\"type\\": \\"Dial\\"\\n}\\n\\n\\n# Relevent Service Configuration data\\n{\\n  \\"data\\": [\\n    {\\n      \\"configs\\": [\\n        \\"7aMiQw8wZY9D23dodHHKSQ\\",\\n        \\"e9lfsIHqqOAZv2hirv46p\\"\\n      ],\\n      \\"encryptionRequired\\": true,\\n      \\"name\\": \\"AKS-API-01\\",\\n      \\"permissions\\": [\\n        \\"Bind\\",\\n        \\"Dial\\"\\n      ],\\n      \\"roleAttributes\\": [\\n        \\"aks\\"\\n      ],\\n      \\"terminatorStrategy\\": \\"smartrouting\\"\\n    }\\n  ],\\n}\\n```\\n\\n### Plan Deployment\\n\\nOnce the service, all the policies, edge router, aks endpoint and Windows client are all configured on the CloudZiti Network, we are ready to install the Windows client\xa0 (if not done so already) and run our terraform plan.\\n\\nUpdate terraform.tfvars file. The reg key can be retrieved from the CloudZiti Console and make sure you have the SSH public key in your path under ~/.ssh/id\\\\_rsa.pub or change the path.\\n\\n```json\\nname_prefix         = \\"Dariusz\\"\\nlocation            = \\"eastus\\"\\nziti_router_reg_key = \\"7MBY8KWYPU\\"\\nziti_router_ssh_pub = \\"~/.ssh/id_rsa.pub\\"\\n```\\n\\nThen, run this script to deploy the infrastructure\\n\\n```bash\\nbash deploy.sh\\n```\\n\\n### OpenAI Apps Deployment\\n\\nFirst, you need to build the app images,\xa0 push them to the private registry in your RG, and finally deploy the apps.\\n\\n1. cd into \\\\`src/\\\\` folder and modify \\\\`Blue\\\\` to your \\\\`prefix\\\\` in 00-variables.sh\\n    \\n2. bash 01-build-docker-images.sh\\n    \\n3. bash 03-push-docker-image.sh (note: may need to run `az account set --subscription <name or id>`)\\n    \\n4. Update the service account with your workload identity details and\xa0env settings if needed in the app deployment file. The workload identity name is added in the AKS Module section and is \\"$\\\\{var.name\\\\_prefix\\\\}aksid\\"\\n    \\n\\n```yaml\\napiVersion: v1\\nkind: ServiceAccount\\nmetadata:\\n  annotations:\\n    azure.workload.identity/client-id: ${CLIENT_ID}\\n    azure.workload.identity/tenant-id: ${TENANT_ID}\\n  \\n# apply it  \\nkubectl apply -f apps-deployment.yml\\n\\n# pods status after deployment\\nkubectl get all -n chatbot\\nNAME                           READY   STATUS    RESTARTS   AGE\\npod/chatapp-78895b949d-lng5l   1/1     Running   0          5m38s\\npod/docapp-776c4d44f5-ddsxm    1/1     Running   0          5m38s\\n\\nNAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE\\nservice/chatapp   ClusterIP   10.0.23.7     <none>        80/TCP    5m39s\\nservice/docapp    ClusterIP   10.0.22.202   <none>        80/TCP    5m38s\\n\\nNAME                      READY   UP-TO-DATE   AVAILABLE   AGE\\ndeployment.apps/chatapp   1/1     1            1           5m39s\\ndeployment.apps/docapp    1/1     1            1           5m39s\\n\\nNAME                                 DESIRED   CURRENT   READY   AGE\\nreplicaset.apps/chatapp-78895b949d   1         1         1       5m39s\\nreplicaset.apps/docapp-776c4d44f5    1         1         1       5m39s\\n```\\n\\n### Application Reachability\\n\\nAs stated in the scope, I am trying to show two ways. I will go through the service details for the End Users access now.\\n\\n#### Ziti Endpoint in the cluster\\n\\nDeploying a Ziti Endpoint in the cluster and hosting HTTP service on it to reach the local cluster private DNS app names. You can ignore the padlock warning on your web browser since the end-to-end encryption is done by the Ziti Overlay Network. This simplifies deployment, where one does not have to create public certificates and deploy an ingress in the cluster.\\n\\nSample code to deploy Ziti Edge Tunnel along with the snippet of the service configuration details needed. First, you need to create an identity on the Ziti Network and download its identity\'s jwt. Link to [OpenZiti CLI](https://github.com/openziti/ziti/releases) or [Dockertized Cli](https://hub.docker.com/r/openziti/ziti-cli)\\n\\n##### Deployment to the cluster\\n\\n```bash\\nziti edge enroll --jwt /tmp/k8s-zet-host.jwt --out /tmp/k8s-zet-host.json\\n```\\n\\nor docker\\n\\n```bash\\ndocker run -v /tmp:/tmp openziti/ziti-cli edge enroll \\\\\\n           --jwt /tmp/k8s-zet-host.jwt --out /tmp/k8s-zet-host.json\\n```\\n\\n```bash\\nhelm install k8s-zet-host openziti/ziti-host \\\\\\n                --set-file zitiIdentity=/tmp/k8s-zet-host.json \\\\\\n                --create-namespace --namespace ziti\\n```\\n\\n```bash\\nkubectl get all -n ziti\\nNAME                                          READY   STATUS    RESTARTS   AGE\\npod/k8s-zet-host-ziti-host-67cb9f8668-4lkql   1/1     Running   0          2m3s\\nNAME                                     READY   UP-TO-DATE   AVAILABLE   AGE\\ndeployment.apps/k8s-zet-host-ziti-host   1/1     1            1           2m3s\\nNAME                                                DESIRED   CURRENT   READY   AGE\\nreplicaset.apps/k8s-zet-host-ziti-host-67cb9f8668   1         1         1       2m3s\\n```\\n\\n##### Service configuration details\\n\\nSecond app, just replace\xa0 \\"docapp.ziti\\" and \u201cdocapp.chatbot.svc\\" respectively.\\n\\n```yaml\\n{\\n  \\"addresses\\": [\\n    \\"chatapp.ziti\\"\\n  ],\\n  \\"portRanges\\": [\\n    {\\n      \\"high\\": 80,\\n      \\"low\\": 80\\n    }\\n  ],\\n  \\"protocols\\": [\\n    \\"tcp\\"\\n  ]\\n}\\n{\\n  \\"address\\": \\"chatapp.chatbot.svc\\",\\n  \\"allowedPortRanges\\": [\\n    {\\n      \\"high\\": 80,\\n      \\"low\\": 80\\n    }\\n  ],\\n  \\"allowedProtocols\\": [\\n    \\"tcp\\"\\n  ],\\n  \\"forwardPort\\": true,\\n  \\"forwardProtocol\\": true\\n}\\n```\\n\\nBoth apps are now private and can be accessed through the overlay and all ports are closed. The HTTPS is not enabled between the web browser and apps, but the end-to-end encryption is provided by the overlay network.\\n\\n[http://chatapp.ziti](http://chatapp.ziti)\\n\\n![](/blogs/openziti/v1696625163323/27790c9b-ba1b-4b9d-bec1-d2c473d80ccd.png)\\n\\n[http://docapp.ziti](http://docapp.ziti)\\n\\n![](/blogs/openziti/v1696625182210/494519a6-064f-4138-a5a2-aecb81bb76d2.png)\\n\\n#### Cluster Private Ingress with Public Certs\\n\\nOne can create public certs that resolve to the cluster external private IP using these annotations:\\n\\n```bash\\n\\nhelm install nginx-ingress ingress-nginx/ingress-nginx\\\\\\n  --create-namespace \\\\\\n  --namespace ingress \\\\\\n  --set controller.nodeSelector.\\"kubernetes\\\\.io/os\\"=linux \\\\\\n  --set controller.replicaCount=1 \\\\\\n  --set defaultBackend.nodeSelector.\\"kubernetes\\\\.io/os\\"=linux \\\\\\n  --set controller.service.annotations.\\"service\\\\.beta\\\\.kubernetes\\\\.io/azure-load-balancer-health-probe-request-path\\"=/healthz \\\\\\n  --set controller.service.annotations.\\"service\\\\.beta\\\\.kubernetes\\\\.io/azure-load-balancer-internal\\"=true \\\\\\n  --set controller.service.loadBalancerIP=\\"10.0.0.122\\"\\n```\\n\\nOne Ingress for each of the apps:\\n\\n```yaml\\napiVersion: networking.k8s.io/v1\\nkind: Ingress\\nmetadata:\\n  name: chatapp-ingress\\n  namespace: chatbot\\nspec:\\n  ingressClassName: nginx\\n  tls:\\n  - hosts:\\n    - chatapp.dariuszski.dev\\n    secretName: chatapp\\n  rules:\\n  - host: \\"chatapp.dariuszski.dev\\"\\n    http:\\n      paths:\\n      - pathType: Prefix\\n        path: /\\n        backend:\\n          service:\\n            name: chatapp\\n            port:\\n              number: 80\\n---\\napiVersion: networking.k8s.io/v1\\nkind: Ingress\\nmetadata:\\n  name: docapp-ingress\\n  namespace: chatbot\\nspec:\\n  ingressClassName: nginx\\n  tls:\\n  - hosts:\\n    - docapp.dariuszski.dev\\n    secretName: docapp\\n  rules:\\n  - host: \\"docapp.dariuszski.dev\\"\\n    http:\\n      paths:\\n      - pathType: Prefix\\n        path: \\"/\\"\\n        backend:\\n          service:\\n            name: docapp\\n            port:\\n              number: 80\\n```\\n\\n```bash\\nkubectl apply -f ingress.yml\\ningress.networking.k8s.io/chatapp-ingress created\\ningress.networking.k8s.io/docapp-ingress created\\n```\\n\\nCreate certs using the Let\'s Encrypt bot and upload them manually or use the cert-manager to automate the process. It was more convenient for me to create certs using Certbot and upload them manually to the secrets\' store.\\n\\n```bash\\ndocker run \\\\\\n  -v \'/var/lib/letsencrypt:/var/lib/letsencrypt\' \\\\\\n  -v \'/etc/letsencrypt:/etc/letsencrypt\' \\\\\\n  --cap-drop=all \\\\\\n  ghcr.io/aaomidi/certbot-dns-google-domains:latest \\\\\\n  certbot certonly \\\\\\n  --authenticator \'dns-google-domains\' \\\\\\n  --dns-google-domains-credentials \'/var/lib/letsencrypt/dns_google_domains_credentials.ini\' \\\\\\n  --server \'https://acme-v02.api.letsencrypt.org/directory\' \\\\\\n  -d \'chatapp.dariuszski.dev\' -m ynwa.lfc@dariuszski.dev --agree-tos\\n```\\n\\n```bash\\nkubectl create secret tls chatapp --cert \\"/etc/letsencrypt/live/chatapp.dariuszski.dev/cert.pem\\" --key  \\"/etc/letsencrypt/live/chatapp.dariuszski.dev/privkey.pem\\" -n chatbot\\nkubectl create secret tls docapp --cert \\"/etc/letsencrypt/live/docapp.dariuszski.dev/cert.pem\\" --key  \\"/etc/letsencrypt/live/docapp.dariuszski.dev/privkey.pem\\" -n chatbot\\n```\\n\\nTo show DNS lookup details.\\n\\n```bash\\n$ nslookup chatapp.dariuszski.dev\\nServer:         127.0.0.53\\nAddress:        127.0.0.53#53\\n\\nNon-authoritative answer:\\nName:   chatapp.dariuszski.dev\\nAddress: 10.0.0.122\\n\\n$ nslookup docapp.dariuszski.dev\\nServer:         127.0.0.53\\nAddress:        127.0.0.53#53\\n\\nNon-authoritative answer:\\nName:   docapp.dariuszski.dev\\nAddress: 10.0.0.122\\n```\\n\\nOnce the certs are loaded and the ingress controller set up,\xa0 the web browser shows the padlock for both apps.\\n\\n[https://chatapp.dariuszski.dev/](https://chatapp.dariuszski.dev/)\\n\\n![](/blogs/openziti/v1696624891569/470957ae-b818-4b02-9303-983f32fa7a1e.png)\\n\\n[https://docapp.dariuszski.dev/](https://docapp.dariuszski.dev/)\\n\\n![](/blogs/openziti/v1696624940888/c827e209-ee04-4f68-9996-9e5ada4442e7.png)\\n\\n### Final Word\\n\\nI went over a couple of options for accessing Applications deployed in AKS Clusters. There are technically two more. The third would be at the pod level, where Ziti Host can be deployed as [a sidecar.](https://openziti.io/docs/guides/kubernetes/workload-tunneling/kubernetes-sidecar) The fourth is using Openziti Python SDK to embed the HTTP listener in both Python applications. Here is the link to the Ziti Python SDK [source code](https://github.com/openziti/ziti-sdk-py/blob/main/README.md) and [introduction blog](./openziti-python-sdk-introduction). Probably good content to go over on the follow-up to this blog, unless there are brave souls - I mean developers - out there that can beat me to it. Challenge accepted?! By the way, I am not an application developer by trade. Surely you must have realized it by now, especially after I mentioned SDK as the last but certainly not least option :). Please let me know if you want me to dive into these other options in a future article in the comment section. Looking forward to your responses and feedback."},{"id":"openziti-zero-trust-iot-wi-fi-gateway","metadata":{"permalink":"/docs/openziti/blog/openziti-zero-trust-iot-wi-fi-gateway","source":"@site/blog/openziti-zero-trust-iot.md","title":"OpenZiti Zero Trust IoT Wi-Fi Gateway","description":"Introduction","date":"2023-09-20T14:08:50.000Z","tags":[{"inline":false,"label":"IoT","permalink":"/docs/openziti/blog/tags/iot","description":"Internet of Things"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":13.86,"hasTruncateMarker":true,"authors":[{"name":"Robert Caamano","title":"Author","url":"https://github.com/r-caamano","imageURL":"https://avatars.githubusercontent.com/r-caamano","key":"RobertCaamano","page":null}],"frontMatter":{"title":"OpenZiti Zero Trust IoT Wi-Fi Gateway","date":"2023-09-20T14:08:50.000Z","cuid":"clmrtkyar000209mh1yq1fybs","slug":"openziti-zero-trust-iot-wi-fi-gateway","authors":["RobertCaamano"],"image":"@site/blogs/openziti/v1695128197082/cec3ab0f-80e7-48fb-aced-f45fe933aedb.jpeg","imageDark":"@site/blogs/openziti/v1695128197082/cec3ab0f-80e7-48fb-aced-f45fe933aedb.jpeg","tags":["iot","openziti"]},"unlisted":false,"prevItem":{"title":"Securing Azure OpenAI Applications with OpenZiti","permalink":"/docs/openziti/blog/securing-azure-openai-applications-with-openziti"},"nextItem":{"title":"zrok with the Power of Caddy","permalink":"/docs/openziti/blog/zrok-with-the-power-of-caddy"}},"content":"## Introduction\\n\\nIoT devices are commonplace in most home networks and while they provide many useful features they can also open your network to vulnerabilities, especially if they are connected via Wi-Fi. For starters most legacy devices don\u2019t support advanced features like wpa3 and 802.11w Wi-Fi protected management frames \\\\*e.g. Google Nest Gen 2 thermostats, Carrier Infinity touch series a/b and Ring security devices. A general recommendation is to only add IoT devices to your guest Wi-Fi network. While this helps to isolate the IoT devices from your home network it does not stop hackers from using that Wi-Fi network to perform illegal activities if it becomes compromised. In this article, we will show you how to set up an OpenZiti Zero trust Wi-Fi gateway using a Raspberry Pi 4 running Ubuntu Server 22.04(64 bit) that will restrict devices attached to the IoT Wi-Fi network to only the set of required IoT cloud servers. To do this we use a combination of OpenZiti DNS-based services which provide a form of DNAT and restrictive fire-walling which limits inbound traffic to only the OpenZiti DNS DNAT range. We will use the hostapd Linux package to provide Wi-Fi access point functionality.\\n\\n\x3c!-- truncate --\x3e\\n\\n###### \\\\*at the time of writing\\n\\n![](/blogs/openziti/v1695064156479/7b2f7b92-a3dd-49f7-8819-377cf546e328.png)\\n\\n## Prerequisites\\n\\n1. Install Ubuntu 22.04 Server (64 bit) on a Raspberry Pi 4: [https://www.raspberrypi.com/software](https://www.raspberrypi.com/software/). We strongly suggest that you set up SSH to only use public key authentication as described in this article  \\n    [How to Set Up SSH Keys on Ubuntu 22.04 | DigitalOcean](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-22-04) Note: in addition to setting `PasswordAuthentication no` in `/etc/ssh/sshd_config` you will also need to set it in `/etc/ssh/sshd_config.d/50-cloud-init.conf.`\\n    \\n2. If you do not already have an existing OpenZiti Network you can create a minimal setup in AWS following steps 1.1-1.3 [here](https://openziti.io/docs/guides/Public_Cloud_Deployment/Controller). Note you will want to assign an elastic IP to the VM before installing OpenZiti so the certificates created will remain valid after this node is restarted for any reason.\\n    \\n3. Create an identity for the Openziti wifi-gateway on the controller created in step 2. This step will create a jwt file in the directory where it\'s executed.\\n    \\n\\nssh to the controller VM public IP or DNS name and then input:\\n\\n```plaintext\\nzitiLogin\\nziti edge create identity wifi-gateway -o wifi-gateway.jwt\\n```\\n\\n## Create IoT Wi-Fi Router (updated)\\n\\nssh or log into the console of the Raspberry Pi 4\\n\\nFollow the instructions for installing ziti-edge-tunnel(zet) on Ubuntu [here](https://openziti.io/docs/reference/tunnelers/linux/). Use jwt file saved (wifi-gateway.jwt) previously.\\n\\nFollow the instructions for installing **zfw v0.7.0 or higher** on arm64 [here](https://github.com/netfoundry/zfw/blob/main/BUILD.md).  \\nSelect tunnel in the last step i.e\\n\\n```plaintext\\nsudo make install ARGS=tunnel\\n```\\n\\nEdit ebpf\\\\_config.json\\n\\n```plaintext\\nsudo vi /opt/openziti/etc/ebpf_config.json\\n```\\n\\nenter the following line and save:\\n\\n```plaintext\\n{\\"InternalInterfaces\\": [{\\"Name\\": \\"eth0\\"}], \\"ExternalInterfaces\\": [{\\"Name\\": \\"wlan0\\", \\"PerInterfaceRules\\": false}]}\\n```\\n\\nEnable zfw and restart ziti-edge-tunnel\\n\\n```plaintext\\nsudo systemctl enable ziti-fw-init.service --now\\nsudo systemctl enable ziti-wrapper.service sudo systemctl restart ziti-edge-tunnel.service\\n```\\n\\nEnter some user-defined firewall rules.\\n\\nWe need to enable 802.1x packets into the Wi-Fi interface (wlan0). Without the enable-eapol, the IoT devices will not be able to connect to the wlan0. Also, we need to enable DNS query (UDP 53)\\n\\n```plaintext\\nsudo vi /opt/openziti/bin/user/user_rules.sh\\n```\\n\\nsample `/opt/openziti/bin/user/user_rules.sh` content\\n\\n```plaintext\\n#!/bin/bash\\n/usr/sbin/zfw --disable-ssh wlan0 #disables ssh passthrough \\n/usr/sbin/zfw --enable-eapol wlan0 #enables 802.1x passthrough\\n```\\n\\n```plaintext\\nsudo chmod 700 /opt/openziti/bin/user/user_rules.sh\\nsudo systemctl restart ziti-edge-tunnel\\n```\\n\\nVerify that zfw is running on the wlan0 interface\\n\\n```plaintext\\nsudo zfw -L -E\\n```\\n\\nOutput:\\n\\n```plaintext\\nwlan0: 5\\n--------------------------\\nicmp echo               :0\\nverbose                 :0\\nssh disable             :1\\nper interface           :0\\ntc ingress filter       :1\\ntc egress filter        :1\\ntun mode intercept      :1\\nvrrp enable             :0\\neapol enable            :1\\nddos filtering          :0\\n--------------------------\\n```\\n\\nEdit netplan to setup ip address/subnet for wlan0 interface\\n\\n```plaintext\\nsudo vi /etc/netplan/50-cloud-init.yaml\\n```\\n\\nsample `/etc/netplan/50-cloud-init.yaml` content:\\n\\n```plaintext\\nnetwork: \\n    ethernets: \\n        eth0: \\n            dhcp4: true\\n            optional: true\\n        wlan0: \\n            addresses: \\n            - 10.1.1.1/24 \\n    version: 2\\n```\\n\\nSave the new netplan parameters\\n\\n```plaintext\\nsudo netplan generate\\n```\\n\\nApply new netplan\\n\\n```plaintext\\nsudo netplan apply\\n```\\n\\nInstall and enable isc-dhcp-server\\n\\n```plaintext\\nsudo apt install isc-dhcp-server sudo mv /etc/dhcp/dhcpd.conf /etc/dhcp/dhcp.conf.bak sudo vi /etc/dhcp/dhcpd.conf\\n```\\n\\nsample `/etc/dhcp/dhcpd.conf` content:\\n\\n```plaintext\\nsubnet 10.1.1.0 netmask 255.255.255.0 { \\n  range 10.1.1.100 10.1.1.254; \\n  option domain-name-servers 100.64.0.2; \\n  option subnet-mask 255.255.255.0; \\n  option routers 10.1.1.1; \\n  option broadcast-address 10.1.1.255; \\n  default-lease-time 2592000; \\n  max-lease-time 2592000; \\n  authoritative; \\n}\\n```\\n\\nNote: 100.64.0.2 is the DNS server that OpenZiti defaults to assuming that  \\nyou have not changed the default DNS range from 100.64.0.0/10.\\n\\n```plaintext\\nsudo systemctl enable isc-dhcp-server\\n```\\n\\nInstall and start hostapd\\n\\n```plaintext\\nsudo apt install hostapd\\n```\\n\\n```plaintext\\nsudo vi /etc/hostapd/hostapd.conf\\n```\\n\\nsample `/etc/hostapd/hostapd.conf` content:\\n\\n```plaintext\\nctrl_interface=/var/run/hostapd\\nlogger_syslog=-1\\nlogger_syslog_level=0\\ncountry_code=US\\ninterface=wlan0\\nssid=iot-access\\nhw_mode=g\\nchannel=1\\nmacaddr_acl=0\\nauth_algs=1\\nignore_broadcast_ssid=0 \\nwpa=2 \\nwpa_strict_rekey=1 \\nwpa_passphrase=******* #Replace ******* with the WiFi password you want to use for this network \\nwpa_key_mgmt=WPA-PSK\\nwpa_pairwise=TKIP\\nrsn_pairwise=CCMP\\n```\\n\\nnote: for additional hostapd options and their descriptions you can refer to `/usr/share/doc/hostapd/examples/hostapd.conf`. You will need to adjust based on the supported WiFi auth options of your IoT devices.\\n\\nStart hostapd service\\n\\n```plaintext\\nsudo systemctl unmask hostapd.service\\nsudo systemctl start hostapd.service\\nsudo systemctl start isc-dhcp-server`\\n```\\n\\n## Discover IoT Service Requirements\\n\\nAt this point, you should be able to connect your Wi-Fi IoT devices to the Wi-Fi access point but we have not built any Openziti services yet.\\n\\nSince we do not know what URLs we need to reach, we are going to use tcpdump to determine URLs for our example. This process will vary slightly depending on whether the device uses DNS or hardcoded IP addresses (most will use DNS). For brevity, we will only look at one destination. In reality, most IoT devices connect to more than one remote destination and use multiple destination ports/protocols i.e. 443/TCP, 8883/TCP, 123/UDP etc. Alternatively, if the device vendor publishes firewall port info you can also use that information to populate OpenZiti service configs as well.\\n\\nWe are going to use a NEST thermostat as an example for the following exercises.\\n\\nPerform the following on the wifi-gateway\\n\\n```plaintext\\nsudo tcpdump -i wlan0 port 53\\n```\\n\\nReboot the Nest Thermostat\\n\\nExample output:\\n\\n```plaintext\\n16:27:31.105359 IP 10.1.1.101.54491 > 100.64.0.2.domain: 15404+ A? logsink.devices.nest.com. (42)\\n16:27:35.046118 IP 10.1.1.101.54491 > 100.64.0.2.domain: 23833+ A? frontdoor.nest.com. (36)\\n16:28:07.132888 IP 10.1.1.101.54895 > 100.64.0.2.domain: 13745+ A? time.nest.com. (31)\\n16:28:13.449597 IP 10.1.1.101.51019 > 100.64.0.2.domain: 45964+ AAAA? clients3.google.com. (37)\\n```\\n\\nNow we will add a service to OpenZiti that will both resolve the DNS name above and Intercept traffic sent to the resolved IP. We are going to use a wildcard DNS address \\\\*.nest.com and \\\\*.google.com for our service because this gives us the most flexibility as it will resolve for any host/subdomains under nest.com and google.com respectively. This is important since we are white-listing domain names and iot manufacturers may change host/subdomain over time but still use the same second-level domain in this case nest.\\n\\nAt this point we don\'t know what ports or protocols will be used so we will seed our service with tcp port 443(most IoT devices will probably use this port). If port 443 is not in use we can replace it with the ports we find in the next tcpdump trace we take. Another option would be to add all ports UDP/TCP and then pare back after tracing i.e. 1-65535 but that\'s not the zero trust way :).\\n\\nAdd the service to OpenZiti\\n\\nssh into the controller vm created in prerequisite step 2\\n\\n```plaintext\\nzitiLogin\\n```\\n\\nCreate the intercept.v1 config. We need to seed at least one port so we are going to add port 443. Note time.nest.com is likely NTP (UDP port 123) so we set that up separately in another service.\\n\\n```plaintext\\nziti edge create config iot-nest-intercept-config-tcp intercept.v1 \'{\\"protocols\\": [\\"tcp\\"], \\"addresses\\": [\\"*.nest.com\\",\\"*.google.com\\"], \\"portRanges\\": [{\\"low\\":443, \\"high\\": 443}]}\'\\n```\\n\\nCreate host.v1 config\\n\\n```plaintext\\nziti edge create config iot-nest-host-config-tcp host.v1 \'{\\"allowedPortRanges\\":[{\\"low\\": 443,\\"high\\": 443}], \\"allowedAddresses\\":[\\"*.nest.com\\",\\"*.google.com\\"], \\"forwardAddress\\":true,\\"forwardPort\\":true,\\"protocol\\":\\"tcp\\"}\'\\n```\\n\\nCreate a service (with tag: nest-iot01-server)\\n\\n```plaintext\\nziti edge create service iot-nest-service-tcp -c iot-nest-intercept-config-tcp,iot-nest-host-config-tcp -a nest-iot01-server\\n```\\n\\nCreate an edge-router policy\\n\\n```plaintext\\nziti edge create edge-router-policy all-erp --edge-router-roles \'#all\' --identity-roles \'#all\' --semantic \'AnyOf\'\\n```\\n\\nCreate a services-edge-router policy\\n\\n```plaintext\\nziti edge create service-edge-router-policy all-routers-serp --edge-router-roles \'#all\' --service-roles \'#all\' --semantic \'AnyOf\'\\n```\\n\\nCreate a service Bind policy\\n\\nGet the name of the edge-router created in prerequisite step 2\\n\\n```plaintext\\nziti edge list edge-routers\\n```\\n\\n```plaintext\\nziti edge create service-policy nest-bind Bind --identity-roles \'@ec2-3-84-183-173-edge-router\' --service-roles \'#nest-iot01-server\' --semantic \'AnyOf\'\\n```\\n\\nCreate a OpenZiti service dial policy\\n\\n```plaintext\\nziti edge create service-policy nest-dial Dial --identity-roles \'@wifi-gateway\' --service-roles \'#nest-iot01-server\' --semantic \'AnyOf\'\\n```\\n\\nCheck connectivity via tcpdump\\n\\nAt this point, we are looking to see if we see connectivity via TCP 443 or any other ports/protocols. We also look for any other DNS the IoT device (Nest) is going to reach.\\n\\n```plaintext\\nsudo tcpdump -nNi wlan0 -v\\n```\\n\\nReboot Nest Thermostat again\\n\\nExample output (**new port** discovery)\\n\\n(**Note we are using ebpf xdp to forward traffic from the ziti0 interface toward wlan0 which operates at a lower layer than tcpdump on egress so you will not see the return traffic with tcpdump for active sessions. You can alternatively enable verbose output on wlan0 for zfw via**`sudo zfw -v ziti0`**&&**`sudo zfw -M ziti0`**will show outbound traffic from ziti0 toward wlan0.**)\\n\\n```plaintext\\n\\n16:40:32.365693 IP (tos 0x0, ttl 64, id 30637, offset 0, flags [DF], proto TCP (6), length 60)^M\\n    10.1.1.101.49777 > 100.64.0.13.11095: Flags [S], cksum 0x00f6 (correct), seq 4291868165, win 29200, options [mss 1460,sackOK,TS val 4294951336 ecr 0,nop,wscale 6], length 0^M\\n16:40:32.365693 IP (tos 0x0, ttl 64, id 30637, offset 0, flags [DF], proto TCP (6), length 60)^M\\n    10.1.1.101.49777 > 100.64.0.13.11095: Flags [S], cksum 0x00f6 (correct), seq 4291868165, win 29200, options [mss 1460,sackOK,TS val 4294951336 ecr 0,nop,wscale 6], length 0^M\\n16:40:32.378421 IP (tos 0x0, ttl 64, id 56631, offset 0, flags [DF], proto TCP (6), length 60)^M\\n    10.1.1.101.58357 > 100.64.0.13.443: Flags [S], cksum 0x87b1 (correct), seq 445914269, win 29200, options [mss 1460,sackOK,TS val 4294951338 ecr 0,nop,wscale 6], length 0^M\\n16:41:14.039751 IP (tos 0x0, ttl 64, id 47285, offset 0, flags [DF], proto UDP (17), length 66)^M\\n    100.64.0.2.53 > 10.1.1.101.45988: 58194- 1/0/1 squeakydoor.nest.com. A 100.64.0.14 (65)^M\\n16:40:33.460676 IP (tos 0x0, ttl 64, id 59775, offset 0, flags [DF], proto TCP (6), length 60)^M\\n    10.1.1.101.33943 > 100.64.0.14.443: Flags [S], cksum 0x4ad5 (correct), seq 2811571049, win 29200, options [mss 1460,sackOK,TS val 4294951446 ecr 0,nop,wscale 6], length 0^M\\n16:40:34.423395 IP (tos 0x0, ttl 254, id 14729, offset 0, flags [none], proto UDP (17), length 89)^M\\n    100.64.0.2.53 > 10.1.1.101.45988: 18020- 1/0/1 weather.nest.com. A 100.64.0.15 (61)^M\\n16:40:34.437242 IP (tos 0x0, ttl 64, id 30277, offset 0, flags [DF], proto TCP (6), length 60)^M\\n    10.1.1.101.59756 > 100.64.0.15.443: Flags [S], cksum 0x8ee1 (correct), seq 1971893298, win 29200, options [mss 1460,sackOK,TS val 4294951543 ecr 0,nop,wscale 6], length 0^M\\n16:40:35.420819 IP (tos 0x0, ttl 254, id 14758, offset 0, flags [none], proto UDP (17), length 97)^M\\n    100.64.0.2.53 > 10.1.1.101.45988: 44500- 1/0/1 logsink.devices.nest.com. A 100.64.0.16 (69)^M\\n16:40:35.426899 IP (tos 0x0, ttl 64, id 29036, offset 0, flags [DF], proto TCP (6), length 60)^M\\n    10.1.1.101.35782 > 100.64.0.16.443: Flags [S], cksum 0x9e81 (correct), seq 3282351031, win 29200, options [mss 1460,sackOK,TS val 4294951643 ecr 0,nop,wscale 6], length 0^M\\n16:41:07.844013 IP (tos 0x0, ttl 254, id 14876, offset 0, flags [none], proto UDP (17), length 86)^M\\n    100.64.0.2.53 > 10.1.1.101.56984: 11018- 1/0/1 time.nest.com. A 100.64.0.17 (58)^M\\n16:41:07.998713 IP (tos 0x0, ttl 254, id 14878, offset 0, flags [none], proto UDP (17), length 92)^M\\n    100.64.0.2.53 > 10.1.1.101.56609: 25412- 1/0/1 clients3.google.com. A 100.64.0.18 (64)^M\\n16:41:08.006201 IP (tos 0x0, ttl 64, id 34792, offset 0, flags [DF], proto TCP (6), length 60)^M\\n    10.1.1.101.58729 > 100.64.0.18.80: Flags [S], cksum 0xaac1 (correct), seq 768676994, win 29200, options [mss 1460,sackOK,TS val 4294939498 ecr 0,nop,wscale 6], length 0^M\\n16:41:15.213276 IP (tos 0x0, ttl 64, id 24325, offset 0, flags [DF], proto UDP (17), length 76)^M\\n    10.1.1.101.43410 > 100.64.0.17.123: NTPv4, Client, length 48^M\\n```\\n\\nThis output indicates that in addition to TCP port 443 we also need to add port 80 and 11095 as well as UDP port 123. So we need to add 80 and 11095 to our existing service configs. And we need to create a new config for the UDP connection.\\n\\nWe would then perform the following:\\n\\nConnect to the controller\\n\\n```plaintext\\nzitiLogin\\n```\\n\\nUpdate invercept.V1 config\\n\\n```plaintext\\nziti edge update config iot-nest-intercept-config-tcp -d \'{\\"protocols\\": [\\"tcp\\"], \\"addresses\\": [\\"*.nest.com\\",\\"*.google.com\\"], \\"portRanges\\": [{\\"low\\":80, \\"high\\": 80},{\\"low\\":443, \\"high\\": 443}, {\\"low\\":11095, \\"high\\": 11095}]}\'\\n```\\n\\nUpdate host.v1 config\\n\\n```plaintext\\nziti edge update config iot-nest-host-config-tcp -d \'{\\"allowedPortRanges\\":[{\\"low\\":80, \\"high\\": 80},{\\"low\\": 443,\\"high\\": 443}, {\\"low\\":11095, \\"high\\": 11095}], \\"allowedAddresses\\":[\\"*.nest.com\\",\\"*.google.com\\"], \\"forwardAddress\\":true,\\"forwardPort\\":true,\\"protocol\\":\\"tcp\\"}\'\\n```\\n\\nCreate UDP config and service:\\n\\nCreate the intercept.v1 config for udp port 123\\n\\n```plaintext\\nziti edge create config iot-nest-intercept-config-udp intercept.v1 \'{\\"protocols\\": [\\"udp\\"], \\"addresses\\": [\\"*.nest.com\\"], \\"portRanges\\": [{\\"low\\":123, \\"high\\": 123}]}\'\\n```\\n\\nCreate host.v1 config\\n\\n```plaintext\\nziti edge create config iot-nest-host-config-udp host.v1 \'{\\"allowedPortRanges\\":[{\\"low\\": 123,\\"high\\": 123}], \\"allowedAddresses\\":[\\"*.nest.com\\"], \\"forwardAddress\\":true,\\"forwardPort\\":true,\\"protocol\\":\\"udp\\"}\'\\n```\\n\\nCreate a udp service (with tag: nest-iot01-server)\\n\\n```plaintext\\nziti edge create service iot-nest-service-udp -c iot-nest-intercept-config-udp,iot-nest-host-config-udp -a nest-iot01-server\\n```\\n\\nContinue to discover new protocols.\\n\\n```plaintext\\nsudo tcpdump -nNi wlan0 -v\\n```\\n\\nExample output (**new DNS domain name** discovery)\\n\\n```plaintext\\n16:48:01.822923 IP (tos 0x0, ttl 64, id 49569, offset 0, flags [DF], proto UDP (17), length 84)\\n    10.1.1.101.36869 > 100.64.0.2.53: 48147+ A? 239.112.73.34.bc.googleusercontent.com. (56)\\n```\\n\\nIn this output, we discovered the nest device is trying to reach \\\\*.googleusercontent.com. So we need to add this domain to our existing TCP service configs.\\n\\nConnect to the controller\\n\\n```plaintext\\nzitiLogin\\n```\\n\\nUpdate invercept.V1 config\\n\\n```plaintext\\nziti edge update config iot-nest-intercept-config-tcp -d \'{\\"protocols\\": [\\"tcp\\"], \\"addresses\\": [\\"*.nest.com\\",\\"*.google.com\\",\\"*.googleusercontent.com\\"], \\"portRanges\\": [{\\"low\\": 80,\\"high\\": 80},{\\"low\\":443, \\"high\\": 443},{\\"low\\":11095, \\"high\\": 11095}]}\'\\n```\\n\\nUpdate host.v1 config\\n\\n```plaintext\\nziti edge update config iot-nest-host-config-tcp -d \'{\\"allowedPortRanges\\":[{\\"low\\": 80,\\"high\\": 80},{\\"low\\": 443,\\"high\\": 443},{\\"low\\":11095, \\"high\\": 11095}], \\"allowedAddresses\\":[\\"*.nest.com\\",\\"*.google.com\\",\\"*.googleusercontent.com\\"], \\"forwardAddress\\":true,\\"forwardPort\\":true,\\"protocol\\":\\"tcp\\"}\'\\n```\\n\\nNow check to see what port(s) are being used by `4.68.185.35.bc.googleusercontent.com`\\n\\nnslookup `4.68.185.35.bc.googleusercontent.com`\\n\\n```plaintext\\nnslookup  4.68.185.35.bc.googleusercontent.com\\nServer:\\t\\t127.0.0.53\\nAddress:\\t127.0.0.53#53\\n\\nNon-authoritative answer:\\nName:\\t4.68.185.35.bc.googleusercontent.com\\nAddress: 100.64.0.22\\n```\\n\\n```plaintext\\nsudo tcpdump -nNi wlan0 -v host 100.64.0.22\\n```\\n\\nHere we see a new resolved ip 100.64.0.22 with TCP destination port 11095\\n\\n```plaintext\\n16:48:06.858236 IP (tos 0x0, ttl 254, id 15176, offset 0, flags [none], proto TCP (6), length 40)\\n    100.64.0.22.11095 > 10.1.1.101.34576: Flags [R.], cksum 0xdb25 (correct), seq 2514414, ack 1381105441, win 768, length 0\\n```\\n\\nSince the new address is connecting to port 11095 which is already included in the existing service configs we did not need to update the configs again.\\n\\nRepeat discovery for each new IoT device type added to the wi-lan in series or parallel.\\n\\n## Conclusion:\\n\\nIn this article, we have shown how OpenZiti can be deployed on a Wi-Fi Raspberry Pi 4 access point to provide IoT device isolation and web filtering.\xa0 We welcome any comments on this OpenZiti use case."},{"id":"zrok-with-the-power-of-caddy","metadata":{"permalink":"/docs/openziti/blog/zrok-with-the-power-of-caddy","source":"@site/blog/zrok-with-the-power-of-caddy.md","title":"zrok with the Power of Caddy","description":"It\'s that time again... we\'ve just dropped a new zrok release! This time the marquee features are based on","date":"2023-09-08T15:24:23.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"Peer-to-Peer","permalink":"/docs/openziti/blog/tags/peer-to-peer","description":"Peer-to-peer networking"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":8.23,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"zrok with the Power of Caddy","date":"2023-09-08T15:24:23.000Z","cuid":"clmaqzvmg000808l2b8ij7yw8","slug":"zrok-with-the-power-of-caddy","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1694020472308/0ab25cb6-f4ef-4227-b487-5bc6a0b5c621.png","imageDark":"@site/blogs/openziti/v1694020472308/0ab25cb6-f4ef-4227-b487-5bc6a0b5c621.png","tags":["security","networking","peer-to-peer","openziti","zrok"]},"unlisted":false,"prevItem":{"title":"OpenZiti Zero Trust IoT Wi-Fi Gateway","permalink":"/docs/openziti/blog/openziti-zero-trust-iot-wi-fi-gateway"},"nextItem":{"title":"The zrok SDK","permalink":"/docs/openziti/blog/the-zrok-sdk"}},"content":"It\'s that time again... we\'ve just dropped a new `zrok` release! This time the marquee features are based on \\nCaddy (https://caddyserver.com/). Caddy is a powerful Swiss Army Knife for serving and proxying HTTP resources, \\nand we\'ve integrated that power into the `zrok` ecosystem.\\n\\n\x3c!-- truncate --\x3e\\n\\n# The Open-ended Caddyfile\\n\\n`zrok` provides a new `caddy` backend mode, which allows you to utilize the full capabilities of Caddy in the `zrok` environment. This power is exposed through a Caddy feature called a `Caddyfile`. A `Caddyfile` is an expressive, powerful mechanism for configuring the different features available in Caddy.\\n\\nLet\'s look at an example of a `Caddyfile`:\\n\\n```apache\\nhttp:// {\\n\\tbind {{ .ZrokBindAddress }}\\n\\treverse_proxy 127.0.0.1:3000\\n}\\n```\\n\\nThis example `Caddyfile` provides a simple reverse proxy implementation that works very much like the `proxy` backend mode. `zrok` will automatically rewrite the `{{ .ZrokBindAddress }}` token in the `bind` statement with the correct address for your share. This happens automatically when `zrok` loads the `Caddyfile` you specify as the target for the `caddy` backend mode.\\n\\nThis example `Caddyfile` is located at `etc/caddy/simple_reverse_proxy.Caddyfile` in the `zrok` repository on GitHub ([https://github.com/openziti/zrok](https://github.com/openziti/zrok)). We can run this example from an enabled `zrok` environment like this:\\n\\n```plaintext\\n\\n$ zrok share public --backend-mode caddy etc/caddy/simple_reverse_proxy.Caddyfile \\n[   0.069]    INFO main.(*sharePublicCommand).run: access your zrok share at the following endpoints:\\n https://3s9fddkilbi6.share.zrok.io\\n2023/09/06 18:12:43.582\\tINFO\\tadmin\\tadmin endpoint started\\t{\\"address\\": \\"localhost:2019\\", \\"enforce_origin\\": false, \\"origins\\": [\\"//localhost:2019\\", \\"//[::1]:2019\\", \\"//127.0.0.1:2019\\"]}\\n2023/09/06 18:12:43.583\\tWARN\\thttp.auto_https\\tserver is listening only on the HTTP port, so no automatic HTTPS will be applied to this server\\t{\\"server_name\\": \\"srv0\\", \\"http_port\\": 80}\\n2023/09/06 18:12:43.583\\tINFO\\ttls.cache.maintenance\\tstarted background certificate maintenance\\t{\\"cache\\": \\"0xc000166c00\\"}\\n2023/09/06 18:12:43.584\\tINFO\\ttls\\tcleaning storage unit\\t{\\"description\\": \\"FileStorage:/home/michael/.local/share/caddy\\"}\\n2023/09/06 18:12:43.584\\tINFO\\ttls\\tfinished cleaning storage units\\n2023/09/06 18:12:43.636\\tINFO\\thttp.log\\tserver running\\t{\\"name\\": \\"srv0\\", \\"protocols\\": [\\"h1\\", \\"h2\\", \\"h3\\"]}\\n2023/09/06 18:12:43.636\\tINFO\\tautosaved config (load with --resume flag)\\t{\\"file\\": \\"/home/michael/.config/caddy/autosave.json\\"}\\n[   0.127]    INFO sdk-golang/ziti.(*listenerManager).createSessionWithBackoff: {session token=[2a9ca2d1-21c2-4516-8b03-ffdd789283e6]} new service session\\n```\\n\\nNotice that we\'ve used `--backend-mode caddy` and the target of our share is the path to our `Caddyfile`.\\n\\n`zrok` logs the ephemeral share URL: `https://3s9fddkilbi6.share.zrok.io`\\n\\nIf we access the URL with `curl`, we get the following result:\\n\\n```bash\\n$ curl https://3s9fddkilbi6.share.zrok.io\\nInvalid Host header\\n```\\n\\nIn my environment, the \\"upstream\\" target specified in the `Caddyfile` is `127.0.0.1:3000`, which corresponds to my local `npm` development server. Evidently this `npm` development server does not like to have a reverse proxy in front of it. If we rewrite the `Host` header hiding the fact that it\'s being proxied, we might get a different result.\\n\\nCaddy supports a `header_up` directive nested within the `reverse_proxy` statement, which allows for \\"upstream\\" (traffic on its way to the proxied \\"backend\\") header rewriting. Let\'s try setting the `Host` header to make it look like the server is being accessed from `localhost:3000`:\\n\\n```apache\\nhttp:// {\\n\\tbind {{ .ZrokBindAddress }}\\n\\treverse_proxy 127.0.0.1:3000 {\\n\\t    header_up Host localhost:3000\\n\\t}\\n}\\n```\\n\\nIf we restart our share and `curl` the new URL, we get:\\n\\n```plaintext\\n$ curl http://e52lx23k7qgq.share.zrok.io\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n  <head>\\n    <meta charset=\\"utf-8\\" />\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1\\" />\\n    <meta name=\\"theme-color\\" content=\\"#000000\\" />\\n    <meta name=\\"description\\" content=\\"zrok ui\\"/>\\n...\\n```\\n\\nThis works! Now the `npm` development server thinks it\'s being accessed from `localhost:3000`.\\n\\nHeader rewriting is the first Caddy capability we\'ve added that goes beyond the built-in `--backend-mode proxy` in `zrok`. But there are tons and tons of other things we can do with the `caddy` backend mode.\\n\\nLet\'s look at a more complex example...\\n\\n## Multiple Upstream Backends\\n\\nThere are many reasons why you might want to utilize multiple upstream backends with a `zrok` share. You might want:\\n\\n* to distribute load across multiple backends, horizontally scaling the workload between multiple systems\\n    \\n* to aggregate multiple microservice backends into a single combined API\\n    \\n* to enforce additional security or performance constraints on the shared resources\\n    \\n* to provide fault tolerance, allowing one or more backends to fail before the shared service becomes unavailable\\n    \\n\\nLet\'s take a look at a simple example using the `caddy` backend mode to route traffic to two different backends:\\n\\n```apache\\nhttp:// {\\n    # Bind to the zrok share\\n\\tbind {{ .ZrokBindAddress }}\\n\\n    # Handle paths starting with `/zrok/*`\\n    # This will also strip the `/zrok/` from the path before sending to the backend\\n\\thandle_path /zrok/* {\\n\\t    reverse_proxy https://zrok.io {\\n\\t        header_up Host zrok.io\\n\\t    }\\n\\t}\\n\\n\\t# All other traffic goes to localhost:3000\\n\\treverse_proxy /* 127.0.0.1:3000 {\\n\\t\\theader_up Host localhost:3000\\n\\t}\\n}\\n```\\n\\nJust like the first example, we bind our configuration to `{{ .ZrokBindAddress }}`. But in this case, we\'ve added a second `reverse_proxy` statement. The new `reverse_proxy` statement is wrapped in a `handle_path` block. Wrapping the `reverse_proxy` statement with the `handle_path` causes Caddy to strip the `/zrok` path prefix before sending the request upstream to the backend. And like before, we\'re replacing the `Host` header to direct the traffic to the correct website instance (`zrok.io`).\\n\\nWe\'ve qualified the existing `reverse_proxy` statement with `/*` to direct all other traffic to the backend at `localhost:3000`.\\n\\nLet\'s see what happens when we send some traffic to this new Caddyfile. We\'ll share it using `zrok share`:\\n\\n```plaintext\\n$ zrok share public --backend-mode caddy etc/caddy/multiple_upstream.Caddyfile \\n[   0.296] WARNING zrok/endpoints/proxy.NewCaddyfileBackend: etc/caddy/multiple_upstream.Caddyfile [4] (): Caddyfile input is not formatted; run \'caddy fmt --overwrite\' to fix inconsistencies\\n[   0.296]    INFO main.(*sharePublicCommand).run: access your zrok share at the following endpoints:\\n https://u7cncngzhohb.share.zrok.io\\n2023/09/07 18:10:20.324\\tINFO\\tadmin\\tadmin endpoint started\\t{\\"address\\": \\"localhost:2019\\", \\"enforce_origin\\": false, \\"origins\\": [\\"//localhost:2019\\", \\"//[::1]:2019\\", \\"//127.0.0.1:2019\\"]}\\n2023/09/07 18:10:20.324\\tWARN\\thttp.auto_https\\tserver is listening only on the HTTP port, so no automatic HTTPS will be applied to this server\\t{\\"server_name\\": \\"srv0\\", \\"http_port\\": 80}\\n2023/09/07 18:10:20.325\\tINFO\\ttls.cache.maintenance\\tstarted background certificate maintenance\\t{\\"cache\\": \\"0xc0005ff880\\"}\\n2023/09/07 18:10:20.325\\tINFO\\ttls\\tcleaning storage unit\\t{\\"description\\": \\"FileStorage:/home/michael/.local/share/caddy\\"}\\n2023/09/07 18:10:20.325\\tINFO\\ttls\\tfinished cleaning storage units\\n2023/09/07 18:10:20.549\\tINFO\\thttp.log\\tserver running\\t{\\"name\\": \\"srv0\\", \\"protocols\\": [\\"h1\\", \\"h2\\", \\"h3\\"]}\\n2023/09/07 18:10:20.550\\tINFO\\tautosaved config (load with --resume flag)\\t{\\"file\\": \\"/home/michael/.config/caddy/autosave.json\\"}\\n[   0.549]    INFO sdk-golang/ziti.(*listenerManager).createSessionWithBackoff: {session token=[c16288b6-401e-4e0c-bacf-1661c5badd59]} new service session\\n```\\n\\nIf we curl our new share URL, `https://u7cncngzhohb.share.zrok.io`, we get this:\\n\\n```plaintext\\n$ curl https://u7cncngzhohb.share.zrok.io\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n  <head>\\n    <meta charset=\\"utf-8\\" />\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1\\" />\\n    <meta name=\\"theme-color\\" content=\\"#000000\\" />\\n    <meta name=\\"description\\" content=\\"zrok ui\\"/>\\n    \x3c!--\\n      manifest.json provides metadata used when your web app is installed on a\\n      user\'s mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\\n    --\x3e\\n...\\n```\\n\\nAnd we can see that this is a response from our development `npm` server running on `localhost:3000`.\\n\\nIf we access a path starting with `/zrok`, we get this:\\n\\n```plaintext\\n$ curl https://u7cncngzhohb.share.zrok.io/zrok/\\n<!DOCTYPE html>\\n<html lang=\\"en-US\\">\\n<head>\\n    <meta http-equiv=\\"Content-Type\\" content=\\"text/html;charset=UTF-8\\">\\n    <meta id=\\"siteViewport\\" name=\\"viewport\\" content=\\"width=device-width, initial-scale=1, maximum-scale=1\\">\\n    <link rel=\\"profile\\" href=\\"https://gmpg.org/xfn/11\\">\\n    <meta name=\'robots\' content=\'index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1\' />\\n\\n\\t\x3c!-- This site is optimized with the Yoast SEO plugin v20.12 - https://yoast.com/wordpress/plugins/seo/ --\x3e\\n\\t<title>Home - zrok</title>\\n...\\n```\\n\\nThis is the HTML from the `zrok.io` website.\\n\\nBe sure to check out the Caddy [reference documentation](https://caddyserver.com/docs/caddyfile) for even more possibilities for the `caddy` backend mode!\\n\\n# Improved Web and File Sharing\\n\\n`zrok` provides a `web` backend mode for sharing files. In this mode, `zrok` behaves as if it is a traditional web server hosting static content on a filesystem. You can use this mode to share arbitrary files like documents, or code, or binaries. When sharing a tree of files like this, `zrok` provides a handy user interface to navigate the tree and download files.\\n\\nAlternatively, if the tree of files contains `index.html` in any of the folders, the built-in file browser is suppressed, and the `index.html` is returned instead. This mimics the behavior of a traditional web server like Apache or nginx. This means you can use `--backend-mode web` to serve arbitrary directories containing files, and you can also use it to host static websites.\\n\\n`I`n the new `v0.4.6` release of `zrok`, the `--backend-mode web` sharing mode has been improved to utilize Caddy for this function.\\n\\nHere\'s what it looks like:\\n\\n![](/blogs/openziti/v1694111195934/b31243c9-c793-4873-9319-506aec9e312b.gif)\\n\\nCaddy gives `zrok` a much nicer-looking file server experience. Built-in searching. Better MIME types. All together this makes for a much smoother and nicer experience.\\n\\nThere\'s a longer format \\"office hours\\" video dedicated to this new integration with Caddy. Check it out for a more leisurely stroll through these features, along with a little `zrok` debugging:\\n\\n%[https://youtu.be/zgP9wLSESl4]\\n\\n# Conclusion\\n\\nBringing Caddy into `zrok` is a powerful new capability enabling lots of new sharing features. The new `web` backend mode implementation is just the first of many user experience and quality-of-life improvements we have planned for `zrok` users.\\n\\nBefore we\'re done with the Caddy integration, we plan on enhancing the `zrok access` functionality to allow you to use the powerful HTTPS certificate management and request routing capabilities on the frontend side of `zrok`. Imagine aggregating multiple `zrok` shares into a single `zrok access` command with fault-tolerance and failover capabilities!\\n\\nAnd stay tuned for the new \\"`zrok` Drives\\" features. We\'re pretty excited about the doors that are going to open when it\'s released!"},{"id":"the-zrok-sdk","metadata":{"permalink":"/docs/openziti/blog/the-zrok-sdk","source":"@site/blog/the-zrok-sdk.md","title":"The zrok SDK","description":"Hopefully, you\'re already familiar with zrok, our open-source solution for easy and secure sharing. If you\'re not,","date":"2023-08-23T20:09:05.000Z","tags":[{"inline":false,"label":"Developer","permalink":"/docs/openziti/blog/tags/developer","description":"Developer topics"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":7.09,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"The zrok SDK","date":"2023-08-23T20:09:05.000Z","cuid":"cllo64dtc000n09mc96du917a","slug":"the-zrok-sdk","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1692720007733/fa2b143a-5887-4e7a-9476-a3d531ab662b.png","imageDark":"@site/blogs/openziti/v1692720007733/fa2b143a-5887-4e7a-9476-a3d531ab662b.png","tags":["developer","networking","openziti","zerotrust","zrok"]},"unlisted":false,"prevItem":{"title":"zrok with the Power of Caddy","permalink":"/docs/openziti/blog/zrok-with-the-power-of-caddy"},"nextItem":{"title":"Got 5 Minutes? Secure Your Python Website with Zero Trust.","permalink":"/docs/openziti/blog/got-5-minutes-secure-your-python-website-with-zero-trust"}},"content":"Hopefully, you\'re already familiar with `zrok`, our open-source solution for easy and secure sharing. If you\'re not, \\ncheck out the initial post [introducing `zrok`](https://hashnode.com/post/cldue515r000509l04jhy0c8q). There\'s also a \\nmore recent post describing some of the new \\n[features in the latest v0.4.0 version](https://hashnode.com/post/cljen4m08000009li4hl1fz7c).\\n\\n\x3c!-- truncate --\x3e\\n\\n`zrok` is an open-source, self-hostable platform combined with a frictionless command-line client, that makes sharing resources like HTTP servers, TCP and UDP tunnels, and files simple, fast, and secure.\\n\\nIf you\'d like to get started with `zrok`, but don\'t want to self-host, you can sign up for a free account at [https://zrok.io/](https://zrok.io/).\\n\\nCheck out the [Getting Started](https://docs.zrok.io/docs/getting-started/) guide for more information.\\n\\n## Introducing the zrok SDK\\n\\nAs of `v0.4.3`, `zrok` ships with an SDK for creating your own custom applications and integrations. The same simple, secure sharing model used for sharing network resources and files can be extended to work for your custom tools.\\n\\nThe best way to understand how the SDK works is to take a look at the example application that ships with the SDK.\\n\\nThe example application is based on a \\"distributed copy/paste buffer\\" idea that we\'ve called a \\"pastebin\\". It exists as two command-line applications, [`copyto`](https://github.com/openziti/zrok/blob/main/sdk/examples/pastebin/cmd/copyto/main.go) ([full source listing](https://github.com/openziti/zrok/blob/main/sdk/examples/pastebin/cmd/copyto/main.go)) and [`pastefrom`](https://github.com/openziti/zrok/blob/main/sdk/examples/pastebin/cmd/pastefrom/main.go) ([full source listing](https://github.com/openziti/zrok/blob/main/sdk/examples/pastebin/cmd/pastefrom/main.go)). The `copyto` utility accepts data through standard input and makes it available as a `zrok` share. The `pastefrom` utility emits a pastebin buffer shared from the `copyto` utility to its standard output.\\n\\n> Side note: the \\"pastebin\\" concept will probably be expanded into a super-convenient, friction-free copy/paste wormhole for all of your `zrok`\\\\-enabled environments in a future release. The expanded version will be included in the regular complement of `zrok` tools.\\n\\nHere\'s what the `copyto` utility looks like in action. We\'re running this from a `zrok`\\\\-enabled shell:\\n\\n```bash\\n$ echo \\"oh, wow!\\" | copyto\\naccess your pastebin using \'pastefrom 1v55r7l10xky\'\\n```\\n\\nWe\'ve piped the text `oh, wow!` into the pastebin buffer of `copyto`. Then `copyto` responds with the corresponding `pastefrom` command (including the share token that was created) that can be used to access the share. This `pastefrom` command can be executed from any other `zrok`\\\\-enabled shell environment:\\n\\n```bash\\n$ pastefrom 1v55r7l10xky\\noh, wow!\\n```\\n\\n`pastefrom` accesses the pastebin offered by `copyto` and emits it to its standard output.\\n\\nNeither `copyto` nor `pastefrom` require any network security accommodations. No firewall rules or holes. They both connect from your local environment to the OpenZiti zero-trust network overlay used by `zrok`:\\n\\n![](/blogs/openziti/v1692807490897/adc76ef9-ead1-4453-82d2-f79839d18c14.png)\\n\\nOnce connectivity is established with the overlay, an end-to-end encrypted network tunnel is established between `copyto` and `pastefrom` to securely transfer the pastebin buffer contents between them.\\n\\n![](/blogs/openziti/v1692812967928/96a6f7e6-1aae-434d-9065-52a78ecfaa32.png)\\n\\nHitting `CTRL-C` to exit the `copyto` utility will automatically clean up the `zrok` share that it created. Then trying to access the pastebin buffer with the same share token will result in an error:\\n\\n```bash\\n$ pastefrom 1v55r7l10xky\\npanic: unable to create access: [POST /access][404] accessNotFound\\n```\\n\\nSo our pastebin example works just like any other ephemeral `zrok` share.\\n\\n### copyto\\n\\nLet\'s take a look at the implementation of the `copyto` application. This is the `main` function:\\n\\n```go\\nfunc main() {\\n\\tdata, err := loadData()\\n    // error handling\\n\\n\\troot, err := environment.LoadRoot()\\n    // error handling\\n\\n\\tshr, err := sdk.CreateShare(root, &sdk.ShareRequest{\\n\\t\\tBackendMode: sdk.TcpTunnelBackendMode,\\n\\t\\tShareMode:   sdk.PrivateShareMode,\\n\\t\\tTarget:      \\"pastebin\\",\\n\\t})\\n    // error handling\\n\\n\\tfmt.Printf(\\"access your pastebin using \'pastefrom %v\'\\\\n\\", shr.Token)\\n\\n\\tlistener, err := sdk.NewListener(shr.Token, root)\\n    // error handling\\n\\n    // shutdown hook\\n\\tc := make(chan os.Signal)\\n\\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\\n\\tgo func() {\\n\\t\\t<-c\\n\\t\\tif err := sdk.DeleteShare(root, shr); err != nil {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\t\\t_ = listener.Close()\\n\\t\\tos.Exit(0)\\n\\t}()\\n\\n    // main connection handling loop\\n\\tfor {\\n\\t\\tif conn, err := listener.Accept(); err == nil {\\n\\t\\t\\tgo handle(conn, data)\\n\\t\\t} else {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nFirst, the `copyto` application loads the `pastebin` buffer from standard input using the `loadData` function ([see the `loadData` function listing](https://github.com/openziti/zrok/blob/349d251c84611f3e24ca6b3b6128eb6a30ab1692/sdk/examples/pastebin/cmd/copyto/main.go#L68)).\\n\\nAll `zrok` SDK applications utilize the enabled environment (via `zrok enable`) in the user\'s shell to provide identity and access control details. `zrok` SDK applications work alongside the built-in `zrok` CLI functions.\\n\\nThe `environment.LoadRoot` call retrieves the necessary details from the user\'s enabled environment.\\n\\nWith the root loaded, we can call `sdk.CreateShare` (passing in the loaded `root`) to create a share for our new pastebin buffer. We\'re advertising our application as a TCP tunnel backend (`sdk.TcpTunnelBackendMode`), utilizing a private share (`sdk.PrivateShareMode`). We\'ve described the target as `pastebin`, the name of our application.\\n\\nNow that we\'ve got the share created, the `sdk.NewListener` call is all that is required to create an inbound listener for connections to this application over the secure OpenZiti overlay network.\\n\\nThe code wrapping the `sdk.DeleteShare` call is just a \\"shutdown hook\\", listening for an operating system signal (`SIGTERM`) to execute our goroutine that deletes the share we created with `sdk.CreateShare`. This just causes `copyto` to delete the share it created when the user exits with `CTRL-C`, or otherwise terminates the process.\\n\\nAnd finally the `for {}` loop wraps around a call to `listener.Accept`, which accepts inbound connections, dispatching them to the `handle` function ([see the `handle` function listing](https://github.com/openziti/zrok/blob/349d251c84611f3e24ca6b3b6128eb6a30ab1692/sdk/examples/pastebin/cmd/copyto/main.go#L81)). This is the main connection handling loop for `copyto`, which runs until terminated.\\n\\n### pastefrom\\n\\nThe `pastefrom` application is a simple client that works similarly to the `zrok access`command. `pastefrom` accesses the share created by `copyto` and emits the pastebin buffer to standard output.\\n\\nLet\'s take a look at the `main` function from `pastefrom`:\\n\\n```go\\nfunc main() {\\n\\tif len(os.Args) < 2 {\\n\\t\\tpanic(\\"usage: pastefrom <shrToken>\\")\\n\\t}\\n\\tshrToken := os.Args[1]\\n\\n\\troot, err := environment.LoadRoot()\\n    // error handling\\n\\n\\tacc, err := sdk.CreateAccess(root, &sdk.AccessRequest{ShareToken: shrToken})\\n    // error handling  \\n\\n    // deferred access cleanup\\n\\tdefer func() {\\n\\t\\tif err := sdk.DeleteAccess(root, acc); err != nil {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\t}()\\n\\n\\tconn, err := sdk.NewDialer(shrToken, root)\\n    // error handling\\n\\tdefer func() {\\n\\t\\t_ = conn.Close()\\n\\t}()\\n\\n\\tbuf := make([]byte, MAX_PASTE_SIZE)\\n\\tn, err := conn.Read(buf)\\n    // error handling\\n\\n\\tfmt.Printf(string(buf[:n]))\\n}\\n```\\n\\nFirst, a little command-line argument handling. As we saw in the example output of `copyto`, `pastefrom` expects the share token emitted by `copyto` to be provided as the first command-line argument.\\n\\nJust like all `zrok` SDK applications, we call `environment.LoadRoot` to load the user\'s environment details.\\n\\nNext we call `sdk.CreateAccess` to allow `pastefrom` to access the share created by `copyto`. Then we `defer` a call to `sdk.DeleteAccess` to clean up the access when `pastefrom` terminates.\\n\\nThe call to `sdk.NewDialer`creates an outbound connection to the `copyto` application through the underlying OpenZiti network.\\n\\nFinally the pastebin buffer data is read from the connection using `conn.Read`, and then the data is emitted to standard output using `fmt.Printf`.\\n\\n> A deeper dive: There is a deeper dive into the `zrok` SDK and this example application in the `zrok` Office Hours video from July 27th:\\n\\n%[https://www.youtube.com/watch?v=T-sXQXG5xvE] \\n\\n## Under the Hood\\n\\nThe `zrok` SDK is an opinionated set of convenience wrappers around the `zrok` API and the OpenZiti SDK. Applications built using the `zrok` SDK will interoperate with the built-in `zrok` functionality and will automatically benefit from the same simple, secure, friction-free model used throughout the `zrok` ecosystem.\\n\\n`zrok` SDK applications can grow to exploit the full spectrum of capabilities provided by OpenZiti and its SDKs.\\n\\nAt the core of these SDKs are the familiar `net.Conn` and `net.Listener` concepts that will be familar to every network programmer working in golang.\\n\\nA follow-up blog post and `zrok` Office Hours video will be coming out later this year that will dive more deeply into how `zrok` works, and what it\'s doing to build on top of OpenZiti. This deeper dive will allow explain how purely native OpenZiti applications can interoperate with `zrok` SDK applications and the `zrok` ecosystem.\\n\\n## Support for Other Programming Languages\\n\\nThe `zrok` SDK currently supports `golang`. Support for other languages is forthcoming. If you\'d like to express interest in having the `zrok` SDK support other languages, reach out to us on our [Discourse](https://openziti.discourse.group/c/zrok/24).\\n\\nIf you like `zrok` and want to support its continued development, please drop a star on our [repository on GitHub](https://github.com/openziti/zrok), it means a lot to us."},{"id":"got-5-minutes-secure-your-python-website-with-zero-trust","metadata":{"permalink":"/docs/openziti/blog/got-5-minutes-secure-your-python-website-with-zero-trust","source":"@site/blog/got-5-minutes-secure-your-python-website-with-zero-trust.md","title":"Got 5 Minutes? Secure Your Python Website with Zero Trust.","description":"I have a website I built using Django; it\'s just a personal site meant to be used by friends and family. This makes it a perfect fit for zero trust as, I can hide it from the world and hand out specific access to friends and family I want to allow to use it. The site has all sorts of tools to keep track of things as a family. We have the \\"Tool Pool\\" so each friend or family member can see who has what special tools so they can borrow them instead of buying their own, and it keeps track of who borrowed what. There\'s another called \\"Packer Tracker\\" which keeps track of what you bring on a camping trip (personal or shared trip) so you can review what was missing or isn\'t needed for future trips and see what other people are bringing on a shared trip. There are many others, but, in any case, this site is just a personal site to be used on an invite-only basis, so I don\'t need the world to have access to it, but I do want it publicly available for those using it. So, I spun up an Oracle cloud instance (totally free \\"forever\\") and hosted it there. Currently, I create an account and send a link to anyone who wants to use it. The problem is it\'s still publicly accessible and prone to security issues from unwanted guests and/or web crawlers. I already have an OpenZiti zero trust network running in another Oracle cloud instance where I\'ve secured my NAS, CCTV, and HomeAssistant access with zero trust, so why not just add this?","date":"2023-08-08T17:24:45.000Z","tags":[{"inline":false,"label":"Python","permalink":"/docs/openziti/blog/tags/python","description":"Python content"},{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"SDK","permalink":"/docs/openziti/blog/tags/sdk","description":"Software Development Kits"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":7.61,"hasTruncateMarker":true,"authors":[{"name":"Geoff Berl","title":"Author","url":"https://github.com/gberl002","imageURL":"https://avatars.githubusercontent.com/gberl002","key":"GeoffBerl","page":null}],"frontMatter":{"title":"Got 5 Minutes? Secure Your Python Website with Zero Trust.","date":"2023-08-08T17:24:45.000Z","cuid":"cll2kn9yd000908mp7xv27s1k","slug":"got-5-minutes-secure-your-python-website-with-zero-trust","authors":["GeoffBerl"],"image":"@site/blogs/openziti/v1681502054184/49a0e1d5-8cf8-46b9-81ce-101311ab78fa.png","imageDark":"@site/blogs/openziti/v1681502054184/49a0e1d5-8cf8-46b9-81ce-101311ab78fa.png","tags":["python","opensource","sdk","openziti"]},"unlisted":false,"prevItem":{"title":"The zrok SDK","permalink":"/docs/openziti/blog/the-zrok-sdk"},"nextItem":{"title":"Announcing the zrok Public Beta!","permalink":"/docs/openziti/blog/announcing-the-zrok-public-beta"}},"content":"I have a website I built using Django; it\'s just a personal site meant to be used by friends and family. This makes it a perfect fit for zero trust as, I can hide it from the world and hand out specific access to friends and family I want to allow to use it. The site has all sorts of tools to keep track of things as a family. We have the \\"Tool Pool\\" so each friend or family member can see who has what special tools so they can borrow them instead of buying their own, and it keeps track of who borrowed what. There\'s another called \\"Packer Tracker\\" which keeps track of what you bring on a camping trip (personal or shared trip) so you can review what was missing or isn\'t needed for future trips and see what other people are bringing on a shared trip. There are many others, but, in any case, this site is just a personal site to be used on an invite-only basis, so I don\'t need the world to have access to it, but I do want it publicly available for those using it. So, I spun up an [Oracle cloud instance](https://www.oracle.com/cloud/) (totally free \\"forever\\") and hosted it there. Currently, I create an account and send a link to anyone who wants to use it. The problem is it\'s still publicly accessible and prone to security issues from unwanted guests and/or web crawlers. I already have an [OpenZiti](https://openziti.github.io/) zero trust network running in another Oracle cloud instance where I\'ve secured my NAS, CCTV, and [HomeAssistant](./zero-trust-overlay-network-to-access-homeassistant.md) access with zero trust, so why not just add this?\\n\\n\x3c!-- truncate --\x3e\\n\\nWell, why not, indeed? But as it stands, my current zero trust resources are using [ZTHA](https://openziti.io/docs/learn/core-concepts/zero-trust-models/ztha) (Zero Trust Host Access) or [ZTNA](https://openziti.io/docs/learn/core-concepts/zero-trust-models/ztna) (Zero Trust Network Access). Since my website is an application I manage, and I control the source, which is written in Python, I thought I would give the [OpenZiti Python SDK](https://github.com/openziti/ziti-sdk-py) a try. Using the SDK will give me [ZTAA](https://openziti.io/docs/learn/core-concepts/zero-trust-models/ztaa) (Zero Trust App Access). Details between the different models can be found [here](https://netfoundry.io/docs/openziti/learn/core-concepts/zero-trust-models/overview), but as a summary, ZTNA is like a basic VPN, where one would have access to something on the network, but unencrypted traffic travels through one or more hosts. ZTHA is more like remote PC access; it narrows that access down to a specific host or IP and port on the network. ZTAA is the most secure; it restricts access down to a specific application, and it\'s integrated into the application, so all data is encrypted before it ever leaves the app. After I incorporate zero-trust on my website, I\'ll have users download the [Ziti Tunneler App](https://netfoundry.io/docs/openziti/reference/tunnelers/) on their desktop or phone, and I\'ll give them an identity file that can be used to grant that user, on that device, access to my website directly, not the network, not the host, but directly into the application itself.\\n\\n![](/blogs/openziti/v1691514336525/4b4a2bed-dffc-47c4-a708-c7f2ded56958.png)\\n\\nIn the image above, I am depicting the Oracle VPS running my existing network. The Controller and an Edge Router reside on this VPS. My phone connects to the network via a tunneler app called Ziti Mobile Edge. Other devices on my Ziti Network would each have their own identity and either tunneler or router to connect to the network. With the Ziti Python SDK, the tunneling is built into the source of my website by using the SDK, no extra router or tunneler is needed. The dashed lines simply show how I set my network up to allow either direct or relayed connection to the Django site, depending on which method is more efficient, but that\'s determined by the controller, so no need to worry about that. Just to clarify, though, I don\'t have to provide multiple routes, I could have skipped the step of giving my \\"Public Edge Router\\" the ability to access the service and, therefore, would only have one path to the site, the direct path.\\n\\n## Get the SDK\\n\\nIf you need an OpenZiti network, check out my [blog article](./setting-up-oracle-cloud-to-host-openziti.md) and set one up, for free, on Oracle. The next step is to integrate OpenZiti into my web application using the `openziti` module from the OpenZiti Python SDK. Anyone with any experience with Python will likely be familiar with `pip`, the Python package manager; let me install the Python SDK.\\n\\n```bash\\npip install openziti\\n```\\n\\n## Determine My Situation\\n\\nMoving on, there are a couple of things to know before going forward. Does my application manage its own sockets? For most people, this will be a simple \\"no,\\" as it is for me. If you manage your own sockets, you can certainly check out the examples; otherwise, you\'ll have to wait for another article.\\n\\n### Decorator vs \\"Code\\"\\n\\nThere are two ways to incorporate OpenZiti; the decorator, or objects using code. Both are super easy, and neither one really has any benefit over the other. It comes down to personal preference, I guess. Do you have a preference? Let me know in the comments.\\n\\nAn example of using the direct code approach looks like this. Here, I would apply a monkey patch to the [`Waitress`](https://pypi.org/project/waitress/) serve function. This essentially forces the waitress module to use the OpenZiti overlay rather than plain old HTTP.\\n\\n```python\\ndef runApp():\\n    with openziti.monkeypatch():\\n        serve(app,host=\'127.0.0.1\',port=18080)\\n```\\n\\nThe decorator avoids messing directly with the function code but is more abstract. This example shows how you run a server using `Waitress`. The `hostIdentity.json` is an identity that has been authorized to host this service `name-of-ziti-service` on the OpenZiti overlay network. With this decorator applied, `waitress` is now serving on `127.0.0.1` port `18080` through the overlay network. Now, port `18080` can be closed on the firewall and traffic will still be allowed, but only through the overlay network.\\n\\n```python\\n@openziti.zitify(bindings={(\'127.0.0.1\', 18080): {\'ztx\': \'hostIdentity.json\', \'service\': \'some.ziti.service\'}})\\ndef runApp():\\n    serve(app,host=\'127.0.0.1\',port=18080)\\n```\\n\\n## The 5-Minute Implementation\\n\\nThe moment you\'ve been waiting for has finally come. Get to the point and show me how to do it already, right?\\n\\n### The Overlay Network\\n\\nAs mentioned, I already have an existing overlay network so all I have to do is create a service, the appropriate service configs, policies, and the identities that I want to have access to host and/or dial my website service. Again, if you don\'t have a network of your own, check out my [blog article](./setting-up-oracle-cloud-to-host-openziti.md), where I set one up totally free on Oracle.\\n\\n```bash\\n# Create and enroll the binding identity\\nziti edge create identity device python.django -a python.django.servers -o python.django.jwt\\nziti edge enroll python.django.jwt\\n\\n# Create the configs and service\\nziti edge create config python.django.interceptv1 intercept.v1 \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"family.tools.ziti\\"], \\"portRanges\\":[{\\"low\\":\'80\', \\"high\\":\'80\'}]}\'\\nziti edge create service family.tools --configs \\"python.django.interceptv1\\"\\n\\n# Create service policies to authorize the identities\\nziti edge create service-policy python.django.bind Bind --service-roles \'@python.django\' --identity-roles \'#family.tools.servers\'\\nziti edge create service-policy python.django.dial Dial --service-roles \'@python.django\' --identity-roles \'#family.tools.clients\'\\n\\n# Update my identity so I can access this service (add family.tools.clients attribute)\\nziti edge update identity geoff.berl -a \\"berlhome.assistant.clients,berlhome.mc.clients,family.tools.clients\\"\\n```\\n\\n### Web Framework\\n\\nMy previous web framework was served up using Waitress thusly (I\'m not going into the details of how to deploy a Django app).\\n\\n```python\\nfrom waitress import serve\\nfrom family_tools_django_site.wsgi import application\\n\\ndef runApp():\\n    serve(application, host=\'127.0.0.1\', port=18080)\\n\\nif __name__ == \'__main__\':\\n    runApp()\\n```\\n\\nHere\'s the best part, this is what my new framework startup code looks like.\\n\\n```python\\nfrom waitress import serve\\nfrom family_tools_django_site.wsgi import application\\nimport openziti\\n\\n@openziti.zitify(bindings={\\n    (\'127.0.0.1\', 18080): {\'ztx\': \'/home/ubuntu/family_tools_django_site/python.django.json\', \'service\': \'family.tools\'}\\n})\\ndef runApp():\\n    serve(application, host=\'127.0.0.1\', port=18080)\\n\\n\\nif __name__ == \'__main__\':\\n    runApp()\\n```\\n\\nLet\'s count the added lines...\\n\\n1. `import openziti`\\n    \\n2. `@openziti.zitify(bindings={(\'127.0.0.1\', 18080): {\'ztx\': \'/home/ubuntu/family_tools_django_site/python.django.json\', \'service\': \'`[`family.tools`](http://family.tools)`\'} })`\\n    \\n\\nAssuming we counted correctly, that\'s two, yes, two lines of code to add zero trust capability to my website, and that includes the import statement.\\n\\n### The Moment of Truth\\n\\nBaBAM!\\n\\n![](/blogs/openziti/v1682352217190/2a924b25-14f4-436d-8e4e-ad2ae7a0e9fa.png)\\n\\n![](/blogs/openziti/v1681415161388/5cf881e1-44b6-4b24-b15b-651ab3972071.png)\\n\\nNow, my website is totally dark to the outside world but it still runs on a public VPS for access anywhere. Only people I trust will be authorized to access my site.\\n\\n## Conclusion\\n\\nIt actually took me less than five minutes since I\'m familiar with the process and had my OpenZiti overlay network up and running. But, I was still extremely impressed at how easily I could add my website to my ever-expanding entourage of private services to which I\'ve been slowly adding zero trust access."},{"id":"announcing-the-zrok-public-beta","metadata":{"permalink":"/docs/openziti/blog/announcing-the-zrok-public-beta","source":"@site/blog/announcing-the-zrok-public-beta.md","title":"Announcing the zrok Public Beta!","description":"zrok is officially in public beta. Feel free to download the latest release of zrok and invite yourself to the public instance using the zrok invite command (there is no longer an invite token requirement):","date":"2023-07-25T15:15:12.000Z","tags":[{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"Peer-to-Peer","permalink":"/docs/openziti/blog/tags/peer-to-peer","description":"Peer-to-peer networking"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":2.61,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"Announcing the zrok Public Beta!","date":"2023-07-25T15:15:12.000Z","cuid":"clkifuqp8000009mmc6jcau1w","slug":"announcing-the-zrok-public-beta","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1690218347002/fb39d742-b2a5-45c8-ab30-f782f588b794.avif","imageDark":"@site/blogs/openziti/v1690218347002/fb39d742-b2a5-45c8-ab30-f782f588b794.avif","tags":["opensource","networking","peer-to-peer","zerotrust","zrok"]},"unlisted":false,"prevItem":{"title":"Got 5 Minutes? Secure Your Python Website with Zero Trust.","permalink":"/docs/openziti/blog/got-5-minutes-secure-your-python-website-with-zero-trust"},"nextItem":{"title":"zrok v0.4.0 Released!","permalink":"/docs/openziti/blog/zrok-v040-released"}},"content":"`zrok` is officially in public beta. Feel free to [download the latest release](https://github.com/openziti/zrok/releases/latest) of `zrok` and invite yourself to the public instance using the `zrok invite` command (there is no longer an invite token requirement):\\n\\n```plaintext\\n$ zrok invite \\n\\nenter and confirm your email address...\\n\\n> michael.quigley@netfoundry.io \\n> michael.quigley@netfoundry.io \\n\\n\\n[_Submit_]\\n\\ninvitation sent to \'michael.quigley@netfoundry.io\'!\\n```\\n\\n\x3c!-- truncate --\x3e\\n\\nAfter you submit your email, you\'ll receive an email with a link to complete your registration through the `zrok` web console.\\n\\n![](/blogs/openziti/v1690217651594/1c8a7251-410a-4134-8b1f-ad2ea28fcacb.png)\\n\\nAfter you\'ve logged in through the web console, use the \\"Enable Your Environment\\" function in the drop-down menu by clicking on your email address. The Enable Your Environment dialog contains a shortcut to the `zrok enable` command that you\'ll use to link your shell environment to your `zrok` account.\\n\\n![](/blogs/openziti/v1690217712774/3bce830b-2848-4466-9e5b-6ab7db442974.png)\\n\\nOnce your shell environment is enabled, you\'re free to create and access shares. See the [getting started guide](https://docs.zrok.io/docs/getting-started) for more details.\\n\\nThis public beta includes all of the capabilities of `zrok`, including HTTP endpoint sharing, file and website sharing, and the new [TCP and UDP \\"tunnel\\" capability](https://docs.zrok.io/docs/concepts/tunnels/) recently introduced in the `v0.4.0` release.\\n\\nSee the previous blog post on the [`v0.4.0` release](./zrok-v0-4-0-released.md) for more detail.\\n\\n`zrok` is deeply committed to open source. If you like the `zrok` concept, but don\'t want to use the service hosted by [NetFoundry](https://netfoundry.io/), you can fully [self-host](https://docs.zrok.io/docs/guides/self-hosting/self_hosting_guide/) `zrok` in your environment.\\n\\nLearn more about `zrok` at [zrok.io](https://zrok.io/) and the project\'s [GitHub](https://github.com/openziti/zrok) at:\\n\\n[https://github.com/openziti/zrok](https://github.com/openziti/zrok)\\n\\nFeel free to reach out if we can help. And if you like `zrok`, adding a star to the repo always means a lot.\\n\\n## What\'s coming next?\\n\\nWe\'re in the middle of preparing some exciting new functionality!\\n\\nFirst up is a set of clean, simple SDKs for powering your own applications and integrations on top of `zrok`. Use our peer-to-peer sharing infrastructure to design and enable clever solutions, secured through the power of the [OpenZiti](https://openziti.io/) network overlay. The `zrok`SDK is designed to make this complicated capability easy to implement and secure.\\n\\nNext, we\'ll be rolling out powerful new HTTP resource proxying, including concepts like request routing, load balancing, and other smart features to level up your HTTP resource sharing.\\n\\nAfter that we\'ll be rolling out our `zrok` \\"drives\\" feature, which we\'re hoping will be a serious contender in peer-to-peer filesharing. Want to quickly set up teleporters and wormholes and dropboxes for files? Want to collaboratively share files directly with your colleagues without going through a third party? Want to mount a `zrok` drive as a folder on your desktop? How about managing collections of files and resources for distributed production environments? Those are all things on our roadmap.\\n\\nAnd there\'s lots more where that came from... see the `zrok` [development roadmap](https://github.com/orgs/openziti/projects/16) for more details!"},{"id":"zrok-v040-released","metadata":{"permalink":"/docs/openziti/blog/zrok-v040-released","source":"@site/blog/zrok-v0-4-0-released.md","title":"zrok v0.4.0 Released!","description":"Today we celebrate the initial release of zrok v0.4.0. This new release of zrok introduces important new","date":"2023-06-27T18:48:03.000Z","tags":[{"inline":false,"label":"Network","permalink":"/docs/openziti/blog/tags/network","description":"Network related posts"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":4.51,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"zrok v0.4.0 Released!","date":"2023-06-27T18:48:03.000Z","cuid":"cljen4m08000009li4hl1fz7c","slug":"zrok-v040-released","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1687898203990/c35b6581-ab18-4f3d-80b7-8b2bfb7035cc.avif","imageDark":"@site/blogs/openziti/v1687898203990/c35b6581-ab18-4f3d-80b7-8b2bfb7035cc.avif","tags":["network","security","networking","openziti","zrok"]},"unlisted":false,"prevItem":{"title":"Announcing the zrok Public Beta!","permalink":"/docs/openziti/blog/announcing-the-zrok-public-beta"},"nextItem":{"title":"Commercial Open Source and Ethical (and practical) Community Engagement","permalink":"/docs/openziti/blog/commercial-open-source-and-ethical-and-practical-community-engagement"}},"content":"Today we celebrate the initial release of `zrok` `v0.4.0`. This new release of `zrok` introduces important new \\nfeatures and provides a stronger more extensible foundation for future growth.\\n\\n\x3c!-- truncate --\x3e\\n\\nIf you\'re just tuning in now and want to learn more about `zrok`, visit the website at https://zrok.io/ for an overview and https://docs.zrok.io/ for details.\\n\\n`zrok` has been out for a couple of months in a private beta capacity. Since then we\'ve added a handful of important new features and capabilities. Here are some of the more important new features:\\n\\n## TCP and UDP Tunnels\\n\\nIn addition to HTTP-based resources, `zrok` now allows users to share local TCP and UDP tunnels.\\n\\nThe TCP and UDP tunnels work very similarly. Here\'s how you can use the `tcpTunnel` backend in `v0.4.0`:\\n\\n![`zrok share` command for creating a TCP tunnel.](/blogs/openziti/v1687806922797/0e19e031-b673-4ec3-b416-9703af9c7713.png)\\n\\nWe\'ll use the `tcpTunnel` backend mode with our `private` share. The target is the `<host>:<port>` destination for the tunnel.\\n\\n![](/blogs/openziti/v1687886605811/9280f0cf-496d-45b3-b454-eb44fd53fff4.png)\\n\\nRunning that launches our `zrok share` client, and gives us the *share token* and the full command to give to remote users to access our TCP tunnel.\\n\\n![](/blogs/openziti/v1687886726762/268bc129-df9c-4d55-a635-69d43536396e.png)\\n\\nOur remote user runs the `zrok access private f4ke09rk2vat` command to access the tunnel, creating a local listener on their system at `127.0.0.1:9191`, which allows them to access our remote TCP resource.\\n\\n![Using netcat locally to access the tunneled SSH server endpoint.](/blogs/openziti/v1687807081992/cdf0073e-e1c0-4caf-82ce-a6acb19002c4.png)\\n\\nThe remote user can use regular networking tools like `netcat` to access the tunnel locally on their system. In this case, we see the announcement from the SSH listener on the other end of the tunnel.\\n\\n## Refreshed Web Console\\n\\n`zrok` `v0.4.0` includes significant updates to the web console.\\n\\nThe updates include:\\n\\n* a new side-by-side layout with an updated look and feel\\n    \\n* new more comprehensive activity indicators, which show both receive and transmission detail, including environment-level activity\\n    \\n* an updated network visualizer, which now includes `zrok access` details and shows relationships between `zrok share private` and `zrok access` bridges owned by the same account\\n    \\n* new metrics visualizations show historical telemetry for the last 30 days, 7 days, and 24 hours; telemetry is available at the account, environment, and share levels\\n    \\n\\n![The `zrok` `v0.4.0` web console, showing the new access endpoints and the private links between share and access.](/blogs/openziti/v1687802216025/c81239e3-d488-4caf-882d-af88c523dea5.png)\\n\\nIn the screenshot above, a dashed green line shows a connection between a `zrok share private` and a `zrok access`.\\n\\n![](/blogs/openziti/v1687886867051/c6b3dc7d-efff-467f-a127-59d45ed007ae.png)\\n\\n`v0.4.0` includes refreshed metrics views. These capabilities will continue to grow as `zrok` matures.\\n\\n## New Metrics and Limits Infrastructure\\n\\nThe metrics infrastructure has been completely revamped for `v0.4.0`. Metrics information now comes directly from the underlying OpenZiti network. Metrics details are now available for all share types and privacy modes.\\n\\nMetrics processing is scalable to work for the smallest self-hosting environments, all the way up to massive multi-user installations. Small installations can use a single `zrok` controller to receive metrics from OpenZiti directly. Large installations can use horizontally scalable message queuing over AMQP to distribute the metrics workload across a cluster of `zrok` controller instances.\\n\\n`v0.4.0` also includes a new *limits* facility providing configurable transfer quotas. If you\'re running your own self-hosted `zrok` service instance, you can configure quotas for transmit and receive volume at the account, environment, and share levels.\\n\\n## Updated Documentation\\n\\nThe [docs.zrok.io](https://docs.zrok.io/) website has been refreshed with expanded and revised concept guides and details about the new sharing modes.\\n\\nFuture `v0.4.x` releases will continue to expand to include documentation for the growing `zrok` web console.\\n\\n## Ready for use!\\n\\nThe official `v0.4.0` release is available on GitHub at [https://github.com/openziti/zrok/releases/tag/v0.4.0](https://github.com/openziti/zrok/releases/tag/v0.4.0).\\n\\nThe production service instance at zrok.io will be updated to `v0.4.0` on Wednesday, June 28th. If you use our hosted instance, be sure to update your local `zrok` client to the latest release. If you\'re running an out-of-date `zrok` client, you will receive an error message like this when you try to access a newer service instance:\\n\\n```plaintext\\n[ERROR]: unable to create zrok client (expected a \'v0.3\' version, received: \'v0.4.0-rc9 [ebfb039]\')\\n```\\n\\nYou can replace your current `zrok` binary with a newer version and continue to use your existing `zrok` account, environments, and shares.\\n\\nIn addition to the usual Github releases and docker images, `zrok` `v0.4.0` is now available through Homebrew:\\n\\n```plaintext\\n% brew install zrok\\n...\\n% zrok version\\n               _    \\n _____ __ ___ | | __\\n|_  / \'__/ _ \\\\| |/ /\\n / /| | | (_) |   < \\n/___|_|  \\\\___/|_|\\\\_\\\\\\n\\n0.4.0 [brew]\\n```\\n\\n## Private Beta\\n\\nWe intend to continue offering `zrok` hosting through zrok.io as a private beta for a short while. After a few weeks, we\'ll be opening zrok.io up to the public.\\n\\nIn the meantime, if you\'d like to request an invitation to the private beta you can reach out to invite@zrok.io.\\n\\n## What\'s Next?\\n\\nWe\'ve got some additional exciting developments in the wings that we\'ll be revealing soon. The `zrok` \\"drives\\" capability is continuing to evolve, and we\'re also sketching out new facilities that will allow you to extend `zrok` with your own custom applications and integrations. The `proxy` backend modes are growing to include advanced capabilities for load-balancing and intelligent service routing.\\n\\nStay tuned!"},{"id":"commercial-open-source-and-ethical-and-practical-community-engagement","metadata":{"permalink":"/docs/openziti/blog/commercial-open-source-and-ethical-and-practical-community-engagement","source":"@site/blog/commercial-open-source-and-ethical-and-practical-community-engagement.md","title":"Commercial Open Source and Ethical (and practical) Community Engagement","description":"I\u2019m a big fan of commercially supported open source. I\u2019m biased, of course, in that it\u2019s how I get my paycheck. However, having worked on OSS without getting paid to do so, I think there are better outcomes for everyone when a project has financial backing.","date":"2023-04-27T23:31:56.000Z","tags":[{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Community","permalink":"/docs/openziti/blog/tags/community","description":"Community topics"}],"readingTime":4.17,"hasTruncateMarker":true,"authors":[{"name":"Paul Lorenz","title":"Author","url":"https://github.com/plorenz","imageURL":"https://avatars.githubusercontent.com/plorenz","key":"PaulLorenz","page":null}],"frontMatter":{"title":"Commercial Open Source and Ethical (and practical) Community Engagement","date":"2023-04-27T23:31:56.000Z","cuid":"clgzreqgd000209l4d0km7qjy","slug":"commercial-open-source-and-ethical-and-practical-community-engagement","authors":["PaulLorenz"],"tags":["opensource","community"]},"unlisted":false,"prevItem":{"title":"zrok v0.4.0 Released!","permalink":"/docs/openziti/blog/zrok-v040-released"},"nextItem":{"title":"My Pi Day Journey with Go 64-bit alignment","permalink":"/docs/openziti/blog/my-pi-day-journey-with-go-64-bit-alignment"}},"content":"I\u2019m a big fan of commercially supported open source. I\u2019m biased, of course, in that it\u2019s how I get my paycheck. However, having worked on OSS without getting paid to do so, I think there are better outcomes for everyone when a project has financial backing.\\n\\nA few jobs ago, when I was still working on my degree, I wrote a [workflow engine](http://plorenz.github.io/sarasvati/reference/html/) for my capstone project. I was able to open-source it and used it at my work. I felt comfortable making improvements that were relevant to work on my paid time, but any community support or maintenance fell on my free time. When I moved to a new company, the project slowly bit-rotted into uselessness. I tried to find a new maintainer and I moved it to GitHub from [code.google.com](http://code.google.com), to keep it on life support, but it\u2019s functionally dead. If someone tried to adopt it today, I wouldn\u2019t have the time to support them.\\n\\nCompare that to my current project. If I got hit by a bus tomorrow, the project would carry on. Not only do I get to work on OSS, but I have time to spend with my family. In addition to writing code, I\u2019m not just allowed, but expected to write docs, ensure we have a solid build process, respond to user questions and, in general, engage with the community to make sure users are successful and improve the project based on user needs. It feels like a sustainable approach to developing open-source software, at least for large projects.\\n\\nCommercial backing does complicate community engagement somewhat. As soon as there\u2019s a profit motive involved, people look at what you\u2019re offering them with some suspicion. I would argue that when you\u2019re engaging with the community, it\u2019s not only ethical but more effective, to follow a few simple rules.\\n\\n1. Be honest\\n    \\n2. Respect people\u2019s time\\n    \\n3. Be nice\\n\\n\x3c!-- truncate --\x3e\\n    \\n\\nThese rules should apply to everyone, of course, but people tend to be more forgiving when you\u2019re not associated with a company.\\n\\n## Be Honest\\n\\nFirst, when posting anything related to your project, where it\u2019s not immediately obvious from the context, let people know that you are affiliated with the project. Second, let people know why you\u2019re posting. If you\u2019re sharing technical learnings, great! If you\u2019re announcing a new feature, amazing! If you\u2019re showing how your project can be used to do something interesting, neat! Don\u2019t try to disguise one thing as another, though. What you\u2019re sharing should have a clear purpose, with a specific audience that might be interested. Don\u2019t waste people\u2019s time by trying to trick people into reading it. It will just annoy them.\\n\\nThis brings us to:\\n\\n## Respect People\u2019s Time\\n\\nWhen you\u2019re posting something, I\u2019m assuming that you think it\u2019s interesting, useful or (at a minimum) entertaining to somebody out there. If not, stop. Why would you bother?\\n\\nThe important thing to keep in mind when you post is that you\u2019re asking for someone\u2019s time, which is a limited resource. The faster you can help them decide whether what you\u2019ve posted is valuable to them, the better.\\n\\nIt\u2019s also important to know your audience. Don\u2019t post about Golang memory optimization techniques on a Rust message board. It\u2019s highly unlikely to be relevant and will just waste people\u2019s time. Don\u2019t post about every minor version release to a general programming language forum. Don\u2019t post about your project in every conversation that is even tangentially related. There are times when people are likely to be interested. There are other times when you\u2019re just interrupting a conversation that doesn\u2019t need you.\\n\\nThis brings us to:\\n\\n## Be Nice\\n\\nDon\u2019t be rude about other people\u2019s hard work to promote yourself. Don\u2019t insult others. It\u2019s not only harmful to them, it\u2019s harmful to you. Most people don\u2019t like bullies and you probably don\u2019t want to attract the ones that do to your project. It can be OK to compare your work with that of others if you do so factually and in a way that someone who works on the other project would agree with.\\n\\n## Summary\\n\\nMost people who work on open source are passionate about their work. It\u2019s natural to be excited to share your work and what you\u2019ve learned with the world. Following these rules will not guarantee universal love and adoration, but they will go a long way toward making sure your words are received in the spirit that they\u2019re meant.\\n\\nI still think fondly about my workflow engine, but I don\u2019t miss the anxiety and stress that came with trying to advance it in my free time. Maybe when I have some free time again, I\u2019ll write up the interesting bits and post them to an appropriate forum. Until then, I\u2019m going to keep enjoying the privilege of being able to work on open source full time, share things that I learn and hopefully give back a little to the open source community from which I\u2019ve benefited so much."},{"id":"my-pi-day-journey-with-go-64-bit-alignment","metadata":{"permalink":"/docs/openziti/blog/my-pi-day-journey-with-go-64-bit-alignment","source":"@site/blog/my-pi-day-journey-with-go-64-bit-alignment.md","title":"My Pi Day Journey with Go 64-bit alignment","description":"A few days ago, we had a user bring to our attention, a failure of OpenZiti on a Raspberry Pi 4 running a 32-bit operating system. As I got started investigating the bug, I smirked a little as it just so happened to be Pi day (March 14th).","date":"2023-03-17T13:07:52.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Raspberry Pi","permalink":"/docs/openziti/blog/tags/raspberry-pi","description":"Raspberry Pi content"},{"inline":false,"label":"Troubleshooting","permalink":"/docs/openziti/blog/tags/troubleshooting","description":"Troubleshooting guides"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":10.66,"hasTruncateMarker":true,"authors":[{"name":"Geoff Berl","title":"Author","url":"https://github.com/gberl002","imageURL":"https://avatars.githubusercontent.com/gberl002","key":"GeoffBerl","page":null}],"frontMatter":{"title":"My Pi Day Journey with Go 64-bit alignment","date":"2023-03-17T13:07:52.000Z","cuid":"clfck29eh000309lkfcoc0ekh","slug":"my-pi-day-journey-with-go-64-bit-alignment","authors":["GeoffBerl"],"image":"@site/blogs/openziti/v1678975036152/5a834580-b0f3-481b-9409-61c697ed719b.png","imageDark":"@site/blogs/openziti/v1678975036152/5a834580-b0f3-481b-9409-61c697ed719b.png","tags":["golang","raspberry-pi","troubleshooting","openziti"]},"unlisted":false,"prevItem":{"title":"Commercial Open Source and Ethical (and practical) Community Engagement","permalink":"/docs/openziti/blog/commercial-open-source-and-ethical-and-practical-community-engagement"},"nextItem":{"title":"Private DNS on Windows","permalink":"/docs/openziti/blog/private-dns-on-windows"}},"content":"A few days ago, we had a user bring to our attention, a failure of OpenZiti on a Raspberry Pi 4 running a 32-bit operating system. As I got started investigating the bug, I smirked a little as it just so happened to be Pi day (March 14th).\\n\\n\x3c!-- truncate --\x3e\\n\\nIn any case, the error presented looked like this.\\n\\n```bash\\npanic: unaligned 64-bit atomic operation\\n\\ngoroutine 118 [running]:\\nruntime/internal/atomic.panicUnaligned()\\n        runtime/internal/atomic/unaligned.go:8 +0x24\\nruntime/internal/atomic.Load64(0x45a8354)\\n        runtime/internal/atomic/atomic_arm.s:280 +0x14\\n```\\n\\nMy immediate thought was, you must be running a 64-bit binary on a 32-bit system. But, to my surprise, the user responded, assuring me they were using the 32-bit arm release.\\n\\nWell, it seemed it was time to dig my raspberry pi out of the abyss of untouched, but of course, still running Raspberry Pis I had around my house. I installed a 32-bit and 64-bit OS on two different SD cards and started my journey.\\n\\n### 64 Bit Raspbian\\n\\nThe 64-bit [expressInstall](https://netfoundry.io/docs/openziti/learn/quickstarts/network/local-no-docker) process went swimmingly, with no issues at all. I started up the router, and zipped through some boilerplate commands I have to test out an OpenZiti network locally. No problems, I hadn\'t expected any since the user seeing the issue is running a 32-bit OS, but I had to be sure.\\n\\n### 32 Bit Raspbian\\n\\nOnto the 32-bit Raspbian, I went, again, [expressInstall](https://netfoundry.io/docs/openziti/learn/quickstarts/network/local-no-docker) is no problem. I start up the router, annnnd there it is.\\n\\n```bash\\n$ startRouter\\n[2] 1486\\nExpress Edge Router started as process id: 1486. log located at: /home/gberl001/.ziti/quickstart/raspberrypi/raspberrypi-edge-router.log\\n\\n[2]+  Exit 2                  \\"${ZITI_BIN_DIR}/ziti\\" router run \\"${ZITI_HOME_OS_SPECIFIC}/${ZITI_EDGE_ROUTER_RAWNAME}.yaml\\" > \\"${log_file}\\" 2>&1\\n```\\n\\nI checked the router log, and sure enough `panic: unaligned 64-bit atomic operation`.\\n\\n```go\\npanic: unaligned 64-bit atomic operation\\n\\ngoroutine 41 [running]:\\nruntime/internal/atomic.panicUnaligned()\\n        runtime/internal/atomic/unaligned.go:8 +0x24\\nruntime/internal/atomic.Load64(0x638f404)\\n        runtime/internal/atomic/atomic_arm.s:280 +0x14\\ngithub.com/openziti/channel/v2.(*heartbeater).Tx(0x638f3e0, 0x5e06080, {0x2eb5ecc, 0x63862d0})\\n        github.com/openziti/channel/v2@v2.0.27/heartbeater.go:82 +0x1b8\\ngithub.com/openziti/channel/v2.(*channelImpl).txer(0x63862d0)\\n        github.com/openziti/channel/v2@v2.0.27/impl.go:422 +0x984\\ncreated by github.com/openziti/channel/v2.(*channelImpl).startMultiplex\\n        github.com/openziti/channel/v2@v2.0.27/impl.go:287 +0x128\\n```\\n\\nSo I traced the stack to the location where it failed, and I see it\'s trying to load an int in an atomic operation.\\n\\n```go\\nif unrespondedHeartbeat := atomic.LoadInt64(&self.unrespondedHeartbeat); unrespondedHeartbeat != 0 {\\n\\t\\tm.PutUint64Header(HeartbeatResponseHeader, uint64(unrespondedHeartbeat))\\n\\t\\tatomic.StoreInt64(&self.unrespondedHeartbeat, 0)\\n\\t\\tselect {\\n\\t\\tcase self.events <- heartbeatRespTxEvent(now):\\n\\t\\tdefault:\\n\\t\\t}\\n\\t}\\n```\\n\\nThis led me to do as every programmer does, look online for an answer, fingers crossed for a stack-overflow post haha. Of course, I saw a bunch of responders who had my initial reaction, thinking it was a 64-bit binary on a 32-bit OS they said, \\"switch to Raspbian 64-bit,\\" and went on with their day. While that *is* *a* solution, it\'s not the right one, the right solution would be to fix the issue with the binary that is supposed to run on a 32-bit OS. But, like me, they didn\'t know the real cause of the problem. I removed the keywords \\"Raspberry\\" and \\"Pi\\" from my search and got much better results, leading me to [this GitHub issue](https://github.com/golang/go/issues/36606) which ultimately (after carefully reading and following a rabbit hole of links) got me to a point where I better understood what was going on.\\n\\n### The Cause\\n\\nIt\'s not every day you hear about unaligned memory-related operations, and this is generally because the compiler handles these messes for you automatically. In fact, I have never experienced an issue like this and had no idea this was even a thing. Hence, my first assumption was that it was simply a 64-bit binary on a 32-bit OS. This is somewhat of a unique situation as it\'s specific to 64-bit atomic operations in Golang. I don\'t pretend to understand the Golang compiler well enough to know why this is only an issue with atomic operations or why this is even an issue at all, as generally, compilers will add padding to align data automatically, you can see much more information on that in this [Wikipedia article](https://en.wikipedia.org/wiki/Data_structure_alignment), which is surprisingly well-written and understandable. But, what I can say is, the problem lies in the fact that memory is byte addressable, and is accessed by a single word size at a time. The word size changes depending on the architecture. On arm, and other 32-bit architectures, this is 32 bits, so the processing word size will be 4 bytes. My guess as to the root of this problem lies in the nature of atomic operations. When memory addresses for data are properly aligned, it should only take one cycle to read the data, if it is misaligned, then it would take more than one cycle and, thus, likely cannot guarantee atomicity. As mentioned, I\'m not entirely positive on this, that\'s just my interpretation, so if you have any input on this, I\'d love to hear it in the comments.\\n\\n### The Fix\\n\\nAs stated by the [Golang documentation](https://pkg.go.dev/sync/atomic#pkg-note-BUG) (link thanks to the treasure trove of information starting, in one way or another, from the original GitHub issue), it is the caller\'s responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically on a 32-bit architecture. To do this, the 64-bit variables need to be aligned with an 8-byte word boundary. Essentially, if the address is not divisible by 8, we\'re going to see this issue. So, I need to find every 64-bit variable that has an atomic operation performed on it, then see if that is stored in a data structure. If the variable is stored in a data structure, I then need to ensure the alignment is at an 8-byte word boundary.\\n\\nI whipped up a quick little test using `Alignof`, `Sizeof`, and `Offsetof` from the `unsafe` package in Golang as is documented [here](https://go.dev/ref/spec#Size_and_alignment_guarantees), to show the offsets of variables in a suspected struct, there is a bit of extra information as I was still not totally sure what I was looking for.\\n\\nHere\'s the struct containing the problem variable; `unrespondedHeartbeat`.\\n\\n```go\\ntype heartbeater struct {\\n\\tch                   Channel\\n\\tlastHeartbeatTx      int64\\n\\theartBeatIntervalNs  int64\\n\\tcallback             HeartbeatCallback\\n\\tevents               chan heartbeatEvent\\n\\tunrespondedHeartbeat int64\\n}\\n```\\n\\nAnd, here\'s the quick test showing Alignof, Sizeof, and Offsetof for each variable in the struct.\\n\\n```go\\nfunc TestAlignment(t *testing.T) {\\n\\thb := heartbeater{}\\n\\n\\tfmt.Printf(\\"Channel Alignof: %v\\\\n\\", unsafe.Alignof(hb.ch))\\n\\tfmt.Printf(\\"lastHearbeatTx Alignof: %v\\\\n\\", unsafe.Alignof(hb.lastHeartbeatTx))\\n\\tfmt.Printf(\\"heartBeatInternalNs Alignof: %v\\\\n\\", unsafe.Alignof(hb.heartBeatIntervalNs))\\n\\tfmt.Printf(\\"Callback Alignof: %v\\\\n\\", unsafe.Alignof(hb.callback))\\n\\tfmt.Printf(\\"chan heartbeatEvent Alignof: %v\\\\n\\", unsafe.Alignof(hb.events))\\n\\tfmt.Printf(\\"unrespondedHeartbeat Alignof: %v\\\\n\\", unsafe.Alignof(hb.unrespondedHeartbeat))\\n\\n\\tfmt.Printf(\\"\\\\n\\\\n\\")\\n\\tfmt.Printf(\\"Channel Sizeof: %v\\\\n\\", unsafe.Sizeof(hb.ch))\\n\\tfmt.Printf(\\"lastHearbeatTx Sizeof: %v\\\\n\\", unsafe.Sizeof(hb.lastHeartbeatTx))\\n\\tfmt.Printf(\\"heartBeatInternalNs Sizeof: %v\\\\n\\", unsafe.Sizeof(hb.heartBeatIntervalNs))\\n\\tfmt.Printf(\\"Callback Sizeof: %v\\\\n\\", unsafe.Sizeof(hb.callback))\\n\\tfmt.Printf(\\"chan heartbeatEvent Sizeof: %v\\\\n\\", unsafe.Sizeof(hb.events))\\n\\tfmt.Printf(\\"unrespondedHeartbeat Sizeof: %v\\\\n\\", unsafe.Sizeof(hb.unrespondedHeartbeat))\\n\\n\\tfmt.Printf(\\"\\\\n\\\\n\\")\\n\\tfmt.Printf(\\"Channel Offsetof: %v\\\\n\\", unsafe.Offsetof(hb.ch))\\n\\tfmt.Printf(\\"lastHearbeatTx Offsetof: %v\\\\n\\", unsafe.Offsetof(hb.lastHeartbeatTx))\\n\\tfmt.Printf(\\"heartBeatInternalNs Offsetof: %v\\\\n\\", unsafe.Offsetof(hb.heartBeatIntervalNs))\\n\\tfmt.Printf(\\"Callback Offsetof: %v\\\\n\\", unsafe.Offsetof(hb.callback))\\n\\tfmt.Printf(\\"chan heartbeatEvent Offsetof: %v\\\\n\\", unsafe.Offsetof(hb.events))\\n\\tfmt.Printf(\\"unrespondedHeartbeat Offsetof: %v\\\\n\\", unsafe.Offsetof(hb.unrespondedHeartbeat))\\n}\\n```\\n\\nAnd, here are the results (run on the Raspberry Pi of course); can you spot the issue?\\n\\n```go\\n$ go test -v -run TestAlignment\\n=== RUN   TestAlignment\\nChannel Alignof: 4\\nlastHearbeatTx Alignof: 4\\nheartBeatInternalNs Alignof: 4\\nCallback Alignof: 4\\nchan heartbeatEvent Alignof: 4\\nunrespondedHeartbeat Alignof: 4\\n\\n\\nChannel Sizeof: 8\\nlastHearbeatTx Sizeof: 8\\nheartBeatInternalNs Sizeof: 8\\nCallback Sizeof: 8\\nchan heartbeatEvent Sizeof: 4\\nunrespondedHeartbeat Sizeof: 8\\n\\n\\nChannel Offsetof: 0\\nlastHearbeatTx Offsetof: 8\\nheartBeatInternalNs Offsetof: 16\\nCallback Offsetof: 24\\nchan heartbeatEvent Offsetof: 32\\nunrespondedHeartbeat Offsetof: 36\\n--- PASS: TestAlignment (0.00s)\\nPASS\\nok  \\tgithub.com/openziti/channel/v2\\t0.014s\\n```\\n\\nIf you guessed that `unrespondedHeartbeat`\'s offset is not at an 8-byte word boundary, then go congratulate yourself and buy that gadget on your Amazon wish list you\'ve had on there for years but know you don\'t need. The variable needed to be at an 8-byte boundary, an offset of 36 is not an 8-byte boundary. The variable `chan`, which is a pointer, hence the 4 bytes, is the reason, and seeing that chan *was* at an 8-byte word boundary, I simply popped that guy (`unrespondedHeartbeat`) up before `chan` and that put it at an offset of 32. Here\'s what I got after moving it up before `chan`. Bear in mind, since I reordered the struct, I reordered the test outputs to keep my sanity.\\n\\n```go\\n$ go test -v -run TestAlignment\\n=== RUN   TestAlignment\\nChannel Alignof: 4\\nlastHearbeatTx Alignof: 4\\nheartBeatInternalNs Alignof: 4\\nCallback Alignof: 4\\nunrespondedHeartbeat Alignof: 4\\nchan heartbeatEvent Alignof: 4\\n\\n\\nChannel Sizeof: 8\\nlastHearbeatTx Sizeof: 8\\nheartBeatInternalNs Sizeof: 8\\nCallback Sizeof: 8\\nunrespondedHeartbeat Sizeof: 8\\nchan heartbeatEvent Sizeof: 4\\n\\n\\nChannel Offsetof: 0\\nlastHearbeatTx Offsetof: 8\\nheartBeatInternalNs Offsetof: 16\\nCallback Offsetof: 32\\nunrespondedHeartbeat Offsetof: 24\\nchan heartbeatEvent Offsetof: 40\\n--- PASS: TestAlignment (0.00s)\\nPASS\\nok  \\tgithub.com/openziti/channel/v2\\t0.015s\\n```\\n\\nWith `unrespondedHeartbeat` having an offset of 24, all is right with the world, well, it is for 32-bit arm devices that can now be used to run OpenZiti. An alternative is that I could have put some padding after chan to bump `unrespondedHeartbeat`\'s offset to 40, which would make it an 8-byte boundary. I guess there are pros and cons to each. There is even a third option, I could have moved all of the int64 variables to the beginning of the struct since the first one will clearly start at offset 0, with each being an 8-byte variable any int64 immediately following would be guaranteed as well. But who\'s to say someone doesn\'t come in down the road and add a variable right at the beginning of the struct and throw everything off? I opted not to go into analysis paralysis and just pick one, any solution was just a one-line commit away from being broken in the future.\\n\\nThis [xkcd](https://xkcd.com/) sums up my pragmatic decision nicely.\\n\\n![Efficiency](https://imgs.xkcd.com/comics/efficiency.png)\\n\\nI knew this wasn\'t going to be the only case, there was no way that more wouldn\'t appear in this project and many other projects used by OpenZiti. So, the easiest way I could come up with to solve this across the board was to, as before, find all variables which have atomic 64-bit operations performed on them, and check if they are in a data structure. To start this venture, I put together a quick little regex and grepped it across the project, to pull out all 64-bit variables having atomic operations performed on them. Unfortunately, Mac grep doesn\'t have Perl regex so there\'s a little quirk in my regex to make it \\"non-greedy\\".\\n\\n```bash\\ngrep --include=\\\\*.go -irn ./ -e \\"atomic\\\\.[^6]*64(\\"\\n```\\n\\nThis resulted in the following, a quick copy-paste into Sublime Text and regex to extract the variable names.\\n\\n![](/blogs/openziti/v1678906066090/0335faba-14a4-4457-bebd-7e9f2f80c67d.png)\\n\\nThere\'s no quick way to determine if they are in a data structure so I just used a search across the project for each variable, then jumped to the declaration of that variable. There were only nine results, and of those, only three distinct variables. I wrote a test that attempted to perform an atomic operation on any variable that I found to be in a struct, and checked if it failed. After collecting them all, and running the test, I investigated any failures and left the rest alone.\\n\\nHere\'s what my new test looked like\\n\\n```go\\nfunc Test64BitAlignment(t *testing.T) {\\n\\tdefer func() {\\n\\t\\tif r := recover(); r != nil {\\n\\t\\t\\tt.Errorf(\\"One of the variables that was tested is not properly 64-bit aligned.\\")\\n\\t\\t}\\n\\t}()\\n\\n\\thb := heartbeater{}\\n\\tchImpl := channelImpl{}\\n\\n\\tatomic.LoadInt64(&hb.lastHeartbeatTx)\\n\\tatomic.LoadInt64(&hb.unrespondedHeartbeat)\\n\\tatomic.LoadInt64(&chImpl.lastRead)\\n}\\n```\\n\\nI repeated this process for other projects and found a few more spots where we likely would have had issues down the road. I, of course, left the tests in place, which will at least make sure we don\'t break these existing variables \\"hooray for regression tests!\\"\\n\\n### Pi Day 2023 Concludes\\n\\nI never really took much significance in Pi Day in the past. It really has nothing to do with Raspberry Pi other than the creators spelled pie without the e, so it resembles the mathematical value. In any case, I just found it slightly amusing that I happened to be fixing a Raspberry Pi-related bug on a Raspberry Pi, on Pi Day."},{"id":"private-dns-on-windows","metadata":{"permalink":"/docs/openziti/blog/private-dns-on-windows","source":"@site/blog/private-dns-on-windows.md","title":"Private DNS on Windows","description":"OpenZiti\'s tunnelers have a killer feature, a superpower, if you will: \\"Private\\" DNS. \\"Private DNS,\\" I hear you ask with a subtle tone of disbelief, \\"what does that mean?\\" When you have an OpenZiti tunneler running on your system with one or more enrolled identities, it\'s likely those services have \\"intercepts\\" configured. Those intercepts are often in the form of some DNS entry and those DNS entries are only available to your system when OpenZiti is running. That, is what it means to have \\"Private DNS\\". These private DNS entries are valuable because they are only available to people who are authenticated and authorized to have them. If you\'re not authorized, you won\'t see the entry at all. That\'s very cool!","date":"2023-03-15T21:06:11.000Z","tags":[{"inline":false,"label":"DNS","permalink":"/docs/openziti/blog/tags/dns","description":"DNS topics"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Windows","permalink":"/docs/openziti/blog/tags/windows","description":"Windows topics"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"NRPT","permalink":"/docs/openziti/blog/tags/nrpt","description":"Windows NRPT"}],"readingTime":5.79,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Private DNS on Windows","seoTitle":"Private DNS on Windows using OpenZiti","seoDescription":"A short article that discusses how the Ziti Desktop Edge for Windows from the OpenZiti project provides secure, authenticated DNS for users.","date":"2023-03-15T21:06:11.000Z","cuid":"clfa69o4m000509lbe5qagw7h","slug":"private-dns-on-windows","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1678971944159/0a3cfe23-5f9a-4576-a89d-e272b3b360d4.png","imageDark":"@site/blogs/openziti/v1678971944159/0a3cfe23-5f9a-4576-a89d-e272b3b360d4.png","tags":["dns","security","windows","openziti","nrpt"]},"unlisted":false,"prevItem":{"title":"My Pi Day Journey with Go 64-bit alignment","permalink":"/docs/openziti/blog/my-pi-day-journey-with-go-64-bit-alignment"},"nextItem":{"title":"Websockets over zrok","permalink":"/docs/openziti/blog/websockets-over-zrok"}},"content":"OpenZiti\'s tunnelers have a killer feature, [a superpower](https://www.youtube.com/playlist?list=PLMUj_5fklasKF1oisSSuLwSzLVxuL9JbC), if you will: \\"Private\\" DNS. \\"Private DNS,\\" I hear you ask with a subtle tone of disbelief, \\"what does *that* mean?\\" When you have an OpenZiti tunneler running on your system with one or more enrolled [identities](https://netfoundry.io/docs/openziti/learn/core-concepts/identities/overview/), it\'s likely those [services](https://netfoundry.io/docs/openziti/learn/core-concepts/services/overview/) have \\"intercepts\\" configured. Those intercepts are often in the form of some DNS entry and those DNS entries are only available to your system when OpenZiti is running. **That**, is what it means to have \\"Private DNS\\". These private DNS entries are valuable because they are only available to people who are authenticated and authorized to have them. If you\'re not authorized, you won\'t see the entry at all. That\'s very cool!\\n\\n\x3c!-- truncate --\x3e\\n\\n## How Private DNS works on Windows\\n\\nCapturing DNS requests is somewhat tricky, as you might expect. Compounding the problem, each operating system works differently. To make matters worse, DNS is such a fundamental part of your (or your users\') operating system, when you get it wrong, it\'s very disruptive! When DNS isn\'t working, it seems like your whole network doesn\'t work! (Depicted is Ziggy wondering why his network doesn\'t work because DNS is broken)\\n\\n![](https://raw.githubusercontent.com/openziti/branding/main/images/ziggy/png/Ziggy-has-a-Question-Closeup.png)\\n\\nSo how does OpenZiti accomplish intercepting any DNS entry at all, including overriding existing DNS entries? We first tried to use the API provided by Microsoft for creating a VPN. That API was poorly documented, difficult to implement and didn\'t do exactly what we wanted. We had to find a better way, and we did! On the Windows operating system, we were able to successfully use a feature called the [Name Resolution Policy Table, or NRPT for short](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn593632(v=ws.11)).\\n\\n## What is the NRPT\\n\\nThe NRPT is really neat. Through the NRPT, we can provide instructions to the operating system to send DNS requests matching a particular pattern to a particular nameserver. That is exactly what we need! If that\'s not clear enough, let\'s look at an example.\\n\\n### An Example - RDP\'ing to Mom\'s Computer\\n\\nLast year I needed to do some remote work on my mother\'s computer. Instead of using one of the existing remote desktop solutions out there, I used OpenZiti. I didn\'t feel like trying to get my mother to download and install the **correct** app, the correct version, etc. I was able to send her an email with the exact link to install and a one-use token to use. Here\'s what I wanted to do:\\n\\n![](/blogs/openziti/v1678898953353/2f0dff3a-bf7c-463e-9bc4-bcbeb4bac89c.png)\\n\\nOnce enrolled, her RDP service (and only her RDP service) was available to me via my OpenZiti overlay network. I defined a single service so I could use RDP to remote into her machine. To make it easy for me to remember, I defined a private DNS entry called \\"mom.rdp\\", I authorized my identity to dial and hers to host and then I was able to RDP to mom.rdp!\\n\\n![](/blogs/openziti/v1678898585739/e840fe62-290a-482d-a7e5-2597e1d47c94.png)\\n\\nIn this example, I need my operating system to be able to resolve \\"mom.rdp\\" to an IP address so that my computer knows how to send data across the OpenZiti overlay.\\n\\n## Using the NRPT\\n\\nFor Windows to be able to resolve \\"mom.rdp\\", a few things need to happen. As mentioned, we need an identity that has been enrolled with the [Ziti Desktop Edge for Windows (ZDEW)](https://github.com/openziti/desktop-edge-win/releases/latest). The identity also needs to have access (been authorized) to a service with an intercept configured for \\"mom.rdp\\". Once authorized, when the ZDEW notices it has a new service, it will run a [powershell command](https://github.com/openziti/ziti-tunnel-sdk-c/blob/ecc12ff3feaf2c0547928bcbe1880192bd0b4da3/programs/ziti-edge-tunnel/windows-scripts.c#L152) to add the entry to the NRPT using the commandlet named [Add-DnsClientNrptRule](https://learn.microsoft.com/en-us/powershell/module/dnsclient/add-dnsclientnrptrule?view=windowsserver2022-ps). Why a powershell command and not an API call? **GREAT QUESTION!** It\'s because Microsoft (at this time) does not provide one! Perhaps you can encourage Microsoft to provide an actual API people and projects like OpenZiti can invoke instead!\\n\\nThe NRPT rule does one specific thing. It instructs Windows that when you see a DNS request to a matching name, send it to this specific server. If you have a ZDEW running, you can see all your configured rules from the ZDEW by running [Get-DnsClientNrptPolicy](https://learn.microsoft.com/en-us/powershell/module/dnsclient/get-dnsclientnrptpolicy?view=windowsserver2022-ps)\\n\\nHere\'s an edited snippet from my NRPT of the rule allowing me to RDP to my mother\'s computer:\\n\\n```plaintext\\nNamespace                        : mom.rdp\\n...SNIP...\\nNameServers                      : 100.64.0.2\\n```\\n\\nYou can see that one of my identities is providing a private DNS entry of mom.rdp, and it instructs Windows to send any requests matching the namespace to the [nameserver](https://en.wikipedia.org/wiki/Name_server) located at 100.64.0.2.\\n\\n### Local Nameserver\\n\\nThe NRPT has told Windows to send any DNS request to 100.64.0.2 if it matches mom.rdp exactly, but something needs to answer the DNS query. OpenZiti tunnelers all run a built-in nameserver to satisfy these requests. You\'ll find the nameserver at whatever the start of private IP space is configured to be, \\"plus 1\\". By default, the ZDEW will create and configure a local network interface at 100.64.0.1, so by adding one to that IP, you\'ll have a nameserver on 100.64.0.2.\\n\\nWe can test this too. We can use the built-in `nslookup` to make a query to the specific nameserver **or** we can use the PowerShell commandlet `DnsClient-ResolveName`. It\'s important to note that DNS tooling sometimes specifically avoids things like the NRPT! For example, if you use `nslookup`, **make sure** you provide the server to send the DNS request to. If you don\'t you might be surprised that it doesn\'t work!\\n\\nExample of using `nslookup mom.rdp 100.64.0.2`:\\n\\n```plaintext\\nnslookup mom.rdp 100.64.0.2\\nServer:  UnKnown\\nAddress:  100.64.0.2\\n\\nNon-authoritative answer:\\nName:    mom.rdp\\nAddress:  100.64.0.6\\n```\\n\\nand Powershell\'s `Resolve-DnsName mom.rdpa`:\\n\\n```plaintext\\nResolve-DnsName mom.rdp\\n\\nName                                           Type   TTL   Section    IPAddress\\n----                                           ----   ---   -------    ---------\\nmom.rdp                                        A      60    Answer     100.64.0.6\\n```\\n\\n# Conclusion\\n\\nThat\'s basically it. The Ziti Desktop Edge for Windows is responsible for managing the NRPT. It manages it using Powershell commands because there are no APIs available yet for an application to manipulate the NRPT at this time. When new services show up, we map all the private DNS entries to NRPT rules and run a small nameserver from the ZDEW to properly answer the DNS requests.\\n\\nThis technique is fairly well-known now, but when the ZDEW was first created back in late 2019, it wasn\'t quite as easy to discover. Maybe you\'ve never heard or seen the NRPT and maybe you\'ll go check it out."},{"id":"websockets-over-zrok","metadata":{"permalink":"/docs/openziti/blog/websockets-over-zrok","source":"@site/blog/websockets-over-zrok.md","title":"Websockets over zrok","description":"Where we started","date":"2023-03-10T16:11:44.000Z","tags":[{"inline":false,"label":"Debugging","permalink":"/docs/openziti/blog/tags/debugging","description":"Debugging topics"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":5.24,"hasTruncateMarker":true,"authors":[{"name":"Cameron Otts","title":"Author","url":"https://github.com/camotts","imageURL":"https://avatars.githubusercontent.com/camotts","key":"CameronOtts","page":null}],"frontMatter":{"title":"Websockets over zrok","date":"2023-03-10T16:11:44.000Z","cuid":"clf2qjqxx000109id6rmz1dfm","slug":"websockets-over-zrok","authors":["CameronOtts"],"image":"@site/blogs/openziti/v1678297112797/d3f17b17-22f7-40ef-aac4-a581a9ab19ea.jpeg","imageDark":"@site/blogs/openziti/v1678297112797/d3f17b17-22f7-40ef-aac4-a581a9ab19ea.jpeg","tags":["debugging","openziti","zrok"]},"unlisted":false,"prevItem":{"title":"Private DNS on Windows","permalink":"/docs/openziti/blog/private-dns-on-windows"},"nextItem":{"title":"OpenAPI Python Clients","permalink":"/docs/openziti/blog/openapi-python-clients"}},"content":"## Where we started\\n\\nIf you were using `zrok` &lt;=`v0.3.3` you might have noticed that websockets weren\'t exactly behaving quite like we \\nwere expecting. We decided to quickly fix that to get users the features they want.\\n\\n\x3c!-- truncate --\x3e\\n\\n## How we got to now\\n\\nConversely, you\'ll notice come the `zrok` `v0.3.4` [release](https://github.com/openziti/zrok/releases/tag/v0.3.4) websockets are in a much better place. We strive to give users the best experience we possibly can. Let me take you on the journey that got us here and show you the debugging steps we took.  \\n\\n### Digging Strategy\\n\\nTo assist with testing we developed 3 test commands (one of which we decided to not ship with `zrok`).\\n\\n  \\nFirst, we have a very simple server `zrok test endpoint`. This is a simple echo server in which the `/echo` endpoint is a websocket connection. This also can listen over a Ziti network with the Ziti relevant flags.\\n\\n  \\nNext is the corresponding websocket client `zrok test websocket`. This was made to directly integrate with the websocket portion of the aforementioned server so it only communicates on the `/echo` endpoint. Like above it can also communicate over Ziti with the relevant flags.\\n\\n  \\nFinally, we have a test expandable proxy server. This was exclusively used just for testing the internal communication of `zrok` so it will not be present in the package. Once again this is optionally Ziti enabled, and all this did was link two URLs through a golang reverse proxy.\\n\\n  \\nHaving these three components will allow us to test each portion of the internal `zrok` workflow with less overhead to dig into the problem. We start with the simplest scenario, direct communication between a websocket endpoint and a test client. Then we add layers of `zrok` components into the equation, trying to locate where the communication fails.\\n\\nSo we start with a websocket server serving over HTTP, which turns out to be a success.\\n\\n```bash\\n% zrok test websocket localhost:9090 \\n[ 0.001] INFO main.(*testWebsocketCommand).run: http://localhost:9090/echo\\n[ 0.006] INFO main.(*testWebsocketCommand).run: Writting to server...\\n[ 0.007] INFO main.(*testWebsocketCommand).run: Reading response...\\n[ 0.007] INFO main.(*testWebsocketCommand).run: MessageText\\n[ 0.007] INFO main.(*testWebsocketCommand).run: i received: \\"hi\\"\\n```\\n\\nNext, let\'s go ahead and verify that websockets work as expected over a straight Ziti connection.\\n\\n```bash\\n% zrok test websocket --ziti --ziti-identity identity.json --ziti-name ws \\n[ 0.003] INFO main.(*testWebsocketCommand).run: http://ws/echo\\n[ 0.114] INFO main.(*testWebsocketCommand).run: Writting to server...\\n[ 0.114] INFO main.(*testWebsocketCommand).run: Reading response...\\n[ 0.115] INFO main.(*testWebsocketCommand).run: MessageText\\n[ 0.115] INFO main.(*testWebsocketCommand).run: i received: \\"hi\\"\\n```\\n\\n  \\nSuccess!  \\nWell, what about introducing one proxy over HTTP?\\n\\n```bash\\n% zrok test websocket localhost:1111\\n[ 0.002] INFO main.(*testWebsocketCommand).run: http://localhost:1111/echo\\n[ 0.007] INFO main.(*testWebsocketCommand).run: Writting to server...\\n[ 0.007] INFO main.(*testWebsocketCommand).run: Reading response...\\n[ 0.008] INFO main.(*testWebsocketCommand).run: MessageText\\n[ 0.008] INFO main.(*testWebsocketCommand).run: i received: \\"hi\\"\\n```\\n\\n  \\nStill looking good.  \\nNow here is where we start looking like the back half of `zrok`. Let\'s have the proxy listen over Ziti and reach out to the websocket server running over HTTP.\\n\\n```bash\\n% zrok test websocket --ziti --ziti-identity ~/.ziti/quickstart/identities/cam.json --ziti-name ws\\n[ 0.003] INFO main.(*testWebsocketCommand).run: http://ws/echo\\n[ 360.003] ERROR main.(*testWebsocketCommand).run: failed to WebSocket dial: failed to send handshake request: Get \\"http://ws/echo\\": context deadline exceeded\\n```\\n\\n  \\nHuh, not great. This part easily took the longest to debug. Most of the process was cross-checking the golang http source to see what exactly the Ziti sdk was doing differently. `dlv` was a huge help here. While I tend to lean on message log debugging for better or worse, `dlv` certainly can help visualize the call stack great. After walking through multiple requests both through HTTP and ziti from the reverse proxy we see that it is consistently sticking during the connection hijack.\\n\\n  \\nIt turns out that the ziti sdk-golang wasn\'t properly handling deadline updates which are required by the `httputil.ReverseProxy`. This caused the application to hang until the client context deadline lapsed and caused the entire call to bubble back.  \\nTo fix what we believe the problem is we need the sdk-golang package to be able to change the deadline for an inflight request and have the current read operation canceled. That boiled down to notifying the connection reader of the deadline change and recalculating the timeout necessary during the read and exiting early so the proxy server could properly handle the websocket upgrade on the connection. While doing this we discovered an oversight on how the sdk handles connection errors so as a bonus error handling should be much more stable.\\n\\n  \\nSo now if we try the same testing scenario as before we see some great news:\\n\\n```bash\\n% zrok test websocket --ziti --ziti-identity identity.json --ziti-name ws\\n[ 0.002] INFO main.(*testWebsocketCommand).run: http://ws/echo\\n[ 0.110] INFO main.(*testWebsocketCommand).run: Writting to server...\\n[ 0.110] INFO main.(*testWebsocketCommand).run: Reading response...\\n[ 0.110] INFO main.(*testWebsocketCommand).run: MessageText\\n[ 0.110] INFO main.(*testWebsocketCommand).run: i received: \\"hi\\"\\n```\\n\\n  \\nIt works! Now let\'s add another proxy, this time listening over HTTP and reaching out over Ziti (like `zrok` will).\\n\\n```bash\\n% zrok test websocket localhost:1112 \\n[ 0.001] INFO main.(*testWebsocketCommand).run: http://localhost:1112/echo[ 0.183] INFO main.(*testWebsocketCommand).run: Writting to server...\\n[ 0.183] INFO main.(*testWebsocketCommand).run: Reading response...\\n[ 0.185] INFO main.(*testWebsocketCommand).run: MessageText\\n[ 0.185] INFO main.(*testWebsocketCommand).run: i received: \\"hi\\"\\n```\\n\\n  \\nNow, this is what we want to see! At this point we are running a very simple `zrok` setup, so why don\'t we run `zrok` with these changes? (I\'m accomplishing this by using a go workspace and modifying a local version of the sdk-golang)\\n\\n```bash\\n% zrok test websocket pdd22wqr5vy0.test:8080 \\n[ 0.001] INFO main.(*testWebsocketCommand).run: http://pdd22wqr5vy0.test:8080/echo\\n[ 0.183] INFO main.(*testWebsocketCommand).run: Writting to server...\\n[ 0.183] INFO main.(*testWebsocketCommand).run: Reading response...\\n[ 0.185] INFO main.(*testWebsocketCommand).run: MessageText\\n[ 0.185] INFO main.(*testWebsocketCommand).run: i received: \\"hi\\"\\n```\\n\\n  \\nWith that, we have websockets over `zrok`! I hope you enjoyed reading through this to get an idea of our process when there are things to fix and expand on. Keep on the lookout for future features and follow the process both here and on GitHub at [https://github.com/openziti/zrok](https://github.com/openziti/zrok)."},{"id":"openapi-python-clients","metadata":{"permalink":"/docs/openziti/blog/openapi-python-clients","source":"@site/blog/openapi-python-clients.md","title":"OpenAPI Python Clients","description":"At the OpenZiti project, we heavily rely on OpenAPI specifications to streamline our development process. The OpenAPI project provides code generators that support a variety of programming languages. In this blog, we\'ll focus on a practical guide for using a generated OpenAPI Python client library. Using a generated client as a user of an API is not entirely a straightforward process. Investing some time upfront to understand the translation between the spec and the code will help you establish the right mental model and kickstart your development.","date":"2023-03-03T20:06:20.000Z","tags":[{"inline":false,"label":"Python","permalink":"/docs/openziti/blog/tags/python","description":"Python content"},{"inline":false,"label":"OpenAPI","permalink":"/docs/openziti/blog/tags/openapi","description":"OpenAPI specification"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":10.53,"hasTruncateMarker":true,"authors":[{"name":"Steven A. Broderick","title":"Author","url":"https://github.com/sabedevops","imageURL":"https://avatars.githubusercontent.com/sabedevops","key":"StevenBroderick","page":null}],"frontMatter":{"title":"OpenAPI Python Clients","date":"2023-03-03T20:06:20.000Z","cuid":"clesyuhca000009lcf8f79ub7","slug":"openapi-python-clients","authors":["StevenBroderick"],"image":"@site/blogs/openziti/v1677866933476/6a4428fe-aa77-489d-b4f3-f8251969f8df.png","imageDark":"@site/blogs/openziti/v1677866933476/6a4428fe-aa77-489d-b4f3-f8251969f8df.png","tags":["python","openapi","openziti"]},"unlisted":false,"prevItem":{"title":"Websockets over zrok","permalink":"/docs/openziti/blog/websockets-over-zrok"},"nextItem":{"title":"Postman and the Management API","permalink":"/docs/openziti/blog/postman-mgmt"}},"content":"At the [OpenZiti project](https://github.com/openziti), we heavily rely on OpenAPI specifications to streamline our development process. The OpenAPI project provides [code generators](https://openapi-generator.tech/docs/generators/) that support a variety of programming languages. In this blog, we\'ll focus on a practical guide for using a generated OpenAPI Python client library. Using a generated client as a user of an API is not entirely a straightforward process. Investing some time upfront to understand the translation between the spec and the code will help you establish the right mental model and kickstart your development.\\n\\n\x3c!-- truncate --\x3e\\n\\nWe\'ll generate an OpenAPI Python client library from our [OpenZiti Edge Client API spec](https://github.com/openziti/edge-api/blob/main/client.yml). This API allows OpenZiti clients to create OpenZiti [controller](https://netfoundry.io/docs/openziti/learn/introduction/components#openziti-controller) sessions to gather information needed for them to do work. We\'ll map what we define in the spec to the concepts expressed in the generated client. We\'ll step through a basic authentication and request/response example to help you understand what is going on.\\n\\n## Generating an OpenAPI Python Client:\\n\\nOur [edge-api](https://github.com/openziti/edge-api) project uses [go-swagger](https://github.com/go-swagger/go-swagger), which is strictly an OpenAPI 2.0 (a.k.a. Swagger 2.0/OAS2) implementation for Go. In our testing, the Python generator that best supported this spec version was the [python-prior](https://openapi-generator.tech/docs/generators/python/) generator. Below, we leverage the `openapi-generator-cli` docker container to generate the Python client library for the OpenZiti Edge Client API from its specification. The generator reads in the spec and produces a Python library compatible with our API. The `--package-name` option specifies the Python package name (directory structure under `site-packages` that will contain our library\'s `__init__.py` file).\\n\\n```bash\\ndocker run \\\\\\n    --rm \\\\\\n    --volume \\"$PWD\\":/out \\\\\\n    docker.io/openapitools/openapi-generator-cli generate \\\\\\n        --generator-name python-prior \\\\\\n        --input-spec \'https://raw.githubusercontent.com/openziti/edge-api/main/client.yml\'\\n        --output \'/out\' \\\\\\n        --package-name \'openziti_edge_client\'\\n```\\n\\nOnce generated, this library can be installed locally with `pip` as follows:\\n\\n```bash\\npip install .\\n```\\n\\n## Understanding the Generated Files:\\n\\nYou\'ll have a wealth of generated files in the output of the generator. Let\'s take a condensed look at the structure of what is generated.\\n\\n```txt\\nREADME.md\\n\u251c\u2500\u2500 docs\\n\u251c\u2500\u2500 openziti_edge_client\\n\u2502\xa0\xa0 \u251c\u2500\u2500 api/\\n\u2502\xa0\xa0 \u251c\u2500\u2500 api_client.py\\n\u2502\xa0\xa0 \u251c\u2500\u2500 apis/\\n\u2502\xa0\xa0 \u251c\u2500\u2500 configuration.py\\n\u2502\xa0\xa0 \u251c\u2500\u2500 exceptions.py\\n\u2502\xa0\xa0 \u251c\u2500\u2500 model/\\n\u2502\xa0\xa0 \u251c\u2500\u2500 models/\\n\u2502\xa0\xa0 \u2514\u2500\u2500 rest.py\\n\u2514\u2500\u2500 test\\n```\\n\\nThe `docs` folder contains a bunch of markdown files that document usage for each API endpoint and model generated in the library. The `README.md` file is essentially a `TOC` which links to these files, and additionally provides a synopsis of using the library.\\n\\nThe `models` and `apis` packages are there for convenience. Importing either will import all `api` or `model` modules respectively.\\n\\n```python\\nimport openziti_edge_client.apis   # all api modules\\nimport openziti_edge_client.models # all model modules\\n```\\n\\nBy now, you may be wondering what we mean by `api` and `model` - they are the meat and potatoes of the translated spec.\\n\\nThe `api` package contains Python modules that map the OpenAPI resource `paths` into Python `classes`. The generator creates a class `method` for each HTTP request method associated with the OpenAPI spec for that `path`. The spec\'s `tags` field determines the generated set of `classes` the Python generator creates. A path specifying multiple `tags` in the spec results in the same `path` being available in multiple `api` modules.\\n\\nThe `model` package contains modules for each of the OpenAPI `definitions`. Each model module contains a Python `class` which maps a `definition`\'s `properties` to the Python class attributes. Requests that contain a payload through an `api` module take a `model` instance pertaining to that `api` request as defined in the spec. Responses through the `api` modules return an instance of the module class pertaining to the defined response definitions in the spec. In other words, `models` are the things exchanged through the `api` modules. Because a model maps OpenAPI definition properties and instance attributes, accessing the response payload is a matter of accessing the resulting model\'s instance attributes.\\n\\nFinally, if requests made against an `api` with the `api_client.py` result in an error, the library throws one of the exceptions defined in the `exceptions.py` module. The `configuration.py` contains a `Configuration` class to hold state regarding things like the `api_client` credentials, or the `logger` configuration. We\'ll show an example below that does this, and we take a closer look at the `api` and `model` modules.\\n\\nFor now, let\'s grab the OpenZiti Edge Client spec so we can inspect a few `paths`, `definitions`, and `securityDefinitions`.\\n\\n```bash\\ncurl -O https://raw.githubusercontent.com/openziti/edge-api/main/client.yml\\n```\\n\\nWe\'ll use `yq` to filter the spec YAML. I\'ll strip the `examples` throughout here to keep the output a little more concise.\\n\\n## Let\'s Get Started:\\n\\nLet\'s look at a subset of the generated documentation and map it to back to the spec.\\n\\n| Class | Method | HTTP request | Description |\\n| --- | --- | --- | --- |\\n| *ServiceApi* | **list\\\\_services** | **GET** /services | List services |\\n\\nHere, we see we have a generated `ServiceApi` class. That class has a `list_services` method, which performs a `GET` request against the `/services` path in our API.\\n\\nLet\'s briefly take a look at that path in our spec:\\n\\n```bash\\nyq --yaml-output \'.paths.\\"/services\\"\' client.yml\\n```\\n\\n```yaml\\nget:\\n  security:\\n    - ztSession: []\\n  description: \'Retrieves a list of config resources; supports filtering, sorting,\\n    and pagination. Requires admin access.\'\\n  tags:\\n    - Service\\n  summary: List services\\n  operationId: listServices\\n  parameters:\\n    - type: integer\\n      name: limit\\n      in: query\\n    - type: integer\\n      name: offset\\n      in: query\\n    - type: string\\n      name: filter\\n      in: query\\n    - type: array\\n      items:\\n        type: string\\n      collectionFormat: multi\\n      name: roleFilter\\n      in: query\\n    - type: string\\n      name: roleSemantic\\n      in: query\\n  responses:\\n    \'200\':\\n      description: A list of services\\n      schema:\\n        $ref: \'#/definitions/listServicesEnvelope\'\\n    \'400\':\\n      description: The supplied request contains invalid fields or could not be parsed\\n        (json and non-json bodies). The error\'s code, message, and cause fields can\\n        be inspected for further information\\n      schema:\\n        $ref: \'#/definitions/apiErrorEnvelope\'\\n    \'401\':\\n      description: The currently supplied session does not have the correct access\\n        rights to request this resource\\n      schema:\\n        $ref: \'#/definitions/apiErrorEnvelope\'\\n```\\n\\nNotice a few of the keys in the spec and how they map to the generated documentation:\\n\\n* `tags` =&gt; defines the Python class the requests methods will be generated in =&gt; `ServicesApi`\\n    \\n* `path` =&gt; the endpoint the request will operate against =&gt; `/services`\\n    \\n* `get` -&gt; defines the HTTP request method when executing the method =&gt; `GET`\\n    \\n* `operationId` -&gt; defines the method name that will perform the request =&gt; `list_services()`\\n    \\n* `parameters` -&gt; become the available function parameters in the generated method =&gt; `list_services(limit=my_limit, offset=my_offset, ...)`\\n    \\n\\nAdditionally, the `responses` describe a number of `schemas` that shall be returned by the API for each of the possible HTTP status codes. These are `models` in the generated Python library. When a request is made successfully (status code == `200`), the return value of the `list_services()` method will be an instance of the `ListServicesEnvelope` model class. For any other status code, implying an error has occurred, the method will instead return an instance of the `ApiErrorEnvelope` model class.\\n\\nYou\'ll also notice the `security` section on this path. This endpoint requires the `ztSession` security definition:\\n\\n```bash\\nyq --yaml-output \'.securityDefinitions\' client.yml\\n```\\n\\n```yaml\\nztSession:\\n  description: An API Key that is provided post authentication\\n  type: apiKey\\n  name: zt-session\\n  in: header\\n```\\n\\nHere, we see that requests to this endpoint must include a header named `zt-session` containing an API key.\\n\\n## Using the Generated API Client:\\n\\nOpenZiti Edge clients can authenticate using either the `password` or `cert` method. In practice, most OpenZiti clients will create a session with the controller by performing an mTLS handshake, reading a client `credentials.json` file after JWT enrollment. We\'ll add these credentials to our `api_client`\'s `configuration`.\\n\\nOnce we authenticate, we\'ll gather the `zt-session` token out of the response and add it to our client `configuration` so that it is used in subsequent requests. We can then finally make a request with our `ServicesApi` class using the `list_services()` method, which will return a `ListServicesEnvelope` model to grant us access to our service information. OpenZiti [services](https://netfoundry.io/docs/openziti/learn/core-concepts/services/overview) are container types that encapsulate information needed by OpenZiti clients to operate on the network.\\n\\n```python\\nimport json\\nimport tempfile\\n\\nimport openziti_edge_client\\nfrom openziti_edge_client.api import authentication_api, service_api\\nfrom openziti_edge_client.model.authenticate import Authenticate\\n\\n# NOTE: we omit some error handling here, to keep things clear\\n\\nwith open(\\"./credentials.json\\", \'r\', encoding=\'UTF-8\') as id_f:\\n    id_json = json.load(id_f)\\n\\n# The generated library expects the CA, client cert and key to be files\\n# so we\'ll split our `credentials.json` file contents here\\nca_fp = tempfile.NamedTemporaryFile(buffering=0)\\ncert_fp = tempfile.NamedTemporaryFile(buffering=0)\\nkey_fp = tempfile.NamedTemporaryFile(buffering=0)\\n\\nca_fp.write(id_json[\'id\'][\'ca\'].encode(\'UTF-8\'))\\ncert_fp.write(id_json[\'id\'][\'cert\'].encode(\'UTF-8\'))\\nkey_fp.write(id_json[\'id\'][\'key\'].encode(\'UTF-8\'))\\n\\n# We instantiate a Configuration class to store the\\n# Edge Client API endpoint and client certificates\\nconfiguration = openziti_edge_client.Configuration(\\n    host=id_json[\'ztAPI\'] + \\"/edge/client/v1\\",\\n    ssl_ca_cert=ca_fp.name\\n)\\n\\nconfiguration.cert_file = cert_fp.name\\nconfiguration.key_file = key_fp.name\\n\\n# We pass the configuration to the constructor of the `ApiClient`,\\n# which will read the stored state of the configuration class\\nwith openziti_edge_client.ApiClient(configuration) as api_client:\\n    \\n    # We\'ll use this api_client as a context manager to make requests\\n    # against the Edge API and set the authentication method\\n    api_auth = authentication_api.AuthenticationApi(api_client)\\n    method = \\"cert\\"\\n  \\n    # The /authenticate endpoint requires an `Authenticate` model\\n    auth = Authenticate()\\n\\n    # Session here will be an instance of the\\n    # CurrentApiSessionDetailEnvelope  model class\\n    session = api_auth.authenticate(method, auth=auth)\\n\\n    # We can descend down the nested definitions to get our\\n    # final return value.\\n    configuration.api_key[\'ztSession\'] = session.data.token\\n    \\n    # Finally, we can make a request to GET /services\\n    api_service = service_api.ServiceApi(api_client)\\n    services = api_service.list_services()\\n```\\n\\nThat\'s it! We authenticated to our API, gathered our `zt-session` token, and ran our first request to `ServiceApi.list_services()`. All other requests using the generated client follow a similar pattern. While not shown here, requests for HTTP resource types that contain a body (often a `POST`, `PUT`, etc.) will require you to create a model class instance with all required properties and attach it to your request via arguments to the relevant class methods.\\n\\nA noteworthy aspect of the resulting `session` and `services` objects above is they are OpenAPI models whose schemas reference other schemas in the spec. When we descend down the instance attributes like `session.data.token`, we are actually traversing the attributes of 3 schema definitions. Similarly, the `services` object is a `ListServicesEnvelope` model class instance as prescribed in the spec, which is composed of other definitions. This relationship between the `api` classes and the `model` classes is key in the behavior of the Python client.\\n\\n## A closer look at the response:\\n\\nLet\'s recursively show the definitions defined in the `ListServicesEnvelope`, and see how we can access the list of services. Remember, each of these definitions becomes a model class in our generated client.\\n\\n```bash\\nyq --yaml-output \'.definitions.listServicesEnvelope\' client.yml\\n```\\n\\n```yaml\\ntype: object\\nrequired:\\n  - meta\\n  - data\\nproperties:\\n  data:\\n    $ref: \'#/definitions/serviceList\'\\n  meta:\\n    $ref: \'#/definitions/meta\'\\n```\\n\\nHere, we see that the envelope itself is a JSON object with two properties: meta and data. The `data` property is itself a `serviceList` with an `array` type.\\n\\n```bash\\nyq --yaml-output \'.definitions.serviceList\' client.yml\\n```\\n\\n```yaml\\ntype: array\\nitems:\\n  $ref: \'#/definitions/serviceDetail\'\\n```\\n\\nEach item in this array is a `serviceDetail`. These are the actual `service` objects stored in the OpenZiti database that the API client making this request has access to. If we want to inspect some properties of the services, we must do so through the `ServiceDetail` model nested in the result.\\n\\n```bash\\nyq --yaml-output \'.definitions.serviceDetail\' client.yml\\n```\\n\\n```yaml\\ntype: object\\nallOf:\\n  - $ref: \'#/definitions/baseEntity\'\\n  - type: object\\n    required:\\n      - name\\n      - terminatorStrategy\\n      - roleAttributes\\n      - permissions\\n      - configs\\n      - config\\n      - encryptionRequired\\n      - postureQueries\\n    properties:\\n      config:\\n        description: map of config data for this service keyed by the config type\\n          name. Only configs of the types requested will be returned.\\n        type: object\\n        additionalProperties:\\n          type: object\\n          additionalProperties:\\n            type: object\\n      configs:\\n        type: array\\n        items:\\n          type: string\\n      encryptionRequired:\\n        description: Describes whether connections must support end-to-end encryption\\n          on both sides of the connection. Read-only property, set at create.\\n        type: boolean\\n      name:\\n        type: string\\n      permissions:\\n        $ref: \'#/definitions/dialBindArray\'\\n      postureQueries:\\n        type: array\\n        items:\\n          $ref: \'#/definitions/postureQueries\'\\n      roleAttributes:\\n        $ref: \'#/definitions/attributes\'\\n      terminatorStrategy:\\n        type: string\\n```\\n\\nContinuing from our example above, we can traverse down to these services to inspect the properties described in the `ServiceDetail` above for each service in our `ServiceList`:\\n\\n```python\\n    # ... continued from above ...\\n    services = api_service.list_services()\\n    \\n    # ListServicesEnvelope->ServiceList->ServiceDetail\\n    for service in services.data.value:\\n        print(f\\"Model: {type(service)}\\")\\n        print(f\\"Service Name: {service.name}\\")\\n        print(f\\"Service: {service}\\")\\n      \\n        # ServiceDetail->DialBindArray->DialBind\\n        for permission in service.permissions.value:\\n            print(f\\"Permissions: {permission}\\")\\n```\\n\\nFinally, we\'ve arrived at our actual services and can access the response JSON through the model\'s instance attributes.\\n\\nWe hope this guide has helped you get started using OpenAPI-generated Python clients. Currently, we host generated Python clients for our Edge Management and Client APIs in the [openziti-test-kitchen](https://github.com/openziti-test-kitchen) GitHub project."},{"id":"postman-mgmt","metadata":{"permalink":"/docs/openziti/blog/postman-mgmt","source":"@site/blog/postman-and-the-management-api.md","title":"Postman and the Management API","description":"Postman can build a collection of API requests and has a friendly interface for walking the API specification. This article aims to accelerate your timeline for productively exploring the API and developing an integration.","date":"2023-03-02T15:08:04.000Z","tags":[{"inline":false,"label":"Postman","permalink":"/docs/openziti/blog/tags/postman","description":"Postman API client"},{"inline":false,"label":"Swagger","permalink":"/docs/openziti/blog/tags/swagger","description":"Swagger / OpenAPI tools"},{"inline":false,"label":"REST API","permalink":"/docs/openziti/blog/tags/rest-api","description":"REST APIs"},{"inline":false,"label":"OpenAPI","permalink":"/docs/openziti/blog/tags/openapi","description":"OpenAPI specification"},{"inline":false,"label":"Code Generation","permalink":"/docs/openziti/blog/tags/codegeneration","description":"Code generation content"}],"readingTime":3.46,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"Postman and the Management API","date":"2023-03-02T15:08:04.000Z","cuid":"cler8r24d000n09ichw8y48u8","slug":"postman-mgmt","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1677732038328/f6149856-e282-4451-b1a4-f278eff9f11b.png","imageDark":"@site/blogs/openziti/v1677732038328/f6149856-e282-4451-b1a4-f278eff9f11b.png","ogimage":"/blogs/openziti/v1677731728423/ba352516-83a5-48a8-a41b-e028c2dad45e.png","tags":["postman","swagger","rest-api","openapi","codegeneration"]},"unlisted":false,"prevItem":{"title":"OpenAPI Python Clients","permalink":"/docs/openziti/blog/openapi-python-clients"},"nextItem":{"title":"The Road Ahead for zrok","permalink":"/docs/openziti/blog/the-road-ahead-for-zrok"}},"content":"Postman can build a collection of API requests and has a friendly interface for walking the API specification. This article aims to accelerate your timeline for productively exploring the API and developing an integration.\\n\\n\x3c!-- truncate --\x3e\\n\\n## About the Management API\\n\\nThe [OpenZiti](https://netfoundry.io/docs/openziti/learn/introduction/) controller provides an edge-management API for creating, reading, updating, and deleting (CRUD) OpenZiti resources, e.g., Services, Edge Router Policies, etc. The simplest way to use the edge-management API is through [the `ziti` CLI](https://netfoundry.io/docs/openziti/downloads#the-ziti-executable) or [the console](https://github.com/openziti/ziti-console#readme).\\n\\n### What about the Client API?\\n\\nThe edge-management API is distinct from the edge-client API. [Edge SDKs](https://netfoundry.io/docs/openziti/reference/developer/sdk/) use the edge-client API to authenticate and find services and routers. The OpenZiti Controller can be configured to provide both APIs on the same server port. Whether the two APIs are combined or split, their URL paths are discrete. You can learn more about both APIs in [the developer references](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/).\\n\\n## Generated Clients\\n\\nBefore you write an edge-management client, could you use the [Go client (`go-swagger`)](https://github.com/openziti/edge-api/tree/main/rest_management_api_client) or [Python client (`openapi-generator`)](https://github.com/openziti-test-kitchen/openziti-edge-management-python) generated from the specification? Those might save you some typing if you can adapt them to your purpose.\\n\\n## Get the OpenAPI 2.0 Specification\\n\\nThe best place to get the specification is your running OpenZiti Controller. That way, you know the specification matches the version you are using. The controller publishes the spec in the edge-management API at the path `/edge/management/v1/swagger.json`. There\'s also a built-in API reference website at the path `/edge/management/v1/docs`. If you don\'t have a running controller, browse [the latest spec and API reference on the docs site](https://netfoundry.io/docs/openziti/reference/developer/api/edge-management-reference).\\n\\n## Import to Postman\\n\\nClick the \\"[Import](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/)\\" button on your Postman Workspace and provide a file path or URL to the OpenZiti edge-management API specification.\\n\\n## Create a Postman Environment\\n\\n1. Create a Postman environment for this API. [Here\'s the Postman help for reference](https://learning.postman.com/docs/sending-requests/managing-environments/).\\n    \\n2. Add a variable \\"[baseUrl](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/)\\" and assign the current value of your management API\'s URL. For example, if the API is listening on local port 1280, assign `https://localhost:1280/edge/management/v1`.\\n    \\n3. Add another variable named \\"**apiKey**\\" without any value. This variable will be assigned by the \\"authenticate\\" request\'s test script.\\n    \\n\\n## Customize the Authenticate Request\\n\\nModify the \\"[authenticate](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/)\\" request to store your API session token in your Postman environment. All subsequent requests will use this bearer token.\\n\\nIn the collection of requests that Postman generated from the spec, find the request named \\"**authenticate**\\" and select the POST operation named \\"**Authenticate via a method supplied via a query string parameter**.\\"\\n\\n1. In the \\"[Params](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/)\\" tab of the request, ensure you have a query param named \\"[method](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/)\\" with the value \\"[password](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/)\\".\\n    \\n2. Ensure the request path of the operation is now showing `{{baseUrl}}/authenticate?method=password`.\\n    \\n3. In the \\"Tests\\" tab of the request, add this Javascript.\\n    \\n    ```javascript\\n    var jsonData = JSON.parse(responseBody);\\n    pm.environment.set(\\"apiKey\\", jsonData.data.token);\\n    ```\\n    \\n4. In the \\"[Body](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/)\\" tab of the request, add JSON like this with your correct username and password for the management API.\\n    \\n    ```json\\n    {\\n        \\"username\\": \\"admin\\",\\n        \\"password\\": \\"Otz2q5gnYVSTkza2aJ1EUq72hGGiFvmZ\\"\\n    }\\n    ```\\n    \\n5. Click the \\"[Send](https://ziti-doc-git-kube-guide-openziti.vercel.app/docs/reference/developer/)\\" button.\\n    \\n\\nYou should have received an HTTP OK (200) response from the management API. Now you can send any other requests in the collection, and they will automatically use the token from your Postman environment."},{"id":"the-road-ahead-for-zrok","metadata":{"permalink":"/docs/openziti/blog/the-road-ahead-for-zrok","source":"@site/blog/the-road-ahead-for-zrok.md","title":"The Road Ahead for zrok","description":"If you\'re not sure what zrok is, see our blog post introducing zrok.","date":"2023-02-22T17:55:42.000Z","tags":[{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"Roadmap","permalink":"/docs/openziti/blog/tags/roadmap","description":"Project roadmaps"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":6.17,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"The Road Ahead for zrok","date":"2023-02-22T17:55:42.000Z","cuid":"clefz7tjy000409l2fd68ako3","slug":"the-road-ahead-for-zrok","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1676487591508/4549ff85-029e-442a-bcbc-94db870e9d63.jpeg","imageDark":"@site/blogs/openziti/v1676487591508/4549ff85-029e-442a-bcbc-94db870e9d63.jpeg","tags":["networking","roadmap","openziti","zerotrust","zrok"]},"unlisted":false,"prevItem":{"title":"Postman and the Management API","permalink":"/docs/openziti/blog/postman-mgmt"},"nextItem":{"title":"Ziti Shell Auto-Complete","permalink":"/docs/openziti/blog/auto-complete"}},"content":"> If you\'re not sure what `zrok` is, see our blog post [introducing `zrok`](./introducing-zrok.md).\\n\\nNow that `v0.3` has been released the `zrok` team is spending time collecting feedback and building our roadmap for what\'s coming next in `v0.4`.\\n\\nAs always, our [project board](https://github.com/orgs/openziti/projects/16) on [Github](https://github.com/openziti/zrok) is always up to date with the latest low-level roadmap details. Don\'t forget to see the tabs at the top of the board for specific views filtering on each major release.\\n\\nHere\'s a high-level preview of some of the things that we\'re working on for `zrok v0.4`.\\n\\n\x3c!-- truncate --\x3e\\n\\n## TCP and UDP Tunneling\\n\\nIn `v0.4`, you\'re going to be able to create low-level network tunnels like this:\\n\\n```plaintext\\n$ zrok share private --backend-mode tunnel udp:127.0.0.1:53\\n```\\n\\nA corresponding `zrok access private` command will allow a remote user to access your shared UDP endpoint locally on their system.\\n\\nThis will also work for TCP.\\n\\nThe new tunnel backend mode will allow you to quickly and easily share tunnels for all manner of low-level TCP and UDP protocols, including things like SSH, RDP, VNC, and various gaming and sharing protocols, etc.\\n\\n## zrok \\"Drives\\"\\n\\nIn `v0.4`, `zrok` will include \\"drive\\" functionality, allowing users to create private virtual drives exposed as `zrok` shares. The `zrok` tooling will include powerful CLI utilities to make reading and writing these decentralized, peer-to-peer drives very frictionless and intuitive right from your shell environment.\\n\\nImage a command like:\\n\\n```plaintext\\n$ zrok share private --backend-mode drive ${HOME}/Documents\\n```\\n\\nAnd then using commands like:\\n\\n```plaintext\\n$ zrok send a_big_archive.zip 3exk5stntix9\\ncopied 1 file for 833477 bytes to \'3exk5stntix9\'\\n```\\n\\nOr:\\n\\n```plaintext\\n$ zrok mount 3exk5stntix9\\n3exk5stntix9::> ls\\n-rwxr-xr-x 1 michael michael   2353 Jan 31 11:50 zrok_deployment.drawio\\n-rwxrwxr-x 1 michael michael  64358 Jan 31 11:51 zrok_deployment.png\\n-rwxrwxr-x 1 michael michael  21116 Jan 30 14:26 zrok_docs_share.png\\n3exk5stntix9::> get zrok_deployment.png\\nreceived 64358 bytes to \'zrok_deployment.png\'\\n3exk5stntix9::> put my_file.png\\nsent 128834 bytes to \'my_file.png\'\\n```\\n\\nOr even:\\n\\n```plaintext\\n$ zrok recv 3exk5stntix9\\ncopied 5 files for 12187888 bytes to \'/home/michael/3exk5stntix9\'\\n```\\n\\nLike all of the other types of shares supported by `zrok`, drives will be peer-to-peer and decentralized. We intend to include support for both public and private drive shares.\\n\\nGot massive storage space? Implement your own replacement for one of the large, centralized cloud storage solutions!\\n\\n## Streamlined Invite Process\\n\\nThere\'s been occasional confusion around how invite tokens work in `v0.3`. We\'re going to spend some cycles working on streamlining and improving the invitation and registration process for `v0.4`.\\n\\n## Web Console Improvements\\n\\nThe web console will be getting another round of refinements for `v0.4`. The explorer interface will be receiving a round of usability improvements and will incorporate all of the additional details about shares, environments, reservations, and usage that are not present in `v0.3`.\\n\\n### Change Password, Revoke Secret\\n\\nThere is no specific function for changing an account password in `v0.3`. The current workaround is to use the `Forgot Password?` link in the web console. `v0.4` will introduce a password change function directly in the web console.\\n\\nAnd if you\'ve ever accidentally let your secret token escape... you\'ll be able to revoke and generate a new one in `v0.4`.\\n\\n## Vanity Share Tokens\\n\\nWe\'re considering introducing the ability to request a specific token when creating reserved shares for `v0.4`. Something along the lines of:\\n\\n```plaintext\\n$ zrok reserve private --backend-mode web . --named myBigShare\\n```\\n\\nOther users will be able to access your share using:\\n\\n```plaintext\\n$ zrok access private myBigShare\\n```\\n\\n## TLS for Controller and Frontends\\n\\nIn `v0.4` you\'ll be able to configure HTTPS listeners for both the controller and any `zrok access` frontends. This will make spinning up HTTPS-enabled `zrok` components simpler, eliminating the need for nginx in a lot of deployment scenarios.\\n\\n## TUI and CLI Refinements\\n\\n`v0.4` will see several improvements to the TUI and the CLI, including:\\n\\n### Refined Reserved Sharing Workflow\\n\\nWe\'re considering some refinements to the `zrok reserve`/`zrok share reserved` workflow, possibly reducing the number of commands involved.\\n\\nWe\'re also looking at allowing you to change the reservation status of an existing public or private share to a reserved share through the TUI. Shared something ephemerally and then decided you want to keep it around as a reserved share? This new TUI change we\'re considering would allow you to do that easily.\\n\\n### Additional `zrok config` Options\\n\\nCurrently, `zrok config` is only used to set the `apiEndpoint` address (to configure your service instance). In `v0.4`, we\'ll be introducing new `zrok config` options that allow you to control various behaviors of the operation of the TUI and CLI. Want to configure headless mode by default? Want the URL parser to use HTTPS by default? Options like that will be configurable through `zrok config`.\\n\\n`zrok config` was intended to be conceptually similar to `git config --global`.\\n\\n### Single-command Multi-share\\n\\nWant to launch multiple shares through a single command? We\'re working on that for `v0.4`.\\n\\n### XDG Base Directory Specification\\n\\n`zrok` currently uses `${HOME}/.zrok` to store secrets and configuration. We\'re considering adjusting this to be compatible with the XDG Base Directory Specification for `v0.4`:\\n\\nhttps://specifications.freedesktop.org/basedir-spec/latest/\\n\\n## Improved Metrics\\n\\n`zrok` `v0.3` has a minimal, proof-of-concept metrics implementation that is primarily used to draw sparkline graphs for activity against public shares. Metrics in `v0.3` are generated by the frontend and delivered to the controller.\\n\\n`v0.4` will see significant improvements to its metrics infrastructure to support new and refined capabilities, including:\\n\\n### OpenZiti Metrics\\n\\nAll of the metrics in `v0.4` will be coming directly from the underlying OpenZiti overlay network.\\n\\n### Bandwidth-based Limits\\n\\n`v0.3` has support for simple resource-based limits. A limit on the number of environments and shares can be configured per instance. This was the absolute minimum we felt we needed to support to allow external users to start working with our shared `zrok.io` instance.\\n\\n`v0.4` will incorporate bandwidth-based limits. This will allow a service instance to limit the amount of traffic per account, environment, and share. We feel this is necessary for us to open up access to `zrok.io` to a larger pool of users.\\n\\n### Sparklines Everywhere\\n\\n`v0.3` only has working sparkline graphs for public shares. With the new metrics subsystem based on OpenZiti metrics, we\'ll be able to provide much deeper analytics for all kinds of shares, and we\'ll also be able to potentially incorporate traffic data into the web console\'s explorer view.\\n\\n## Back-porting to v0.3\\n\\nAs much as possible we\'ll attempt to try to back-port the most pressing features from the `v0.4` development stream back into `v0.3`. We expect to get capabilities like secret token revocation incorporated in `v0.3` very quickly. We\'ll be monitoring many of the other improvements so that we can get them into your hands as quickly as possible.\\n\\n## Forward to v0.5\\n\\nThings get a little hazier the further out into the future we get, but the general idea for `v0.5` will be to focus on the non-technical end-user experience. The plan is to ship a desktop client for `zrok` that quietly sits in your toolbar or tray, and is available for rapid sharing and access from one or more `zrok` service instances.\\n\\nWe\'ll continue to refine and improve our shell-based experience, but the goal will be to expand the usefulness of `zrok` for a wider group of users looking for integration with their desktop experience."},{"id":"auto-complete","metadata":{"permalink":"/docs/openziti/blog/auto-complete","source":"@site/blog/ziti-shell-auto-complete.md","title":"Ziti Shell Auto-Complete","description":"This one\'s for the shell ninjas. The ziti CLI comes with auto-complete! You can use completions in any shell","date":"2023-02-22T15:47:45.000Z","tags":[{"inline":false,"label":"Bash","permalink":"/docs/openziti/blog/tags/bash","description":"Bash shell content"},{"inline":false,"label":"Zsh","permalink":"/docs/openziti/blog/tags/zsh","description":"Z shell content"},{"inline":false,"label":"Autocomplete","permalink":"/docs/openziti/blog/tags/autocomplete","description":"Autocomplete features"}],"readingTime":2.25,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Bingham","title":"Author","url":"https://github.com/qrkourier","imageURL":"https://avatars.githubusercontent.com/qrkourier","key":"KennethBingham","page":null}],"frontMatter":{"title":"Ziti Shell Auto-Complete","seoTitle":"openziti command shell auto-complete","seoDescription":"How to set up auto-complete for the ziti command","date":"2023-02-22T15:47:45.000Z","cuid":"clefun9ff000009jj6du9fwil","slug":"auto-complete","authors":["KennethBingham"],"image":"@site/blogs/openziti/v1677080778065/71fdf983-8355-486e-bb8a-fb57861ea45a.png","imageDark":"@site/blogs/openziti/v1677080778065/71fdf983-8355-486e-bb8a-fb57861ea45a.png","ogimage":"/blogs/openziti/v1677080756391/8f849497-c588-4a59-bf63-108bd522d8f0.png","tags":["bash","zsh","autocomplete"]},"unlisted":false,"prevItem":{"title":"The Road Ahead for zrok","permalink":"/docs/openziti/blog/the-road-ahead-for-zrok"},"nextItem":{"title":"Introducing zrok","permalink":"/docs/openziti/blog/introducing-zrok"}},"content":"This one\'s for the shell ninjas. The `ziti` CLI comes with auto-complete! You can use completions in any shell \\nsupported by [Cobra](https://cobra.dev/#generating-bash-completions). This post will distill the Cobra instructions \\nwith correct examples for `ziti` in BASH and ZSH.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Install `ziti`\\n\\nFirst, make sure you have the `ziti` CLI. You can [download the latest executable for your OS from GitHub](https://github.com/openziti/ziti/releases/latest).\\n\\n## BASH\\n\\n### Enable Completions in BASH\\n\\nYou must install `bash-completion` to enable completions for BASH. This is a standard package name for Homebrew, Apt, and Yum/DNF.\\n\\n### Install `ziti` Completions for BASH\\n\\nBASH completions are loaded directly into the shell\'s environment with the `source` command like this:\\n\\n```bash\\nsource <(ziti completion bash)\\n```\\n\\nThat\'s it! You\'re done setting up completion in your currently-running BASH shell. Now you can type `ziti` (followed by a space) and hit the TAB key to auto-complete subcommands and options.\\n\\nTo install this configuration permanently, add the same `source` command to your BASH configuration file, e.g., `~/.bashrc`.\\n\\n### BASH `ziti` Alias\\n\\nWhat if you want to save some typing and say `z`, instead of `ziti`, to run a command? Unfortunately, this breaks BASH completion, but it\'s easily fixed. You must add a completion alias to your BASH config file like this:\\n\\n```bash\\nalias z=ziti\\ncomplete -o default -F __start_ziti z\\n```\\n\\n## ZSH\\n\\n### Enable Completions in ZSH\\n\\nYou must load `compinit` to enable completion in ZSH. You can run this command to test and then add the same command to your ZSH config, e.g., `~/.zshrc`to auto-configure future shells.\\n\\n```bash\\nautoload -U compinit\\ncompinit\\n```\\n\\n### Install `ziti` Completions for ZSH\\n\\nZSH completions work with the `$fpath` environment variable and you must generate the completion script and install it with the correct filename in any one of the directories listed in your `$fpath`.\\n\\n```bash\\n# assuming ~/.zsh/completion/ is in $fpath\\nziti completion zsh > ~/.zsh/completion/_ziti\\n```\\n\\n### ZSH `ziti` Alias\\n\\nGood news! Shell aliases work automatically with ZSH completions.\\n\\n```bash\\nalias z=ziti\\n# now you can say \\"z\\" (space) and tab auto-complete \\"ziti\\" commands!\\n```\\n\\n## Which shell am I running?\\n\\nIf you didn\'t change your shell on purpose, you\'re probably running ZSH on macOS and BASH on Linux (including Windows Subsystem for Linux \\\\[WSL\\\\]). You can try these two commands to see if the `ps` command can tell you which shell you\'re using.\\n\\n```bash\\n$ ps -p$$ -ocommand=\\n/usr/bin/zsh\\n\\n# try this variant if the first one gave you an error\\n$ ps -p$$ -ocmd=\\n/usr/bin/zsh\\n```\\n\\nWith the command `chsh`, you may change your default shell for all future terminal sessions in macOS or Linux.\\n\\n```bash\\n# use zsh for future shells \\nchsh -s /usr/bin/zsh\\n```"},{"id":"introducing-zrok","metadata":{"permalink":"/docs/openziti/blog/introducing-zrok","source":"@site/blog/introducing-zrok.md","title":"Introducing zrok","description":"I\'m fortunate that I\'ve had the opportunity to work on many interesting projects throughout my career. I was one of the original developers who broke ground on the OpenZiti project back in 2017. Most of my work on OpenZiti centered on the fabric, data and control plane design, and designing abstractions that would support a lot of what became the \\"edge\\" layers. It\'s been quite exciting to watch OpenZiti blossom and grow.","date":"2023-02-07T15:22:31.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"},{"inline":false,"label":"NetSec","permalink":"/docs/openziti/blog/tags/netsec","description":"Network security"},{"inline":false,"label":"Ziti","permalink":"/docs/openziti/blog/tags/ziti","description":"Ziti related posts"}],"readingTime":4.93,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Introducing zrok","date":"2023-02-07T15:22:31.000Z","cuid":"cldue515r000509l04jhy0c8q","slug":"introducing-zrok","image":"@site/blogs/openziti/v1674827219782/e0a7faf4-3645-4289-b8a0-84536277f4d0.png","imageDark":"@site/blogs/openziti/v1674827219782/e0a7faf4-3645-4289-b8a0-84536277f4d0.png","tags":["golang","openziti","zrok","netsec","ziti"]},"unlisted":false,"prevItem":{"title":"Ziti Shell Auto-Complete","permalink":"/docs/openziti/blog/auto-complete"},"nextItem":{"title":"Connecting to Local Development Environment from Cloud Hosts with zrok","permalink":"/docs/openziti/blog/connecting-to-local-development-environment-from-cloud-hosts-with-zrok"}},"content":"I\'m fortunate that I\'ve had the opportunity to work on many interesting projects throughout my career. I was one of the original developers who broke ground on the [OpenZiti](https://github.com/openziti/ziti) project back in 2017. Most of my work on OpenZiti centered on the [fabric](https://github.com/openziti/fabric), data and control plane design, and designing abstractions that would support a lot of what became the \\"edge\\" layers. It\'s been quite exciting to watch OpenZiti blossom and grow.\\n\\nFor the last six months, I\'ve had the opportunity to re-approach the world of zero-trust and next-generation networking from the other side of the stack. Instead of working in the lowest layers of protocols and abstractions, I\'m working from the perspective of end users and enabling an amazing end-user experience. I\'m excited to introduce you to a new set of tools designed to empower end users at the network edge to seamlessly and transparently share resources. Imagine network sharing that is equally secure and transparent.\\n\\n![](/blogs/openziti/v1674828434457/eb0a6668-f227-44af-94e4-e639fff0cea2.png)\\n\\nThis new project is called... `zrok`.\\n\\n\x3c!-- truncate --\x3e\\n\\n`zrok` focuses on making secure sharing easy for both developers and end users alike. `zrok` takes inspiration from several other offerings that streamline developer endpoint sharing. Starting from that recipe, `zrok` adds powerful capabilities that are made possible by building on the foundation provided by OpenZiti.\\n\\nHere are some of the things that make `zrok` different...\\n\\n## Private Sharing\\n\\nMost of the offerings in this space allow you to easily create \\"tunnels\\" that allow outbound-only access to local HTTP resources without punching any holes in a firewall. These tools make these kinds of tunnels effortless to create; with a single command, you\'ve got a public URL that you can share to allow access to your endpoint.\\n\\n`zrok` expands on this model by supporting something that we\'re calling \\"private sharing\\". You\'ll share your resources using a single command, but your resources will be privately shared on an OpenZiti network, where they can be securely accessed with a single `zrok` command by other users. Private sharing enables secure, peer-to-peer zero-trust connectivity between `zrok` users.\\n\\nIn this model, no user ever has to enable any inbound access from untrusted users. All network access is handled through a secure, zero-trust overlay network. And to make it even simpler, `zrok` handles all of the control plane management of the overlay network, deeply simplifying the experience. This secure sharing model remains the single-command affair that users have come to expect.\\n\\n## Files; Repositories; Video... Decentralized\\n\\nMost of the other offerings in this space are focused on sharing low-level network resources. These tools are often used by developers or operations staff to allow access to a private HTTP endpoint or to facilitate a callback to a private endpoint through a webhook. It\'s considered table stakes for these tools to do this in a *frictionless* way.\\n\\n`zrok` also provides a frictionless experience for sharing these kinds of network resources. However, we\'re taking it a step further... `zrok` will also make this kind of frictionless, decentralized sharing possible for files, software repositories, video streams, and other kinds of resources we haven\'t even thought of yet.\\n\\nCombine this kind of resource sharing with our private sharing model, and you\'ve got the recipe for very powerful decentralized services. Imagine using `zrok` as a decentralized, distributed replacement for large centralized file-sharing platforms. Or use it as a replacement for large, centralized video streaming platforms.\\n\\nWe\'re still just getting started on building out these aspects of `zrok`. But as of this writing, `zrok` already provides built-in single-command file sharing. Combine this with private sharing and you can see this powerful model in action today.\\n\\n## Production zrok\\n\\n[NetFoundry](https://netfoundry.io) is offering [zrok.io](https://zrok.io), a managed `zrok` service instance you can use to try out `zrok` and even run small production workloads. This service is currently in limited beta and is available through an invitation process. Visit [zrok.io](https://zrok.io) for details about requesting an invite.\\n\\nOnce `zrok` and `zrok.io` are out of beta, we\'ll be opening it up to the public.\\n\\n`zrok.io` runs on top of the open-source version of `zrok`. We\'re building out a production environment to make sure we can properly operationalize it, but it\'s the same code you can run in your own environments.\\n\\n![](/blogs/openziti/v1674828293204/5ba67a95-c7bf-4efd-9a52-f160c7f60924.png)\\n\\n## Open-Source; Self-Host\\n\\n`zrok` is committed to being open-source. You\'ve got everything you need to host your own `zrok` instance on top of your own private OpenZiti network. We\'ve even streamlined this process, and we\'re including a simple [guide](https://docs.zrok.io/docs/category/self-hosting/) to getting this running in minutes, including the OpenZiti portions.\\n\\nYou can [access](https://github.com/openziti/zrok) the open-source version of `zrok` today.\\n\\n## A Start\\n\\nI\'m really excited about sharing `zrok` with you. As of this writing, we\'re at `v0.3.0`, and there is still a ton of work to do to get `zrok` to where I know it can go. `zrok` is open-source, and we\'re going to be developing it in public, just like the rest of the OpenZiti products (check out the [OpenZiti GitHub](https://github.com/openziti)).\\n\\nStarting with `v0.4`, I\'m planning on producing a set of regularly-released \\"development notebooks\\", documenting the development process and giving you a look at the work we\'re doing with `zrok`. I\'m also planning on producing a set of videos that work through some of what\'s involved in building your own tiny version of `zrok` on top of OpenZiti; these will be a great introduction to building a *Ziti Native Application* from the ground up. These videos will also be a comprehensive look at how `zrok` works.\\n\\nWe\'d love your participation in the `zrok` project! You can find us on GitHub at [https://github.com/openziti/zrok](https://github.com/openziti/zrok).\\n\\n%[https://youtu.be/zJaUyaVc5Mo]"},{"id":"connecting-to-local-development-environment-from-cloud-hosts-with-zrok","metadata":{"permalink":"/docs/openziti/blog/connecting-to-local-development-environment-from-cloud-hosts-with-zrok","source":"@site/blog/connecting-to-local-development-environment-from-cloud-hosts-with-zrok.md","title":"Connecting to Local Development Environment from Cloud Hosts with zrok","description":"All developers have at some point used cloud-provided compute hosts. It\'s very easy, it\'s very convenient, and it\'s relatively cheap. One problem that you frequently run into is how to use these hosts in local development.","date":"2023-02-02T03:28:34.000Z","tags":[{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":3.6,"hasTruncateMarker":true,"authors":[{"name":"Jens Alm","title":"Author","url":"https://github.com/jensalm","imageURL":"https://avatars.githubusercontent.com/jensalm","key":"JensAlm","page":null}],"frontMatter":{"title":"Connecting to Local Development Environment from Cloud Hosts with zrok","date":"2023-02-02T03:28:34.000Z","cuid":"cldmgr6yi000309l2af9p25zs","slug":"connecting-to-local-development-environment-from-cloud-hosts-with-zrok","authors":["JensAlm"],"image":"@site/blogs/openziti/v1675019484328/e1156433-d3b2-4a5d-b709-1679afe76be3.jpeg","imageDark":"@site/blogs/openziti/v1675019484328/e1156433-d3b2-4a5d-b709-1679afe76be3.jpeg","tags":["opensource","openziti"]},"unlisted":false,"prevItem":{"title":"Introducing zrok","permalink":"/docs/openziti/blog/introducing-zrok"},"nextItem":{"title":"Lessons Learned Writing a Zero Trust NGINX Module","permalink":"/docs/openziti/blog/lessons-learned-writing-a-zero-trust-nginx-module"}},"content":"All developers have at some point used cloud-provided compute hosts. It\'s very easy, it\'s very convenient, and it\'s relatively cheap. One problem that you frequently run into is how to use these hosts in local development.\\n\\nAt work, we use cloud-provided hosts extensively and I often need the hosts to connect back to my local environment to read data. One such example is when we use the Salt stack to manage software on the hosts.\\n\\n\x3c!-- truncate --\x3e\\n\\n## How We Use Salt\\n\\nSalt ([https://saltproject.io/](https://saltproject.io/)) is an open-source software project for configuration management and remote execution of commands, designed to manage and automate large-scale infrastructure. Salt needs configuration data to execute those commands. In our case, we need data to configure the [OpenZiti](https://github.com/openziti/) software we\'re installing on the host.  \\nI often need the cloud host to read this configuration data from my local machine while I\'m developing or testing the integration between Salt and our systems.\\n\\n## Without zrok\\n\\nFor Salt to be able to read its configuration data from my local development machine I had to:\\n\\n* Get my public IP\\n    \\n* Open a port in my firewall\\n    \\n* Set up port forwarding\\n    \\n* Use the IP in our configuration\\n    \\n\\nThis is not necessarily difficult but it does take time and it involves configuring your router to allow incoming connections. You also have to remember to remove it or you are potentially risking someone accessing your computer.  \\nUnless you also have a static IP, it will change quite frequently and you may have to repeat this process quite often. In the case of Salt, that means reconfiguring Salt every time this happens.\\n\\n## With zrok\\n\\nzrok will let us skip parts of the setup above. If you haven\'t already read the [Introducing zrok](./introducing-zrok.md) I suggest you do so, it will give a lot more information about the underlying technology.  \\nHere are the steps we need to do:\\n\\n* Create a reserved share\\n    \\n* Start sharing\\n    \\n* Use the generated <mark>domain name</mark> in our configuration\\n    \\n\\nHop over to [https://zrok.io](https://zrok.io) and create an account (it\'s free!) and download the binaries for your environment.  \\nIn my Salt scenario, I am trying to share the configuration data on a local service running on port 9302. Let\'s see how we do that with zrok.\\n\\nFirst, let\'s create the share.\\n\\n```bash\\n> zrok reserve public http://localhost:9302 --backend-mode proxy\\n[   0.374]    INFO main.(*reserveCommand).run: your reserved share token is \'u4eh9mnwl4jb\'\\n[   0.374]    INFO main.(*reserveCommand).run: reserved frontend endpoint: https://9iq4zzirypdu.in.staging.zrok.io/\\n```\\n\\nThis is creating a *reserved* share which means it is permanent. We started this share in *proxy* mode so all traffic is passed through to our backend service.  \\nThis step is only necessary the first time, the share is reserved until it\'s deleted, and that means it can be shared any time it\'s needed.\\n\\nNext, we start sharing. The token `u4eh9mnwl4jb` is our reserved share from the command above.\\n\\n```bash\\n> ./zrok share reserved u4eh9mnwl4jb\\n```\\n\\nYou can now access your hosted service from anywhere with a URL like `https://u4eh9mnwl4jb.in.zrok.io`, including from any cloud-provided host.  \\nIn our Salt use case, this means we configure the Salt master to connect to this URL.\\n\\n![](/blogs/openziti/v1675096019317/c7851a8a-c71a-4afb-b7e0-087b18991a53.png)\\n\\nThe output in the terminal will show every request routed to your hosted service.  \\nA simple `ctrl + c` will stop the share and you no longer have anything open for anyone to take advantage of.\\n\\nFuture uses are even simpler. Since it\'s a domain name based on the token it won\'t change so the next time you need it, just start the share by executing the second command above. No need to change any configuration or to update anything.\\n\\n## Conclusion\\n\\nzrok simplifies local development while also making it more secure. In our scenario Salt can be configured with the public URL from zrok which connects directly to my local development environment using a connection secured by [OpenZiti](https://github.com/openziti/).\\n\\nFurther reading on the technologies involved in this blog:\\n\\n* Introducing zrok - [./introducing-zrok](./introducing-zrok.md)\\n    \\n* OpenZiti - [https://github.com/openziti/](https://github.com/openziti/)\\n    \\n* zrok - [https://zrok.io](https://zrok.io)\\n    \\n* zrok Getting Started - [https://docs.zrok.io/docs/getting-started](https://docs.zrok.io/docs/getting-started)\\n    \\n* Salt - [https://saltproject.io/](https://saltproject.io/)\\n    \\n* SaltStack Meets OpenZiti - [https://netfoundry.io/saltstack-meets-openziti/](https://netfoundry.io/saltstack-meets-openziti/)"},{"id":"lessons-learned-writing-a-zero-trust-nginx-module","metadata":{"permalink":"/docs/openziti/blog/lessons-learned-writing-a-zero-trust-nginx-module","source":"@site/blog/lessons-learned-writing-a-zero-trust-nginx-module.md","title":"Lessons Learned Writing a Zero Trust NGINX Module","description":"I authored my first NGINX module to offload OpenZiti connections into a legacy application deployment. That work can be seen in Github in the OpenZiti ngxzitimodule and an article explaining its operation can be found here: NGINX& ZeroTrust API Security","date":"2023-01-18T00:00:00.000Z","tags":[{"inline":false,"label":"Nginx","permalink":"/docs/openziti/blog/tags/nginx","description":"Nginx web server and integrations"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":15.69,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"slug":"lessons-learned-writing-a-zero-trust-nginx-module","title":"Lessons Learned Writing a Zero Trust NGINX Module","authors":["AndrewMartinez"],"date":"2023-01-18T00:00:00.000Z","tags":["nginx","zero-trust","security"]},"unlisted":false,"prevItem":{"title":"Connecting to Local Development Environment from Cloud Hosts with zrok","permalink":"/docs/openziti/blog/connecting-to-local-development-environment-from-cloud-hosts-with-zrok"},"nextItem":{"title":"Zero Trust Monitoring with OpenZiti","permalink":"/docs/openziti/blog/zero-trust-monitoring-with-openziti"}},"content":"I authored my first NGINX module to offload [OpenZiti](http://openziti.io) connections into a legacy application deployment. That work can be seen in Github in the OpenZiti [`ngx_ziti_module`](https://github.com/openziti/ngx_ziti_module) and an article explaining its operation can be found here: [NGINX& ZeroTrust API Security](./nginx-zerotrust-api-security.mdx)\\n\\n\x3c!-- truncate --\x3e\\n\\nThis article describes how the goals of the module were achieved and outlines some NGINX not-so-obvious-to-me gotchas.\\n\\nResources I used include the following:\\n\\n* [NGINX web site](https://nginx.org/en/)\\n    \\n* [NGINX GitHub mirror](https://github.com/nginx/nginx)\\n    \\n* [NGINX Developer Documentation](https://nginx.org/en/docs/dev/development_guide.html)\\n    \\n* [OpenZiti web site](http://openziti.io)\\n    \\n* [OpenZiti GitHub](https://github.com/openziti)\\n    \\n* [OpenZiti C SDK GitHub](https://github.com/openziti/ziti-sdk-c)\\n    \\n\\n## Enabling CMake\\n\\nAt first, I failed to grasp how much easier it is to use CMake in modern IDEs over other build processes. Most of my work has been in projects that already had CMake implemented. The NGINX repository has its own method of building itself and its modules. However, IDEs, such as CLion, do not immediately pick it up. I spent some time learning to use the NGINX build scripts, but it left me wanting.\\n\\nI decided to make my module buildable with CMake. I knew it would enable an automatic build flow in CLion, my IDE of choice, and would provide patterns for dependency management. CMake makes it trivial to include other projects no matter how they are built. I had two dependencies NGINX itself and the Ziti C SDK. I figured it would make my life easier....and it did eventually, but only after I learned that the NGINX build tools auto-generate module code for you. If you miss this, as I did, NGINX will not load the resulting library.\\n\\nBelow you can see the main `CMakeLists.txt` used in the `ngx_ziti_module` project:\\n\\n```plaintext\\ncmake_minimum_required(VERSION 3.16)\\nproject(ngx_ziti_module C)\\n\\nset(CMAKE_C_STANDARD 99)\\n\\ninclude(ExternalProject)\\ninclude(FetchContent)\\nfind_package(Git REQUIRED)\\n\\nadd_library(${PROJECT_NAME} SHARED ngx_ziti_module.c)\\nset_target_properties(${PROJECT_NAME} PROPERTIES PREFIX \\"\\")\\n\\nadd_compile_definitions(IS_CMAKE=1)\\n\\nadd_subdirectory(\\"deps\\")\\n```\\n\\nAdditionally, there is a `deps` folder that contains another `CMakeLists.txt` that includes both the [Ziti C SDK](https://github.com/openziti/ziti-sdk-c) and NGINX as dependencies.\\n\\n```plaintext\\nset(NGINX_CONFIGURE_ARGS \\"--with-threads\\" \\"--with-compat\\")\\n\\nif (DEBUG)\\n    set(NGINX_CONFIGURE_ARGS \\"--with-threads\\" \\"--with-compat\\" \\"--with-debug\\")\\nendif()\\n\\nmessage(\\"args ${NGINX_CONFIGURE_ARGS}\\")\\n\\n# build against nginx at the version specified by GIT_TAG. nginx uses custom auto configuration scripts that\\n# creates header files that are specific to the current host and output to <nginx dir>/objs/*.h.\\nExternalProject_Add(\\n        nginx\\n        PREFIX ${CMAKE_BINARY_DIR}/_deps/nginx\\n        GIT_REPOSITORY https://github.com/nginx/nginx.git\\n        GIT_TAG release-1.23.2\\n        TIMEOUT 10\\n        CONFIGURE_COMMAND ./auto/configure ${NGINX_CONFIGURE_ARGS}\\n        INSTALL_COMMAND \\"\\" #empty install command to disable install\\n        UPDATE_COMMAND \\"\\" #empty update command to disable update\\n        LOG_DOWNLOAD ON\\n        BUILD_IN_SOURCE 1 #build inside of the downloaded repo\'s source directory as expected by auto/configure\\n)\\n\\nif(NOT DEFINED $ENV{ZITI_SDK_C_BRANCH})\\n    SET(ZITI_SDK_C_BRANCH \\"main\\")\\nendif()\\n\\nFetchContent_Declare(ziti-sdk-c\\n        GIT_REPOSITORY https://github.com/openziti/ziti-sdk-c.git\\n        GIT_TAG ${ZITI_SDK_C_BRANCH}\\n        )\\n\\n\\nset(ZITI_BUILD_TESTS off)\\nset(ZITI_BUILD_PROGRAMS off)\\nFetchContent_MakeAvailable(ziti-sdk-c)\\n\\nadd_dependencies(${PROJECT_NAME} nginx)\\n\\nExternalProject_Get_property(nginx SOURCE_DIR)\\nmessage(\\"project name ${PROJECT_NAME}\\")\\ntarget_include_directories(${PROJECT_NAME}\\n        PUBLIC \\"${SOURCE_DIR}/objs\\"\\n        PUBLIC \\"${SOURCE_DIR}/src/core\\"\\n        PUBLIC \\"${SOURCE_DIR}/src/event\\"\\n        PUBLIC \\"${SOURCE_DIR}/src/event/modules\\"\\n        PUBLIC \\"${SOURCE_DIR}/src/http\\"\\n        PUBLIC \\"${SOURCE_DIR}/src/http/modules\\"\\n        PUBLIC \\"${SOURCE_DIR}/src/mail\\"\\n        PUBLIC \\"${SOURCE_DIR}/src/stream\\"\\n        PUBLIC \\"${SOURCE_DIR}/src/os/unix\\"\\n        )\\n\\ntarget_link_libraries(${PROJECT_NAME} ziti)\\n```\\n\\nFor a new project that doesn\'t need the Ziti C SDK, the above can be simplified and reduced to one file if desired.\\n\\n```plaintext\\ncmake_minimum_required(VERSION 3.16)\\ninclude(ExternalProject)\\nfind_package(Git REQUIRED)\\n\\nproject(ngx_ziti_module C)\\n\\nset(CMAKE_C_STANDARD 99)\\n\\nset(NGINX_CONFIGURE_ARGS \\"--with-threads\\" \\"--with-compat\\")\\n\\nif (DEBUG)\\n    set(NGINX_CONFIGURE_ARGS \\"--with-threads\\" \\"--with-compat\\" \\"--with-debug\\")\\nendif()\\n\\nmessage(\\"args ${NGINX_CONFIGURE_ARGS}\\")\\n\\n# build against nginx at the version specified by GIT_TAG. nginx uses custom auto configuration scripts that\\n# creates header files that are specific to the current host and output to <nginx dir>/objs/*.h.\\nExternalProject_Add(\\n        nginx\\n        PREFIX ${CMAKE_BINARY_DIR}/_deps/nginx\\n        GIT_REPOSITORY https://github.com/nginx/nginx.git\\n        GIT_TAG release-1.23.2\\n        TIMEOUT 10\\n        CONFIGURE_COMMAND ./auto/configure ${NGINX_CONFIGURE_ARGS}\\n        INSTALL_COMMAND \\"\\" #empty install command to disable install\\n        UPDATE_COMMAND \\"\\" #empty update command to disable update\\n        LOG_DOWNLOAD ON\\n        BUILD_IN_SOURCE 1 #build inside of the downloaded repo\'s source directory as expected by auto/configure\\n)\\n\\nadd_dependencies(${PROJECT_NAME} nginx)\\n\\nadd_library(${PROJECT_NAME} SHARED ngx_ziti_module.c)\\nset_target_properties(${PROJECT_NAME} PROPERTIES PREFIX \\"\\")\\n\\nadd_compile_definitions(IS_CMAKE=1)\\n```\\n\\nOf vital importance is the `add_compile_definitions(IS_CMAKE=1)` line. This line is used to generate a `#define IS_CMAKE=1` line during compilation performed by CMake. If the NGINX build tools are used, it will not be defined. This allowed me to conditionally define the code that the NGINX build tool generates during a CMake build.\\n\\nThe following code shows how the `IS_CMAKE` definition is used and shows an example of the auto-generated code that the NGINX tool produces.\\n\\n```c\\n#ifdef IS_CMAKE\\n/*\\n * nginx required symbols, unused by this project, but required by nginx.\\n * The standard nginx build tools add this section of code automatically during `./configure ....`.\\n * This is only used for standalone CMake builds.\\n */\\nngx_module_t *ngx_modules[] = {\\n        &ngx_ziti_module,\\n        NULL\\n};\\n\\nchar *ngx_module_names[] = {\\n        \\"ngx_ziti_module\\",\\n        NULL\\n};\\n\\nchar *ngx_module_order[] = {\\n        NULL\\n};\\n\\n#endif //IS_CMAKE\\n```\\n\\nThe variables `ngx_modules`, `ngx_module_names`, and `ngx_module_order` are required to be present in every NGINX module. NGINX will refuse to load libraries without them. As stated earlier, the NGINX build tools do this for you. For CMake, we must do it for ourselves.\\n\\n## Debugging\\n\\nNGINX will default to starting a background (daemon) process and then fork many processes underneath it. This is not favorable for debugging and testing, as your IDE will not be attached to the correct process unless you manually attach a debugger to a specific child process. Even so, it is difficult to know which child process will handle a given incoming test request.\\n\\nI chose violence from the start by beginning to develop with child processes enabled and in daemon mode. Debugging would not hit my breakpoints, nor would the process end when I stopped it via my IDE. This caused me much confusion, and I unknowingly had a pile of NGINX processes all running or trying to run in the background. I was slowly strangling my machine, causing it to run slower and slower. I was already upset that I couldn\'t debug my module, and I was becoming increasingly upset that my machine was running slowly. It was a vicious cycle.\\n\\nAfter taking a break and a bit of searching on the internet, I figured out what I was doing wrong and how to deal with it. It is possible to start NGINX in a single foreground process with the following lines added to the top of an NGINX configuration:\\n\\n```plaintext\\n# development settings to keep nginx from starting in daemon mode and forking child processes\\n# do not use for non-dev deployments\\ndaemon off;\\nmaster_process off;\\n```\\n\\nThe line `daemon off` starts NGINX as a foreground process. This is desirable so that killing the process via `ctrl+c`, interrupts (i.e., SIGINT), or via an IDE\'s stop/kill buttons, will have the NGINX process fully exit. Without it, the process and its children will remain in the background even if the IDE is no longer debugging. This can cause issues with subsequent runs and may lead to scenarios where one is debugging a previous run instead of the current run.\\n\\nThe line `master_process off` keeps NGINX from forking into many child processes. This effectively creates a single process that is easier to debug. This will simplify attaching debuggers and enable you to debug the entire life cycle of a module.\\n\\nIt is worth noting that you must test your module with `master_process on` (it can be omitted and will default to on) to ensure it works when running in child processes. Your module will configure once at startup and initialize in each child process. I could not find clear documentation of this. I discovered this only after stepping through the NGINX startup process. If your module depends on shared memory, it cannot be initialized during configuration. It must be configured in each process initialization. If not, you risk accessing random memory or null pointers.\\n\\n## Logging\\n\\nI found logging in NGINX to be misleading during initial module development. One of the first tasks in writing a module includes adding configuration processing. This configuration is what helps your module to do \\"something\\" - like hit a specific server or load resources. I wanted to index any `ziti` blocks and prepare to handle them. This included many log statements about what blocks and values were found. This did not work.\\n\\nDuring configuration, logging statements with a level lower than `emergency` are ignored and produce no output. At this point in the NGINX process, your only options are to return a configuration error or to log emergency statements.\\n\\nI initially did not understand the difference between the configuration and run phases. This caused me hours of debug time trying to figure out why my log messages were not emitting. Once I understood what was going on, I started to attack logging in other areas of my module.\\n\\nI found the following macros to be useful:\\n\\n```c\\n#define ngx_ziti_debug(log, ...) ngx_log_error(NGX_LOG_DEBUG, log, 0, __VA_ARGS__)\\n#define ngx_ziti_emerg(log, ...) ngx_log_error(NGX_LOG_EMERG, log, 0, __VA_ARGS__)\\n#define ngx_ziti_warn(log, ...) ngx_log_error(NGX_LOG_WARN, log, 0, __VA_ARGS__)\\n#define ngx_ziti_info(log, ...) ngx_log_error(NGX_LOG_INFO, log, 0, __VA_ARGS__)\\n```\\n\\nExample invocation:\\n\\n```c\\nstatic void ngx_ziti_run_service(void *data, ngx_log_t *log) {\\n    //...\\n    if(server_socket <= 0) {\\n        ngx_ziti_emerg(log, \\"for block %s service %s could not open server socket (%d), service thread exiting\\", service_ctx->block->name.data, service_ctx->service.data, server_socket);\\n        return;\\n    }\\n    //...\\n}\\n```\\n\\n## Custom Configuration Blocks\\n\\nFor the `ngx_ziti_module` I wanted a clean top-level custom block. Most of the examples of configuration I found only included adding directives to existing blocks or a simple single top-level configuration value. I wanted to define blocks that could contain more configuration values.\\n\\nI could have had many `ziti_` prefixed configuration items and simply moved on, but that would have bruised my sensibilities. I had \\"higher\\" aspirations. The goal was the following configuration block:\\n\\n```nginx\\nziti myZitiInstanceNameUsedForLogging {\\n    identity_file /home/testacct/.zi/identities/http_host.json;\\n\\n    bind http-service {\\n        upstream localhost:7070;\\n    }\\n}\\n```\\n\\nHowever, I could not get it to work. NGINX complained about the block not being allowed or the block not being allowed to have sub-configuration items. To make matters worse, I could not find an example that demonstrated what I was doing wrong. The NGINX developer documentation also left me puzzled.\\n\\nSo, I started reading the NGINX code that already defines complex configuration blocks, and I eventually stumbled upon what I was missing. It turns out there were some very subtle configurations necessary to do it. I needed custom location ids, and I needed to set the type of my blocks during configuration.\\n\\nThe following are the directives I eventually settled upon:\\n\\n```c\\n#define NGX_ZITI_CONF 0x80000001\\n#define NGX_ZITI_BIND_CONF 0x80000002\\n\\n/**\\n * Defines nginx directives for the ziti block and sub components.\\n */\\nstatic ngx_command_t ngx_ziti_commands[] = {\\n\\n        {ngx_string(\\"ziti\\"), /* directive */\\n         NGX_MAIN_CONF| NGX_DIRECT_CONF | NGX_CONF_BLOCK | NGX_CONF_TAKE1, /* location context and takes\\n                                            no arguments*/\\n         ngx_ziti, /* configuration setup function */\\n         0, /* No offset. Only one context is supported. */\\n         0, /* No offset when storing the module configuration on struct. */\\n         NULL},\\n\\n        {ngx_string(\\"identity_file\\"),\\n         NGX_ZITI_CONF | NGX_DIRECT_CONF | NGX_CONF_TAKE1,\\n         ngx_ziti_identity_file,\\n         0,\\n         0,\\n         NULL},\\n        { ngx_string(\\"bind\\"),\\n          NGX_ZITI_CONF | NGX_DIRECT_CONF | NGX_CONF_BLOCK | NGX_CONF_TAKE1,\\n          ngx_ziti_bind,\\n          0,\\n          0,\\n          NULL\\n        },\\n        { ngx_string(\\"upstream\\"),\\n          NGX_ZITI_BIND_CONF | NGX_DIRECT_CONF | NGX_CONF_TAKE1,\\n          ngx_ziti_bind_upstream,\\n          0,\\n          0,\\n          NULL\\n        },\\n        ngx_null_command /* command termination */\\n};\\n```\\n\\nThis code starts with some declarations of id\'s that are used later on during configuration parsing:\\n\\n```c\\n#define NGX_ZITI_CONF 0x80000001\\n#define NGX_ZITI_BIND_CONF 0x80000002\\n```\\n\\n`NGX_ZITI_CONF` and `NGX_ZITI_BINDCONF` are both block ids - one for `ziti` and the other for `bind`. The `ziti` and `bind` items are both blocks that will contain other configuration items. During the `ziti` and `bind` configuration item processing, they will set their type to `NGX_ZITI_CONF` and `NGX_ZITI_BIND_CONF`. Configuration items that go within those blocks will specify `NGX_ZITI_CONF` or `NGX_ZITI_BIND_CONF` as their configuration location during their definition.\\n\\nThe following snippet shows the declaration of the `ziti` block item\\n\\n```c\\n/**\\n * Defines nginx directives for the ziti block and sub components.\\n */\\nstatic ngx_command_t ngx_ziti_commands[] = {\\n\\n        {ngx_string(\\"ziti\\"), /* directive */\\n         NGX_MAIN_CONF| NGX_DIRECT_CONF | NGX_CONF_BLOCK | NGX_CONF_TAKE1, /* location context and takes\\n                                            no arguments*/\\n         ngx_ziti, /* configuration setup function */\\n         0, /* No offset. Only one context is supported. */\\n         0, /* No offset when storing the module configuration on struct. */\\n         NULL},\\n//...\\n}\\n```\\n\\nEach entry in the array `ngx_ziti_commands` specified the name of the configuration item, and the second section is a bit `OR`\'ed set of flags that determines how the named configuration item is processed. The `ziti` directive is described as `NGX_MAIN_CONF| NGX_DIRECT_CONF | NGX_CONF_BLOCK | NGX_CONF_TAKE1`.\\n\\n* `NGX_MAIN_CONF` declares that this item should be under the main or \\"root\\" configuration section\\n    \\n* `NGX_DIRECT_CONF` declares this item will only be in the main configuration file\\n    \\n* `NGX_CONF_BLOCK` declares that this item is expected to be a block (`{}`) that contains more configuration items\\n    \\n* `NGX_CONF_TAKE1` signifies that this item expects a single block\\n    \\n\\nThe value `ngx_ziti` is a function that is called when the `ziti` block items are encountered in the main/root configuration section. That function is responsible for handling any initialization needed as well as specifying its type via `cf->cmd_type = NGX_ZITI_CONF;`.\\n\\n```c\\nstatic char *ngx_ziti(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) {\\n    //...\\n    cf->cmd_type = NGX_ZITI_CONF;\\n    //...\\n}\\n```\\n\\nFor an item within the `ziti` block, the `NGX_ZITI_CONF` location is used. The `identity_file` configuration item is an example of this.\\n\\n```c\\n        {ngx_string(\\"identity_file\\"),\\n         NGX_ZITI_CONF | NGX_DIRECT_CONF | NGX_CONF_TAKE1,\\n         ngx_ziti_identity_file,\\n         0,\\n         0,\\n         NULL},\\n```\\n\\n* `NGX_ZITI_CONF` declares that this item should be under the configuration block, `ziti`\\n    \\n* `NGX_DIRECT_CONF` declares this item will only be in the main configuration file\\n    \\n* `NGX_CONF_TAKE1` signifies that this item expects a single value\\n    \\n\\nThe process of declaring configuration items is repeated, specifying each configuration item\'s location, expected values, and callback.\\n\\n## Threading Support\\n\\nThreading support does not exist in Windows (as of writing 1/18/2023). I did not initially know this, and attempting to test on Windows proved very quick - as it would not compile.\\n\\nEnabling threading support can significantly increase the performance of an NGINX deployment. It is possible for each module to detect if threading is enabled or not at compile time and output a helpful message to instruct the operator to use `--with-threads`. This can be included anywhere.\\n\\n```c\\n#ifndef NGX_THREADS\\n#error ngx_ziti_module.c requires --with-threads\\n#endif /* NGX_THREADS */\\n```\\n\\nAdditionally, the following code is used to make use of threading:\\n\\n```c\\n    //multiple adds are fine, they are cached by name\\n    tp = ngx_thread_pool_add(cf, &ngx_ziti_thread_pool_name);\\n\\n\\n    if (tp == NULL) {\\n        return NGX_CONF_ERROR;\\n    }\\n```\\n\\nThis code will handle scenarios where the platform supports threading, but threading has not been enabled. A thread pool named `ngx_ziti_tp` must be enabled in the NGINX configuration file with the following:\\n\\n```nginx\\nthread_pool ngx_ziti_tp threads=32 max_queue=65536;\\n```\\n\\n## Invoking the Ziti SDK\\n\\nBefore working on the `ngx_ziti_module` I had developed within the [Ziti C SDK](https://github.com/openziti/ziti-sdk-c), but I had not developed applications that made use of it beyond simple test applications. Between then and now, the SDK has become incredibly friendly to use. I was used to a lower-level API that required quite a bit of knowledge. I was prepared to get bloody cutting my hands on it.\\n\\nHowever, my colleagues pointed me to the `Ziti_*` API functions in `ziti_lib.h`. I was pleasantly surprised by it. There was no blood this time from the Zit C SDK, but I still found way to weaponize my NGINX inexperience against myself.\\n\\nTo get started, the line `Ziti_lib_init();` must be invoked. Since child processes are at play, it has to be invoked in each process during process initialization. I had initially included the call during module initialization, but that occurs during configuration processing and within the NGINX main process. Meaning that each child process did not have an initialized library. The main NGINX process did, but the module code doesn\'t run there. My module effectively sat there doing nothing - no matter how hard I edited and saved my NGNIX configuration file. No matter how many times i stepped through the configuration parsing. Nothing was working! Not until I realized each child process has a life cycle that NGINX provides callbacks for.\\n\\nProcess initialization is done according to the module\'s `ngx_module_t` definition. Below you can see my module, `ngx_ziti_module`.\\n\\n```c\\nngx_module_t ngx_ziti_module = {\\n        NGX_MODULE_V1,\\n        &ngx_ziti_module_ctx, /* module context */\\n        ngx_ziti_commands, /* module directives */\\n        NGX_CORE_MODULE, /* module type */\\n        ngx_ziti_init_master, /* init master */\\n        ngx_ziti_init_module, /* init module */\\n        ngx_ziti_init_process, /* init process */\\n        ngx_ziti_init_thread, /* init thread */\\n        ngx_ziti_exit_thread, /* exit thread */\\n        ngx_ziti_exit_process, /* exit process */\\n        ngx_ziti_exit_master, /* exit master */\\n        NGX_MODULE_V1_PADDING\\n};\\n```\\n\\nThe process initialization callback is the seventh callback - where `ngx_ziti_init_process` is provided. This callback is triggered when a child process is started and is where the Ziti C SDK had to be initialized.\\n\\nThe callback, `ngx_ziti_init_process`, checks to see if the configuration had any `ziti` blocks defined. If so, it initializes the Ziti C SDK. Otherwise, it does not initialize it and saves some resources.\\n\\n```c\\nstatic ngx_int_t ngx_ziti_init_process(ngx_cycle_t *cycle){\\n    ngx_ziti_debug(cycle->log, \\"enter: ngx_ziti_init_process\\");\\n\\n\\n    ngx_ziti_conf_t* ziti_conf = (ngx_ziti_conf_t*) ngx_get_conf(cycle->conf_ctx, ngx_ziti_module);\\n\\n    if(ziti_conf->blocks->nelts > 0){\\n        Ziti_lib_init();\\n    } else {\\n        return NGX_OK;\\n    }\\n    //...\\n}\\n```\\n\\nFurther down, `ngx_initi_process` then checks for each `ziti` block\'s `identity_file` value and loads them.\\n\\n```c\\nstatic ngx_int_t ngx_ziti_init_process(ngx_cycle_t *cycle){\\n    //...\\n    ngx_ziti_block_conf_t **blocks = ziti_conf->blocks->elts;\\n\\n    for(ngx_uint_t i = 0; i < ziti_conf->blocks->nelts; i++) {\\n        ngx_ziti_block_conf_t* block = blocks[i];\\n        ngx_ziti_warn(cycle->log, \\"initializing block %s\\", block->name.data);\\n        ngx_str_t         identity_file_full_path;\\n\\n        identity_file_full_path = block->identity_file;\\n\\n        if (ngx_conf_full_name(cycle, &identity_file_full_path, 0) != NGX_OK) {\\n            return NGX_ERROR;\\n        }\\n\\n        block->ztx = Ziti_load_context((char*)block->identity_file.data);\\n    //...\\n}\\n```\\n\\nAfter all `ziti` blocks and `identity_file`s have been processed, we have a collection of `ztx` instances or \\"ziti contexts.\\" Each `ztx` represents an OpenZiti identity that is connected to an OpenZiti network. We can use each `ztx` to either request connections to services or host services. The module aims to terminate services to a back-end legacy system - so we will be hosting services. Hosting services is done via the `Ziti_socket()`, `Ziti_bind()`, `Ziti_listen()` , and `Ziti_accept()` functions.\\n\\n```c\\n    //create a socket\\n    server_socket = Ziti_socket(SOCK_STREAM);\\n    //error handling\\n\\n    //use the socket to bind/host a specific service on specific ztx\\n    int err = Ziti_bind(server_socket, service_ctx->block->ztx, (char*)service_ctx->service.data, NULL);\\n    //error handling\\n\\n    //start to listen\\n    err = Ziti_listen(server_socket, 64);\\n    //error handling\\n\\n    do {\\n         //wait for new connections\\n         new_client = Ziti_accept(server_socket, new_client_name, sizeof(new_client_name));\\n        //...\\n```\\n\\nAfter creating a socket, binding (hosting) a service, and starting to listen, the process will sit and wait for incoming connections. The thread blocks on `Ziti_accept` waiting for client connections. When a new connection is received, standard C socket programming is used to send/receive data and close sockets when necessary.\\n\\n## Closing Remarks\\n\\nNGINX module development has several startup hurdles. Attempting to search for answers to those questions was difficult. NGINX is so widely used that I would routinely only have search results filled with deployment/configuration articles rather than articles aimed at module developers. I made the most progress by reading the NGINX developer documentation and then reading the code while stepping through on a debugger. It wasn\'t always easy, but I triumphed in the end.\\n\\nOverall I\'m proud of the progress I made. My understanding of NGINX has been dramatically improved, and the addition of the `ziti_lib.h` `Ziti_*` API was a refreshing way to use the Ziti C SDK."},{"id":"zero-trust-monitoring-with-openziti","metadata":{"permalink":"/docs/openziti/blog/zero-trust-monitoring-with-openziti","source":"@site/blog/zero-trust-monitoring-with-openziti.md","title":"Zero Trust Monitoring with OpenZiti","description":"Monitoring is very important in today\'s technology world. It allows system administrators to","date":"2023-01-09T00:00:00.000Z","tags":[{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"Monitoring","permalink":"/docs/openziti/blog/tags/monitoring","description":"Monitoring and observability"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":5.12,"hasTruncateMarker":true,"authors":[{"name":"Eugene Kobyakov","title":"Author","url":"https://github.com/ekoby","imageURL":"https://avatars.githubusercontent.com/ekoby","key":"EugeneKobyakov","page":null}],"frontMatter":{"slug":"zero-trust-monitoring-with-openziti","title":"Zero Trust Monitoring with OpenZiti","authors":["EugeneKobyakov"],"date":"2023-01-09T00:00:00.000Z","tags":["zero-trust","monitoring","openziti"]},"unlisted":false,"prevItem":{"title":"Lessons Learned Writing a Zero Trust NGINX Module","permalink":"/docs/openziti/blog/lessons-learned-writing-a-zero-trust-nginx-module"},"nextItem":{"title":"It\'s A Zitiful Life","permalink":"/docs/openziti/blog/its-a-zitiful-life"}},"content":"# Intro\\n\\nMonitoring is very important in today\'s technology world. It allows system administrators to\\n\\n* detect early signs of failures and security breaches, and address them before they cause outages\\n    \\n* improve resource utilization\\n    \\n* reduce time spent on active monitoring and instead be alert-driven\\n\\n\x3c!-- truncate --\x3e\\n    \\n\\nMonitoring systems are usually deployed alongside the main system or software that is being monitored. What this means is that monitoring systems must have the same security requirements as any other production system. If your monitoring system is vulnerable a sophisticated attacker can launch a multi-prong attack on your whole infrastructure. Disabling or impairing monitoring can lead to a delayed discovery of incidents or missing them altogether.\\n\\n![](/blogs/openziti/v1672149178577/1otp4yY5I.png)\\n\\nThis is a typical monitoring system at a very high level. The link from `Agent` to `Collector` is likely to go over the public Internet, which means that `Collector` endpoints are vulnerable to attacks by malevolent actors. These attacks can range from [DDOS](https://en.wikipedia.org/wiki/Denial-of-service_attack) to targeting vulnerabilities in `Collector` software (e.g. [Log4Shell](https://en.wikipedia.org/wiki/Log4Shell)). When the collector becomes compromised or impaired, your `Analytics` engine cannot trigger appropriate alerts. While these attack vectors can be mitigated with VPNs, firewalls with port-forwarding/ACL/IP-whitelists, etc., those solutions are non-trivial to implement and maintain.\\n\\nOpenZiti is offering a solution that avoids deploying additional software (e.g VPN agents) or maintaining other infrastructure (e.g. firewalls). OpenZiti SDKs allow building zero trust networking right into your applications and leverage full mesh, zero trust overlay, policy controlled access without separate agents.\\n\\nThe rest of this article will walk through connecting modified popular agent and collector software over OpenZiti overlay network. It makes `Collector` inaccessible from the public Internet and makes it available only to `Agents` with proper permissions.\\n\\n![](/blogs/openziti/v1670514568002/2iIdy5Ep1.png)\\n\\n# Implementation Overview\\n\\nFor this exercise, we picked [Elastic](https://www.elastic.co/logstash/) Logstash as the collector and Elastic Beats tools as the agents. It was done for two reasons:\\n\\n* The Beats/LogStash combination is a very popular monitoring solution\\n    \\n* Our own Ops team (at NetFoundry) is using them for monitoring data collection and is incorporating Zero Trust into our internal tools\\n    \\n\\n## Beats\\n\\nElastic Beats tools are written in Golang. We use OpenZiti Golang SDK to embed Zero Trust networking right into the executables.\\n\\nTo get *zitified* Beats binaries, clone our fork and build them:\\n\\n```bash\\n$ git clone --branch=zitify https://github.com/openziti-test-kitchen/beats.git\\n$ cd beats\\n$ mkdir build\\n$ go build -o build/ ./filebeat #./metricbeat, etc\\n```\\n\\nThese binaries can be dropped into the existing beats install and configured to use OpenZiti overlay network.\\n\\n### Beats implementation details\\n\\nThe fork above just pulls the zitified version of the Elastic agent support library with the following `replace`\\n\\n```less\\ngithub.com/elastic/elastic-agent-libs => github.com/openziti-test-kitchen/elastic-agent-libs v0.0.0-20221118205208-c84fcc069fb2\\n```\\n\\nIn the modified library the only code [change](https://github.com/elastic/elastic-agent-libs/compare/main...openziti-test-kitchen:elastic-agent-libs:zitify-transport?diff=unified) (aside from added dependency in `go.mod`) is this:\\n\\n![](/blogs/openziti/v1672929730994/7b56ef69-a963-485e-aa4a-f0e7be490a47.png)\\n\\nThe Ziti dialer takes care of matching the target address to the service with a matching intercept.\\n\\n## LogStash\\n\\nOn the LogStash side, we created a [zitified](https://github.com/openziti-test-kitchen/logstash-input-zitibeats/tree/zitify) version of the LogStash Beats input plugin. LogStash is built with JRuby/Java. We use OpenZiti JVM SDK to embed Zero Trust networking into the Beats plugin.\\n\\nTo build and install zitified plugin (make sure you have all the required tools for LogStash plugin development):\\n\\n```bash\\n$ git clone --branch=zitify https://github.com/openziti-test-kitchen/logstash-input-zitibeats.git\\n$ cd logstash-input-zitibeats\\n$ ./gradlew vendor\\n$ gem build ./logstash-input-zitibeats.spec\\n# LS_HOME is logstash installation directory\\n$ ${LS_HOME}/bin/logstash-plugin install ./logstash-input-zitibeats-6.4.1-java.gem\\n```\\n\\n### LogStash Input Beats implementation\\n\\nWe implemented a Beats input endpoint [server](https://github.com/openziti-test-kitchen/logstash-input-zitibeats/blob/zitify/src/main/java/org/openziti/logstash/beats/Server.java) by using `org.openziti:ziti-netty` library.\\n\\n```java\\nServerBootstrap server = new ServerBootstrap();\\nserver.group(workGroup)\\n      .channelFactory(new ZitiServerChannelFactory(ztx))\\n      .childHandler(getBeatsInitializer());\\n\\nService service = ztx.getService(serviceName, 10000L);\\nChannel channel = server.bind(new   ZitiAddress.Bind(service.getName())).sync().channel();\\n```\\n\\nIt fits nicely with the original plugin and reuses the rest of the original implementation.\\n\\n# Configuring OpenZiti\\n\\nTo tie it all together, the OpenZiti network has to be configured with appropriate identities, services, and policies.\\n\\n%[https://gist.github.com/ekoby/63163db01f8496164adae6e4410fdf71] \\n\\nThe diagram below shows how ziti configuration is mapped/used in the LogStash/Beats deployments.\\n\\n![](/blogs/openziti/v1671648706947/ZzjDwkvvM.png)\\n\\n## Running Zitified LogStash\\n\\nOnce our new input is configured LogStash can be started. This is a sample output you\'d see in the LogStash log.\\n\\n```less\\n[2022-12-27T12:33:56,061][INFO ][org.openziti.impl.ZitiImpl][main] ZitiSDK version 0.23.18 @23cb6b8()\\n[2022-12-27T12:33:56,332][INFO ][logstash.javapipeline    ][main] Pipeline started {\\"pipeline.id\\"=>\\"main\\"}\\n[2022-12-27T12:33:56,398][INFO ][org.openziti.logstash.beats.Server][main][a0be65cb7a03f4efc1785fd4746bd82f98469e6bef41caf7afeb4b8ac3763006] Starting server for service: beats.logstash\\n[2022-12-27T12:33:56,406][INFO ][logstash.agent           ] Pipelines running {:count=>1, :running_pipelines=>[:main], :non_running_pipelines=>[]}\\n[2022-12-27T12:33:56,714][INFO ][org.openziti.api.Controller][main] controller[https://fec44561-7d3b-41e7-a26f-e9f851a9ec33.production.netfoundry.io/] version(v0.26.11/807dd591b1f5)\\n```\\n\\nIt shows that Ziti SDK is loaded and the plugin is waiting for connections on the configured service.\\n\\n## Running Zitified Beats agents\\n\\nTo connect zitified Beats agents over Ziti overlay network you need to do two things:\\n\\n* point `output.logstash` to the service intercept address\\n    \\n    ```less\\n    output.logstash:\\n      hosts: [\\"beats.logstash.ziti:5044\\"]\\n    ```\\n    \\n* reference enrolled agent identity file in `ZITI_IDENTITIES` environment variable\\n    \\n    ```less\\n    $ export ZITI_IDENTITIES=beatz.json\\n    $ ./metricbeat -c metricbeat.yml\\n    ```\\n    \\n\\n# Conclusion\\n\\nUsing Zero Trust solutions is important not only in customer-facing production systems but in internal ones as well. Systems monitoring falls under that umbrella.\\n\\nOpenZiti SDKs make it easy to embed Zero Trust networking right into your applications provided you can modify the source code. OpenZiti SDKs are designed to match target languages/frameworks styles of programming and in most cases can be embedded with just a few lines of code.\\n\\nSee all of them on [GitHub](https://github.com/orgs/openziti/repositories?q=sdk).\\n\\nWant to learn more or provide feedback? Head to our [docs](https://openziti.github.io/) and discussion [forum](https://openziti.discourse.group/top?period=quarterly), and follow this very [blog](./)."},{"id":"its-a-zitiful-life","metadata":{"permalink":"/docs/openziti/blog/its-a-zitiful-life","source":"@site/blog/it-s-a-zitiful-life.md","title":"It\'s A Zitiful Life","description":"The Plex Media Server is awesome because it makes it easy to access all your music, photos or videos, and stream to any device. The server is free to download, self-hosting is easy, and many people run it in their homes. Doing so enables you to own and control your content without the need to upload to a cloud (or pay for it).","date":"2022-12-19T18:00:42.000Z","tags":[{"inline":false,"label":"Web","permalink":"/docs/openziti/blog/tags/web","description":"Web content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Self Hosted","permalink":"/docs/openziti/blog/tags/self-hosted","description":"Self-hosted setups"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":4.01,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"title":"It\'s A Zitiful Life","seoTitle":"How to enable Secure Remote Access to Plex Server via OpenZiti BrowZer","seoDescription":"The easy way to provide secure remote access to your Plex content, without making any changes to your Plex server or making tedious/insecure router changes.","date":"2022-12-19T18:00:42.000Z","cuid":"clbv3rvhf02u6p2nvat895sfh","slug":"its-a-zitiful-life","authors":["CurtTudor"],"image":"@site/blogs/openziti/v1671286570889/kpfd19y_F.jpg","imageDark":"@site/blogs/openziti/v1671286570889/kpfd19y_F.jpg","tags":["web","security","self-hosted","zerotrust"]},"unlisted":false,"prevItem":{"title":"Zero Trust Monitoring with OpenZiti","permalink":"/docs/openziti/blog/zero-trust-monitoring-with-openziti"},"nextItem":{"title":"NGINX & ZeroTrust API Security","permalink":"/docs/openziti/blog/nginx-zerotrust-api-security"}},"content":"The [Plex Media Server](https://www.plex.tv/your-media/) is awesome because it makes it easy to access all your music, photos or videos, and stream to any device. The server is free to [download](https://www.plex.tv/media-server-downloads/#plex-media-server), self-hosting is easy, and many people run it in their homes. Doing so enables you to own and control your content without the need to upload to a cloud (or pay for it).\\n\\nOnce the Plex media server is running in the home, many people then want to take the next step and share their content with remote friends and family or enable access to their content while they are away from home on a vacation or business trip.\\n\\nIn this article, I discuss that while self-hosting your Plex media server is *easy*, the traditional techniques for providing remote access to it *arenot.* The good news is that there is a modern approach to securely sharing web apps that is worth your attention.\\n\\n\x3c!-- truncate --\x3e\\n\\nHere I\'ll introduce you to [BrowZer](./introducing-openziti-browzer.md), a novel group of open-source components from the [OpenZiti project](https://github.com/openziti/) that collectively enables you to operate private-to-the-internet web applications like Plex while still easily providing secure access for your authorized internet-based remote users using just a browser. No VPN. No plugins. No installation. No hassle.\\n\\n## Remote Access?\\n\\nMaking a Plex media server remotely accessible over the internet is possible, but many people consider the traditional setup process to be *fraught with peril*.\\n\\nThere are multiple reasons for hesitation.\\n\\n## Not \\"easy\\" for most\\n\\nTo illustrate my point, here\'s a snippet from the [Plex Remote-Access setup guide](https://support.plex.tv/articles/200289506-remote-access/):\\n\\n![](/blogs/openziti/v1671291804369/QOCHtR1Af.png)\\n\\nAfter reading the above snippet, there\'s no doubt some people would then be thinking...\\n\\n*\\"Huh?... UPnP? NAT-PMP? Manually forwarding a port? External port number? Internal IP address? ...um, never mind.\\"*\\n\\nThe fact is, establishing remote access is possible using Plex\'s traditional technique, but it\'s certainly not \\"easy\\" for most people.\\n\\n## Not \\"secure\\" and introduces risk\\n\\nEven for those brave, tech-savvy folks who can successfully navigate the Plex remote access setup process and power through the tedious technical details, there is something else to think about. It\'s something that many may not consider (until after disaster strikes).\\n\\nWhat thing am I referring to? Well, if you did follow the Plex remote access setup, you opened a port on your router. In other words... you exposed your server to anyone on the internet -- including exposing it to malicious threat actors who will welcome the opportunity to hack into your home network.\\n\\nThe fact is, establishing remote access is possible using Plex\'s traditional technique, but it\'s certainly not \\"secure\\" and it introduces unacceptable risk.\\n\\n## Easy and Secure Remote Access\\n\\nOK, problems like those described above, while real, shouldn\'t stop you from achieving the goal of having easy and secure remote access.\\n\\nThere is an easy way to provide remote access to your Plex content, without the need to make any changes to your Plex server or deal with any of the router tedium described above.\\n\\nThere is a way to make your Plex server invisible on the internet, secure and unassailable to malicious actors, while still simultaneously providing access to the friends and family you wanted to authorize.\\n\\nAnd you can realize this reality without requiring your friends or family to install any additional software (*like a VPN, yuck*) on their client-side laptop, tablet, or mobile phone. And all they\'d need is the browser they already use every day.\\n\\nThe reality I refer to is enabled by our open-source [OpenZiti](https://github.com/openziti/) project and some of its components that we collectively refer to as [BrowZer](./introducing-openziti-browzer.md).\\n\\n![](/blogs/openziti/v1671318547985/kIttXBpOF.png)\\n\\nMore background and detail on BrowZer can be read in my introductory article where I discuss [modern web app security](./introducing-openziti-browzer.md).\\n\\n## Companion Video Demo\\n\\nHere is a 3-min video that demonstrates streaming a movie (the holiday movie classic ***It\'s A Wonderful Life***) from a Plex media server to a remote user using OpenZiti BrowZer.\\n\\n%[https://www.youtube.com/watch?v=0nXISwUG4yo] \\n\\n## Express Your Interest in a BrowZerPlex Pilot\\n\\nWe haven\'t yet shipped everything necessary for you to self-deploy BrowZer for your Plex network, and experience what I describe above. However...\\n\\nWe\'d like to hear from you if you\'re interested in participating in a pilot (beta) program where we will work with you now to get everything set up.\\n\\nIf you are excited by the opportunity to be among the first to use BrowZer to securely share your Plex media content with your remote friends and family, then simply complete this [OpenZiti BrowZerPlex Pilot Form](https://forms.gle/3iA9Hsghk5KWhEzH9) and we will follow up with you shortly.\\n\\nThanks!"},{"id":"nginx-zerotrust-api-security","metadata":{"permalink":"/docs/openziti/blog/nginx-zerotrust-api-security","source":"@site/blog/nginx-zerotrust-api-security.mdx","title":"NGINX & ZeroTrust API Security","description":"ngxsimplepre@2x.png","date":"2022-12-01T00:00:00.000Z","tags":[{"inline":false,"label":"Nginx","permalink":"/docs/openziti/blog/tags/nginx","description":"Nginx web server and integrations"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"APIs","permalink":"/docs/openziti/blog/tags/apis","description":"API development"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":5.15,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"slug":"nginx-zerotrust-api-security","title":"NGINX & ZeroTrust API Security","authors":["AndrewMartinez"],"date":"2022-12-01T00:00:00.000Z","tags":["nginx","zero-trust","apis","security"]},"unlisted":false,"prevItem":{"title":"It\'s A Zitiful Life","permalink":"/docs/openziti/blog/its-a-zitiful-life"},"nextItem":{"title":"Using eBPF-TC to securely mangle packets in the kernel, and pass them to my secure networking application","permalink":"/docs/openziti/blog/using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application"}},"content":"![ngx_simple_pre@2x.png](/blogs/openziti/v1669908439678/tz_p-x3qS.png)\\n\\n*With the first version of* [*ngx\\\\_ziti\\\\_module*](https://github.com/openziti/ngx_ziti_module)*, it is possible to take an NGINX-exposed Web API and make it completely dark. This means no open ports in NGINX, and it brings the Zero Trust capabilities of [OpenZiti](https://github.com/openziti) to any NGINX deployment. Yes, replace open ports with open source! OpenZiti works in existing applications or new ones.*\\n\\n\x3c!-- truncate --\x3e\\n\\n![ngx_simple_post@2x.png](/blogs/openziti/v1669908465505/gf5pDUJQn.png)\\n\\nThe [OpenZiti](https://github.com/openziti/) team was pondering how to make it drop-dead simple for existing API deployments sitting on the open Internet to benefit from OpenZiti. OpenZiti allows new forms of API Security in scenarios where the API is only intended for usage by a controlled set of clients or when access needs to be tightly controlled. APIs deployed permissively listening on any network are attack vectors. The reason they are deployed in this fashion is a false sense of security. For internally exposed APIs, the common idea is that \\"the corporate network is safe.\\" For internet-exposed APIs, it is usually \\"my service is safe.\\" Both of those concepts are never genuinely correct. The [corporate network is only safe until it is breached](https://auth0.com/blog/the-death-of-the-corporate-network/), and internet APIs have [bugs that allow remote access](https://owasp.org/www-project-top-ten). \\n\\nFor APIs that aren\'t using OpenZiti, what do they need to get off the ground quickly? The first obvious answer was to \\"zitify\\" (add an OpenZiti SDK to an existing code base) whatever is hosting the public exposure of their API - most likely an application server, load balancer, or API Gateway. The problem with that approach is that there is a multitude of those. Each language has its application server approach, there are many cloud and self-hosted API Gateways, and there is an extensive list of load balancers. To get started, we had to choose we needed something pervasive.\\n\\nNGINX is popular. About 20-30% of the internet uses it, and most developers are deployers who have used it before or heard about it. There are other solutions, like Envoy, that we are also considering if this approach gains traction. NGINX is also a front-line or edge-deployed solution - either it is already situated on the front lines for existing APIs or can comfortably be deployed there.\\n\\nMost importantly, NGINX also supports a C API that allows developers to add functionality by authoring modules. We took this and created [ngx\\\\_ziti\\\\_module](https://github.com/openziti/ngx_ziti_module). The first version is aimed at solidifying the configuration blocks and enabling the forwarding of traffic to upstream servers from an NGINX with no open ports.\\n\\n### A Note On Full Zero Trust\\n\\nNow, for this setup, we aren\'t eliminating all of the trusted networks, which means the solution is not fully Zero Trust. The back-end API Servers are still trusting the network they are deployed on. The best use of OpenZiti is to embed every server with the OpenZiti SDK and use OpenZiti itself to load balance services between multiple hosts. This would be a complete Zero Trust set up. However, this article and the `ngx_ziti_module` assumes that the reader would like to dip their toes in OpenZiti without altering the code base for all of their servers or is in a scenario where they can\'t alter the server directly. OpenZiti strives to provide flexible solutions that enable a path to Zero Trust with realistic solutions for real problems.\\n\\n### Example\\n\\nConsider the following deployment of NGINX, which has three upstream services.\\n\\n![ngx_simple_pre@2x.png](/blogs/openziti/v1669834189600/RCThUvpKI.png?height=450)\\n\\n\\n*The NGINX configuration for this deployment may look like this:*\\n\\n```plaintext\\nerror_log /dev/stderr debug;\\nerror_log logs/error.log debug;\\n\\nevents {\\n    worker_connections  1024;\\n}\\n\\nstream {\\n\\n    server {\\n        listen 8080;\\n        proxy_pass backend.example.com:8080;\\n    }\\n\\n    server {\\n        listen 8081;\\n        proxy_pass backend.example.com:8081;\\n    }\\n\\n    server {\\n        listen 8082;\\n        proxy_pass backend.example.com:8082;\\n    }\\n}\\n```\\n\\nThis NGINX instance listens on three ports: 8080, 8081, and 8082. If this NGINX instance is hosted in the cloud and listening openly on the internet, anyone can attempt to connect. This leaves the instance and its back-end services open to attack - including the [top ten OWASP](https://owasp.org/www-project-top-ten/) attack vectors. Using OpenZiti the NGINX instance can be instructed to load `ngx_ziti_module` and any number of identities hosting any number of services defined in the OpenZiti network. Implementing OpenZiti via NGINX would change our scenario diagram to the following:\\n\\n<img src=\\"/blog/v1669834486585/vXVR-gs9R.png\\" style={{ height: \'150px\' }} />\\n\\nTo bind (host) the OpenZiti Services via the NGINX instance, we need the following configuration.\\n\\n```plaintext\\nload_module ngx_ziti_module.so;\\n\\nerror_log /dev/stderr debug;\\nerror_log logs/error.log debug;\\n\\nthread_pool ngx_ziti_tp threads=32 max_queue=65536;\\n\\nevents {\\n    worker_connections  1024;\\n}\\n\\nziti identity1 {\\n    identity_file /path/to/ziti/identity1.json;\\n\\n    bind http-service00 {\\n        upstream localhost:8080;\\n    }\\n\\n    bind http-service01 {\\n        upstream localhost:8081;\\n    }\\n\\n    bind http-service02 {\\n        upstream localhost:8082;\\n    }\\n}\\n```\\n\\nThe above configuration uses a single `ziti` block to load an identity named `identity1` using the configuration file `identity_file /path/to/ziti/identity1.json`. It then exposes three OpenZiti Services named `http-service00`, `http-service01`, and `http-service02`. The NGINX instance will pass all incoming OpenZiti-facilitated traffic to the designated upstream servers. \\n\\n### The Benefits\\n\\n1. No open ports on NGINX\\n2. Strong immutable identities for clients and hosts\\n3. Allows OpenZiti\'s policies to define ACL for services\\n4. Bring OpenZiti\'s visibility into access control, activity logs, etc., replacing traditional API logging\\n4. Restricts access to the target backend APIs to OpenZiti connections only\\n5. Allows existing micro/macro-service architectures to adopt OpenZiti without altering their existing code or deployment models\\n\\n### HowTo Overview\\n\\n1. Create an OpenZiti network via one of the [quickstarts](https://openziti.github.io/docs/quickstarts/network/).\\n2. [Create a new identity](https://openziti.github.io/docs/core-concepts/identities/overview#one-time-token-ott)\\n3. [Enroll the new identity](https://openziti.github.io/docs/core-concepts/identities/overview#one-time-token-ott)\\n4. [Define your services in OpenZiti](https://openziti.github.io/docs/core-concepts/services/overview)\\n5. [Define your policies in OpenZIti](https://openziti.github.io/docs/core-concepts/security/authorization/policies/overview)\\n6. [Build the ngx_ziti_module](https://github.com/openziti/ngx_ziti_module#building)\\n7. [Configure NGNIX](https://github.com/openziti/ngx_ziti_module#using)"},{"id":"using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application","metadata":{"permalink":"/docs/openziti/blog/using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application","source":"@site/blog/using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application.md","title":"Using eBPF-TC to securely mangle packets in the kernel, and pass them to my secure networking application","description":"Introduction","date":"2022-11-09T22:10:42.000Z","tags":[{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Firewall","permalink":"/docs/openziti/blog/tags/firewall","description":"Firewall technologies"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"eBPF","permalink":"/docs/openziti/blog/tags/ebpf","description":"eBPF tech"},{"inline":false,"label":"tc","permalink":"/docs/openziti/blog/tags/tc","description":"Linux tc"},{"inline":false,"label":"TProxy","permalink":"/docs/openziti/blog/tags/tproxy","description":"Transparent proxy"}],"readingTime":12.09,"hasTruncateMarker":true,"authors":[{"name":"Robert Caamano","title":"Author","url":"https://github.com/r-caamano","imageURL":"https://avatars.githubusercontent.com/r-caamano","key":"RobertCaamano","page":null}],"frontMatter":{"title":"Using eBPF-TC to securely mangle packets in the kernel, and pass them to my secure networking application","seoDescription":"This article described how I leveraged eBPF-TC to build a Plugin TPROXY IFW to steer traffic to my target application.","date":"2022-11-09T22:10:42.000Z","cuid":"claa73b5k000509l012jsa3ic","slug":"using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application","authors":["RobertCaamano"],"image":"@site/blogs/openziti/v1668008121762/C4XmMYoVT.jpg","imageDark":"@site/blogs/openziti/v1668008121762/C4XmMYoVT.jpg","tags":["opensource","firewall","openziti","ebpf","tc","tproxy"]},"unlisted":false,"prevItem":{"title":"NGINX & ZeroTrust API Security","permalink":"/docs/openziti/blog/nginx-zerotrust-api-security"},"nextItem":{"title":"OpenZiti BrowZer Gateway","permalink":"/docs/openziti/blog/browzer-gateway-fqdn-certs"}},"content":"## Introduction\\n\\neBPF enables you to safely run sandboxed programs for functions like security and networking in the OS kernel, without \\nchanging kernel source code or loading kernel modules. eBPF-TC specifically has robust packet mangling capability, and \\nenables ingress and egress operations, with high performance.\\n\\n\x3c!-- truncate --\x3e\\n\\nThis is how I used TC-eBPF to build a Plugin TPROXY Interception Firewall (IFW) to intercept and deliver packets to my target application - OpenZiti Edge Routers. You can use a similar eBPF-TC implementation to intercept packets to send to your specific observability, security or networking application. The code is here: [https://github.com/netfoundry/zfw](https://github.com/netfoundry/zfw). Process flow and packet flow diagrams are at the end of this article.\\n\\n## Project context \u2013 passing packets to OpenZiti endpoints\\n\\nOpenZiti (open source zero trust networking platform) enables private connections across full mesh Internet overlay networks. Ziti endpoints are embedded in applications as code (via Ziti SDKs), and deployed as OS agents, daemons, containers or VMs. You can spin up any number of Ziti routers in your private mesh - it looks like this if you deploy two routers:\\n\\n![OpenZiti End to End Encryption Terminating at the Routers](/blogs/openziti/v1668007504136/qJTZ9uPxE.png)\\n\\nZiti Edge Routers are often used on Linux and default to iptables to map incoming interesting traffic toward service listening ports using [IP Table Tproxy Target](https://docs.kernel.org/networking/tproxy.html). This works great if for example you are running Ubuntu and FWD. However, there are many Linux distros with key variances. I therefore used TC-eBPF to build a more universal option for Linux distros which support eBPF, enabling those distros to intercept traffic of interest. The eBPF feature set also enabled additional packet filtering and manipulation not natively supported in iptables/nftables.\\n\\n## TC-eBPF IFW \u2013 tproxy target entries\\n\\nSo before diving into building the eBPF IFW I needed to reverse engineer how OpenZiti edge-routers natively translate services into iptables rules - which TPROXY target statements need to be added/deleted based on services the router learned from the OpenZiti Controller. The following is the information used to create the tproxy target entries via iptables.\\n\\n```plaintext\\nIP Destination Prefix: Dotted Decimal IP/mask bit-length\\nTCP/UDP port range in the format Decimal Low_Port:High_Port\\nProtocol: TCP/UDP\\nTPROXY Listening port: Decimal port\\n```\\n\\n## TC-eBPF IFW \u2013 insertion and mapping\\n\\nSo now with this information I could start thinking about the eBPF map types and structures that I would use to communicate between a user space mapping tool and the IFW to dynamically update rules.\\n\\nSince I wanted my program to act function similarly to ufw/iptables I chose TC-eBPF as my insertion point due to the combination of its attachment at the interface level (ability to drop packets before forwarding to the Linux IP stack), and the currently available sk helpers for socket lookup/splicing.\\n\\nIn order to check if an incoming packet matches an intercept policy created by a Ziti network administrator (Ziti intercepts specifically defined flows \u2013 doesn\u2019t default to intercepting all flows), I needed a pinned map that supported a struct key type. A a eBPF hash map which allows for struct as a key gave me the flexibility to customize the lookup and add or delete criteria as use cases evolve. Using pinned maps allows multiple copies of the ebpf program to run (One on each inbound interface) and share the map updated by the mapping tool/Ziti.\\n\\nDepicted below is the initial map definition I chose:\\n\\n```plaintext\\nstruct {\\n    __uint(type, BPF_MAP_TYPE_ARRAY);\\n    __uint(id, BPF_MAP_ID_IFINDEX_IP);\\n    __uint(key_size, sizeof(uint32_t));\\n    __uint(value_size, sizeof(struct ifindex_ip4));\\n    __uint(max_entries, 50);\\n    __uint(pinning, LIBBPF_PIN_BY_NAME);\\n} ifindex_ip_map SEC(\\".maps\\");\\nThe initial key I chose a struct of the following form:\\nstruct tproxy_key {\\n    __u32 dst_ip;\\n    __u16 prefix_len;\\n    __u16 protocol;\\n} \\nThese data structures allow for a lookup based on destination ip prefix, cidr length, and ip protocol(tcp/udp) which can all be decerned from the incoming packet. \\nFor value I used a struct of the following format:\\nstruct tproxy_tuple {\\n   __u16 index_len; /*tracks the number of entries in the index_table*/\\n   __u16 index_table[MAX_INDEX_ENTRIES];/* Array used as index table which points to    \\nStruct *tproxy_port_mapping in the     \\nport_maping array with each poulated\\nindex representing a udp or tcp tproxy     \\nmapping in the port_mapping\\n                                         */\\nstruct tproxy_port_mapping port_mapping[MAX_TABLE_SIZE];/* Array to store unique   \\ntproxy mappings\\nwith each index match   \\nthe low_port of the\\nstruct  tproxy_port_mapping{\\n__u16 low_port;\\n__u16 high_port;\\n__u16 tproxy_port;\\n__u32 tproxy_ip;\\n}*/\\n}\\n```\\n\\nSince OpenZiti IP based service policies can be defined at any level of granularity, including network CIDR blocks, I did not want to have to generate hash entries for every host address in contained in a block. I therefore implemented a longest match lookup algorithm that successively widens the mask checking to see if an incoming IP tuple either directly matches a host address or falls within a CIDR block range that matches the ip\\\\_dest / prefix\\\\_len fields in the tproxy\\\\_key along with matching IP transport protocol (TCP or UDP).\\n\\n```javascript\\nstruct tproxy_tuple *tproxy\\n__u32 exponent=24;  /* unsugend integer used to calulate prefix matches */\\n__u32 mask = 0xffffffff;  /* starting mask value used in prefix match calculation */\\n__u16 maxlen = 32; /* max number ip ipv4 prefixes */\\n \\nfor (__u16 count = 0;count <= maxlen; count++){\\n    struct tproxy_key key = {(tuple->ipv4.daddr & mask), maxlen-count,protocol}\\n    if ((tproxy = get_tproxy(key))){\\n            { Redacted for brevity}\\n           \\n    /*algorithm used to calucate mask while traversing each octet.*/\\n    if(mask == 0x00ffffff){\\n       exponent=16;\\n    }\\n    if(mask == 0x0000ffff){\\n       exponent=8;\\n    }\\n    if(mask == 0x000000ff){\\n       exponent=0;\\n    }\\n    if(mask == 0x00000080){\\n       return TC_ACT_SHOT;\\n    }\\n    if((mask >= 0x80ffffff) && (exponent >= 24)){\\n       mask = mask - (1 << exponent);\\n    }else if((mask >= 0x0080ffff) && (exponent >= 16)){\\n       mask = mask - (1 << exponent);\\n    }else if((mask >= 0x000080ff) && (exponent >= 8)){\\n       mask = mask - (1 << exponent);\\n    }else if((mask >= 0x00000080) && (exponent >= 0)){\\n       mask = mask - (1 << exponent);\\n            }\\n    exponent++;\\n}\\n```\\n\\nFurther, since a Ziti end user can associate any number of port ranges to a destination on a per protocol basis, in this first pass I did not want to create an entry in the hash map for every port given the potential for large port ranges i.e 1-65535. Instead, I created an index table in which each entry points to a populated array index in the port\\\\_mapping table where the index is the low\\\\_port value of the mapped rule. This limits the search for a port match to only populated port range entries vs sequential index searches directly in the port mapping table. I plan to test the performance and resource limitation of creating hash map entries for every member port vs indexed lookup of range start. Below is a code snippet of the lookup used to find a match based on the incoming tuple-&gt;ipv4.dport\\n\\n```javascript\\nfor (int index = 0; index < max_entries; index++) {\\n    /* set port_key equal to the port value stored at current Index */\\n    int port_key = tproxy->index_table[index];\\n    /*\\ncheck if tuple destination port is greater than low port and lower than high    \\nport at mapping[port_key]\\nif matched get associated tproxy port and attempt to find listening socket\\nif successfull jump to assign:\\n   */\\n     if ((bpf_ntohs(tuple->ipv4.dport) >= bpf_ntohs(tproxy->port_mapping[port_key].low_port))\\n          && (bpf_ntohs(tuple->ipv4.dport) <=bpf_ntohs(tproxy>port_mapping[port_key].high_port))){               \\n          If(local){ /* if tuple->daddr == router\u2019s ip then forward to stack */\\n              return TC_ACT_OK;\\n         }\\n         /* construct tuple to used to lookup TPROXY sk */\\n         sockcheck.ipv4.daddr = tproxy->port_mapping[port_key].tproxy_ip;\\n         sockcheck.ipv4.dport = tproxy->port_mapping[port_key].tproxy_port;\\n         /* look up sk based on protocol in map key */\\n         if(protocol == 6){\\n              sk = bpf_skc_lookup_tcp(skb, &sockcheck, sizeof(sockcheck.ipv4),\\n                 BPF_F_CURRENT_NETNS, 0);\\n         }else{\\n             sk = bpf_sk_lookup_udp(skb, &sockcheck,  sizeof(sockcheck.ipv4),\\n                 BPF_F_CURRENT_NETNS, 0);\\n         }  \\n         if(!sk){\\n             return TC_ACT_SHOT;\\n         }  \\n         if((protocol == IPPROTO_TCP) && (sk->state != BPF_TCP_LISTEN)){\\n             bpf_sk_release(sk);\\n             return TC_ACT_SHOT;\\n         }\\n         goto assign;\\n     }\\n}\\nassign:\\n    /*attempt to splice the skb to the tproxy or local socket*/\\n    ret = bpf_sk_assign(skb, sk, 0);\\n    /*release sk*/\\n    if(ret == 0){\\n       //if succedded forward to the stack\\n       return TC_ACT_OK;\\n    }   \\n    /*else drop packet if not running on loopback*/\\n    if(skb->ingress_ifindex == 1){\\n        return TC_ACT_OK;\\n    }else{\\n        return TC_ACT_SHOT;\\n    }\\n}\\n```\\n\\n## TC-eBPF \u2013 Stateful Firewall\\n\\nSince I wanted eBPF to perform the functionality of a stateful firewall (At least to the extent that there must be an active outbound session to a host for acknowledged packets to be accepted from that host), I needed to consider how to allow the program to manage session states for both UDP and TCP. I initially thought that this might be complicated. However, while working with the ebpf helpers used to splice sockets together, I realized that the same helpers could be used to check to see if an outgoing sockets had been initiated. In the case that an incoming packet tuple matched an existing outgoing session, splice the incoming skb to the existing sk while performing the same lookup that the program was already performing for the OpenAiti service tproxy sk(s). The following code excerpts shows the basic state inspection code I used for TCP:\\n\\n```javascript\\n/* if tcp based tuple implement statefull inspection to see if they were\\ninitiated by the local OS if not pass on to tproxy logic to determin if the OpenZiti router has tproxy \\nintercepts defined for the flow\\n */\\nsk = bpf_skc_lookup_tcp(skb, tuple, tuple_len,BPF_F_CURRENT_NETNS, 0);\\nif(sk){\\n  if (sk->state != BPF_TCP_LISTEN){\\n     goto assign;\\n  }\\n  bpf_sk_release(sk);\\n}\\n\\nassign:\\n    /*attempt to splice the skb to the tproxy or local socket*/\\n    ret = bpf_sk_assign(skb, sk, 0);\\n    /*release sk*/\\n    if(ret == 0){\\n       //if succeeded forward to the stack\\n       return TC_ACT_OK;\\n    }   \\n/*else drop packet if not running on loopback*/\\n    if(skb->ingress_ifindex == 1){\\n        return TC_ACT_OK;\\n    }else{\\n        return TC_ACT_SHOT;\\n    }\\n}\\n```\\n\\n## TC-eBPF IFW \u2013 SSH inbound\\n\\nTaking things, a step further I wanted to allow ssh inbound by default, but wanted to restrict ssh to only the IP address of the external interface which the eBPF program was attached. However, when running eBPF at the TC level you do not have access to the interface\u2019s IP address. Having this functionality is essential to support ssh services over Ziti when using the standard port since the services would also have a destination port of TCP/22. So, without being able to discern the router\u2019s IP, the program would not know whether to forward to the Linux stack or to Ziti Tproxy service ports. To solve this, I initially allow ssh to pass to any address, and then let my user space zfw app inform eBPF what its attached IP is via a bpf hash map. I did this by having the user space app use the ifindex as the hash map key and then then store the IP address in a struct with the IP Address array as one of its fields. Specifically, the map and structs I created are as follows:\\n\\n```plaintext\\n/* hash Map */\\nstruct {\\n    __uint(type, BPF_MAP_TYPE_HASH);\\n    __uint(key_size, sizeof(uint32_t));\\n    __uint(value_size, sizeof(struct ifindex_ip4));\\n    __uint(max_entries, MAX_IF_ENTRIES);\\n    __uint(pinning, LIBBPF_PIN_BY_NAME);\\n    __uint(map_flags, BPF_F_NO_PREALLOC);\\n} ifindex_ip_map SEC(\\".maps\\");\\n \\n/*value to ifindex_ip_map*/\\nstruct ifindex_ip4 {\\n    uint32_t ipaddr[MAX_ADDRESSES];\\n    char ifname[IFNAMSIZ];\\n    uint8_t count;\\n};\\n \\nstatic inline struct ifindex_ip4 *get_local_ip4(__u32 key){\\n    struct ifindex_ip4 *ifip4;\\n    ifip4 = bpf_map_lookup_elem(&ifindex_ip_map, &key);\\n\\treturn ifip4;\\n}\\n \\n/*look up attached interface IP address*/\\nstruct ifindex_ip4 *local_ip4 = get_local_ip4(skb->ingress_ifindex);\\n\\n/* if ip of attached interface found in map only allow ssh to that IP */\\nif(tcp && (bpf_ntohs(tuple->ipv4.dport) == 22)){\\n        if((!local_ip4 || !local_ip4->count)){\\n            return TC_ACT_OK;\\n        }else{\\n            uint8_t addresses = 0; \\n            if(local_ip4->count < MAX_ADDRESSES){\\n                addresses = local_ip4->count;\\n            }else{\\n                addresses = MAX_ADDRESSES;\\n            }\\n            for(int x = 0; x < addresses; x++){\\n                if((tuple->ipv4.daddr == local_ip4->ipaddr[x]) && !local_diag->ssh_disable){\\n                    if(local_diag->verbose && ((event.tstamp % 2) == 0)){\\n                        event.proto = IPPROTO_TCP;\\n                        send_event(&event);\\n                    }\\n                    return TC_ACT_OK;\\n                }\\n            }\\n        }\\n  }\\n```\\n\\nUDP follows the same basic premise, but I needed to make an exception specifically for DHCP since it operates in a way that makes state inspection difficult (other stateful FWs like UFW also make the same inbound exception)\\n\\n```javascript\\n/* forward DHCP messages to local system */\\n    if(udp && (bpf_ntohs(tuple->ipv4.sport) == 67) && (bpf_ntohs(tuple->ipv4.dport) == 68)){\\n       return TC_ACT_OK;\\n}\\n```\\n\\n## eBPF User Space Integration\\n\\nI created a user space app zfw.c which updates the pinned maps described earlier. The zfw populates the ip address / name of the interface with the attached eBPF program and inserts/deletes rules into/ffrom the nf\\\\_tproxy\\\\_map with the usage following patterns:\\n\\n```javascript\\nUsage: sudo zfw -I -c <ip dest address or prefix> -m <dst prefix len> -o <ip src address or prefix> -n <src prefix len>  -p tcp -l <dst low port> -h <dst high port> -t <tproxy port> -p <ip protocol>\\n\\n sudo zfw -I -c 172.16.240.1 -m 32 -o 10.1.1.1 -n 32  -p tcp -l 22 -h 22 -t 0\\n \\nUsage: sudo zfw -D -c <ip dest address or prefix> -m <dst prefix len> -o <ip src address or prefix> -n <src prefix len>  -p tcp -l <dst low port> -h <dst high port> -t <tproxy port> -p <ip protocol>\\n \\n sudo zfw -D -c 172.16.240.1 -m 32 -o 10.1.1.1 -n 32  -p tcp -l 22\\n```\\n\\nIf you run an OpenZiti Router in diverter mode it will dynamically update the pinned BPF zt\\\\_tproxy\\\\_map used by the IFW to make forwarding decisions. The system calls are made dynamically whenever changes are made to any service either to add or delete them when running an OpenZiti edge-router in diverter mode.\\n\\nThe following shows the logging output from the edge-router running in diverter mode when initially learning services from the Ziti controller. You can see that it makes system calls to the zfw user space program to add the learned services as hash map entries into the bpf map.\\n\\n```javascript\\nFeb 24 20:21:32 ebpf-router ziti-router[30284]: {\\"command\\":\\"/opt/openziti/bin/zfw -I -c 100.72.0.4 -m 32 -p tcp -l 5985 -h 5985 -t 43321\\",\\"file\\":\\"/home/ziggy/gitnfnew/ziti/tunnel/intercept/tproxy/tproxy_linux.go:546\\",\\"func\\":\\"github.com/openziti/ziti/tunnel/intercept/tproxy.(*tProxy).addInterceptAddr\\",\\"level\\":\\"info\\",\\"msg\\":\\"diverter command succeeded. output: Adding TCP mapping\\\\n\\",\\"time\\":\\"2024-02-24T20:21:32.420Z\\"}\\nFeb 24 20:21:32 ebpf-router ziti-router[30284]: {\\"command\\":\\"/opt/openziti/bin/zfw -I -c 100.72.0.4 -m 32 -p tcp -l 22 -h 22 -t 43321\\",\\"file\\":\\"/home/ziggy/gitnfnew/ziti/tunnel/intercept/tproxy/tproxy_linux.go:546\\",\\"func\\":\\"github.com/openziti/ziti/tunnel/intercept/tproxy.(*tProxy).addInterceptAddr\\",\\"level\\":\\"info\\",\\"msg\\":\\"diverter command succeeded. output: Adding TCP mapping\\\\nlookup success\\\\n\\",\\"time\\":\\"2024-02-24T20:21:32.426Z\\"}\\n```\\n\\n## TC-eBPF IFW \u2013 process and packet flow diagrams\\n\\n![TC-eBPF IFW \u2013 process diagram](/blogs/openziti/v1668007360611/6LzUjyxVe.jpg)\\n\\n![TC-eBPF IFW \u2013 packet flow diagram](/blogs/openziti/v1668007368128/DlMW3rsU9.jpg)\\n\\n## Summary\\n\\nThis article described how I leveraged eBPF-TC to build a Plugin TPROXY IFW to steer traffic to my target application. Hopefully you found the experience that I shared useful. Would love to hear how other eBPF developers are making use of this robust functionality."},{"id":"browzer-gateway-fqdn-certs","metadata":{"permalink":"/docs/openziti/blog/browzer-gateway-fqdn-certs","source":"@site/blog/openziti-browzer-gateway.md","title":"OpenZiti BrowZer Gateway","description":"Welcome back to the next article concerning BrowZer, a new group of open-source components from the OpenZiti project that enables automatic embedding of zero trust networking into web applications. The reason BrowZer exists, and the problem it aims to solve is preventing your internet-facing web applications from being attacked by malicious threat actors.","date":"2022-11-03T17:06:18.000Z","tags":[{"inline":false,"label":"JavaScript","permalink":"/docs/openziti/blog/tags/javascript","description":"JavaScript content"},{"inline":false,"label":"Web Development","permalink":"/docs/openziti/blog/tags/web-development","description":"Web development content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Browzer","permalink":"/docs/openziti/blog/tags/browzer","description":"Browzer related content"}],"readingTime":10.92,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"title":"OpenZiti BrowZer Gateway","seoTitle":"How to Acquire FQDN TLS Certificates from a Public CA","seoDescription":"FQDN Certs and web application security: How OpenZiti BrowZer bootstraps trusted network sessions between your authorized users and your web app.","date":"2022-11-03T17:06:18.000Z","cuid":"cla1bkqn0000q08jvbdf0bn1l","slug":"browzer-gateway-fqdn-certs","authors":["CurtTudor"],"image":"@site/blogs/openziti/v1667494026072/ewG54FUJv.jpg","imageDark":"@site/blogs/openziti/v1667494026072/ewG54FUJv.jpg","tags":["javascript","web-development","security","openziti","zerotrust","browzer"]},"unlisted":false,"prevItem":{"title":"Using eBPF-TC to securely mangle packets in the kernel, and pass them to my secure networking application","permalink":"/docs/openziti/blog/using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application"},"nextItem":{"title":"OpenZiti Authentication API Integrations","permalink":"/docs/openziti/blog/openziti-authentication-api-integrations"}},"content":"Welcome back to the next article concerning **BrowZer**, a new group of open-source components from the [OpenZiti project](https://github.com/openziti/) that enables [**automatic embedding of zero trust networking into web applications**](./introducing-openziti-browzer.md). The reason **BrowZer** exists, and the problem it aims to solve is preventing your internet-facing web applications from being attacked by malicious threat actors.\\n\\n\x3c!-- truncate --\x3e\\n\\nThis article is part of the ongoing [web application security](./openziti-browzer-gateway.md) series concerning **BrowZer**, and here I will provide instructions concerning how to acquire TLS certificates for its *gateway* component \u2014 or what we internally refer to as the HTTP Agent.\\n\\nBefore proceeding below, you may be interested in reading the [architectural overview of the OpenZiti BrowZer Gateway](./openziti-browzer-gateway.md) to get some broader context if you haven\'t already read it.\\n\\nThis article describes how to acquire fully qualified domain name ([FQDN](https://en.wikipedia.org/wiki/Fully_qualified_domain_name)) certs for use with BrowZer, but you may also be interested in Part-1 of this article where I describe [how to acquire wildcard certs for use with BrowZer](./openziti-browzer-gateway.md).\\n\\n# BrowZer Gateway Internet-Facing TLS\\n\\nCustomers of our CloudZiti offering will have everything described below automatically orchestrated for them. However, if you are a user of our [OpenZiti open source offerings](https://github.com/openziti), then continue reading, and I\'ll provide information regarding the BrowZer Gateway TLS requirements and how to satisfy them.\\n\\nThe educational material contained in this article will certainly help enable you to deploy your own instance of the BrowZer Gateway, but please note that it is not exhaustive. Here we limit discussion to tooling you can use to acquire the necessary TLS certs you need to use with the BrowZer Gateway.\\n\\nUpcoming articles in the [series](./tags/browzer) will be published soon and they will close the remaining gap and describe all the IdP integration/configuration details, the BrowZer Gateway Docker container, and all BrowZer Gateway configuration details related to the OpenZiti overlay network it will be a part of.\\n\\n### HTTPS\\n\\nFor general web-related usability and security reasons, as well as BrowZer architectural reasons, the BrowZer Gateway ***must*** be served over HTTPS.\\n\\nNot using HTTPS causes nasty things to happen:\\n\\n* browsers render scary warnings to users\\n    \\n* users are exposed to security issues (e.g man-in-the-middle attacks).\\n    \\n\\nAs discussed earlier in the [architectural overview of the OpenZiti BrowZer Gateway](./openziti-browzer-gateway.md), in a BrowZer environment your web app will be invisible to the internet, and the BrowZer Gateway is deployed such that ***it*** is the web server that your users will point their browsers to in order to reach your dark web app.\\n\\n## Self-signed Cert? That\'s a No-No!\\n\\nUsing HTTPS implies using a TLS certificate. And while using TLS certificates with the BrowZer Gateway is certainly a requirement, using just ***any*** TLS certificate isn\'t good enough.\\n\\nFor example, you might be thinking: \\"*I\'ll just run a command similar to the following*...\\n\\n```plaintext\\nopenssl req -new -x509 -sha256 -newkey rsa:2048 \\\\\\n  -nodes -keyout example-com.key.pem -days 365 \\\\\\n  -out example-com.cert.pem\\n```\\n\\n... *to generate a self-signed cert, and I\'ll use that*.\\"\\n\\nThe problem with using a self-signed cert to host the BrowZer Gateway is that doing so will result in the client-side browser rendering something resembling the following when it visits a web server that uses a self-signed cert:\\n\\n![image.png](/blogs/openziti/v1666373910089/OTYczI-mw.png?width=500)\\n\\nThat\'s an obvious show-stopper.\\n\\nThe solution is to acquire a TLS certificate from a **public** [certificate authority](https://en.wikipedia.org/wiki/Certificate_authority) (**CA**) because certificates generated by public CA\'s will be trusted by browsers.\\n\\n## TLS Cert From a Public CA\\n\\nIt\'s possible to pay money to a company like AWS, Godaddy, Namecheap, etc., in order to get a certificate from a well-known public certificate authority..., but don\'t worry...\\n\\n***You don\'t need to spend any money to get the certificates you need*!**\\n\\n[Let\u2019s Encrypt](https://letsencrypt.org/) is an organization that issues TLS certificates for free to the public. Let\u2019s Encrypt is reputable, and trusted by browsers. They were created by the Internet Security Research Group (with members like Chrome, Mozilla, Cisco, the Bill and Melinda Gates Foundation, etc.) and aim to facilitate an Internet where all websites communicate over HTTPS even if the site\u2019s owner does not have money to buy TLS certificates on a recurring basis.\\n\\nBroadly speaking, you can use Let\u2019s Encrypt to generate certificates in multiple ways:\\n\\n1. Using the automated system that your hosting company provides\\n    \\n2. Generating a certificate by manually interacting with Let\u2019s Encrypt with scripts you run\\n    \\n3. Configuring your DNS zone and running a lightweight DNS-challenge name server to automatically use Let\u2019s Encrypt to generate ***wildcard certificates***\\n    \\n\\nI\'ll skip any discussion of item #1 (hosting providers) since self-hosting BrowZer is the environment we\'re focused on here.\\n\\nIf you wish to serve a ***single*** dark web app via the BrowZer gateway, item #2 (Manual Cert Generation) will suffice, and this is what we will describe in the subsections below.\\n\\nIf you wish to serve ***multiple*** dark web apps via a single BrowZer gateway, item #3 (Automatic Wildcard Cert Generation) is the recipe you\'ll need, since wildcard certs are a key underpinning of how the BrowZer Gateway facilitates hosting multiple dark web apps. In that case, click over to the article where I describe [how to acquire wildcard certs for use with BrowZer](./openziti-browzer-gateway.md).\\n\\n### Manual Cert Generation (Mac)\\n\\nYou can use your Mac to get a TLS certificate issued by Let\u2019s Encrypt. You can then use the cert on your laptop to get your feet wet in a local BrowZer environment. Later, you could then install this same cert on the (cloud) instance where you\'d like to host your BrowZer Gateway.\\n\\nHere are the required items:\\n\\n* computer running macOS.\\n    \\n* reliable internet connection.\\n    \\n* comfort with running commands in a terminal.\\n    \\n* Homebrew: You can find instructions for installing it [here](https://brew.sh/).\\n    \\n\\n**Install certbot:**\\n\\nOpen a terminal, and use Homebrew to install [cerbot](https://certbot.eff.org/) by running the following command in a terminal:\\n\\n```plaintext\\nbrew install certbot\\n```\\n\\n**Create a directory for Let\u2019s Encrypt to save to:**\\n\\nCreate a directory in a location you like (e.g in your home directory) and give it a name you want. Let\u2019s say we want to use YOUR\\\\_HOME\\\\_DIR/lets-encrypt. We can create the said directory by running this command:\\n\\n```plaintext\\nmkdir ~/lets-encrypt\\n```\\n\\nLater, you will tell Let\u2019s Encrypt to save its output in this directory. Otherwise, Let\u2019s Encrypt will write to `/etc/letsencrypt`, and you may not have the permissions needed to access some of the contents in that location\\n\\n**Prove that you own the domain:**\\n\\nWhen you get a TLS certificate from Let\u2019s Encrypt, their servers validate that you control the domain names for the certificate you are requesting. You need to prove to Let\u2019s Encrypt that you own the domain. To do this, you need to solve a \\"challenge\\", as defined by the [ACME](https://en.wikipedia.org/wiki/Automatic_Certificate_Management_Environment) standard. That is, you need to do something that you would not be able to do if you didn\u2019t own the domain and have admin access to it.\\n\\nYou can accomplish this in multiple ways: with a [HTTP-01](https://letsencrypt.org/docs/challenge-types/#http-01-challenge) challenge or a [DNS-01](https://letsencrypt.org/docs/challenge-types/#dns-01-challenge) challenge.\\n\\nWe will use the [DNS-01](https://letsencrypt.org/docs/challenge-types/#dns-01-challenge) technique, and you will need to add a certain DNS record to your domain (i.e. the DNS challenge).\\n\\n**Run certbot to acquire a free TLS certificate:**\\n\\nEnter the following command to run certbot and start the process for getting a certificate:\\n\\n```plaintext\\ncertbot certonly --preferred-challenges=dns \\\\\\n  --manual --config-dir ~/lets-encrypt \\\\\\n  --work-dir ~/lets-encrypt --logs-dir ~/lets-encrypt\\n```\\n\\ncertbot will then prompt you like this:\\n\\n```plaintext\\nPlease enter the domain name(s) you would like on your certificate (comma and/or\\nspace separated) (Enter \'c\' to cancel):\\n```\\n\\nYou will now enter the fully qualified domain name ([FQDN](https://en.wikipedia.org/wiki/Fully_qualified_domain_name)) where you want to host the BrowZer Gateway. The FQDN you enter must reside in a DNS zone that you control (i.e. you need to prove you own the domain).\\n\\nYou might be using Google Domains, AWS Route53, or some other DNS administration tool. I will use an AWS Route53 example here.\\n\\nI have the ability to administrate the `.ziti.netfoundry.io` domain, so I will use a FQDN of `browzer-gateway.ziti.netfoundry.io` for this example.\\n\\nWhen I enter that FQDN, certbot will prompt like the following:\\n\\n```plaintext\\nSaving debug log to /Users/curt/lets-encrypt/letsencrypt.log\\nPlease enter the domain name(s) you would like on your certificate (comma and/or\\nspace separated) (Enter \'c\' to cancel): browzer-gateway.ziti.netfoundry.io\\nRequesting a certificate for browzer-gateway.ziti.netfoundry.io\\n\\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\\nPlease deploy a DNS TXT record under the name:\\n\\n_acme-challenge.browzer-gateway.ziti.netfoundry.io.\\n\\nwith the following value:\\n\\nAsI-Nz4WrH7hKX9-cO2tIEbxyQBzXW0ROXw_KRidJ2Q\\n\\nBefore continuing, verify the TXT record has been deployed. Depending on the DNS\\nprovider, this may take some time, from a few seconds to multiple minutes. You can\\ncheck if it has finished deploying with aid of online tools, such as the Google\\nAdmin Toolbox: https://toolbox.googleapps.com/apps/dig/#TXT/_acme-challenge.browzer-gateway.ziti.netfoundry.io.\\nLook for one or more bolded line(s) below the line \';ANSWER\'. It should show the\\nvalue(s) you\'ve just added.\\n\\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\\nPress Enter to Continue\\n```\\n\\nUsing the values certbot specified, I enter them into the AWS Route53 console, like this:\\n\\n![image.png](/blogs/openziti/v1666380266489/jQxckv0iS.png)\\n\\nI then click the \\"Create\\" button, and then Route53 will produce the TXT record, like this:\\n\\n![image.png](/blogs/openziti/v1666380502004/g8mYmuuDR.png)\\n\\nNow that the DNS challenge record is in place, I can return to the certbot prompt, and press ENTER. It will then respond like this:\\n\\n```plaintext\\nPress Enter to Continue\\n\\nSuccessfully received certificate.\\nCertificate is saved at: /Users/curt/lets-encrypt/live/browzer-gateway.ziti.netfoundry.io/fullchain.pem\\nKey is saved at:         /Users/curt/lets-encrypt/live/browzer-gateway.ziti.netfoundry.io/privkey.pem\\nThis certificate expires on 2023-01-19.\\n```\\n\\nLooking at what was produced, you\'ll see the following:\\n\\n```plaintext\\n{13:29}~/lets-encrypt/archive \u27ad ls -l /Users/curt/lets-encrypt/live/browzer-gateway.ziti.netfoundry.io\\ntotal 8\\n-rw-r--r--  1 curt  staff  692 Oct 21 13:29 README\\nlrwxr-xr-x  1 curt  staff   58 Oct 21 13:29 cert.pem -> ../../archive/browzer-gateway.ziti.netfoundry.io/cert1.pem\\nlrwxr-xr-x  1 curt  staff   59 Oct 21 13:29 chain.pem -> ../../archive/browzer-gateway.ziti.netfoundry.io/chain1.pem\\nlrwxr-xr-x  1 curt  staff   63 Oct 21 13:29 fullchain.pem -> ../../archive/browzer-gateway.ziti.netfoundry.io/fullchain1.pem\\nlrwxr-xr-x  1 curt  staff   61 Oct 21 13:29 privkey.pem -> ../../archive/browzer-gateway.ziti.netfoundry.io/privkey1.pem\\n```\\n\\nIf you paste the contents of the `fullchain.pem` file into a cert validator (e.g. [https://www.sslchecker.com/certdecoder](https://www.sslchecker.com/certdecoder)), you will then see the following:\\n\\n![image.png](/blogs/openziti/v1666381231538/d3dV6UhXs.png)\\n\\n### Manual Cert Generation (Linux)\\n\\nYou can use Linux to get a TLS certificate issued by Let\u2019s Encrypt. You can then use the cert on your laptop to get your feet wet in a local BrowZer environment. Later, you could then install this same cert on the (cloud) instance where you\'d like to host your BrowZer Gateway.\\n\\nFollow the instructions [located here](https://certbot.eff.org/instructions) to get certbot installed on your system.\\n\\nOnce installed, you can use the same sequence of steps described in the above Mac sub-section to get your cert generated.\\n\\n### Manual Cert Generation (Windows)\\n\\nYou can use Windows to get a TLS certificate issued by Let\u2019s Encrypt. You can then use the cert on your laptop to get your feet wet in a local BrowZer environment. Later, you could then install this same cert on the (cloud) instance where you\'d like to host your BrowZer Gateway.\\n\\nFollow the instructions [located here](https://certbot.eff.org/instructions) to get certbot installed on your system.\\n\\nOnce installed, you can use the same sequence of steps described in the above Mac sub-section to get your cert generated.\\n\\nHere is a looping/animated GIF showing what it looks like when executed, as well as some (non-essential) decoding of the acquired cert just to prove it contains what we need.\\n\\n# BrowZer Gateway Deployment & Configuration\\n\\nCustomers of our CloudZiti offering will have everything described in this article automatically orchestrated for them.\\n\\nMeanwhile, if you are a user of our OpenZiti open-source offerings, and you\'d like to take BrowZer out for a spin, then you will be interested in reading the next few articles in this series where I describe how to use the certificates you obtained as shown above, and then configure and deploy your own instance of the BrowZer Gateway.\\n\\n# Wrap up\\n\\nDo you host a web app and want to be invisible to malicious threat actors?\\n\\nDo you want your users to have easy access from anywhere with no additional software on their client laptop of mobile phone?\\n\\nDo you want to do all this without making any modifications to your web app?\\n\\nIf so, I hope you\'ll join our community and try BrowZer.\\n\\nPlease subscribe to this blog to be notified of more information concerning how to succeed."},{"id":"openziti-authentication-api-integrations","metadata":{"permalink":"/docs/openziti/blog/openziti-authentication-api-integrations","source":"@site/blog/openziti-authentication-api-integrations.md","title":"OpenZiti Authentication API Integrations","description":"In the OpenZiti project, we have created an overlay network that makes network services dark. Part of that system is authenticating devices and users before they connect. The challenge is that most companies already have methods to authenticate human users and hardware devices. The challenge we faced with OpenZiti was to provide ways to integrate both users and devices through external Identity Providers (IdP). Our solution was to allow two of the fundamental building blocks of modern authentication systems to be validated by OpenZiti: x509 certificates and JWTs.","date":"2022-10-20T00:00:00.000Z","tags":[{"inline":false,"label":"Authentication","permalink":"/docs/openziti/blog/tags/authentication","description":"Authentication methods and systems"},{"inline":false,"label":"APIs","permalink":"/docs/openziti/blog/tags/apis","description":"API development"},{"inline":false,"label":"Integrations","permalink":"/docs/openziti/blog/tags/integrations","description":"Third-party integrations"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":3.87,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"slug":"openziti-authentication-api-integrations","title":"OpenZiti Authentication API Integrations","authors":["AndrewMartinez"],"date":"2022-10-20T00:00:00.000Z","tags":["authentication","apis","integrations","openziti"]},"unlisted":false,"prevItem":{"title":"OpenZiti BrowZer Gateway","permalink":"/docs/openziti/blog/browzer-gateway-fqdn-certs"},"nextItem":{"title":"High-Level Public/Private Cryptography","permalink":"/docs/openziti/blog/high-level-publicprivate-cryptography"}},"content":"In the OpenZiti project, we have created an overlay network that makes network services dark. Part of that system is authenticating devices and users before they connect. The challenge is that most companies already have methods to authenticate human users and hardware devices. The challenge we faced with OpenZiti was to provide ways to integrate both users and devices through external Identity Providers (IdP). Our solution was to allow two of the fundamental building blocks of modern authentication systems to be validated by OpenZiti: x509 certificates and JWTs.\\n\\n\x3c!-- truncate --\x3e\\n\\nFor OpenZiti to validate both of those new data model entities were created to support them:\\n\\n- [External JWT Signers](https://openziti.github.io/ziti/security/authentication/external-jwt-signers.html) - Allows static x509 and JWKS endpoint configuration\\n- [3rd Party CAs](https://openziti.github.io/ziti/security/authentication/third-party-cas.html) - Allows static x509 CA certificates configuration\\n\\nBoth have several options that are documented in the above links. The main goal of both of these entities is to allow external systems to generate signed documents (certificates and JWTs) that can be verified (if you need a refresher on this, please see this [article](https://openziti.io/high-level-publicprivate-cryptography)). These documents can have variable length lifetimes and other qualities that are outside the control of OpenZiti, we must delegate trust upwards to some higher authority, a \\"signer.\\" For x509 certificates, this is either an intermediate Certificate Authority (CA) or a root CA. For JWTs this is simply a certificate that creates digital signatures.\\n\\n\\n![3rd party id.png](/blogs/openziti/v1666618727994/u2laPGD0G.png)\\n\\n### Example Public Key Infrastructure\\n[![](https://mermaid.ink/img/pako:eNplkD0PgjAQhv8KuQkSGFSmDiZAUUmc1M06NPQQogWCZTCE_-4RPmLCTZfneXN3bQdppRAYPBtZ59aNi9KiCu6XqjJWFDw8bx_aSWmw0agKaZCgtXGmGNloZbd_lq_sbrKcbDzZRfqTDEke7DPKbNk1oOOI5gURodOI5qkxoWREvgMuaJouC0UP7IaAAJOjRgGMWiWblwBR9pSTramu3zIFZpoWXWhrRSfxQtK_aGCZfH-w_wFth1dP?type=png)](https://mermaid.live/edit#pako:eNplkD0PgjAQhv8KuQkSGFSmDiZAUUmc1M06NPQQogWCZTCE_-4RPmLCTZfneXN3bQdppRAYPBtZ59aNi9KiCu6XqjJWFDw8bx_aSWmw0agKaZCgtXGmGNloZbd_lq_sbrKcbDzZRfqTDEke7DPKbNk1oOOI5gURodOI5qkxoWREvgMuaJouC0UP7IaAAJOjRgGMWiWblwBR9pSTramu3zIFZpoWXWhrRSfxQtK_aGCZfH-w_wFth1dP)\\n\\n*Above is an example charter of a Public Key Infrastructure (PKI). All PKIs have one root CA that can create zero or more intermediate CAs. Each CA can in turn also sign leaf certificates - certificates that cannot sign other **certificates**. The interesting part is that each certificate in a PKI has a number of flags that determine what it is allowed to do beyond creating other CAs. One of those flags is the ability to digitally sign documents. One of the types of documents that can be signed are JWTs. Whether one is using x509 certificates or JWTs, there is a PKI at work behind the scenes. Services like Auth0, Okta, and Google all have PKIs they are managing for you powering certificate issuing and signing JWTS.*\\n\\n# Identities & External Authentication & Authorization\\n\\nOpenZiti [Identities](https://openziti.github.io/ziti/identities/overview.html?tabs=tabid-new-ca-ui%2Ctabid-new-identity-ui) are a core part of authentication and authorization. Authentication in OpenZiti uses an additional field on identities called `externalId`. The `externalId` or the internal `id` field can be used with 3rd Party CAs and External JWT signers to match certificates and JWTs to an identity. \\n\\n3rd Party CAs support [x509 Claims](https://openziti.github.io/ziti/security/authentication/third-party-cas.html#external-id--x509-claims) and External JWT Signers support a [`claimsProperty`](https://openziti.github.io/ziti/security/authentication/external-jwt-signers.html) to determine which value from the JWT or certificate should be matched against the existing set of `externalId` or `id` values.\\n\\nFor authorization OpenZiti supports a rich and flexible Attribute Based Access Control system (ABAC). It powers all of OpenZiti\'s [policies](https://openziti.github.io/ziti/security/authorization/policies/overview.html?tabs=tabid-new-service-policy-ui%2Ctabid-new-edge-router-policy-ui%2Ctabid-new-service-edge-router-policy-ui). Identities support attributes so that they can be tied to policies which determine authorization.\\n\\n### Example JWT Authentication Flow \\n\\n[![](https://mermaid.ink/img/pako:eNqFk11PgzAUhv8K6RWL03hNFi78iJlZohnRm7GL2p5tldJiW8Rl2X-3pQNhw60XBDjPOed929MdIpICipCGrxIEgQeG1wrnqQjswqWRosw_QPnvNw3qOo7vOQNhoiDZyGpKX3U48mH_3wFSGCU5BxUFT2B6TBvqFJoslowWOj4q49o1XQodOmQ0LAQ4ENemZha3y2NBd0pWdbGXAkQD3ZSKXxHM-Qcm2SHjANoUW-0ybqFu9cnG5Dw-ruRtzEFQUKEj-iba7JlcMxESBVQPqzkFfP86-A6KrbYD0T91n5UZB42DE5n9PeqxJ3Lag7NYfObwvWILDZ1-LXsORjH4hucqa2fE6-7WsX2ydjx6E9SB_A48_hjbL2FrYXe7duFyRxdyZ1JmZTGl1gIz2_8Ut7Z1SQjoMwObeKBxVD_9a7PQGOWgcsyovX07F0uR2UAOKYrsK8UqS1Eq9pZz1zDZCoIio0oYo7Kg2DQ3FUUrzDXsfwG1Bj9J?type=png)](https://mermaid.live/edit#pako:eNqFk11PgzAUhv8K6RWL03hNFi78iJlZohnRm7GL2p5tldJiW8Rl2X-3pQNhw60XBDjPOed929MdIpICipCGrxIEgQeG1wrnqQjswqWRosw_QPnvNw3qOo7vOQNhoiDZyGpKX3U48mH_3wFSGCU5BxUFT2B6TBvqFJoslowWOj4q49o1XQodOmQ0LAQ4ENemZha3y2NBd0pWdbGXAkQD3ZSKXxHM-Qcm2SHjANoUW-0ybqFu9cnG5Dw-ruRtzEFQUKEj-iba7JlcMxESBVQPqzkFfP86-A6KrbYD0T91n5UZB42DE5n9PeqxJ3Lag7NYfObwvWILDZ1-LXsORjH4hucqa2fE6-7WsX2ydjx6E9SB_A48_hjbL2FrYXe7duFyRxdyZ1JmZTGl1gIz2_8Ut7Z1SQjoMwObeKBxVD_9a7PQGOWgcsyovX07F0uR2UAOKYrsK8UqS1Eq9pZz1zDZCoIio0oYo7Kg2DQ3FUUrzDXsfwG1Bj9J)\\n\\n*Above, an external Identity Provider (IdP) is signing JWTs with the `sub` (subject) field set to the email address of the human authenticating. This email address is also the `externalId` of OpenZiti identities.*\\n\\n# Extending Authentication To Services\\n\\nUsing 3rd Party CAs and External JWT Signers, it is also possible to developed applications with Ziti\'s SDKs that can make double use of the certificates and JWTs that are used for authentication.  The double uage is:\\n\\n\\n1. Use the certificate/JWT to authenticate with an OpenZiti overlay network\\n2. Use the certificate/JWT to authenticate over OpenZiti to a target service\\n\\nTo accomplish this, the client accessing the service over OpenZiti must:\\n\\n- be configured to accept, verify, and trust the same signers (CA or JWT) that OpenZiti does\\n- the client must embed a Ziti SDK and use the same certificate or JWT to authenticate to a service on connection\\n\\nUsing this pattern, it is possible to tie OpenZiti network authentication and service authentication together in one neat flow."},{"id":"high-level-publicprivate-cryptography","metadata":{"permalink":"/docs/openziti/blog/high-level-publicprivate-cryptography","source":"@site/blog/high-level-publicprivate-cryptography.md","title":"High-Level Public/Private Cryptography","description":"I find myself writing this high-level overview of public/private key cryptography often. Sometimes I even call it \\"an overview of asymmetric encryption.\\" It depends on my mood. Rather than hunt for a simple overview and fail to find one I like, I created this. An article that I can control and point to in the future. Welcome. This is my high-level overview of public-private key cryptography.","date":"2022-10-19T00:00:00.000Z","tags":[{"inline":false,"label":"Cryptography","permalink":"/docs/openziti/blog/tags/cryptography","description":"Cryptography topics and encryption methods"},{"inline":false,"label":"Public Key Infrastructure","permalink":"/docs/openziti/blog/tags/pki","description":"Public key infrastructure and usage"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":2.53,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"slug":"high-level-publicprivate-cryptography","title":"High-Level Public/Private Cryptography","authors":["AndrewMartinez"],"date":"2022-10-19T00:00:00.000Z","tags":["cryptography","pki","security"]},"unlisted":false,"prevItem":{"title":"OpenZiti Authentication API Integrations","permalink":"/docs/openziti/blog/openziti-authentication-api-integrations"},"nextItem":{"title":"Set Up a Secure Multiplayer Minecraft Server","permalink":"/docs/openziti/blog/set-up-a-secure-multiplayer-minecraft-server"}},"content":"I find myself writing this high-level overview of public/private key cryptography often. Sometimes I even call it \\"an overview of asymmetric encryption.\\" It depends on my mood. Rather than hunt for a simple overview and fail to find one I like, I created this. An article that I can control and point to in the future. Welcome. This is my high-level overview of public-private key cryptography.\\n\\n\x3c!-- truncate --\x3e\\n\\n# Public Private Key Cryptography\\n\\nPublic Private Key cryptography is based on math. It allows two huge numbers to work in tandem. To make them work in tandem, we must know some information about what type of cryptography is in use (RSA, EC) and then additional parameters that are specific to that type. One of those numbers represents the public key, and the other is the private key. Both keys can encrypt data that only the other key can decrypt.\\n\\nThe public key is meant to be shared, it is not secret. The private key is highly secret and is not meant to be shared. Private keys are sometimes stored in hardware to make them safer from operating system and software attacks. \\n\\nSharing the public key means that anyone can send encrypted data to the private key holder and only they will be able to decrypt it. This functionality is the basis of TLS that powers HTTPS. It is used for a client to send an encrypted second key that only the target server will have and is then used to send responses to the client that no one else can read.\\n\\nThe private key can be used to encrypt data that any holder of the public key can decrypt. This seems useless from a data privacy standpoint, but it does something else that is vitally important. Any data decrypted by the public key must have been encrypted with the private key. This means we know who sent the data with a high degree of certainty. This is the basis of \\"signing data.\\" In scenarios where signing large amounts of data is necessary, rather than encrypting the entire data payload, we take a hash of the data and encrypt that, and include it with the original data.\\n\\nHashing data makes a statistically unique fingerprint. Changing even one bit in the data means will generate a different hash. Hashing allows us to deterministically generate fingerprints that are smaller than the original data. The algorithm to sign data is to hash the data into a fingerprint and then encrypt the fingerprint with a private key to generate a signature. To verify a signature, the verifier hashes the data into a fingerprint. That fingerprint is compared to the value of the decrypted signature. If the values match, the data was sent by the private key holder, and the data wasn\'t changed.\\n\\nTwo examples of where signatures are used is in JWTs and x509 certificates. They are signed documents - they include data and a signature. Verifying the signature ensures the authenticity and author of the data. And that\'s it!"},{"id":"set-up-a-secure-multiplayer-minecraft-server","metadata":{"permalink":"/docs/openziti/blog/set-up-a-secure-multiplayer-minecraft-server","source":"@site/blog/set-up-a-secure-multiplayer-minecraft-server.md","title":"Set Up a Secure Multiplayer Minecraft Server","description":"Many kids love Minecraft for many different reasons. There comes a point in most users\'","date":"2022-10-14T17:03:01.000Z","tags":[{"inline":false,"label":"Minecraft","permalink":"/docs/openziti/blog/tags/minecraft","description":"Minecraft content"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"Gaming","permalink":"/docs/openziti/blog/tags/gaming","description":"Gaming topics"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":9.72,"hasTruncateMarker":true,"authors":[{"name":"Geoff Berl","title":"Author","url":"https://github.com/gberl002","imageURL":"https://avatars.githubusercontent.com/gberl002","key":"GeoffBerl","page":null}],"frontMatter":{"title":"Set Up a Secure Multiplayer Minecraft Server","date":"2022-10-14T17:03:01.000Z","cuid":"cl98qngwj000m09le2qf7ay1l","slug":"set-up-a-secure-multiplayer-minecraft-server","authors":["GeoffBerl"],"image":"@site/blogs/openziti/v1665606377950/M5Imv9fw6.png","imageDark":"@site/blogs/openziti/v1665606377950/M5Imv9fw6.png","tags":["minecraft","networking","gaming","openziti","zerotrust"]},"unlisted":false,"prevItem":{"title":"High-Level Public/Private Cryptography","permalink":"/docs/openziti/blog/high-level-publicprivate-cryptography"},"nextItem":{"title":"Setting Up Oracle Cloud To Host OpenZiti","permalink":"/docs/openziti/blog/setting-up-oracle-cloud-to-host-openziti"}},"content":"Many kids love [Minecraft](https://www.minecraft.net) for many different reasons. There comes a point in most users\' \\nlives where they decide they want to host their own Minecraft server allowing them and their friends to play on their \\nown private server. It\'s kind of a big deal for some, it\'s like owning your own little world where you and your friends \\ncan collaboratively search for hidden caves or build giant pyramids with mazes of halls and tunnels.\\n\\n\x3c!-- truncate --\x3e\\n\\nIf these aspiring server hosters get ambitious enough, they\'ll figure out a way to make it work. Take my son for example; walking by him one day he says \\"Hey dad, I\'ve hosted my own Minecraft server\\" to which I replied \\"Cool, are you playing a LAN party with your brother or something?\\" (a LAN party is a term for when you play with a group of friends on a local network, like your home wifi). He then replied, \\"Yeah, I\'m playing with Brett and Xavier.\\" After a short pause to process this information I say \\"Why isn\'t Brett down here playing with you?\\" (Brett is his friend after all). My son replies \\"Brett\'s at home, I sent him a program that lets him connect to my server.\\"\\n\\n![You did what now 2.jpg](/blogs/openziti/v1665497114782/No7U8v5FY.jpg?height=300)\\n\\n> \\"You did what now?\\"\\n\\nMy son had sent his friend an invite via a VPN program, this allowed his friend to connect to our local network so he could connect as if he were sitting right here in our home. This is a security risk, even being one of my son\'s friends, it means someone could gain access to my network if they manage to obtain the friend\'s credentials or his computer.\\n\\nI told him we would need to quickly remedy that situation as I was not comfortable with it. So, we decided to work together and build a zero trust overlay network so he can more securely play with friends. One key difference with the zero trust approach is, it will allow outside users to access my network but I can restrict what they can access. In this case, I\'m going to only allow access to the Minecraft server so, users won\'t be able to access anything else on the machine and definitely won\'t have access to any other devices on my network. And hey, with zero trust I\'m even comfortable letting him invite online friends (the ones he\'s never met in person).\\n\\n## The Current Network\\n\\nThe way the network is right now, there is no way for people outside of the home network to reach the Minecraft server because it\'s not exposed to the internet. There are a number of ways to give someone access, such as opening the port on your firewall allowing anyone in, using VPN allowing anyone with permission in, a zero trust network allowing anyone with permission in. Though, in the case of zero trust, only those with permission can access Minecraft, they can\'t access any other device or service provided inside my home network. Here\'s a simple image to illustrate the network as is, Mr. Enderman wants to connect to my local Minecraft instance but my firewall is blocking the connection.\\n\\n![OpenZiti HomeAssistant Network Architecture - Minecraft Without Ziti.png](/blogs/openziti/v1665671198902/2-dQ11FBa.png)\\n\\n## Getting Started\\n\\nFor starters, you\'re going to need to set up a virtual private server (VPS) to host the [zero trust overlay network](https://openziti.io/docs/learn/introduction/#overview-of-a-ziti-network). I set mine up through Oracle since it\'s totally free, you can set up the same by checking out [this how-to article](./setting-up-oracle-cloud-to-host-openziti). If you\'re curious why you need a VPS, you don\'t technically need one. The OpenZiti network could be hosted on your own computer however, there needs to be a way for users to reach that network from the internet and the only way to do that (if your hosting the network) is to expose those precious firewall ports so it\'s the same scenario as exposing your Minecraft server to the internet. By instead using a VPS, anyone can access the network, with proper authorization of course, then all traffic is sent to your local computer over ports that are already open for you to be able to access the internet.\\n\\n## Some Setup to Simplify the Process\\n\\nThere is a bit of repetitive naming going on throughout the process of configuring the network so here is a list of values that you can change to whatever you want so you can simply copy and paste the network configuration commands and they will adjust based on your values here.\\n\\n```bash\\nexport DEVICE_NAME=\\"my.minecraft.server\\"\\nexport MY_NAME=\\"my.name.here\\"\\nexport PORT=25565\\n```\\n\\nFor example, in the screen captures going forward, you\'ll see what would result from using the following values which I used\\n\\n![image.png](/blogs/openziti/v1665514471708/gwyRJcMtL.png)\\n\\n## Configuring the Network\\n\\nThe hardest part is getting the network up and running, once you do that it\'s simply a matter of a few configurations and you\'ll be good to go.\\n\\n### Create Identities\\n\\nIdentities are what identify users and devices that you want to connect to something over the network. At a minimum, you\'ll need an identity for the computer that will be running your Minecraft server. In addition, you\'ll need an identity for any person who you want to connect to your server. *Technically* you normally only need identities for people outside your local network but for the sake of simplicity and security we\'ll give an identity to everyone regardless of their location.\\n\\nTo see the list of identities use `ziti edge list identities`, here is an example of my *before* output.\\n\\n![image.png](/blogs/openziti/v1665512404482/9t6t1iAd3.png)\\n\\n#### Create an Identity for the Host\\n\\nCreate an identity for the device that will host the server.\\n\\n```bash\\nziti edge create identity device ${DEVICE_NAME} -o ${DEVICE_NAME}.jwt -a \\"${DEVICE_NAME}.hosts\\"\\n```\\n\\n#### Create an Identity for Yourself\\n\\nCreate an identity to represent you and later allow you to give yourself access to the server.\\n\\n```bash\\nziti edge create identity user ${MY_NAME} -o ${MY_NAME}.jwt -a \\"${DEVICE_NAME}.clients\\"\\n```\\n\\n#### Example Output\\n\\nYou should see two new identities, here\'s another screenshot showing my output afterward.\\n\\n![image.png](/blogs/openziti/v1665512560404/BeIng6PWX.png)\\n\\nYou should also see two new files in your current working directory with the extension `jwt`. These are Java Web Tokens and are used to authenticate identity enrollment. Keep these output files handy, we\'ll need them in order to enroll and get access to the server. They have a timeout for security purposes but the default timeout will give plenty of time for enrollment before expiring.\\n\\n![image.png](/blogs/openziti/v1665512646430/5iBesKmhV.png)\\n\\n### Create a Service and Configurations\\n\\nWithout getting into too much confusing jargon, a service is essentially how you connect your overlay network (the zero trust OpenZiti network) to the underlay (your home network).\\n\\nI won\'t bother showing output for the following commands as it\'s just an empty list. To see service configurations and services use `ziti edge list configs` and `ziti edge list services` respectively.\\n\\n#### Service Configurations\\n\\n```bash\\nziti edge create config ${DEVICE_NAME}.hostv1 host.v1 \'{\\"protocol\\":\\"tcp\\", \\"address\\":\\"localhost\\",\\"port\\":\'${PORT}\'}\'\\nziti edge create config ${DEVICE_NAME}.interceptv1 intercept.v1 \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"\'${DEVICE_NAME}\'.ziti\\"], \\"portRanges\\":[{\\"low\\":\'${PORT}\', \\"high\\":\'${PORT}\'}]}\'\\n```\\n\\n#### Service\\n\\n```bash\\nziti edge create service ${DEVICE_NAME} --configs \\"${DEVICE_NAME}.hostv1,${DEVICE_NAME}.interceptv1\\"\\n```\\n\\n#### Example Output\\n\\n![image.png](/blogs/openziti/v1665515474563/Nn9tnA79o.png)\\n\\n### Create the Service Policies\\n\\nThe service policies define who will have access to a given service. Here we\'ll give access to the server so it may host the service. We will also give access to a \\"group\\" to be able to connect to the server. By creating a policy granting access based on an \'attribute\', we can simply give this attribute to any identities we want to give access to. Otherwise, you\'d need to create a service policy for every user.\\n\\n```bash\\nziti edge create service-policy \\"${DEVICE_NAME}.bind\\" Bind --service-roles \\"@${DEVICE_NAME}\\" --identity-roles \\"#${DEVICE_NAME}.hosts\\"\\nziti edge create service-policy \\"${DEVICE_NAME}.dial\\" Dial --service-roles \\"@${DEVICE_NAME}\\" --identity-roles \\"#${DEVICE_NAME}.clients\\"\\n```\\n\\n#### Example Output\\n\\n![image.png](/blogs/openziti/v1665667125801/EL3NcxMCw.png)\\n\\n### Enroll the Identities\\n\\nNow we need the `jwt` files created earlier. First, you\'ll want to download the Ziti Desktop Edge for the appropriate operating system you have.\\n\\n#### Windows\\n\\nCurrently, only Windows 9 and later are supported. If you are running an older version of Windows and want support for it, let us know in the comments. [Ziti Desktop Edge for Windows (ZDEW)](https://github.com/openziti/desktop-edge-win/releases)\\n\\n#### Mac\\n\\n[Ziti Desktop Edge for Mac](https://apps.apple.com/app/id1460484572)\\n\\n#### Linux\\n\\nThere is a Ziti Desktop Edge in the works for Linux, in order to set up a host using Linux you would need to use the Ziti Tunneler SDK which can be found [here](https://openziti.io/docs/reference/tunnelers/linux/). The setup is a little different so that will be saved for another article. In the meantime you can certainly try it yourself, there are lots of helpful people on the [OpenZiti Discourse Forum](https://openziti.discourse.group/) so if you run into problems, you can get some help there.\\n\\n#### Enroll the Host Device\\n\\nYou\'ll want the enrollment token named with the value you entered for `DEVICE_NAME` to be used on your device hosting the server.\\n\\nOpen your Ziti Desktop Edge app and click the plus button to \\"Add an Identity\\". Navigate to your enrollment token and select it. Once it\'s been added you will see an \\"Enroll\\" button, click that and that\'s it!\\n\\n#### Enroll Yourself\\n\\nThe other `jwt` should be named with the value of `MY_NAME` and this will be used on the device you will be using to connect to your server. It\'s quite possible that this is the same computer as the one hosting the server. The process is the same in either case.\\n\\nAgain, open the Ziti Desktop Edge app, click the \\"Add an Identity\\" button, click \\"Enroll\\" and you\'re ready to test your zero trust network.\\n\\n## The New Network\\n\\nNow that we\'ve configured all of this, I\'ll revisit that image of the network from before. Only now, we can see that through the use of ziti desktop edge, and our hosted zero trust overlay network Mr. Enderman would have access to play on my server (assuming I gave him a token with the right attribute).\\n\\n![OpenZiti HomeAssistant Network Architecture - Minecraft With Ziti.png](/blogs/openziti/v1665672104968/TarU6rpXk.png)\\n\\n## Testing Your Zero Trust Minecraft Server\\n\\nAfter that hopefully short and simple configuration process, we should be able to connect over the overlay network.\\n\\nEnsure your Minecraft server is running on the host machine. Connect to the host machine using the new ziti service address. Obviously, we need to also be sure that our Ziti Desktop Edge application is running on each machine.\\n\\nSelect multiplayer and enter your server address. The server address will be the value you put in `DEVICE_NAME` plus \\".ziti\\". For example, in my case, I had \\"`berlhome.mc.server`\\" as the `DEVICE_NAME` so my address is `berlhome.mc.server.ziti`.\\n\\n![image.png](/blogs/openziti/v1665583029690/33jAA-8pA.png)\\n\\nNow backing out to the multiplayer menu again, I can see that the server is online, exciting!\\n\\n![image.png](/blogs/openziti/v1665588063386/vWiGu64yz.png)\\n\\nHere\'s a little proof I was able to connect, I only played for about 20 minutes but it works great. Now, if I want to invite friends I just ask them to download the Ziti Desktop Edge, create an identity token for them, making sure they have the attribute `#${DEVICE_NAME}.clients` so they are authorized, and send it their way. At any time I can issue a new one or revoke permissions.\\n\\n![Screenshot 2022-10-12 091403.png](/blogs/openziti/v1665597926195/tTNxDByaf.png)\\n\\n![Screenshot 2022-10-12 135859.png](/blogs/openziti/v1665597910252/XBKP0vrrA.png)"},{"id":"setting-up-oracle-cloud-to-host-openziti","metadata":{"permalink":"/docs/openziti/blog/setting-up-oracle-cloud-to-host-openziti","source":"@site/blog/setting-up-oracle-cloud-to-host-openziti.md","title":"Setting Up Oracle Cloud To Host OpenZiti","description":"For a long time, I\'ve been concerned about relying on a company\'s focus on security. I generally expect the least","date":"2022-10-14T12:55:39.000Z","tags":[{"inline":false,"label":"Oracle","permalink":"/docs/openziti/blog/tags/oracle","description":"Oracle content"},{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Oracle Cloud","permalink":"/docs/openziti/blog/tags/oracle-cloud","description":"Oracle Cloud content"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":10.6,"hasTruncateMarker":true,"authors":[{"name":"Geoff Berl","title":"Author","url":"https://github.com/gberl002","imageURL":"https://avatars.githubusercontent.com/gberl002","key":"GeoffBerl","page":null}],"frontMatter":{"title":"Setting Up Oracle Cloud To Host OpenZiti","date":"2022-10-14T12:55:39.000Z","cuid":"cl98htd35000a09ld3o9b110i","slug":"setting-up-oracle-cloud-to-host-openziti","authors":["GeoffBerl"],"image":"@site/blogs/openziti/v1665675327581/brOl0o0pl.png","imageDark":"@site/blogs/openziti/v1665675327581/brOl0o0pl.png","tags":["oracle","opensource","oracle-cloud","openziti","zerotrust"]},"unlisted":false,"prevItem":{"title":"Set Up a Secure Multiplayer Minecraft Server","permalink":"/docs/openziti/blog/set-up-a-secure-multiplayer-minecraft-server"},"nextItem":{"title":"Integrating Ziti is Easy! How we got our app tested with go-httpbin","permalink":"/docs/openziti/blog/integrating-ziti-is-easy"}},"content":"For a long time, I\'ve been concerned about relying on a company\'s focus on security. I generally expect the least \\nfocus on security as many companies just want to be first to market. Yikes, that sounds bad, but many companies \\nindeed focus too little on security. I do not expose my internal network to the world by opening ports on my firewall. \\nWhile I\'d like access to a few things like my security camera system, network storage device, home assistant, etc., \\nI am very concerned that some bad actor will somehow find my hosted service and find a way in because of some CVE \\nthat hasn\'t been patched. Now that I\'ve drawn a severely dark picture let\'s bring some light in, haha.\\n\\n\x3c!-- truncate --\x3e\\n\\nI started working for a company called [NetFoundry](https://netfoundry.io/), which develops an open source project, [OpenZiti](https://openziti.github.io/). The product is a [zero trust network overlay](https://openziti.github.io/ziti/overview.html#overview-of-a-ziti-network) that allows you private and secure access to your hosted services without having to add firewall rules to allow traffic on specific ports/addresses. Hosting my own network requires a virtual private server; as you may know, many different options are available. I ultimately settled on [Oracle\'s Cloud Infrastructure](https://www.oracle.com/cloud/) because they have a free tier like many other cloud providers. [Oracle\'s free tier](https://www.oracle.com/cloud/free/) is different. However, their free tier won\'t allow you to accidentally use paid services if you don\'t upgrade your account to a paid account. You can host up to two instances totally free, and there\'s no expiration where you\'ll have to pay for services going forward. Read on to see how I set up my OpenZiti zero trust network on Oracle\'s Cloud Infrastructure.\\n\\n## Creating an Instance\\n\\nThe [signup page](https://oracle.com/cloud) is inundated with mentions of their free account offerings, so signing up should be easy.\\n\\nOn the left sidebar, you should see an \\"instances\\" option; go ahead a select that. This will bring you to a dashboard showing you any current instances, and you should see a \\"Create instance\\" button.\\n\\n### Name and Compartment\\n\\n![image.png](/blogs/openziti/v1663268339377/4i6-HpNYt.png)\\n\\n#### Name\\n\\nThat name is hideous, so feel free to change that; I called mine BerlHomeOverlay. My dad came up with the BerlHome moniker for his home WiFi, and it\'s stuck with me, so I prepend Berl to many of my devices and services.\\n\\n#### Compartment\\n\\nWithout going into too much detail, compartments allow you to organize your resources, but since we\'re covering the free version, which only hosts two instances at max, I will skip over this and leave the default.\\n\\n### Image and Shape\\n\\n![image.png](/blogs/openziti/v1663270206709/boT3NyGlH.png)\\n\\nI\'ve skipped over\\"placement\\" for brevity and accepted the defaults; it allows you to specifically choose an availability domain.\\n\\n#### Image\\n\\nThe default is Oracle Linux 8, but I\'d rather not deal with the differences that might occur in their instance over a standard Canonical Ubuntu release, so I\'ve changed mine to **Canonical Ubuntu** 22.04 though there are other OS options and versions that fall into the \\"always free-eligible\\" tier, so it\'s worth checking out.\\n\\n#### Shape\\n\\nThe shape defines the characteristics of your virtual machine, such as how much memory and CPU power. Options are pretty limited here if you\'re using the always free options, so your likely option is just to leave this one the default.\\n\\n* Oh, and ignore that warning \\"Service limit will be reached...\\" it\'s just saying that because I already have an instance. I\'m only allowed two instances, so creating this instance will meet my service limit.\\n    \\n\\n### Networking\\n\\n![image.png](/blogs/openziti/v1663269806073/Ol_I1Zx4Z.png)\\n\\nAs with many cloud service providers, the networking bit is pretty much automatic. The nice thing about Oracle\'s (that I\'ve noticed) is that it uses your existing virtual network and subnet if you\'ve already created these services from another project. You can also define whether or not you want a publicly accessible IP address which we do, so leave that the default.\\n\\n### SSH Keys\\n\\n![image.png](/blogs/openziti/v1663269918604/t7gHDIEQD.png)\\n\\nI want an SSH key, so I can SSH into my machine. If you already have an SSH key set up for something else, you can use an existing SSH key by pasting or uploading the public key.\\n\\n### Boot volume\\n\\nI\'m skipping this section as I don\'t want to specify any particular criteria for the boot volume, I\'ll just accept the defaults.\\n\\n## Edit the Security List\\n\\nAfter giving the instance a few minutes to boot up, we should edit the Security List. By default, as of this writing, Oracle automatically creates four rules. One of those rules is for SSH access. The Security List allows all IPs access to the SSH port 22. This is a security risk, and I recommend editing this rule to include only your IP.\\n\\nTo find your public IP, you can Google search \\"what\'s my IP\\" or use `curl eth0.me` if you\'re on a \\\\*nix machine.\\n\\nHere are the steps to edit that setting:\\n\\n1. On the instance page, under instance details, click the virtual cloud network link (should start with \\"vcn\\")\\n    \\n2. On the VCN page, in the left sidebar, select Security Lists\\n    \\n3. You should only see one security list in the table; click that\\n    \\n4. Click the three-dot menu button on the right for the rule that has a \\"Destination Port Range\\" of 22 and select Edit\\n    \\n5. Paste your public IP address into the Source CIDR field and add `/32`. It should look like this `12.34.5.67/32`\\n    \\n6. Save and you\'re all done. Hit the back button or use the breadcrumb menu to go back to your VCN\\n    \\n\\n### Adding Security List Rules\\n\\nNow we need to configure network traffic to and from the instance by adding some rules to the Security List. Click the \\"Add Ingress Rules\\" button and read on.\\n\\n#### Ingress Rules\\n\\nHere is the first ingress rule we need.\\n\\n* Source Type: **CIDR**\\n    \\n* Source CIDR: **0.0.0.0/0** (all traffic)\\n    \\n* IP Protocol: **TCP**\\n    \\n* Source Port Range: **Leave Blank!**\\n    \\n* Destination Port Range: **8441**\\n    \\n* Description: **Controller Edge Traffic**\\n    \\n\\n![image.png](/blogs/openziti/v1663595681462/NM_Pt7e4N.png)\\n\\nThis process needs to be repeated for the remaining ports required for my overlay network; here are the remaining ports:\\n\\n* 8442 - The Edge Router port\\n    \\n* 8443 - *(optional)* Ziti Admin Console (for GUI interface)\\n    \\n* **EDIT**: As of November 2022, use port **8440** <s>6262</s> - For Router to Controller communication\\n    \\n* 10080 - For Router to Router communication\\n    \\n\\nThe following fields are the same for all ports.\\n\\n* Source Type: **CIDR**\\n    \\n* Source CIDR: **0.0.0.0/0** (all traffic)\\n    \\n* IP Protocol: **TCP**\\n    \\n* Source Port Range: **Leave Blank!**\\n    \\n\\n#### Egress Rules\\n\\nI want to allow all outbound traffic. The security list already contains a rule with the following information, so that\'s all set.\\n\\n* Destination Type: **CIDR**\\n    \\n* Destination CIDR: **0.0.0.0/0** (all traffic)\\n    \\n* IP Protocol: **All Protocols**\\n    \\n* Source Port Range: **Leave Blank!**\\n    \\n* Destination Port Range: **Leave Blank**\\n    \\n\\n#### Here are all of the inbound rules\\n\\n![image.png](/blogs/openziti/v1663597412650/P-3TGPZKW.png)\\n\\n## Installing the Ziti Network Overlay\\n\\nAt this point, we\'re ready to set up the beginnings of our network. With the Express Install feature, we\'ll quickly and easily create a controller and edge-router, a PKI, and a slew of useful commands.\\n\\n### SSH Into the Instance\\n\\nSimply use the following command to SSH into the instance from your home computer. Replace the key file path and name with the one you downloaded or if you uploaded one, the one you uploaded. Also, change the IP address to the public IP address of your instance.\\n\\n```bash\\nssh -i ~/.ssh/id_geoff_berl.key ubuntu@129.159.84.227\\n```\\n\\n### Open Ports On The Local Firewall\\n\\nAnother quirk about Oracle instances is that they have a local firewall that needs ingress and egress rules applied, just as we already did in the Oracle web interface. To set the rules on the local firewall:\\n\\n```bash\\nsudo apt install firewalld -y \\n\\nsudo firewall-cmd --zone=public --add-port=8440/tcp --permanent\\nsudo firewall-cmd --zone=public --add-port=8441/tcp --permanent\\nsudo firewall-cmd --zone=public --add-port=8442/tcp --permanent\\nsudo firewall-cmd --zone=public --add-port=8443/tcp --permanent\\nsudo firewall-cmd --zone=public --add-port=10080/tcp --permanent\\n\\nsudo systemctl restart firewalld\\n```\\n\\n### Run Express Install\\n\\nNow, you\'ll run the express install. Rather than including those commands here, you can follow the guide [here](https://netfoundry.io/docs/openziti/learn/quickstarts/network/hosted) and come back. But WAIT, one thing to note is that Oracle does not provide an external DNS, so when the guide asks you to set that value, use the public IP instead. For the record, I would recommend following the instructions to set up the systemd service so the controller and routers will start up with the instance if it\'s ever shut down.\\n\\n### Change The Admin Password\\n\\n*UPDATE: The quickstart now allows you to set your password during the express install; if you don\'t set it, a random password will be generated. At any time, you can find the password in the* `.env` *file created during express install, or if your session environment hasn\'t been cleared, you can use* `echo \\"${ZITI_PWD}` *to display your password in the terminal. If you do wish to change your password, the following section of this article will explain the details involved. Otherwise, if you set your password or want to use the generated password, you scan skip this section.*\\n\\nIt is extremely important to change your password from the default as, being a default, it poses a security risk since anyone can log into it providing the default values.\\n\\nThe zitiLogin command is a simplified way to log into the controller. It uses the values from the .env file created during the installation. If at any time you receive an error code UNAUTHORIZED, your session likely timed out, simply run zitiLogin again\\n\\n```bash\\nzitiLogin\\nziti edge update authenticator updb --identity \\"Default Admin\\" --password \\"your_new_password\\"\\n```\\n\\nSince we updated the password, we\'ll want to update that value in the `.env` file that contains pertinent information about your network and is used for logging in with a single command.\\n\\nUse your favorite bash editor (here, I\'m using vi)\\n\\n```bash\\nvi \\"/home/ubuntu/.ziti/quickstart/$(hostname -s)/$(hostname -s).env\\"\\n```\\n\\nScroll down until you find `ZITI_PWD`. You\'ll see it says the value is admin, change that value to whatever your new password is and then re-source the env file to update your environment with the new password.\\n\\n```bash\\nsource \\"/home/ubuntu/.ziti/quickstart/$(hostname -s)/$(hostname -s).env\\"\\n```\\n\\n### BONUS - Remote Access To Ziti Controller\\n\\nSuppose you don\'t want to SSH into the instance whenever you want to access your controller. In that case, you can pull some files down locally, source them and log in from your local computer.\\n\\n1. Find your instance\'s hostname `echo $(hostname -s)` (in my case, it\'s berlhomeoverlay)\\n    \\n2. Copy this value and return to your local machine\\n    \\n3. I like to create a local folder for the instance-related files, but it\'s optional, so on my home computer, I run `mkdir berlhomeoverlay` and `cd berlhomeoverlay` into it\\n    \\n4. Create an env variable with the previously copied Oracle instance hostname to make things easier export INSTANCE\\\\_HOSTNAME=\\"berlhomeoverlay\\"\\n    \\n5. Copy the `.env` file from your Oracle instance to your local computer, and be sure to change the identity key and public IP again.\\n    \\n\\n```bash\\n# Copy env file so we can connect to the AWS hosted network from local machine\\nscp -i ~/.ssh/id_geoff_berl.key ubuntu@129.159.84.227:\\"~/.ziti/quickstart/${INSTANCE_HOSTNAME}/${INSTANCE_HOSTNAME}.env\\" .\\n```\\n\\n1. Remove some of the environment values intended for use on the instance itself and source the file to load the values locally. sed -i \'\' -e \'/ubuntu/d\' \\"./$\\\\{INSTANCE\\\\_HOSTNAME\\\\}.env\\"\\n    \\n2. Create a `login.sh` file with the contents below\\n    \\n\\n```bash\\n#!/bin/bash ziti edge login https://$ZITI_EDGE_CTRL_ADVERTISED_HOST_PORT -u $ZITI_USER -p $ZITI_PWD\\n```\\n\\n1. Make that login file executable `chmod +x login.sh`\\n    \\n2. Source the Ziti CLI functions file and download the binaries for use on your local machine.\\n    \\n\\n```bash\\nsource /dev/stdin <<< \\"$(wget -qO- https://raw.githubusercontent.com/openziti/ziti/release-next/quickstart/docker/image/ziti-cli-functions.sh)\\"; getZiti\\n```\\n\\n1. Now, any time you want to log into the controller on the oracle instance, run\\n    \\n\\n```bash\\n# Source the remote instance environment values\\nsource \\"./${INSTANCE_HOSTNAME}.env\\"\\n# Log in\\n./login.sh\\n```\\n\\n## Now What?\\n\\nCheck out my other articles in this series (see series links below) where I add to this network and start adding many of the devices and services I host at home so that I can access them from anywhere. If you\'re having trouble finding the series articles, start with one of these articles; [I Created a Zero Trust Overlay Network to Access HomeAssistant](./zero-trust-overlay-network-to-access-homeassistant), [Free Secure Access to NAS From Anywhere](./free-secure-access-to-nas-from-anywhere)."},{"id":"integrating-ziti-is-easy","metadata":{"permalink":"/docs/openziti/blog/integrating-ziti-is-easy","source":"@site/blog/integrating-ziti-is-easy.md","title":"Integrating Ziti is Easy! How we got our app tested with go-httpbin","description":"What is something everyone wants but can be difficult or cumbersome to implement? Better security practices. Here we are going to explore Zero Trust via OpenZiti. Zero Trust is a concept where a network is never trusted and always reverified. Constantly revalidating all connections and participants to validate they should be there. OpenZiti seeks to alleviate the hassle of setting up a zero trust network and putting the power in developers to create more secure apps  If you haven\'t heard of OpenZiti then you can check out the project here as well as an overview. Today we are going to be extending a very helpful http testing tool to talk over Ziti.","date":"2022-10-11T00:00:00.000Z","tags":[{"inline":false,"label":"Integrations","permalink":"/docs/openziti/blog/tags/integrations","description":"Third-party integrations"},{"inline":false,"label":"Application Security","permalink":"/docs/openziti/blog/tags/application-security","description":"Application security"},{"inline":false,"label":"AppSec","permalink":"/docs/openziti/blog/tags/appsec","description":"Application security"},{"inline":false,"label":"Ziti","permalink":"/docs/openziti/blog/tags/ziti","description":"Ziti related posts"}],"readingTime":4.86,"hasTruncateMarker":true,"authors":[{"name":"Cameron Otts","title":"Author","url":"https://github.com/camotts","imageURL":"https://avatars.githubusercontent.com/camotts","key":"CameronOtts","page":null}],"frontMatter":{"slug":"integrating-ziti-is-easy","title":"Integrating Ziti is Easy! How we got our app tested with go-httpbin","authors":["CameronOtts"],"date":"2022-10-11T00:00:00.000Z","tags":["integrations","application-security","appsec","ziti"]},"unlisted":false,"prevItem":{"title":"Setting Up Oracle Cloud To Host OpenZiti","permalink":"/docs/openziti/blog/setting-up-oracle-cloud-to-host-openziti"},"nextItem":{"title":"Golang Aha! Moments: Generics","permalink":"/docs/openziti/blog/golang-aha-moments-generics"}},"content":"# Integrating with Ziti? An Introduction\\nWhat is something everyone wants but can be difficult or cumbersome to implement? Better security practices. Here we are going to explore [Zero Trust](https://en.wikipedia.org/wiki/Zero_trust_security_model) via OpenZiti. Zero Trust is a concept where a network is never trusted and always reverified. Constantly revalidating all connections and participants to validate they should be there. OpenZiti seeks to alleviate the hassle of setting up a zero trust network and putting the power in developers to create more secure apps  If you haven\'t heard of OpenZiti then you can check out the [project here](https://github.com/openziti) as well as [an overview](https://openziti.github.io/ziti/overview.html). Today we are going to be extending a very helpful http testing tool to talk over Ziti.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Why?\\nSometimes we get a little excited when learning about a new technology or concept. Like learning about zero trust and finding OpenZiti! So we make a plan to setup our apps to use ziti Soon enough the engineering team had everything sorted out with their main application talking through a Ziti network, however, this was a small realization: what about all the testing infrastructure that relied on the app just reaching out to a web server? Well, luckily there are plenty of ways to still test an app over a Ziti network.\\n\\n## What?\\nLet me introduce you to [go-httpbin](https://github.com/mccutchen/go-httpbin). There are a few reasons I went with this over the main httpbin. This fork is much more recent and actively being maintained. It also doesn\'t user any external packages, though that is about to change. Finally its in Go which happens to be my favorite language (a very subjective reason, I know). With OpenZiti\'s [go-sdk](https://github.com/openziti/sdk-golang) this should be a very simple task! Now let\'s get to some code.\\n\\n\\n![cup-of-coffee-1280537_1280.jpg](/blogs/openziti/v1664985400182/_O6OC_fG5.jpg)\\n\\n## How\\nWe are pretty much going to apply the go-sdk outlined in [this repository](https://github.com/openziti-test-kitchen/go-http). If you\'d like to follow along, then the finished code is in the [Ziti Test Kitchen](https://github.com/openziti-test-kitchen/go-httpbin)!\\nSo, first thing we need to do when integrating OpenZiti into an app is store and take in information required to running against the network. All of the work we need to do is done within the command main `cmd/httpbin/main.go`. This would be the identity file and service name. I want this service to still listen over normal http so we can use a single binary for both Ziti and non Ziti testing so we are also going to have an enable Ziti flag. We\'ll use them later on, but for convenience we will also take in these from ENV: ENABLE_ZITI, ZITI_IDENTITY, ZITI_SERVICE_NAME.\\n\\n```go\\nvar (\\n    ...\\n    useRealHostname bool\\n\\n    identityJson string\\n    serviceName  string\\n    enableZiti   bool\\n )\\n\\nfunc main() {\\n    ...\\n    flag.BoolVar(&useRealHostname, \\"use-real-hostname\\", false, \\"Expose value of os.Hostname() in the /hostname endpoint instead of dummy value\\")\\n\\n    flag.BoolVar(&enableZiti, \\"ziti\\", false, \\"Enable the usage of a ziti network\\")\\n    flag.StringVar(&identityJson, \\"ziti-identity\\", \\"\\", \\"Path to Ziti Identity json file\\")\\n    flag.StringVar(&serviceName, \\"ziti-name\\", \\"\\", \\"Name of the Ziti Service\\")\\n}\\n```\\n\\nNext we just have to do the normal stuff of checking flags and env. Erroring out when there are problems. All that fun stuff.\\n\\n```go\\nif zitiEnv := os.Getenv(\\"ENABLE_ZITI\\"); !enableZiti && (zitiEnv == \\"1\\" || zitiEnv == \\"true\\") {\\n\\tenableZiti = true\\n}\\n\\nif enableZiti {\\n  if identityJson == \\"\\" && os.Getenv(\\"ZITI_IDENTITY\\") != \\"\\" {\\n \\tidentityJson = os.Getenv(\\"ZITI_IDENTITY\\")\\n }\\n  if identityJson == \\"\\" {\\n \\tfmt.Fprintf(os.Stderr, \\"Error: When running a ziti enabled service must have ziti identity provided\\\\n\\\\n\\")\\n \\tflag.Usage()\\n \\tos.Exit(1)\\n }\\n\\n  if serviceName == \\"\\" && os.Getenv(\\"ZITI_SERVICE_NAME\\") != \\"\\" {\\n \\tserviceName = os.Getenv(\\"ZITI_SERVICE_NAME\\")\\n }\\n  if serviceName == \\"\\" {\\n \\tfmt.Fprintf(os.Stderr, \\"Error: When running a ziti enabled service must have ziti service name provided\\\\n\\\\n\\")\\n \\tflag.Usage()\\n \\tos.Exit(1)\\n  }\\n} \\n```\\n\\nNow we get to the fun part of Ziti integration. And its super easy to add! First we\'re going to manually create the net.Listener instead of it happening behind the scenes. OpenZiti\'s sdk allows us to easily create a listener that will listen over a Ziti network and then when we don\'t want that then the normal net listener will work great!\\n\\n```go\\nvar listener net.Listener\\n\\nif enableZiti {\\n\\tconfig, err := config.NewFromFile(identityJson)\\n\\tif err != nil {\\n\\t\\tfmt.Fprintf(os.Stderr, \\"Error: Unable to parse ziti identity: %v\\\\n\\\\n\\", err)\\n\\t\\tos.Exit(1)\\n\\t}\\n\\tzitiContext := ziti.NewContextWithConfig(config)\\n\\tif err := zitiContext.Authenticate(); err != nil {\\n\\t\\tfmt.Fprintf(os.Stderr, \\"Error: Unable to authenticate ziti: %v\\\\n\\\\n\\", err)\\n\\t\\tos.Exit(1)\\n\\t}\\n\\n\\tlistener, err = zitiContext.Listen(serviceName)\\n\\tif err != nil {\\n\\t\\tfmt.Fprintf(os.Stderr, \\"Error: Unable to listen on ziti network: %v\\\\n\\\\n\\", err)\\n\\t\\tos.Exit(1)\\n\\t}\\n} else {\\n\\tlistener, err = net.Listen(\\"tcp\\", listenAddr)\\n\\tif err != nil {\\n\\t\\tfmt.Fprintf(os.Stderr, \\"Error: Unable to listen on %s: %v\\\\n\\\\n\\", listenAddr, err)\\n\\t\\tos.Exit(1)\\n\\t}\\n}\\nserver := &http.Server{\\n\\tHandler: h.Handler(),\\n}\\n``` \\n\\nOnce we have the listener it\'s as easy as using the serve methods that don\'t create listeners. I additionally added some conditional logging, but that is entirely up to preference.\\n\\n```go\\nvar listenErr error\\ngetListening := func() string {\\n\\tif enableZiti {\\n\\t\\treturn fmt.Sprintf(\\"ziti serviceName=%s\\", serviceName)\\n\\t}\\n\\ts := \\"http\\"\\n\\tif serveTLS {\\n\\t\\ts += \\"s\\"\\n\\t}\\n\\treturn fmt.Sprintf(\\"%s://%s\\", s, listenAddr)\\n}\\nif serveTLS {\\n\\tserverLog(\\"go-httpbin listening on %s\\", getListening())\\n\\tlistenErr = server.ServeTLS(listener, httpsCertFile, httpsKeyFile)\\n} else {\\n\\tserverLog(\\"go-httpbin listening on %s\\", getListening())\\n\\tlistenErr = server.Serve(listener)\\n}\\nif listenErr != nil && listenErr != http.ErrServerClosed {\\n\\tserverLog(\\"%T\\", listenErr)\\n\\tlogger.Fatalf(\\"failed to listen: %s\\", listenErr)\\n}\\n```\\n\\nIs there any more to do? Nope! That\'s all we need to enable OpenZiti on the go-httpbin project. And do you know what the best part is? Nothing we did was specific to this project. Any go project that uses the standard library for serving http content can be done in the exact same way! \\n\\n## Thank you!\\nYou can check out the code used in this example in the [OpenZiti Test Kitchen](https://github.com/openziti-test-kitchen/go-httpbin). You can also find other projects that are ziti integrated here!"},{"id":"golang-aha-moments-generics","metadata":{"permalink":"/docs/openziti/blog/golang-aha-moments-generics","source":"@site/blog/golang-aha-moments-generics.md","title":"Golang Aha! Moments: Generics","description":"Introduction","date":"2022-10-06T17:46:21.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Developer","permalink":"/docs/openziti/blog/tags/developer","description":"Developer topics"},{"inline":false,"label":"Generics","permalink":"/docs/openziti/blog/tags/generics","description":"Programming generics"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"golang-aha","permalink":"/docs/openziti/blog/tags/golang-aha","description":"Golang Ahas!"}],"readingTime":13.79,"hasTruncateMarker":true,"authors":[{"name":"Paul Lorenz","title":"Author","url":"https://github.com/plorenz","imageURL":"https://avatars.githubusercontent.com/plorenz","key":"PaulLorenz","page":null}],"frontMatter":{"title":"Golang Aha! Moments: Generics","date":"2022-10-06T17:46:21.000Z","cuid":"cl8xcodj6000c09mi9gbne8el","slug":"golang-aha-moments-generics","authors":["PaulLorenz"],"image":"@site/blogs/openziti/v1663771708776/OXjhFrMmZ.jpg","imageDark":"@site/blogs/openziti/v1663771708776/OXjhFrMmZ.jpg","tags":["golang","developer","generics","openziti","golang-aha"]},"unlisted":false,"prevItem":{"title":"Integrating Ziti is Easy! How we got our app tested with go-httpbin","permalink":"/docs/openziti/blog/integrating-ziti-is-easy"},"nextItem":{"title":"Securing NodeJS Applications \u2014 An Introduction to the OpenZiti SDK for NodeJS","permalink":"/docs/openziti/blog/securing-nodejs-applications"}},"content":"## Introduction\\nI work with Golang every day as a developer on the [OpenZiti project](http://openziti.io). In learning Go, \\nI\'ve hit various stumbling blocks, settled on some best practices and hopefully gotten better at writing Go code. \\nThis series exists to share some of the \'Aha!\' moments I\'ve had overcoming obstacles and finding solutions that \\nsparked joy.\\n\\n\x3c!-- truncate --\x3e\\n\\nThis [series](./tags/golang-aha) is targeted both at new team members and for anyone in the Go community who might be interested. I\'m very happy to hear from others about their own \'aha\'\\nmoments and also how the solutions presented strike your sensibilities. Suggested improvements, corrections and constructive criticism are welcome.    \\n\\nThis second installment will cover various topics related to Go generics.\\n\\n## Generics Overview\\nGenerics were introduced into the Go language in version 1.18 after years of debate and discussion. \\n\\nThis article assumes you are already familiar with generics from other languages and is not focused on the basics of using generics. Other than a brief overview, it it is focused on shortcomings, workarounds and considerations more specific to Go. For some links to more introductory works, please see the [further reading](./golang-aha-moments-generics#further-readingviewing) section at the end.\\n\\nThe initial release of Go generics seems focused on two things.\\n\\n* Reducing copy/paste code\\n* Better type safety and removing casts for container types\\n\\nIf you\'re already familiar with these, feel free to skip ahead to the [learnings section](./golang-aha-moments-generics.md#generics-learnings).\\n\\n### Copy/Paste Reduction\\nFor an example of copy/paste reduction, take the classic `math.Min` function. The standard library (as of Go 1.19) only has `math.Min(x, y float64) float64`. If you want to find the minimum of any other types you either need to do some casting or write your own. \\nThis is admittedly trivial code to write, but there are likely many implementations scattered across many code bases at this point. With generics you can write the following code\\n\\n```golang\\nimport \\"golang.org/x/exp/constraints\\"\\n\\nfunc Min[T constraints.Ordered](x, y T) T {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n``` \\n\\nWhile this code isn\'t in the standard library yet (and neither is the useful constraints package) it likely will be in a future release. At a minimum, developers now only need to write a single `Min` function now, instead of writing one each time a new type needs to compared.\\n\\n### Container Types\\nBefore generics if you wanted a custom container, such as a b-tree implementation, copy-on-write data structures or some concurrency friendly map, it would generally be implemented in terms of `interface{}`, requiring values to be cast when extracted. An API that looked like:\\n\\n```golang\\ntype MyMap interface {\\n\\tPut(key, value interface{})\\n\\tGet(key interface{}) (interface{}, bool)\\n\\tDelete(key interface{}) bool\\n\\tEach(func (key, value interface{}))\\n}\\n```\\ncan now instead look like:\\n```golang\\ntype MyGenericMap[K comparable, V any] interface {\\n\\tPut(key K, value V)\\n\\tGet(key K) (V, bool)\\n\\tDelete(key K) bool\\n\\tEach(func (key K, value V))\\n}\\n```\\n\\nOpenZiti has some data structures using generics [in the foundation library](https://github.com/openziti/foundation/blob/main/concurrenz/), including:\\n\\n* CopyOnWriteMap - https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/copy_on_write_map.go\\n* CopyOnWriteSlice - https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/copy_on_write_slice.go\\n\\nOver time I expect more of these types to be in the standard library. \\n\\n## Generics Learnings\\n### No Generic Methods\\nAs of Go 1.19, generic functions are supported, but not generic methods (funcs defined on a type).\\n\\nSo for a Tree type, with the given partial implementation:\\n\\n```golang\\ntype node[E any] struct {\\n\\tvalue E\\n\\tchildren []*node[E]\\n}\\n\\nfunc (self *node[E]) Add(elem E) {\\n\\tself.children = append(self.children, &node[E]{\\n\\t\\tvalue: elem,\\n\\t})\\n}\\n```\\nIf you wanted to define a `Map` method to map a Tree of values from one type to another, you couldn\'t define a generic method with the following signature:\\n```golang\\n// not allowed\\nfunc (self *node[E]) Map[T any](f func(E) T) *node[T] { ... }\\n```\\nThe workaround is to convert the method into a func. For example, the above method could be rewritten as func:\\n\\n```golang\\n// legal version\\nfunc Map[E any, T any](self *node[E], f func(E) T) *node[T] { ... }\\n```\\n\\nIf you had a tree and wanted map it, you\'d have to write:\\n\\n```golang\\nvar tree *node[string]\\nvar result *node[int] := Map(tree, func(s string) { return len(s) })\\n\\n// instead of \\nvar result *node[int] := tree.Map(func(s string) { return len(s) })\\n``` \\n\\nWhile not ideal, it means that this functionality is within reach, even if the syntax is not what I would have preferred.\\n\\n### New Instances of Generic Types\\nA common need is to be able to return a valid instance of a generic type. In the simplest case you might just need to return some default value to satisfy the method contract. Let\'s start with the generic Tree implementation we were using above.\\n\\n```golang\\ntype node[E any] struct {\\n\\tvalue E\\n\\tchildren []*node[E]\\n}\\n```\\n\\nLet\'s add a method to find the first value in the tree matching a given predicate. The basic implementation is straightforward.\\n\\n```golang\\nfunc (self *node[E]) GetFirstMatch(f func(E) bool) (E, bool) {\\n\\tif f(self.value) {\\n\\t\\treturn self.value, true\\n\\t}\\n\\n\\tfor _, child := range self.children {\\n\\t\\tif val, found := child.GetFirstMatch(f); found {\\n\\t\\t\\treturn val, found\\n\\t\\t}\\n\\t}\\n    // what to return here? \\n}\\n```\\nWhat do we return at the end, if nothing is found? We can\'t return nil, since E maybe a primitive or non-pointer struct. Fortunately we can just declare a `var` of type `E` and it will be assigned the default value for that type. \\n\\n```golang\\nfunc (self *node[E]) GetFirstMatch(f func(E) bool) (E, bool) {\\n\\tif f(self.value) {\\n\\t\\treturn self.value, true\\n\\t}\\n\\n\\tfor _, child := range self.children {\\n\\t\\tif val, found := child.GetFirstMatch(f); found {\\n\\t\\t\\treturn val, found\\n\\t\\t}\\n\\t}\\n\\tvar defaultValue E\\n\\treturn defaultValue, false\\n}\\n```\\nThere are also some cases where we want to create new instances of structs. This gets a little complicated. Let\'s use a type factory as an example. This example is not necessarily realistic, but it is concise.\\n\\n```golang\\ntype Example interface {\\n\\tInit(config map[string]interface{})\\n}\\n\\ntype ExampleFactory[T Example] struct {\\n\\tconfig map[string]interface{}\\n}\\n\\nfunc (self *ExampleFactory[T]) Get() T {\\n\\tresult := new(T)\\n\\tresult.Init(self.config)\\n\\treturn result\\n}\\n```\\nWhen we compile this, we see:\\n```\\n./scratch_2.go:14:9: result.Init undefined (type *T is pointer to type parameter, not type parameter)\\n./scratch_2.go:15:9: cannot use result (variable of type *T) as type T in return statement\\n```\\n\\nIn order to resolve this we need two type parameters. One for the underlying type and one for the pointer type. \\n\\n ```golang\\ntype Example[T any] interface {\\n\\t*T // indicates that Example must be a pointer type\\n\\tInit(config map[string]interface{})\\n}\\n\\ntype ExampleFactory[T any, P Example[T]] struct {\\n\\tconfig map[string]interface{}\\n}\\n\\nfunc (self *ExampleFactory[T,P]) Get() P {\\n\\tvar result P = new(T) // result := new(T) won\'t work\\n\\tresult.Init(self.config)\\n\\treturn result\\n}\\n```\\n\\nThe `Example` interface now has a type parameter. That type parameter is used to indicate that the interface must be implemented by a pointer type. We also need to include both types on the factory. Otherwise, when we call `new`, we don\'t have the correct type to call it with. \\n\\nFinally, `result := new(T)` doesn\'t work due to apparent limitations in the type inferencing, the explicit type must be provided.\\n\\n### Case Study: Command Decoding\\nTo pull some of these threads together, I thought it would be useful to look at a place where we introduced generics, in an attempt to reduce boilerplate. \\n\\nOur software has two main server side components: controllers and routers. While you can run any number of routers to form a network mesh, up till now you\'ve only been able to run a single controller. We\'re working on allowing the controller to be run in a cluster for better availability and performance. Part of that work has been moving most of our model into Raft (using the excellent [Raft library](https://github.com/hashicorp/raft/) from Hashicorp). We had to move the create/update/delete logic into commands, which get applied as entries to the Raft log. We need to be able to marshal/unmarshal these commands to and from binary, both so we can ship them to the leader and so the Raft library can propagate them.\\n\\n**TL;DR**: We need to be able to decode binary encoded commands. Can we reduce the boilerplate for doing that?\\n\\nWe\'re going to take a look at a simplified version of the code. We\'re using protobufs for the binary format.\\n\\n#### Supporting Types Reference\\nHere are some of the primary interfaces, which you can reference when looking at the decoder implementations:\\n\\n  * `TypedMessage` - message interface which is just a protobuf message which knows its command type\\n  * `Command` - types we\'re marshalling/unmarshalling\\n  * `DeleteEntityCommand` - example command for deleting entities\\n  * `Decoder` -  func for decoding a binary messages back into a Command\\n  * `DecoderRegistry` - place to lookup the Decoder for a give message  \\n\\nThis implementation has some interfaces for types messages, which extend the protobuf message\\n\\n```golang\\n// TypedMessage instances are protobuf messages which know their command type\\ntype TypedMessage interface {\\n\\tproto.Message\\n\\tGetCommandType() int32\\n}\\n```\\n\\nNext we\'ve got the Command interface and the delete entity command, which covers all model types. \\n\\n```golang\\ntype Command interface {\\n\\tApply() error\\n\\tEncode() ([]byte, error)\\n}\\n\\ntype DeleteEntityCommand struct {\\n\\tId         string\\n\\tEntityType string\\n}\\n\\nfunc (self *DeleteEntityCommand) Apply() error {\\n\\t// implemention elided for brevity \\n}\\n\\nfunc (self *DeleteEntityCommand) Encode() ([]byte, error) {\\n    // EncodeProtobuf marshalls the msg to bytes and prefixes the command type\\n\\treturn cmd_pb.EncodeProtobuf(&cmd_pb.DeleteEntityCommand{\\n\\t\\tEntityId:   self.Id,\\n\\t\\tEntityType: self.EntityType,\\n\\t})\\n}\\n\\nfunc (self *DeleteEntityCommand) Decode(msg *cmd_pb.DeleteEntityCommand) error {\\n\\tself.Id = msg.EntityId\\n\\tself.EntityType = msg.EntityType\\n\\treturn nil\\n}\\n```\\n\\nSo encoding is straightforward, we can just create the appropriate protobuf type and serialize them. Decoding is a little more complicated because we\'re starting with the raw bytes and need a way to rebuild our types. We\'re going to need a `Registry` of things that can decode our various commands for us. To  keep things simple, let\'s just use `funcs`.\\n\\n```golang\\ntype Decoder func(data []byte) (Command, error)\\n\\ntype DecoderRegistry interface {\\n\\tAddDecoder(commandType int32, decoder Decoder)\\n}\\n```\\n\\n#### Decoder: No Generics\\n\\nNow we can create a decoder for our `DeleteEntityCommand` and register it.\\n\\n```golang\\nfunc decodeDeleteEntityCommand(data []byte) (Command, error) {\\n    // Unmarshal to a protobuf message type\\n\\tmsg := &cmd_pb.DeleteEntityCommand{}\\n\\tif err := proto.Unmarshal(data, msg); err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n    // Populate the command using the protobuf message\\n\\tcmd := &DeleteEntityCommand{}\\n\\tif err := cmd.Decode(msg); err != nil {\\n\\t\\treturn nil, err\\n\\t}\\n\\n\\treturn cmd, nil\\n}\\n\\nfunc registerDecodeDeleteCommand(registry DecoderRegistry) {\\n\\tregistry.AddDecoder(int32(cmd_pb.CommandType_DeleteEntityType), decodeDeleteEntityCommand)\\n}\\n```\\nHowever, there\'s not much special going on here. This function will be essentially the same for every command. It needs to create an instance of the protobuf command, Unmarshal it, and then pass that off to a new instance of the model Command.\\n\\n#### Decoder: Generics + Reflection\\n\\nHere\'s a first pass at using generics to take care of this boilerplate.\\n\\n```golang\\nfunc RegisterCommand[M TypedMessage, C decodableCommand[M]](registry DecoderRegistry, cmdType C, msgType M) {\\n\\tdecoder := func(data []byte) (Command, error) {\\n\\t\\tmsg := proto.MessageV1(proto.MessageV2(msgType).ProtoReflect().New()).(M)\\n\\t\\tif err := proto.Unmarshal(data, msg); err != nil {\\n\\t\\t\\treturn nil, err\\n\\t\\t}\\n\\t\\tcmd := reflect.New(reflect.TypeOf(cmdType).Elem()).Interface().(C)\\n\\t\\tif err := cmd.Decode(msg); err != nil {\\n\\t\\t\\treturn nil, err\\n\\t\\t}\\n\\t\\treturn cmd, nil\\n\\t}\\n\\tregistry.AddDecoder(msgType.GetCommandType(), decoder)\\n}\\n\\nfunc registerDecodeDeleteCommand(registry DecoderRegistry) {\\n\\tRegisterCommand(registry, &DeleteEntityCommand{}, &cmd_pb.DeleteEntityCommand{})\\n}\\n```\\n\\nThis works for removing the boilerplate. We have a single line where we register the decoder, with the two types it needs to know about.\\n\\nUnfortunately, the implementation is ugly and employs both some sketchy protobuf library reflection and regular reflection. This is both hard to read and not terribly efficient.\\n\\n#### Decoder: Pure Generics\\n\\nWe can do better using what we learned about instantiating generic types above.\\n\\n```golang\\ntype commandMsg[T any] interface {\\n\\tTypedMessage\\n\\t*T\\n}\\n\\ntype decodableCommand[T any, M any] interface {\\n\\tCommand\\n\\tDecode(msg M) error\\n\\t*T\\n}\\n\\nfunc RegisterCommand[MT any, CT any, M commandMsg[MT], C decodableCommand[CT, M]](registry DecoderRegistry, _ C, msg M) {\\n\\tdecoder := func(data []byte) (Command, error) {\\n\\t\\tvar msg M = new(MT)\\n\\t\\tif err := proto.Unmarshal(data, msg); err != nil {\\n\\t\\t\\treturn nil, err\\n\\t\\t}\\n\\n\\t\\tcmd := C(new(CT))\\n\\t\\tif err := cmd.Decode(msg); err != nil {\\n\\t\\t\\treturn nil, err\\n\\t\\t}\\n\\t\\treturn cmd, nil\\n\\t}\\n\\n\\tregistry.AddDecoder(msg.GetCommandType(), decoder)\\n}\\n\\nfunc registerDecodeDeleteCommand(registry DecoderRegistry) {\\n\\tRegisterCommand(registry, &DeleteEntityCommand{}, &cmd_pb.DeleteEntityCommand{})\\n}\\n```\\n\\n##### Performance\\nThis is better from an efficiency perspective, though admittedly not by much. The reflection based code results:\\n\\n```\\nBenchmarkRegisterCommand-16         1013774          1259 ns/op\\nBenchmarkRegisterCommand-16         1012059          1267 ns/op\\n```\\n\\nvs the generics based code:\\n\\n```\\nBenchmarkRegisterCommand-16         1165557          1144 ns/op\\nBenchmarkRegisterCommand-16         1143402          1134 ns/op\\n``` \\n\\nHowever, the code is less fragile, as it\'s not relying on protobuf tricks, and is likely to get faster over time as generics support improves. \\n\\n##### Complexity\\nIt is still hard code to read. However, that ugliness is balanced by a relatively clean API and reduced code externally. Personally I\'ll trade some encapsulated ugliness for reduced code and complexity elsewhere. This is an area where reasonable people can disagree, though.\\n\\n##### Generic parameters vs args\\nThis method could also be written with a different type signature:\\n\\n```golang\\nfunc RegisterCommand[MT any, CT any, M commandMsg[MT], C decodableCommand[CT, M]](registry DecoderRegistry) { ... }\\n\\nfunc registerDecodeDeleteCommand(registry DecoderRegistry) {\\n\\tRegisterCommand[cmd_pb.DeleteEntityCommand, DeleteEntityCommand](registry)\\n}\\n```\\nSo we\'ve replaced the arguments, which weren\'t strictly necessary and are explicitly providing the generic types instead. This is another matter of taste. As someone calling the library, I found it easier to provide function parameters than generic types, since it was easier to figure out what was required. Others might reach different conclusions.\\n\\nTo look at the actual implementation in OpenZiti, here are some starting points:\\n  * https://github.com/openziti/fabric/tree/v0.21.0/controller/command\\n  * https://github.com/openziti/fabric/blob/v0.21.0/controller/network/command.go\\n\\n### Case Study: Entity Managers\\nThere are also places where the the complexity tradeoff goes the other way. Let\'s look at an entity manager type. We\'ve got an interface for Entities which know how to load themselves from a data store. Our model is persisted in [bbolt](https://github.com/etcd-io/bbolt), but the pattern should be broadly applicable. \\n\\nWe want our base entity manager type to be able to load entities. For that, it must be able to create new instances of the entity type.\\n\\n```golang\\ntype Entity interface {\\n\\tGetId() string\\n\\tLoad(store DataStore, entityData *Bucket)\\n}\\n\\ntype baseEntityManager[E Entity] struct {\\n\\tstore DataStore\\n}\\n\\nfunc (mgr *baseEntityManager[E]) Load(id string) (E, error) {\\n\\tvar entity E // need to get new instance of E somehow\\n\\t// load entity, if it exists, otherwise return an error\\n\\treturn entity, nil\\n}\\n```\\n\\nIf our base manager type can create new instances of the Entity type, it can load them in a generic fashion. We could use the same pattern from above to allow new instances of the entity type to be created using generics. That would look something like:\\n\\n```golang\\ntype EntityP[T any] interface {\\n\\tEntity\\n\\t*T\\n}\\n\\ntype baseEntityManager[E any, PE EntityP[E]] struct {\\n\\tstore DataStore\\n}\\n\\nfunc (mgr *baseEntityManager[E, PE]) Load(id string) (PE, error) {\\n\\tvar entity PE = new(E) // init using generics\\n\\t// load entity, if it exists, otherwise return an error\\n\\treturn entity, nil\\n}\\n```\\n\\nSo this works,but it also requires a more complex generics parameters and those more complex parameters have to be on every method we define on the type. So by making the one method slightly simpler, we have incurred a complexity penalty in many places. This will also spread to anywhere were the type is used. \\n\\nGiven this we decided to go for a simpler solution: providing a `func` which can create new entity instances.\\n\\n```golang\\ntype baseEntityManager[E Entity] struct {\\n\\tstore DataStore\\n\\tnewEntity func() E\\n}\\n\\nfunc (mgr *baseEntityManager[E]) Load(id string) (E, error) {\\n\\tvar entity E = mgr.newEntity() // init using a constructor function\\n\\t// load entity, if it exists, otherwise return an error\\n\\treturn entity, nil\\n}\\n```\\n\\nWhile this requires us to provide logic at construction time, it keeps the rest of the code cleaner.\\n\\n## Conclusion\\nWhile not perfect, generics in Go have let us remove a lot of boilerplate from the OpenZiti project. We\'ve also found and fixed some bugs when we switched to type safe collections. \\n\\nWe\'re generally still trying to be somewhat conservative with where we use generics. When we add it, as with the examples above, we want to be sure that we\'re getting good value for the extra complexity.    \\n\\nIt will be interesting to see where generics make their way into the standard libraries and what best practices emerge around Go generics. \\n\\nIf you\'ve got any feedback, maybe better ways to accomplish the things outlined above, let me know!\\n\\n## Further Reading/Viewing\\n\\n* https://go.dev/blog/intro-generics\\n* https://go.dev/doc/tutorial/generics\\n* https://gobyexample.com/generics\\n\\nHere\'s a video some of my coworkers did around the time of the initial generics release on our weekly video stream:\\n\\n%[https://www.youtube.com/watch?v=4JFA31O2UaE]"},{"id":"securing-nodejs-applications","metadata":{"permalink":"/docs/openziti/blog/securing-nodejs-applications","source":"@site/blog/securing-nodejs-applications.md","title":"Securing NodeJS Applications \u2014 An Introduction to the OpenZiti SDK for NodeJS","description":"Securing NodeJS Applications","date":"2022-09-28T00:00:00.000Z","tags":[{"inline":false,"label":"NodeJS","permalink":"/docs/openziti/blog/tags/nodejs","description":"NodeJS content"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"SDK","permalink":"/docs/openziti/blog/tags/sdk","description":"Software Development Kits"}],"readingTime":9.59,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"slug":"securing-nodejs-applications","title":"Securing NodeJS Applications \u2014 An Introduction to the OpenZiti SDK for NodeJS","authors":["CurtTudor"],"date":"2022-09-28T00:00:00.000Z","tags":["nodejs","openziti","zero-trust","sdk"]},"unlisted":false,"prevItem":{"title":"Golang Aha! Moments: Generics","permalink":"/docs/openziti/blog/golang-aha-moments-generics"},"nextItem":{"title":"OpenZiti is Participating in Hacktoberfest, Prost!","permalink":"/docs/openziti/blog/openziti-is-participating-in-hacktoberfest-prost"}},"content":"## Securing NodeJS Applications\\n\\n# Welcome\\n\\nIf you are a **NodeJS** app developer or DevSecOps practitioner, and application security and business agility is \\nimportant to you, then you\'re in the right place.\\n\\n\x3c!-- truncate --\x3e\\n\\nHere I will take the abstract notion of app-embedded zero trust, and show you how OpenZiti uniquely positions you to achieve it in ***your NodeJS applications***.\\n<table>\\n    <tr>\\n      <td>\\n        <br/>\\n        <br/>\\n        <br/>\\n        <br/>\\n        So as our mascot Ziggy would say...  \\n        <br/>\\n       Let\'s get cookin\' !\\n      </td>\\n      <td>\\n        <img src=\\"/docs/blogs/openziti/v1663795868819/oZBNK_WSq.png?height=250\\" alt=\\"How to secure NodeJS apps\\" />\\n      </td>\\n  </tr>\\n</table>\\n\\nIn case you haven\'t heard, [OpenZiti](https://openziti.github.io/ziti/overview.html) is a free, open source project, focused on bringing zero trust networking to any application. \\n\\nOpenZiti provides a best-in-class overlay network and numerous SDKs making it easy to embed secure connectivity directly into your app, without exposing incoming ports to the internet, and without VPNs!\\n\\nOpenZiti is referred to as an overlay network because it provides secure connectivity on top \u2013 or \u201coverlaying\u201d \u2013 existing networking infrastructure, like the internet.\\n\\nEverything is based on trusted identity, and we take it a step further by providing identity-specific end-to-end encryption, even before we do mTLS.\\n\\nHere\'s an overview of an OpenZiti network:\\n\\n![image.png](/blogs/openziti/v1663946224862/C-eySQ1IN.png)\\n\\nIf you want to learn more about what an OpenZiti network is, and the various ways we make it programmable, we invite you to visit our main [OpenZiti documentation site](https://openziti.github.io/ziti/overview.html).\\n\\nIt\'s important to know that you can incrementally implement your rollout of OpenZiti.  \\n\\nYou can begin by running our [Ziti Desktop Edge](https://apps.apple.com/app/id1460484572) (or [Mobile Edge](https://apps.apple.com/us/app/ziti-mobile-edge/id1460484353)) software on your client (we have versions for Mac, Windows, and Linux).\\n\\nThat approach would look like this:\\n\\n![image.png](/blogs/openziti/v1664213475093/cePW5PfP0.png)\\n\\nOnce you\'re up, running, and comfortable with your OpenZiti network, you would then work towards the ***ultimate goal*** of having app-embedded zero trust networking built directly into both your client and server software, by using our OpenZiti SDKs.  \\n\\nThat would look like this:\\n\\n![image.png](/blogs/openziti/v1664214142956/ZmA3_879t.png)\\n\\nNo more need to run VPN-like OpenZiti edge software.\\n\\n\\n\\n\\n# Installation\\n\\nThe OpenZiti SDK for NodeJS is published to [NPM](https://www.npmjs.com/package/@openziti/ziti-sdk-nodejs), and it\'s now waiting for you.\\n\\nOur DevX philosophy is to always eliminate as much friction as we can, so we made it possible for you to install the OpenZiti SDK for NodeJS just like you would any other package, via:\\n\\n```\\nnpm i @openziti/ziti-sdk-nodejs\\n```\\nor\\n```\\nyarn add @openziti/ziti-sdk-nodejs\\n```\\n\\nSimple. Straightforward. Familiar.\\n\\n## Native Addon\\n\\nThe OpenZiti SDK for NodeJS is implemented as a [NodeJS Addon](https://nodejs.org/api/addons.html) (a.k.a. \\"*Native Addon*\\", a.k.a. \\"*Native Module*\\").\\n\\nThis is why our NodeJS SDK is actually implemented in C. Here\'s how GitHub breaks it down:\\n\\n![image.png](/blogs/openziti/v1663801229089/K2VwyFi2B.png?width=400)\\n\\nInternally, the OpenZiti SDK for NodeJS embeds the [OpenZiti SDK for C-language](https://github.com/openziti/ziti-sdk-c).  \\n\\nThe core OpenZiti capabilities (e.g. identity enrollment, communications with OpenZiti control-plane, etc.) within our C-SDK are wrapped by our NodeJS-SDK, and that core power is then exposed to NodeJS apps at the JavaScript language level.\\n\\nBeyond these core OpenZiti capabilities, additional capabilities exist within the OpenZiti SDK for NodeJS that are specific to the types of web server frameworks that reside in the NodeJS ecosystem (*more on that below*).\\n\\n## N-API\\n\\nThe OpenZiti SDK for NodeJS leverages the [N-API](https://nodejs.org/api/n-api.html\\n) (an abstraction of the underlying V8 JavaScript engine).\\n\\nDetails surrounding the N-API are beyond the scope of this article, but if you\'re curious about architectural structure and flow and about what actually happens when your NodeJS code calls one of our APIs, like `ziti_dial` for example,  take a peek at the following diagram:\\n\\n![image.png](/blogs/openziti/v1663862820471/SgksvyXlp.png)\\n\\nWe\'ll cover this in greater detail in future articles.\\n\\n## Compilation?\\n\\nYou might be wondering: \\n> *Hey wait... if this SDK is implemented in C language code, does that mean it needs to be compiled when I install it?  Am I at risk of being dragged into a quagmire of compiler/linker tooling nightmares*\\n\\nNope. \\n\\nThere is no need for install-time compilation of the OpenZiti SDK for NodeJS.  \\n\\nWe did the heavy-lifting for you ahead of time (...*again, to reduce friction*).\\n\\nWe baked some special sauce into the `@openziti/ziti-sdk-nodejs` npm package that executes during the `npm i` (or `yarn add`) command.\\n\\nThese mechanisms will dynamically determine what **OS** you are using, what **NodeJS version** you are using, and what **CPU Architecture** you are using, and it will then automatically download a pre-built binary (*that we publish during our SDK release process*).  \\n\\nThe binary that is installed for you is the one that is suitable for the environment where you are doing the install.\\n\\nSweet!\\n\\n## Server-side web application platform support\\n\\nThere are many server-side web application platforms built upon NodeJS.  You may be using one of them and wonder whether these platforms are supported by the OpenZiti SDK for NodeJS.  \\n\\nSpoiler alert... the answer is ***yes***!\\n\\n![image.png](/blogs/openziti/v1663857963037/IfNqwmW1l.png)\\n\\n![image.png](/blogs/openziti/v1663799247907/l0bwWvRBp.png)\\n\\nExcept for a couple JavaScript-related server-side frameworks (circled above in red), all others are currently supported by the OpenZiti SDK for NodeJS.\\n\\n> *Note that one of my upcoming blog articles will do a deep technical dive into the underpinnings of the OpenZiti NodeJS SDK, how it transparently integrates with ExpressJS, and how with just a couple lines of code the SDK makes it trivial for a Node/Express web server to host a Ziti service and listen for incoming Ziti connections instead of listening on a port open to the internet.  Be sure to subscribe to this blog to to ensure you won\'t miss these further educational materials*\\n\\n# Basic usage\\n\\nThe OpenZiti SDK for NodeJS can be used with apps written in the [CJS style](https://nodejs.org/api/modules.html#modules-commonjs-modules) as well as the more modern [ESM style](https://nodejs.org/api/esm.html#modules-ecmascript-modules).\\n\\nSome code snippets below are crafted as CJS, and some as ESM, to illustrate differences in coding style.\\n\\n### Importing the SDK\\nCJS\\n```js\\nconst ziti = require(\'@openziti/ziti-sdk-nodejs\');\\n```\\nESM\\n```js\\nimport ziti from \'@openziti/ziti-sdk-nodejs\';\\n```\\n\\n### Identity enrollment\\n\\nOnce you have [created an OpenZiti enrollment token](https://openziti.github.io/ziti/identities/creating.html#creating-an-identity), it is easy to perform the enrollment, and create an [OpenZiti Network Identity](https://openziti.github.io/ziti/identities/overview.html?tabs=tabid-new-ca-ui%2Ctabid-new-identity-ui) from the enrollment token, using the `ziti_enroll` API, as shown in the demo app below:\\n\\nESM\\n```js\\nimport fs from \'fs\';\\nimport ziti from \'@openziti/ziti-sdk-nodejs\';\\n\\nconst ziti_enroll = async (jwt_path) => {\\n    return new Promise((resolve, reject) => {\\n        let rc = ziti.ziti_enroll(jwt_path, (data) => {\\n            if (data.identity) {\\n                resolve(data);\\n            } else {\\n                reject(data);\\n            }\\n        });\\n    });\\n};\\n\\nlet jwt_path = process.argv[2];\\n\\nconsole.log(\'Specified Enrollment JWT is (%o)\', jwt_path);\\n\\nlet data = await ziti_enroll(jwt_path).catch((data) => {\\n    console.log(\'Enroll failed with error (%o)\', data);\\n});\\n\\nif (data) {\\n    console.log(\\"data is:\\\\n\\\\n%s\\", data);\\n\\n    if (data.identity) {\\n        fs.writeFileSync(\'identity.json\', data.identity);\\n    }\\n}\\n\\nprocess.exit(0);\\n```\\n\\nYou would run the above app like this: \\n```\\nnode index.js path/to/enrollment.jwt\\n```\\n\\nIf the enrollment JWT file is valid (e.g. unexpired, not enrolled previously, etc.), then the app will write the OpenZiti Identity file in the local directory with the name ```\\nidentity.json```.\\n\\n### Authenticate with Control Plane\\n\\nAuthenticating your client or server app onto the OpenZiti network is done via the ```\\ninit``` API. \\n\\nIn the snippet below, let\'s assume you exported the path to the ```\\nidentity.json``` file created in the above example into an env var named ZITI_IDENTITY_FILE. \\n\\nWith that in place, network authentication is one API call away, as shown here:\\n\\n```\\n// Somehow provide path to identity file, e.g. via env var\\nconst zitiIdentityFile  = process.env.ZITI_IDENTITY_FILE;\\n// Authenticate ourselves onto the Ziti network\\nawait ziti.init( zitiIdentityFile )\\n  .catch(( err ) => { /* probably exit */ });\\n```\\n\\nFollowing that, you\'re now free to read and write data across the network, as discussed below.\\n\\n### Make a client-side REST call to a dark service\\n\\nOnce your OpenZiti network has been configured with a [service](https://openziti.github.io/ziti/services/overview.html?tabs=create-service-ui), your NodeJS app can make REST calls to it.\\n\\nLet\'s assume there is a web server on your network, and it is represented by the OpenZiti Service name ```myDarkWebService```. You\'d make REST calls to that service from your NodeJS app like this:\\n\\n```\\nconst on_resp_data = ( obj ) => {\\n    console.log(`response is: ${obj.body.toString(\'utf8\')}`);\\n};\\n\\n// Perform an HTTP GET request to a dark OpenZiti web service\\nziti.httpRequest(\\n  \'myDarkWebService\', \\n  \'GET\', \\n  \'/\',              // path\\n  [\'Accept: application/json\' ], // headers\\n  undefined,        // optional on_req cb \\n  undefined,        // optional on_req_data cb\\n  on_resp_data      // optional on_resp_data cb\\n);\\n```\\n\\nThe above example used GET, but POST operations, and all other REST verbs, are supported too.\\n\\n### Host a server-side OpenZiti service\\n\\nIf you have a NodeJS/ExpressJS web server, and you want to make it dark to the internet, we have you covered.\\n\\nHere is how things are traditionally done (without OpenZiti), which involve the risks of opening a TCP port to the internet, and listening for insecure, unauthenticated incoming connections:\\n```js\\nimport express from \'express\';\\nlet app = express();\\napp.listen(myExposedTCPport, function() { ... }\\n```\\nThe attack vector above can be easily eliminated with OpenZiti.\\n\\nHere is how things are done with the OpenZiti NodeJS SDK, involving none of the risks of opening an insecure TCP port to the internet, and instead, listening only for pre-authenticated, secure, trusted OpenZiti connections:\\n```js\\nimport express from \'express\';\\nlet app = ziti.express( express, zitiServiceName );//<-easy peasy\\napp.listen(ignored, function() { ... }\\n```\\n\\nThat\'s right. \\n\\n**With only a single-line code change** (the ```ziti.express``` call), **your web server is now capable of being dark on the internet.**\\n\\n**Nothing else in your existing ExpressJS web server code needs to change!**\\n\\nExisting routing, middleware, etc., all operates the same as it always did... but now you enjoy the comfort of knowing that if a connection comes in, it is from a trusted identity on the client side.  \\n\\nNo malicious actors can see your dark web server, and thus, no malicious actors can attack it.\\n\\n# Next Steps\\n\\nThe API exposed by the OpenZiti NodeJS SDK extends beyond the examples rendered above, so we encourage you to come explore the repo.\\n\\n### Projects using this SDK\\n\\nYou might also want to check out a couple of our projects that use the OpenZiti NodeJS SDK (*yes, we use OpenZiti, to build more OpenZiti*):\\n\\n- Call a Dark Webhook from GitHub Actions ([Ziti Webhook Action](https://github.com/openziti/ziti-webhook-action)). We self-host a dark instance of [Mattermost](https://netfoundry.io/why-we-switched-to-mattermost/)) at our company, and this webhook tooling is a way we securely allow our GitHub Actions CI pipelines to post status messages to developer-oriented notification channels on a Mattermost app that would otherwise be inaccessible to the GitHub runners.\\n\\n- [Zitified Ziti Admin Console](https://github.com/openziti/ziti-console), optionally capable of hosting a Ziti service.\\n\\n### Connect with us\\n\\nWe\'d love to hear from you about your NodeJS-based applications and whether or not you decide OpenZiti is the right fit to secure them, so please join us and your peers in conversation:\\n\\n\\n- Main OpenZiti [repo](https://github.com/openziti/ziti) - please give us a star!\\n- OpenZiti NodeJS SDK [repo](https://github.com/openziti/ziti-sdk-nodejs)\\n- Join [discussion](https://openziti.discourse.group/)\\n- Follow [@openziti](https://twitter.com/openziti)\\n\\nWe are here to help.\\n\\nAlso feel free to leave us comments or questions below, right here on this article."},{"id":"openziti-is-participating-in-hacktoberfest-prost","metadata":{"permalink":"/docs/openziti/blog/openziti-is-participating-in-hacktoberfest-prost","source":"@site/blog/openziti-is-participating-in-hacktoberfest-prost.md","title":"OpenZiti is Participating in Hacktoberfest, Prost!","description":"OpenZiti is Participating in Hacktoberfest, Prost!","date":"2022-09-27T00:00:00.000Z","tags":[{"inline":false,"label":"Hacktoberfest","permalink":"/docs/openziti/blog/tags/hacktoberfest","description":"Hacktoberfest participation and contributions"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Community","permalink":"/docs/openziti/blog/tags/community","description":"Community topics"}],"readingTime":1.9,"hasTruncateMarker":true,"authors":[{"name":"Geoff Berl","title":"Author","url":"https://github.com/gberl002","imageURL":"https://avatars.githubusercontent.com/gberl002","key":"GeoffBerl","page":null}],"frontMatter":{"slug":"openziti-is-participating-in-hacktoberfest-prost","title":"OpenZiti is Participating in Hacktoberfest, Prost!","authors":["GeoffBerl"],"date":"2022-09-27T00:00:00.000Z","tags":["hacktoberfest","openziti","community"]},"unlisted":false,"prevItem":{"title":"Securing NodeJS Applications \u2014 An Introduction to the OpenZiti SDK for NodeJS","permalink":"/docs/openziti/blog/securing-nodejs-applications"},"nextItem":{"title":"OpenZiti Python SDK: Introduction","permalink":"/docs/openziti/blog/openziti-python-sdk-introduction"}},"content":"## OpenZiti is Participating in Hacktoberfest, Prost!\\n\\n## What\'s Hacktoberfest?\\nHacktoberfest is a month long journey many take to get a free t-shirt. Wait, no, it\'s a community gathering to support the open source community and projects. Every year, during the month of October, [DigitalOcean](https://www.digitalocean.com/) hosts an event in which developers around the world join together to contribute to open source. You can contribute by submitting changes ranging in difficulty from fixing a typo to implementing a full-fledged feature on a project. As the official [Hacktoberfest website](https://hacktoberfest.com/participation/) says, \\"Quantity is fun, Quality is key.\\"\\n\\n\x3c!-- truncate --\x3e\\n\\n## I Want a Free T-Shirt, How Do I Participate?\\nIt\'s coming up fast, your first step is to get acquainted with the process; \\"Hello Preptember.\\" Preptember is just a fancy way of saying, start getting ready now, find open source projects you\'re interested in, and take a look at the issues. \\n1. The first step would be to check out the [official Hacktoberfest website](https://hacktoberfest.com/participation/). \\n1. Register between September 26 and October 31.\\n1. Any changes you make need to be in a pull request (PR) that is **accepted** by the project maintainers\\n1. You officially \\"complete\\" Hacktoberfest by having 4 PRs accepted during the month of October, feel free to keep contributing though; it\'s fun!\\n1. ***If*** you are one of the first 40,000 participants to complete Hacktoberfest, you receive a prize: a tree planted in your name or a t-shirt.\\n1. Check out [this link](https://hacktoberfest.com/participation/) for more detail on participation. It covers everything from what is open source to how to submit a PR \\n\\n## How Do I Find Open Source Projects?\\nTake a look at github\'s [#hacktoberfest](https://github.com/topics/hacktoberfest) topic to see all the repositories participating in Hacktoberfest; currently, there are almost 100,000 projects! You can filter by language to help focus on one you have more experience with or take this opportunity to work on a language you\'ve wanted to learn.\\n\\nYou can also check your local community, many times there are maintainers or groups of developers hosting an event in your area.\\n\\nBut of course, why not check out [OpenZiti hacktoberfest issues](https://github.com/search?q=org%3Aopenziti+label%3A%22hacktoberfest%22+state%3Aopen&type=Issues)?"},{"id":"openziti-python-sdk-introduction","metadata":{"permalink":"/docs/openziti/blog/openziti-python-sdk-introduction","source":"@site/blog/openziti-python-sdk-introduction.md","title":"OpenZiti Python SDK: Introduction","description":"OpenZiti project adds security layers that make your service available without exposing incoming ports, provides identity-specific end-to-end encryption, masks your network traffic protocols/ports, and allows developers to be more agile and secure than ever in all networking scenarios.","date":"2022-09-20T17:51:44.000Z","tags":[{"inline":false,"label":"Python","permalink":"/docs/openziti/blog/tags/python","description":"Python content"},{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"SDK","permalink":"/docs/openziti/blog/tags/sdk","description":"Software Development Kits"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":3.61,"hasTruncateMarker":true,"authors":[{"name":"Eugene Kobyakov","title":"Author","url":"https://github.com/ekoby","imageURL":"https://avatars.githubusercontent.com/ekoby","key":"EugeneKobyakov","page":null}],"frontMatter":{"title":"OpenZiti Python SDK: Introduction","seoDescription":"Build your next Python application with embedded zero trust networking using OpenZiti SDK","date":"2022-09-20T17:51:44.000Z","cuid":"cl8ahtom3080fu5nv6bxr6ylc","slug":"openziti-python-sdk-introduction","authors":["EugeneKobyakov"],"image":"@site/blogs/openziti/v1663698832345/Nj2I2jCi0.jpg","imageDark":"@site/blogs/openziti/v1663698832345/Nj2I2jCi0.jpg","tags":["python","opensource","sdk","openziti"]},"unlisted":false,"prevItem":{"title":"OpenZiti is Participating in Hacktoberfest, Prost!","permalink":"/docs/openziti/blog/openziti-is-participating-in-hacktoberfest-prost"},"nextItem":{"title":"Free Secure Access to NAS From Anywhere","permalink":"/docs/openziti/blog/free-secure-access-to-nas-from-anywhere"}},"content":"OpenZiti project adds security layers that make your service available without exposing incoming ports, provides identity-specific end-to-end encryption, masks your network traffic protocols/ports, and allows developers to be more agile and secure than ever in all networking scenarios.\\n\\n\x3c!-- truncate --\x3e\\n\\nIn our previous posts, we introduced the concept of [Zitification](https://openziti.io/docs/reference/glossary/#zitification-zitified-zitify) -- taking an app and changing it to use a secure, zero-trust, overlay network -- and shared a [few](./zitifying-ssh.md) [examples](./zitifying-scp.md) we developed internally.\\n\\nThis article will show how to *zitify* your Python applications with minor code changes.\\n\\n![Ziggy Loves Python.jpg](/blogs/openziti/v1663167906947/aDQdNSiXW.jpg)\\n\\n## Setup\\n\\nThere are several ways to get started with OpenZiti.\\n\\n* follow instructions from previous posts\\n    \\n* read [quickstart](https://openziti.github.io/ziti/quickstarts/quickstart-overview.html) docs\\n    \\n* and even play in our [sandbox/ZEDS](https://zeds.openziti.org) -- fastest way to start. Ziti Edge Developer Sandbox(ZEDS) hosts a multi-tenant Ziti network.\\n    \\n\\n## Acquiring SDK\\n\\nOpenZiti Python SDK is published to Python Package Index(PyPI) so just go ahead with standard install, or add it to your application\'s `requirements.txt`\\n\\n```pycon\\n$ pip install openziti\\n```\\n\\n## Basic Usage\\n\\nIn the following code examples the following is assumed (read more about Ziti [identities](https://openziti.io/docs/learn/core-concepts/identities/overview) and [services](https://openziti.io/docs/learn/core-concepts/services/overview)):\\n\\n* `id.jwt` - enrollment token file\\n    \\n* `id.json` - ziti identity file\\n    \\n* `best-service-ever` - name of the ziti service\\n    \\n\\n### Ziti identity enrollment\\n\\n```pycon\\n$ python -m openziti enroll --jwt id.jwt --identity id.json\\n```\\n\\n### Open connection to Ziti service\\n\\n```python\\nimport openziti\\n\\n# load ziti context, provide full path to identity file if needed\\nztx = openziti.load(\'id.json\')\\n\\nconn = ztx.connect(\'best-service-ever\')\\n\\n# do cool stuff here with conn (socket)\\n```\\n\\nyou can also connect with an intercepted address (each service may have one or more standard network address `[protocol, host, port]`):\\n\\n```python\\nconn = ztx.connect((\'httpbin.ziti\', 80))\\n```\\n\\n### Host(serve) Ziti service\\n\\n```python\\nimport openziti\\n\\nztx = openziti.load(ziti_id)\\nserver = ztx.bind(service)\\nserver.listen()\\n\\nwhile True:\\n    # conn is the incoming connection(socket)\\n    # peer is a tuple (connecting identity, 0)\\n    conn, peer = server.accept()\\n    \\n    # do some cool interaction with your client\\n```\\n\\n## It\'s 2022: WDIMMOS\\\\*?!!\\n\\n\\\\*`WDIMMOS`: why do I manage my own sockets\\n\\nObviously when you develop your cool Python application you probably would not start with writing your own networking layer. Instead, you\'d use excellent networking capabilities of Python standard library or other modules to do networking for you. The good news is that you can use OpenZiti SDK with other networking modules.\\n\\n### Client Side\\n\\nFor example, let\'s say you want to make an HTTP request with `requests`, `urllib3`, or even `urllib`:\\n\\n```python\\nimport requests\\n\\nr = requests.get(\'http://httpbin.org/json\')\\nprint(r.headers)\\nprint(r.json())\\n```\\n\\nIn order to make `requests` library use Ziti socket, we [`monkeypatch`](https://en.wikipedia.org/wiki/Monkey_patch) the code. In this case you can `request`(get it?) with an intercepted address.\\n\\n```python\\nimport requests\\nimport openziti\\n\\nztx = openziti.load(\'id.json\')\\n\\nwith openziti.monkeypatch():\\n    # FIY, httpbin.ziti is a common service you can use in our sandbox\\n    r = requests.get(\'http://httpbin.ziti/json\')\\n    print(r.headers)\\n    print(r.json())\\n```\\n\\n### Server Side\\n\\nOn the hosting server side we need inform the monkey patching code what it needs to do when underlying networking code binds to an address. This is done via `bindings` parameter to the `monkeypatch()` method. The value must be a map from network address(host, port) to the Ziti context/service -- like this:\\n\\n```python\\nimport sys\\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\\nimport openziti\\n\\nclass MyServer(BaseHTTPRequestHandler):\\n    def do_GET(self):\\n        self.send_response(200)\\n        self.send_header(\\"Content-type\\", \\"application/json\\")\\n        self.end_headers()\\n        msg = \\"\\"\\"{\\"msg\\": \\"Hello! Have some ziti!\\"}\\"\\"\\"\\n        self.wfile.write(bytes(msg, \\"utf-8\\"))\\n\\nif __name__ == \\"__main__\\":\\n    bind_addr = (\'localhost\', 8080)\\n    srv_addr = {\\n        ztx: \'id.json\',\\n        service: \'best-service-ever\'\\n    }\\n    # map network bind address to Ziti Service target\\n    bind_map = { bind_addr: srv_addr }\\n\\n    openziti.monkeypatch(bindings=bind_map)\\n    webServer = HTTPServer(bind_addr, MyServer)\\n    webServer.serve_forever(poll_interval=600)\\n```\\n\\n## Next Steps\\n\\nWe would love to hear from you about your applications and if decide that [OpenZiti](https://github.com/openziti/ziti) is the right fit to secure them.\\n\\nCheckout some of our projects that use OpenZiti Python SDK:\\n\\n* [Call a Dark Webhook from AWS Lambda](./my-intern-assignment-call-a-dark-webhook-from-aws-lambda)\\n    \\n* [Zitified Ansible/Paramiko](https://github.com/openziti-test-kitchen/ansible-paramikoz-demo)\\n    \\n\\nFollow us:\\n\\n* Python SDK [repo](https://github.com/openziti/ziti-sdk-py)\\n    \\n* Main OpenZiti [repo](https://github.com/openziti/ziti) - give us a star!\\n    \\n* Join [discussion](https://openziti.discourse.group/)\\n    \\n* Follow [@openziti](https://twitter.com/openziti)"},{"id":"free-secure-access-to-nas-from-anywhere","metadata":{"permalink":"/docs/openziti/blog/free-secure-access-to-nas-from-anywhere","source":"@site/blog/free-secure-access-to-nas-from-anywhere.md","title":"Free Secure Access to NAS From Anywhere","description":"The Problem","date":"2022-09-15T13:34:40.000Z","tags":[{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Secure","permalink":"/docs/openziti/blog/tags/secure","description":"Security enhancements"},{"inline":false,"label":"Synology","permalink":"/docs/openziti/blog/tags/synology","description":"Synology NAS content"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"Network Attached Storage","permalink":"/docs/openziti/blog/tags/nas","description":"NAS content"}],"readingTime":7.82,"hasTruncateMarker":true,"authors":[{"name":"Geoff Berl","title":"Author","url":"https://github.com/gberl002","imageURL":"https://avatars.githubusercontent.com/gberl002","key":"GeoffBerl","page":null}],"frontMatter":{"title":"Free Secure Access to NAS From Anywhere","date":"2022-09-15T13:34:40.000Z","cuid":"cl833ftkq00301hnv4uk00ynp","slug":"free-secure-access-to-nas-from-anywhere","authors":["GeoffBerl"],"image":"@site/blogs/openziti/v1662661576643/TBtuZgOgd.png","imageDark":"@site/blogs/openziti/v1662661576643/TBtuZgOgd.png","tags":["opensource","secure","synology","openziti","network-attached-storage"]},"unlisted":false,"prevItem":{"title":"OpenZiti Python SDK: Introduction","permalink":"/docs/openziti/blog/openziti-python-sdk-introduction"},"nextItem":{"title":"Introducing OpenZiti BrowZer","permalink":"/docs/openziti/blog/introducing-openziti-browzer"}},"content":"## The Problem\\n\\nTo put it plainly, I don\'t like opening up ports on my local firewall. However, I have a network attached storage (NAS) device that I want accessible from the internet so I have access from anywhere. So, how can I access my private network from anywhere without opening ports?\\n\\n\x3c!-- truncate --\x3e\\n\\n## Backstory\\n\\n#### ([Skip if you don\'t care about me and my life](#so-howd-you-do-it))\\n\\nI finally got around to using a NAS device ([Synology DS220j](https://www.synology.com/en-us/products/DS220j) to be exact) instead of fiddling with USB backup drives. It was an exciting time (I get overly excited about organization since I\'m a naturally messy person) since I could now centralize my data storage and backups, I could create users, quotas, you know, all the stuff about which my wife could not care less.\\n\\nNow, how could I make NAS even more exciting? I could access my network storage from anywhere or maybe even create a shared folder that I could use to share things with my family members (who don\'t live in the same house). But, alas, I\'m not a fan of opening ports to the world, I am very critical in my trust of companies\' ability to focus on security to the degree I would expect. If you want to read about at least one huge reason why I don\'t like opening ports or trusting companies, [check out my other article](./zero-trust-overlay-network-to-access-homeassistant.md), which talks about my IP camera that was seemingly taken control of by some \\"rando.\\" So, I decided to simply restrict my usage to my local network, I\'ll go without global accessibility for now.\\n\\n## What Has Changed?\\n\\nAh, but wait, now I work for [NetFoundry](https://netfoundry.io/), which provides the world with free, open source, zero trust networking through what they call \\"[OpenZiti](https://github.com/openziti).\\" So I had a couple of options, I could use their [free tier](https://netfoundry.io/pricing/) which is where they host the [overlay network](https://openziti.github.io/ziti/overview.html#overview-of-a-ziti-network), and I just connect my services to their network. But as you will see, it\'s so easy to host my own overlay network, why not just do that? In fact, I already set up a hosted network on an Oracle instance that I created for accessing Home Assistant over the internet, you can see how I did that in [this article](./zero-trust-overlay-network-to-access-homeassistant.md).\\n\\nNow, I know what you\'re thinking, \\"Why don\'t you just use a VPN?\\". Well, VPNs are great tools and will provide internet access to devices on my local network. However, VPNs don\'t do what I want and may require opening ports on my home network firewall. Of course, I can modify the firewall rules to limit access to specific IPs and ports, but I like the features of zero trust, the usage is essentially the same. However, zero trust implemented with my hosted network doesn\'t require modifying my local firewall, so I don\'t need to be concerned with ensuring that my firewall configuration is correctly set up; all the setup is in the network. That\'s where a zero trust network comes in, it doesn\'t require opening up any ports locally, and it will only provide authenticated users to access my NAS, even though I have many other things hosted on my network.\\n\\n## The current network\\n\\nThe way it stands now, I can only access my NAS from home.\\n\\n![OpenZiti HomeAssistant Network Architecture - NAS Without Ziti.png](/blogs/openziti/v1662648067724/X4tRrDGBK.png)\\n\\n## So How\'d You Do It?\\n\\nI thought you\'d never ask, implementing a self-hosted zero trust network is much easier than one might think. There\'s a pretty simple process, actually really simple with the use of \\"[Express Install](https://openziti.io/docs/learn/quickstarts/network/hosted).\\" The general process is as follows;\\n\\n1. Acquire a VPC to host the controller (if you don\'t mind opening ports, you could host your own locally)\\n    \\n2. Expose the appropriate ports on *that* host for the overlay devices to communicate\\n    \\n3. Create a controller and Edge Router for the overlay network\\n    \\n4. Create an Edge Router on your home device (NAS in this case)\\n    \\n    * This can be a router, tunnel, or \\"zitified\\" application\\n        \\n5. Create the appropriate service, configs, and policies so the network can communicate\\n    \\n6. Create an identity for those who you deem worthy of having access to your NAS\\n    \\n\\n### Acquire a VPC to host the controller\\n\\nI used [Oracle Cloud Infrastructure](https://www.oracle.com/cloud/) (OCI) as they have a [free tier](https://www.oracle.com/cloud/free/) that is free, and you can\'t accidentally use any paid-for services without upgrading your account. You could use any VPC you want, though, and as mentioned, if you don\'t mind opening ports, you could host your own locally, but my goal was to *not* open local ports. I used a free tier Canonical Ubuntu image for my server.\\n\\n### Expose the appropriate ports\\n\\nThe controller host must have a few ports open for communication on the overlay network. For full functionality, open the following ports;\\n\\n* 8441 - The Controller port (this allows you to use the controller API)\\n    \\n* 8442 - The Edge Router port\\n    \\n* 8443 - The Ziti Console port (optional)\\n    \\n* 6262 - For Router to Controller communication\\n    \\n* 10080 - For Router to Router communication\\n    \\n* 22 - This one may already be open, but you should restrict it to your home IP\\n    \\n\\nOracle has a little quirk that makes it less intuitive than other cloud providers. You not only have to create a \\"Security List,\\" but you have to open up the local instance firewall as well. The security list is trivial but for a little help opening up the local firewall ports, check out the example below.\\n\\nsudo firewall-cmd --zone=public --add-port=8441/tcp --permanent # ... repeat for the other four ports sudo systemctl restart firewalld\\n\\n### Create a Controller and Edge-Router\\n\\nThis step is easy as a one-dish ziti casserole, ssh into your intended host and run the [express install for \\"host it anywhere\\"](https://openziti.io/docs/learn/quickstarts/network/hosted). If the few steps were followed correctly, you\'ve set up a Controller and Edge-Router on your host, and you\'re ready for the next step.\\n\\n### Create an Edge Router on your home device\\n\\nYou can create a private Edge Router hosted on the NAS, but the route I took, which is even easier, was to host a Ziti Tunnel which avoids the configuration setup for an Edge Router.\\n\\nCreate the identity in your controller, enroll that puppy, and you\'ll have all your network \\"devices\\" set up.\\n\\n### Create the Service, Configs, and Policies\\n\\nNow I need five essential things for the configuration setup of our network. I\'ll need the service, of course, this is the \\"address\\" used to access the resource. I\'ll need two service configs; one host, and one intercept. I\'ll need two service policies; one bind, and one dial. The configs define the address of the service you\'re hosting and the address of the service you will be dialing on the OpenZiti Network. The service is the mechanism that links those configs together, and the service policies define who/what will have access to host, or connect to a service. The service policy has a nice feature in that you can give access based on attributes, so in my case, I can create identities for all my family members and give them all an attribute of `berlhome.berlcloud.clients` so they automatically have access to use my network storage.\\n\\n### Create an identity for those who you deem worthy\\n\\nFor now, I\'m just creating one identity that I\'ll call `geoff.phone`, which will be used on my cell phone. That\'s one other nice feature of zero trust networks, enrollment can only take place once so that a user won\'t have access to your service from just anywhere; you\'ll have to be on the device that performed the enrollment.\\n\\n## Too wordy, just give me the code\\n\\nOkay, I\'ve been known to ramble, if you just want the code and want to work your way through it, here is what we call a \\"cheat sheet.\\" It\'s just a collection of commands needed to get set up, but it\'s up to you to adjust them as needed for your situation.\\n\\n\\\\# Create a user identity: `ziti edge create identity user geoff.phone -o geoff.phone.jwt -a \\"berlhome.berlcloud.clients\\"`\\n\\n\\\\# Create the identity: `ziti edge create identity device berlhome.berlcloud -a berlhome.berlcloud.servers -o berlhome.berlcloud.jwt ziti edge enroll berlhome.berlcloud.jwt`\\n\\n\\\\# Create the configs and service: `ziti edge create config berlhome.berlcloud.hostv1 host.v1 \'{\\"protocol\\":\\"tcp\\", \\"address\\":\\"localhost\\",\\"port\\":\'5000\'}\' ziti edge create config berlhome.berlcloud.interceptv1 intercept.v1 \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"berlhome.berlcloud.ziti\\"], \\"portRanges\\":[{\\"low\\":\'5000\', \\"high\\":\'5000\'}]}\' ziti edge create service berlhome.berlcloud --configs \\"berlhome.berlcloud.hostv1,berlhome.berlcloud.interceptv1\\"`\\n\\n\\\\# Create the service policies: `ziti edge create service-policy berlhome.berlcloud.bind Bind --service-roles \'@berlhome.berlcloud\' --identity-roles \'#berlhome.berlcloud.servers\' ziti edge create service-policy berlhome.berlcloud.dial Dial --service-roles \'@berlhome.berlcloud\' --identity-roles \'#berlhome.berlcloud.clients\'`\\n\\n## The New Network\\n\\n![OpenZiti HomeAssistant Network Architecture - NAS With Ziti.png](/blogs/openziti/v1663003673358/YO8IQD_W2.png)\\n\\n## Conclusion\\n\\nWith some pretty simple setup, I can now access my NAS from anywhere I have internet access. So now I have not only the security of the zero trust network but also the credentialed login to my \\"BerlCloud.\\" The best part is I could gain access to the NAS to have it host the ziti tunnel, directing all NAS traffic directly to that device and only that device."},{"id":"introducing-openziti-browzer","metadata":{"permalink":"/docs/openziti/blog/introducing-openziti-browzer","source":"@site/blog/introducing-openziti-browzer.md","title":"Introducing OpenZiti BrowZer","description":"I am pleased to introduce you to BrowZer, a new group of open source components that collectively enable you and your organization, enterprises and self-hosting enthusiasts alike, in the cloud or at home, to operate private-to-the-internet web applications while still easily providing secure access for your authorized internet-based remote users.","date":"2022-09-12T21:49:23.000Z","tags":[{"inline":false,"label":"Web Development","permalink":"/docs/openziti/blog/tags/web-development","description":"Web development content"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":10.87,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"title":"Introducing OpenZiti BrowZer","seoDescription":"Open source components to enable private-to-the-internet web application security while still easily providing access for authorized remote users.","date":"2022-09-12T21:49:23.000Z","cuid":"cl7zashi604a0fxnv038w59b1","slug":"introducing-openziti-browzer","authors":["CurtTudor"],"image":"@site/blogs/openziti/v1662574403443/kofV_IBBh.jpg","imageDark":"@site/blogs/openziti/v1662574403443/kofV_IBBh.jpg","tags":["web-development","security","zerotrust"]},"unlisted":false,"prevItem":{"title":"Free Secure Access to NAS From Anywhere","permalink":"/docs/openziti/blog/free-secure-access-to-nas-from-anywhere"},"nextItem":{"title":"Golang Aha! Moments: Channels","permalink":"/docs/openziti/blog/golang-aha-moments-channels"}},"content":"I am pleased to introduce you to `BrowZer`, a new group of open source components that collectively enable you and your organization, enterprises and self-hosting enthusiasts alike, in the cloud or at home, to operate private-to-the-internet web applications while still easily providing secure access for your authorized internet-based remote users.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe `Z` in this article\'s title, within the word normally spelled \\"*browser*\\", is not a typo. It is a purposeful indication that we are bringing you a solution, unique in today\'s technology offerings, for securing browser-based applications. This solution is built as part of the [Open**Z**iti](https://github.com/openziti/) project.\\n\\nOpenZiti enables developers to embed secure networking into their applications, as code. With BrowZer, we extend that revolution by also enabling developers to automatically embed [zero trust](https://openziti.github.io/ziti/overview.html) networking in the browser, transforming it into a full-fledged OpenZiti client.\\n\\nIn this context, *private* doesn\'t mean *invite only*. Here, private means the web application is *dark* \u2014 with no open incoming ports on your cloud instance \u2014 nor any port-forwarding on your home internet cable modem/router.\\n\\nAnd while your web application will be invisible to, and thus protected from, malicious attackers on the internet, BrowZer still facilitates simple and secure access for remote users that you authorize. And it does so without requiring your users to install any additional software on their client-side laptop, tablet, or mobile phone. Again, all they need is the browser they already use every day.\\n\\nAlso noteworthy is that BrowZer places no burden upon web application developers to first instrument or otherwise make any modifications to the web application itself in order to enable remote access to its dark deployment.\\n\\nThis is a great enabler. For example, if you are operating a web app licensed from a 3rd party that you want to make dark (e.g. [Mattermost](https://netfoundry.io/why-we-switched-to-mattermost/)), and you can\'t make alterations to it, there\'s no problem. The same goes for a web app you *can* alter, but elect not to.\\n\\nBrowZer has you covered because it does the necessary [Zitification](./zitification.md) instrumentation of your web application automatically, on the fly, as it is being loaded from the web server to the user\'s browser. It\'s what I call touchless-Zitification. More details on how this is accomplished are discussed below.\\n\\nOK, that was a mouthful, so let\'s unpack what was just said.\\n\\n# Traditional Web App Security\\n\\nTo help you better understand how BrowZer works, and why we are building it, let\'s first consider an example that highlights the traditional challenges that can occur when remote users require access to a critical web application located in a private network.\\n\\nUsually, some kind of gateway bridges access into a private network. For example, the gateway could be a VPN or an SSH bastion host. Both solutions offer varying degrees of security, but, the side effects might not be acceptable.\\n\\n![image.png](/blogs/openziti/v1662656432216/z6354leaK.png)\\n\\nThis traditional access model is not well suited for cloud-native highly ephemeral environments (like K8S). Also, scaling this type of solution as company workforces and infrastructure grows or fluctuates also creates substantial pain points and complexity for administrators.\\n\\nSpeaking of pain, remote users typically dislike or experience technical struggles installing, configuring, and using VPN software on their (*sometimes personal*) laptops and mobile phones.\\n\\nLet\'s not forget that once users gain access to these private networks using traditional access models, they can access any system on the network, and not just the intended target. The dangerous follow-on is that if the credentials used to access the VPN or SSH host fall into the wrong hands, a malicious actor could access the entire network.\\n\\nTraditional workflows typically place a firewall inside private networks that restricts what users have access to in order to safeguard against this risk. However, managing internal firewalls is time-consuming, tedious, error-prone, and wasteful, when the system granting access should have followed the principle of least privilege from the outset.\\n\\n# Modern Web App Security via BrowZer\\n\\nBrowZer\'s mission is to simplify workflows involved with providing zero trust access to private web applications while simultaneously reducing the attack surface associated with traditional solutions.\\n\\nWith OpenZiti in general, and certainly with BrowZer, access is based on the trusted identity of the user, rather than their network location. The user first authenticates to the network, then connects to the network, and only then, based on their assigned roles, can they connect to web applications made available to them \u2014 with role-based access controls (RBAC).\\n\\nIt bears repeating:\\n\\nBrowZer enforces a pattern of ***authenticate-before-connect*** and the ***principle of least privilege*** for your web applications.\\n\\nTrusted [identities](https://openziti.io/docs/learn/core-concepts/identities/overview) and roles are a core principle in OpenZiti BrowZer. They define which users are allowed to connect with which specific set of web applications.\\n\\nFor example, with BrowZer, you could grant only developers access to connect to a Jenkins web app and grant only HR members to a payroll web app, even while both web apps are operating within the same private network.\\n\\nThis model allows BrowZer to define logical sets of web applications and removes the brittleness associated with static IP addresses.\\n\\n# Big Picture\\n\\nThe diagram below depicts how various components connect to each other in a BrowZer deployment.\\n\\n![image.png](/blogs/openziti/v1663013534461/fw9fqJOaE.png)\\n\\nAlthough this diagram shows the target web app example is [Apache Guacamole](https://guacamole.apache.org/), BrowZer supports any web app. If you are unfamiliar with Guacamole, it is an open-source RDP, VNC, and SSH gateway. And yes, BrowZer supports HTML5-based RDP.\\n\\n> *Note that my upcoming blog articles will do deep technical dives into BrowZer RDP support, so be sure to subscribe to this blog to receive further educational materials*\\n\\nNow let\'s discuss the various BrowZer components.\\n\\n## Authentication in a BrowZer Environment\\n\\nBelow is a (*simplified*) diagram depicting the network-auth flow from user to a web application in a BrowZer environment.\\n\\n![image.png](/blogs/openziti/v1662733522760/XoZApNB43.png)\\n\\nYou\'ll notice that similar to the traditional model, there is still a gateway (*more details on that below*). But with BrowZer, the user doesn\'t provide a unique VPN credential or SSH key.\\n\\nInstead, users need to perform a **single sign-on** (SSO) that provides a strong assertion of the user\'s identity.\\n\\nBrowZer requires that an Identity Provider (IdP) be associated with the network. Which IdP is used is up to you. It could be ADFS, AzureAD, Okta, Auth0, ...whatever.\\n\\nYou can even enable [MFA](https://en.wikipedia.org/wiki/Multi-factor_authentication) if you like. This is pluggable by design.\\n\\nThe example in the above diagram shows BrowZer using Auth0 which in turn federates out to Google for authn, but BrowZer doesn\'t care who the IdP is. It uses OpenID Connect (OIDC) protocol to integrate with your IdP. Bring whatever your favorite or existing solution is. BrowZer just needs your web application users to be able to prove who they are.\\n\\n> *While there are no burdensome VPN credentials or SSH bastion host keys to manage, BrowZer does involve a little upfront administration in the Ziti network to inform the control plane about the IdP. Note that my upcoming blog articles will do deep technical dives into BrowZer-IdP integration, so be sure to subscribe to this blog to receive further educational materials*\\n\\n![image.png](/blogs/openziti/v1662670313410/t71lKyYuC.png)\\n\\nWith a small amount of network admin work out of the way, the user-facing flow that BrowZer enables for your dark web application is intentionally designed to be very simple, and friction-free.\\n\\nOn the client side, it will look like the following:\\n\\n1. open your favorite browser (on a laptop, mobile phone, tablet, etc)\\n    \\n2. surf to URL representing dark web app (see discussion of gateway below)\\n    \\n3. perform an SSO\\n    \\n4. enjoy using the dark web app\\n    \\n\\nNo fuss.\\n\\nBrowZer authenticates and authorizes web request flows, and maps users to web applications at a logical [service](https://openziti.io/docs/learn/core-concepts/services/overview) level. This is important because it lets you elevate from the dynamic details \u2014 no more worrying about IP addresses.\\n\\n# The BrowZer Gateway (Ziti HTTP Agent)\\n\\nAs mentioned above, BrowZer environments have a gateway. But unlike traditional approaches (like VPNs) where all network traffic from all remote users funnels into and is concentrated within a single gateway, BrowZer takes a different, and novel approach.\\n\\nIn an OpenZiti BrowZer deployment, the component that acts as the gateway is something we refer to as the **HTTP Agent**.\\n\\nThe HTTP Agent has the following responsibilities:\\n\\n* Ensure all incoming HTTP requests have an established BrowZer-Session, and if they do not, to redirect out to the IdP so the user can authenticate themselves\\n    \\n* Inject a component into the browser \u2014 something we refer to as the Ziti BrowZer Runtime (see discussion of the ZBR below)\\n    \\n* Respond to requests from the now browser-resident-ZBR to load other BrowZer components \u2014 namely the Ziti BrowZer Service Worker, and the Ziti BrowZer WebAssembly \u2014 to complete the Zitified web app boot-strapping process.\\n    \\n\\nThe Ziti HTTP Agent then gets out of the way.\\n\\n# The Ziti BrowZer Runtime (ZBR)\\n\\nThe ZBR is a JavaScript component that is transparently injected into the web app as it is being loaded into the browser. Once the ZBR is resident within the browser, all further traffic between the browser and the dark web application does not involve the HTTP Agent at all.\\n\\n> *Note that my upcoming blog articles will do deep technical dives into the Ziti BrowZer Runtime, so be sure to subscribe to this blog to receive further educational materials*\\n\\nFor now, just understand that the ZBR will intercept all `fetch`, `XHR`, and `WebSocket` requests, as well as some HTML5 events.\\n\\nIf something is happening in the browser that requires contact with the dark web app, the ZBR is responsible for facilitating it.\\n\\nAll HTTP requests are examined, and those requests targeting the dark web app are transparently routed directly from the browser to a Ziti Edge Router on the network, where the requests will ultimately be delivered to the dark web app residing inside the network.\\n\\nIf an HTTP request targets a resource that is not associated with the dark web app (e.g. a POST to Google Analytics), the ZBR will simply let it go to the raw internet for processing.\\n\\n# The Ziti BrowZer Service Worker (ZBSW)\\n\\nThe ZBSW is a JavaScript component that is transparently injected into the web app by the ZBR as it is being loaded. Once the ZBSW is resident within the browser, all network requests originating within the DOM (e.g. loads of JavaScript, CSS, fonts, etc) are examined, and those requests that are targeting the dark web app are transparently routed directly from the browser to a Ziti Edge Router on the network, where the requests will be delivered to the dark web app residing inside the network.\\n\\nIf a DOM request targets a resource that is not associated with the dark web app (e.g. a resource load from the [JsDelivr](https://www.jsdelivr.com/) CDN), the ZBR will simply let it go to the raw internet for processing.\\n\\n# The BrowZer WebAssembly\\n\\nIn addition to the JavaScript components described above, BrowZer involves some WebAssembly components as well.\\n\\nBrowZer does some heavy lifting involving dynamic PKI (key-pair generation, CSR generation, x509 certificate acquisition), it also does its own mTLS handshakes and message encrypt/decrypt.\\n\\nYes, you heard that right. BrowZer does not use the browser\'s native ability to do mTLS.\\n\\nBrowZer does all crypto work itself, at the JavaScript runtime level.\\n\\nThe reasons for this revolve around the necessity to employ x509 certs to accomplish trusted connections between the browser and the Edge Router(s). Since nothing can be installed on clients ahead of time, including certificates, the certificates are acquired from the control plane dynamically (a ZBR-to-Controller conversation), and the certs are subsequently used by mTLS logic within the ZBR.\\n\\nBrowZer also does some end-to-end (E2E) encryption if you enable it. E2E encryption means that data passing between the browser-resident web app JavaScript, and the dark web app server, is encrypted even ***before*** it gets written to the wire at the mTLS level.\\n\\nTranslation: double encryption for your web app traffic as it traverses the network.\\n\\n> *Note that my upcoming blog articles will do deep technical dives into the Ziti BrowZer WASM, and how mTLS and E2E encryption work is done at the JavaScript runtime level, so be sure to subscribe to this blog to receive further educational materials*\\n\\n# Wrap up\\n\\nDo you host a web app and want to be invisible to malicious intruders?\\n\\nDo you want your users to have easy access from anywhere with no additional software on their client devices?\\n\\nDo you want to do all this without making any modifications to your web app?\\n\\nIf you are nodding yes, then we hope you\'ll reach out for a conversation about BrowZer.\\n\\nPlease stay tuned to this blog for more information concerning how you can get started."},{"id":"golang-aha-moments-channels","metadata":{"permalink":"/docs/openziti/blog/golang-aha-moments-channels","source":"@site/blog/golang-aha-moments-channels.md","title":"Golang Aha! Moments: Channels","description":"Introduction","date":"2022-09-09T00:40:45.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Developer","permalink":"/docs/openziti/blog/tags/developer","description":"Developer topics"},{"inline":false,"label":"Channels","permalink":"/docs/openziti/blog/tags/channels","description":"Communication channels"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"golang-aha","permalink":"/docs/openziti/blog/tags/golang-aha","description":"Golang Ahas!"}],"readingTime":8.35,"hasTruncateMarker":true,"authors":[{"name":"Paul Lorenz","title":"Author","url":"https://github.com/plorenz","imageURL":"https://avatars.githubusercontent.com/plorenz","key":"PaulLorenz","page":null}],"frontMatter":{"title":"Golang Aha! Moments: Channels","date":"2022-09-09T00:40:45.000Z","cuid":"cl7tr5gdz01hqpgnv7zbl75uh","slug":"golang-aha-moments-channels","authors":["PaulLorenz"],"image":"@site/blogs/openziti/v1662683219596/YY8xRufSo.jpg","imageDark":"@site/blogs/openziti/v1662683219596/YY8xRufSo.jpg","tags":["golang","developer","channels","openziti","golang-aha"]},"unlisted":false,"prevItem":{"title":"Introducing OpenZiti BrowZer","permalink":"/docs/openziti/blog/introducing-openziti-browzer"},"nextItem":{"title":"I Created a Zero Trust Overlay Network to Access HomeAssistant","permalink":"/docs/openziti/blog/zero-trust-overlay-network-to-access-homeassistant"}},"content":"## Introduction\\n\\nI work with Golang every day as a developer on the [OpenZiti project](http://openziti.io). In learning Go, \\nI\'ve hit various stumbling blocks, settled on some best practices and hopefully gotten better at writing Go code. \\nThis series exists to share some of the \'Aha!\' moments I\'ve had overcoming obstacles and finding solutions that \\nsparked joy.\\n\\n\x3c!-- truncate --\x3e\\n\\nThis [series](./tags/golang-aha) is targeted both at new team members and for anyone in the Go community who might be interested. We\'d be very happy to hear from others about their own \'aha\' moments and also how the solutions presented strike your sensibilities. Suggested improvements, corrections and constructive criticism are welcome.\\n\\nThis first installment will cover various topics related to Go channels.\\n\\n## Channels\\n\\nChannels are a core feature of Go. As is typical of Go, the channel API is small and simple, but provides a lot of power.\\n\\nSee here for a quick [Go channels refresher](https://go.dev/tour/concurrency/2). Also, if you haven\'t read it yet, Dave Cheney\'s [Channel Axioms](https://dave.cheney.net/2014/03/19/channel-axioms) is worth a look.\\n\\n## Channels For Signals\\n\\n### Simple Broadcast\\n\\nThere are a few ways we can use channels to signal other goroutines. The first is if we want to broadcast a one time notification. For example, if you have a something with several associated goroutines and you want to clean them all up together, you can use a single unbuffered channel which they can monitor for closes.\\n\\nAs an example, you might have a UDP socket listener that\'s handling UDP connections. Since UDP doesn\'t have timeouts, you need to make sure that idle connections are eventually cleaned up. So you create an idle connection scanner. You want the goroutine for this scanner to stop when the UDP socket listener is closed, so you pass it a channel that you\'ll close when the socket is closed.\\n\\n```golang\\nimport (\\n\\t\\"time\\"\\n)\\n\\ntype IdleScanner struct {\\n\\tcloseNotify <-chan struct{}\\n}\\n\\nfunc (self *IdleScanner) run() {\\n\\tticker := time.NewTicker(time.Minute)\\n\\tdefer ticker.Stop()\\n\\n\\tfor {\\n\\t\\tselect {\\n\\t\\tcase <- ticker.C:\\n\\t\\t\\t// scan for idle connections\\n\\t\\tcase <- self.closeNotify:\\n\\t\\t\\treturn // shutting down\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nNote that the `IdleScanner` has a `<- chan`, so it can only check if the channel is closed, it cannot close the channel itself.\\n\\nThis pattern can be seen in several places in OpenZiti. Here\'s one in a UDP connection handling context:\\n\\n* https://github.com/openziti/edge/blob/v0.22.89/tunnel/udp\\\\_vconn/conn.go#L51\\n    \\n\\nNote that this pattern does have one downside for handling shutdown behavior, namely that you can signal components to shut down, but you can\'t tell when all the components are finished shutting down. In many use cases this is fine, but there are places where this would be a problem.\\n\\n### Wake Signal\\n\\nIn this example we have something running periodically, but we want to be able to trigger it to run sooner. With a single element channel, we can notify a goroutine. By using `select` with`default`, we can ensure that signalling code doesn\'t block and that the receiving side only gets a single signal per loop.\\n\\n```golang\\npackage main\\n\\nimport (\\n\\t\\"fmt\\"\\n\\t\\"sync/atomic\\"\\n\\t\\"time\\"\\n)\\n\\nfunc NewWorker() *Worker {\\n\\tw := &Worker{\\n\\t\\tsignal:  make(chan struct{}, 1),\\n\\t}\\n\\tgo w.run()\\n\\treturn w\\n}\\n\\ntype Worker struct {\\n\\tsignal chan struct{}\\n\\tstopped atomic.Bool\\n}\\n\\nfunc (self *Worker) run() {\\n\\tticker := time.NewTicker(time.Minute)\\n\\tdefer ticker.Stop()\\n\\n\\tfor !self.stopped.Load() {\\n\\t\\tselect {\\n\\t\\tcase <-ticker.C:\\n\\t\\t\\tself.work()\\n\\t\\tcase <-self.signal:\\n\\t\\t\\tself.work()\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (self *Worker) work() {\\n\\tif !self.stopped.Load() {\\n\\t\\tfmt.Println(\\"working hard\\")\\n\\t}\\n}\\n\\nfunc (self *Worker) RunNow() {\\n\\tselect {\\n\\tcase self.signal <- struct{}{}:\\n\\tdefault:\\n\\t}\\n}\\n```\\n\\nThis is used in OpenZiti in an event processor to force quicker evaluation of events for tests. See here:\\n\\n* https://github.com/openziti/edge/blob/v0.22.89/controller/persistence/eventual\\\\_eventer.go#L404\\n    \\n\\n## Closing Multi-writer Channels\\n\\nClosing channels can be complicated. On the reader side, things are generally simple. A read on a closed channel will return immediately with the zero value and flag indicating that it is closed.\\n\\n```golang\\nfunc main() {\\n\\tch := make(chan interface{}, 1)\\n\\tch <- \\"hello\\"\\n\\tval, ok := <- ch\\n\\n\\tfmt.Printf(\\"%v, %v\\\\n\\", val, ok) // prints hello, true\\n\\n\\tclose(ch)\\n\\n\\tval, ok = <- ch\\n\\tfmt.Printf(\\"%v, %v\\\\n\\", val, ok) // prints <nil>, false\\n}\\n```\\n\\nOn the writer side, things can be more complicated. If you only have a single writer, it can be responsible for closing the channel. This notifies any blocker readers that the channel is closed. However, if there are multiple writers, this won\'t work. Writing to a closed channel will cause a panic. Closing an already closed channel will also cause a panic. So what to do?\\n\\nThe realization I eventually had was that the channel doesn\'t need to be closed. What we want to achieve is making sure the readers and writers are safely notified that they should stop trying to use the channel. For this, we can use a second channel, following the broadcast pattern shown above.\\n\\nHere is an example of a multi-reader/multi-writer queue which can be closed, notifying writers and readers that no further reads or writes should be made.\\n\\n```golang\\npackage main\\n\\nimport (\\n\\t\\"errors\\"\\n\\t\\"sync/atomic\\"\\n)\\n\\ntype Queue struct {\\n\\tch          chan int\\n\\tcloseNotify chan struct{}\\n\\tclosed      atomic.Bool\\n}\\n\\nfunc (self *Queue) Push(val int) error {\\n\\tselect {\\n\\tcase self.ch <- val:\\n\\t\\treturn nil\\n\\tcase <-self.closeNotify:\\n\\t\\treturn errors.New(\\"queue closed\\")\\n\\t}\\n}\\n\\nfunc (self *Queue) Pop() (int, error) {\\n    if self.closed.Load() {\\n\\t\\treturn 0, errors.New(\\"queue closed\\")\\n    }        \\n\\tselect {\\n\\tcase val := <-self.ch:\\n\\t\\treturn val, nil\\n\\tcase <-self.closeNotify:\\n\\t\\treturn 0, errors.New(\\"queue closed\\")\\n\\t}\\n}\\n\\nfunc (self *Queue) Close() {\\n\\tif self.closed.CompareAndSwap(false, true) {\\n\\t\\tclose(self.closeNotify)\\n\\t}\\n}\\n```\\n\\nA variation on this would let readers drain the channel once it\'s closed. Because select case evaluation is random, we may not read a val from the channel once the close notify channel is closed. We can ensure that we return a value if it\'s available by modifying `Pop()` as follows:\\n\\n```golang\\nfunc (self *Queue) Pop() (int, error) {\\n\\tselect {\\n\\tcase val := <-self.ch:\\n\\t\\treturn val, nil\\n\\tcase <-self.closeNotify:\\n\\t\\tselect {\\n\\t\\tcase val := <-self.ch:\\n\\t\\t\\treturn val, nil\\n\\t\\tdefault:\\n\\t\\t\\treturn 0, errors.New(\\"queue closed\\")\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nThis pattern is used in several places in OpenZiti, including in the binary message framework (somewhat confusing also called channel) and the mesh network flow control.\\n\\n* https://github.com/openziti/channel/blob/v1.0.2/impl.go (see rxer, txer)\\n    \\n* https://github.com/openziti/fabric/blob/v0.19.64/router/xgress/xgress.go (littler harder to see, but can start with `closeNotify` in the xgress struct)\\n    \\n\\n## Semaphores and Pools\\n\\nBecause channels have a sized buffer and well defined blocking behavior, creating a semaphore implementation is very straightforward. We can create a channel with a buffer of the size we want our semaphore to have. We can then read and write from the channel to acquire and release the semaphore.\\n\\n```golang\\npackage concurrenz\\n\\nimport \\"time\\"\\n\\ntype Semaphore interface {\\n\\tAcquire()\\n\\tAcquireWithTimeout(t time.Duration) bool\\n\\tTryAcquire() bool\\n\\tRelease() bool\\n}\\n\\nfunc NewSemaphore(size int) Semaphore {\\n\\tresult := &semaphoreImpl{\\n\\t\\tc: make(chan struct{}, size),\\n\\t}\\n\\tfor result.Release() {\\n\\t}\\n\\treturn result\\n}\\n\\ntype semaphoreImpl struct {\\n\\tc chan struct{}\\n}\\n\\nfunc (self *semaphoreImpl) Acquire() {\\n\\t<-self.c\\n}\\n\\nfunc (self *semaphoreImpl) AcquireWithTimeout(t time.Duration) bool {\\n\\tselect {\\n\\tcase <-self.c:\\n\\t\\treturn true\\n\\tcase <-time.After(t):\\n\\t\\treturn false\\n\\t}\\n}\\n\\nfunc (self *semaphoreImpl) TryAcquire() bool {\\n\\tselect {\\n\\tcase <-self.c:\\n\\t\\treturn true\\n\\tdefault:\\n\\t\\treturn false\\n\\t}\\n}\\n\\nfunc (self *semaphoreImpl) Release() bool {\\n\\tselect {\\n\\tcase self.c <- struct{}{}:\\n\\t\\treturn true\\n\\tdefault:\\n\\t\\treturn false\\n\\t}\\n}\\n```\\n\\nWe could use mostly the same implementation for a resource pool. Instead of a channel of `struct{}`, we could have a channel of connections or buffers that are acquired and released.\\n\\nThis semaphore implementation is here:\\n\\n* https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/semaphore.go\\n    \\n\\nGolang does have a weighted semaphore implementation in the extended libraries here: https://pkg.go.dev/golang.org/x/sync/semaphore which may be preferable.\\n\\nThat said, there are lots of ways to implement semaphores, but I appreciate how this implementation showcases some of the power and simplicity of Go channels.\\n\\n## Event Handler Loops\\n\\nWe often have a loop which is processing inputs from one or more channels. This is usually to keep a set of data local to a single goroutine, so we don\'t have to use any synchronization or worry about CPU cache effects. We use channels to feed data to the goroutine and/or to trigger different kinds of processing. A `for` with `select` loop can handle channels of different types. A first impulse might be to have a channel per type of work, or per type of data. However you can also use a single channel which takes an interface.\\n\\nHere\'s a simple example where the processor is maintaining some cached data which can be updated externally. Presumably the processor would be doing something with the cached data, but we\'ve left that out to focus on the pattern itself.\\n\\n```golang\\ntype Event interface {\\n\\t// events are passed the processor so they don\'t each have to include it\\n\\tHandle(*Processor)\\n}\\n\\ntype Processor struct {\\n\\tch          chan Event\\n\\tcloseNotify chan struct{}\\n\\tcache map[string]string\\n}\\n\\nfunc (self *Processor) run() {\\n\\tfor {\\n\\t\\tselect {\\n\\t\\tcase event := <-self.ch:\\n\\t\\t\\tevent.Handle(self)\\n\\t\\tcase <-self.closeNotify:\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (self *Processor) queueEvent(evt Event) {\\n\\tselect {\\n\\tcase self.ch <- evt:\\n\\tcase <-self.closeNotify:\\n\\t\\treturn\\n\\t}\\n}\\n\\nfunc (self *Processor) UpdateCache(k, v string) {\\n\\tself.queueEvent(&updateCache{key: k, value: v})\\n}\\n\\nfunc (self *Processor) Invalidate(k string) {\\n\\tself.queueEvent(invalidate(k))\\n}\\n\\ntype updateCache struct {\\n\\tkey string\\n\\tvalue string\\n}\\n\\nfunc (self *updateCache) Handle(p *Processor) {\\n\\tp.cache[self.key] = self.value\\n}\\n\\ntype invalidate string\\n\\nfunc (self invalidate) Handle(p *Processor) {\\n\\tdelete(p.cache, string(self))\\n}\\n```\\n\\nThis can be seen in OpenZiti here:\\n\\n* https://github.com/openziti/sdk-golang/blob/v0.16.119/ziti/edge/msg\\\\_mux\\\\_ch.go#L104\\n    \\n\\nNote that over time we\'ve used this pattern less and moved more to using explicitly concurrent data structures. For example, we generally don\'t use the above type any more and instead use a different implementation which uses a copy-on-write map, as the data that was being protected was rarely being written, but read often. The alternative version can be found here: https://github.com/openziti/sdk-golang/blob/v0.16.119/ziti/edge/msg\\\\_mux.go (not yet updated for generics).\\n\\nFunnily enough, after my initial post I found myself using this pattern again in some metrics processing code. I\'ll update this post once the code is complete.\\n\\n*The Go Gopher was created by* [*Renee French*](http://reneefrench.blogspot.com/) *and is licensed under* [*Creative Commons Attribution 3.0*](https://creativecommons.org/licenses/by/3.0/) *(see https://go.dev/blog/gopher)*"},{"id":"zero-trust-overlay-network-to-access-homeassistant","metadata":{"permalink":"/docs/openziti/blog/zero-trust-overlay-network-to-access-homeassistant","source":"@site/blog/zero-trust-overlay-network-to-access-homeassistant.md","title":"I Created a Zero Trust Overlay Network to Access HomeAssistant","description":"I Created a Zero Trust Overlay Network to Access HomeAssistant","date":"2022-08-31T00:00:00.000Z","tags":[{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"Overlay Networking","permalink":"/docs/openziti/blog/tags/overlaynetworking","description":"Overlay networking"},{"inline":false,"label":"Home Assistant","permalink":"/docs/openziti/blog/tags/homeassistant","description":"Home Assistant integrations"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":9.52,"hasTruncateMarker":true,"authors":[{"name":"Geoff Berl","title":"Author","url":"https://github.com/gberl002","imageURL":"https://avatars.githubusercontent.com/gberl002","key":"GeoffBerl","page":null}],"frontMatter":{"slug":"zero-trust-overlay-network-to-access-homeassistant","title":"I Created a Zero Trust Overlay Network to Access HomeAssistant","authors":["GeoffBerl"],"date":"2022-08-31T00:00:00.000Z","tags":["zero-trust","overlaynetworking","homeassistant","security"]},"unlisted":false,"prevItem":{"title":"Golang Aha! Moments: Channels","permalink":"/docs/openziti/blog/golang-aha-moments-channels"},"nextItem":{"title":"My Intern Assignment - Call a Dark Webhook from AWS Lambda","permalink":"/docs/openziti/blog/my-intern-assignment-call-a-dark-webhook-from-aws-lambda"}},"content":"## I Created a Zero Trust Overlay Network to Access HomeAssistant\\n\\n## Backstory\\n### Solving Problems\\nI wanted a way to check on my house (mainly my dogs) while I was away. So, I did what any trendy person would do and \\nbought an IP camera with pan and tilt, which was great. A quick sign-up to their proprietary app, and I could view \\nlive video of my pups tearing apart my house from anywhere in the world.\\n\\n\x3c!-- truncate --\x3e\\n\\n![image.png](/blogs/openziti/v1661350622005/r1QoFC6Lq.png?height=300)\\n\\n### Somebody\'s Watching Me\\nThe camera happened to sit atop my computer desk, and I kept hearing a buzzing noise one day while working. After searching frantically for every brief moment I heard this noise, to my surprise I saw it was my IP cam panning. I thought, hmm, that\'s odd... I\'ll turn it off and back on again, maybe a motor started going haywire. After its boot sequence it seemed stable _pats self on back, you did it buddy_.\\n\\nColor me surprised when I started hearing it again... I started wondering, have I been hacked? So I turn the camera to face the wall, and almost immediately, it pans until it\'s pointing back at me. Growing more concerned, I turned it again, and yet again, it panned until it again pointed at me. So, I found a nearby box, turned it upside down, and plopped it on the camera... now what\'ll it do? To my surprise, it was repeatedly panning and tilting, so I was left to believe it was someone accessing the camera and was trying to pan and tilt to figure out where the action was.\\n\\n### Time To Don The Tin Hat\\n<img class=\\"floatLeft\\" src=\\"http://cdn.hashnode.com/blog/v1661350997400/t_oWcOGFK.png?height=270\\"/>\\nNow, this is pretty scary, to realize firsthand that someone, unbeknownst to me, had access to manipulate my camera, which also had audio so they could also hear what was going on in my house. Could I have been wrong, and it was just a fluke, sure... but this really brought home the importance of securing my privacy over making my life easier by nonchalantly adding copious amounts of _smart_ devices into my household.\\n\\n## The Fix\\n### v1.0 - No Internet\\nI decided to upgrade to a wired camera system with no internet access. My main focus was to eliminate any access to the cameras except when connected to my local network (my home WiFi). By doing this, I would no longer be able to see which dog tore the house apart unless I recorded a constant stream or, at the very least, movement and was able to review it later. This would require the cameras to each have an SD card or a central DVR that would record constant video.\\n\\nSo now, I can view the camera footage, but only if I\'m home or view the recordings after the fact. Sure, my DVR had the option to expose the data to the internet for viewing while away from home, but it still required me to use their app or expose the port and hope that the native software on the DVR was secure enough not to hack. Unfortunately, many companies don\'t focus on security because they want to be first to market or release the latest features without putting the appropriate focus on security.\\n\\nI also recently implemented [HomeAssistant](https://www.home-assistant.io/) to give my CCTV station smart features since most CCTV setups are fairly lacking in the \\"smart\\" department. This was also a safety feature for my wife, who isn\'t as technically savvy, so she could simply ask to see the workshop camera and know that I\'m safely making progress on my woodworking projects not losing any more fingertips (that\'s another story).\\n\\n### v2.0 - Zero Trust Access\\nFast-forward a few years from \\"the camera incident,\\" and I\'ve finished a degree in software engineering, worked at a few companies as a software developer, so I started to grasp a much better understanding of networking and network security. It also doesn\'t hurt that I was graced with employment by my current employer [NetFoundry](https://netfoundry.io/), which is a leader in zero trust networks. Say hello to OpenZiti, which has a freely available [overlay network](https://openziti.github.io/ziti/overview.html#overview-of-a-ziti-network) and, even better, it\'s open source, so if you\'re handy with technology, you can implement your own zero trust network. With OpenZiti, I could grant myself access to my HomeAssistant server and feel confident that nobody else will have access to view my cameras without my explicit permission.\\n\\nThere\'s a lot of debate and confusion surrounding the term \\"Zero Trust\\" since it\'s inherently ironic in that you have to trust some things, but the general idea is that you have a set of people or devices that you trust and only once you trust them, you grant them access to services. So, how does this differ from a VPN? A VPN grants access to a network, so if I were to use a VPN to provide access to my home cameras, the users would also have access to other services on my server or even other devices within my network. So, in my case, I only want to provide access to my HomeAssistant server, not the CNC software or 3D printer software I have hosted on the same device.\\n\\n## How I Implemented My Own Zero Trust Network to Access HomeAssistant\\n### The Network Before\\n![OpenZiti HomeAssistant Network Architecture - Without Ziti.png](/blogs/openziti/v1662473588022/e1yBYsYn8.png)\\n\\n### Planning The Network\\nTo build the network, I need to know three things:\\n1. Who is the client (the one who wants access)\\n1. Who is the host (the one with the service I want to access)\\n1. Where is my zero trust controller going to sit (usually some globally accessible location like a cloud server)\\n\\n#### The Client\\nI am the one who wants to use my service, so I will be the client in this scenario. Though it\'s also important to think big picture, do I want more people to have access to this at some point? If I want others to access it, will I want to add the new client identities one by one or use an attribute? Using an attribute allows me to give access to any identity (user or device) by using a key identifier. I will eventually want to add my immediate family, so I\'ll use an attribute that defines my family; we\'ll call it `#berl.household.member`. Now, any identity I create in the future and assign this attribute (which I will assign to any person living in my household) will have access to view my cameras. This is neat because it doesn\'t have to be my family, just any person or device residing at my house as long as I give them that attribute.\\n\\nEvery client will still need an identity, and the identity will only work with the device the user chooses to enroll that identity. Multiple devices will require multiple identity tokens, which is one of the great security features built-in.\\n\\n#### The Host\\nThe host, in my case, will be the device hosting my HomeAssistant server; this is my Raspberry Pi 4 on my local home network. Just like the client, this can be a person or device. I don\'t plan to host my HomeAssistant anywhere else, so in this case, I\'ll be granting permission to this single device alone.\\n\\n#### The Network Controller\\nI chose to use Oracle Cloud Infrastructure (OCI) to host my OpenZiti controller as they have a [free tier](https://www.oracle.com/cloud/free/), and it is actually that, free. No fine print says it\'s free for a certain amount of time or a free $100 of use. It\'s free and won\'t let you use premium features from paid plans unless you upgrade to a paid tier. \\n\\nThe controller will be the global point of access, this allows me to connect to my network on already open ports from anywhere where I can access the controller, which in this case is anywhere in the world.\\n\\n### Building The Network\\n#### The Network Controller\\nThe first thing I set up is my Oracle instance, for which I chose a standard Canonical Ubuntu image. I opened up the necessary ports for my needs.\\n- 8441 - The Controller port\\n- 8442 - The Edge Router port\\n- 8443 - The Ziti Console port (optional)\\n- 6262 - For Router to Controller communication\\n- 10080 - For Router to Router communication\\n- 22 - This one may already be open, but you should restrict it to your home IP\\n\\nDue to an OCI quirk, I had to open up those same five ports on the local firewall using \\n\\n    sudo firewall-cmd --zone=public --add-port=8441/tcp --permanent\\n    # ... repeat for other four ports\\n    sudo systemctl restart firewalld\\n\\nOnce all that was done, I SSH into my Oracle instance and run the [OpenZiti Express Install](https://openziti.github.io/ziti/quickstarts/quickstart-overview.html) following instructions for \\"Host it Anywhere\\" and that\'s it, seriously, the controller is all set up now and I even have an Edge Router set up for me as well.\\n\\nWhile we\'re here though, it would make sense to set up all the configurations we will need later. This can be done from your local computer since we have opened port 8441 to access the controller, or it can be done on the instance using SSH.\\n\\nAt this point I set up the following\\n- Create a client identity (to be enrolled later on a device of my choosing)\\n- Create a host identity which can be enrolled at creation\\n- Create a host service config\\n- Create a client service config\\n- Create a service\\n- Create service policies defining who/what can bind and/or dial the service\\n\\n\\n#### The Host\\nTo set up the host, I need to run the Ziti Tunneler on my host machine. I used the `ziti-tunnel-sdk-c` and provide it with the JSON output from the host identity I enrolled after setting up the controller.\\n\\n#### The Client\\nI used my mobile phone, so I sent the JWT to my phone. This JWT was created when I created the identity with the controller. With the Ziti Mobile Edge app found in the app store, I opened the JWT and enrolled my identity.\\n**Note:** There is a time limit on enrollment; this is given to you when you create the identity. It will also show when you load the JWT into the phone app.\\n\\n#### The New Network Using OpenZiti\\n![OpenZiti HomeAssistant Network Architecture - With Ziti.png](/blogs/openziti/v1662473614565/gyGvTqVYP.png)\\n\\n#### Check Out My Feed\\n![Ziti Camera View.png](/blogs/openziti/v1661535186931/AWIoUlOKY.png)\\n\\n## What\'s Next?\\nHow cool is it that anyone I identify as `#berl.household.member` in my household now has access to my cameras once provided an identity token? But what\'s even cooler is, say I go on vacation for a week, I can temporarily grant access to a house sitter by giving them the same attribute. Or I could also create another attribute or grant them permission explicitly based on their identity. Best of all, this was entirely free!\\n\\nNow, to clarify, do you need HomeAssistant... no, this could have certainly been implemented in a way where I only had direct access to my CCTV. But, by using HomeAssistant, I can now expand my security to other devices on my network and start removing network access through designated smart device apps. But alas, you\'ll have to stay tuned for that one as it\'s saved for a future article."},{"id":"my-intern-assignment-call-a-dark-webhook-from-aws-lambda","metadata":{"permalink":"/docs/openziti/blog/my-intern-assignment-call-a-dark-webhook-from-aws-lambda","source":"@site/blog/my-intern-assignment-call-a-dark-webhook-from-aws-lambda.md","title":"My Intern Assignment - Call a Dark Webhook from AWS Lambda","description":"Published by Clint on behalf of Spencer Griebel","date":"2022-08-25T01:11:42.000Z","tags":[{"inline":false,"label":"Webhooks","permalink":"/docs/openziti/blog/tags/webhooks","description":"Webhooks integrations"},{"inline":false,"label":"AWS Lambda","permalink":"/docs/openziti/blog/tags/aws-lambda","description":"AWS Lambda content"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":8.65,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"My Intern Assignment - Call a Dark Webhook from AWS Lambda","seoTitle":"Zero trust webhook from AWS Lambda","seoDescription":"As an intern I used OpenZiti to invoke a webhook to a server over a zero trust, OpenZiti network","date":"2022-08-25T01:11:42.000Z","cuid":"cl78cngvf02tr36nvc56efb0j","slug":"my-intern-assignment-call-a-dark-webhook-from-aws-lambda","authors":["ClintDovholuk"],"image":"@site/blogs/openziti//kOMCC0op3.jpeg","imageDark":"@site/blogs/openziti//kOMCC0op3.jpeg","tags":["webhooks","aws-lambda","zerotrust"]},"unlisted":false,"prevItem":{"title":"I Created a Zero Trust Overlay Network to Access HomeAssistant","permalink":"/docs/openziti/blog/zero-trust-overlay-network-to-access-homeassistant"},"nextItem":{"title":"Extrovert Wednesday","permalink":"/docs/openziti/blog/extrovert-wednesday"}},"content":"*Published by Clint on behalf of Spencer Griebel*\\n\\n# The Intern\\n\\nThis summer, I had the pleasure of working at NetFoundry, a company that is trying to keep the world secure by providing and supporting a totally free and open source, zero trust overlay network called OpenZiti. OpenZiti is on GitHub, you can go and fork it right now and run your own network if you like. Since I worked for NetFoundry, I was able to use their SaaS offering for free and let them manage the OpenZiti overlay (which you could also do too if interested, they have a free tier).\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Assignment\\n\\nNaturally, as the summer intern responsible for odd jobs, I was tasked with creating a script to automate finding CVEs that OpenZiti could quickly solve - i.e., CVEs that, from their CVSS metrics, have an attack vector of network and no privileges required. The zero trust overlay network OpenZiti provides allows you to close any and all open ports from your servers. That means firewalls only require outbound connectivity, nothing inbound at all, blocking unknown attackers from accessing your data on your network (as well as a bunch of other [superpowers](https://www.youtube.com/playlist?list=PLMUj_5fklasKF1oisSSuLwSzLVxuL9JbC)).\\n\\nOpenZiti has a mascot, a cute and friendly piece of pasta, Ziggy. Ziggy also has a [Twitter handle](https://twitter.com/openziggy) and he likes to tweet about CVEs which OpenZiti could have easily solved or at least reduced the impact of and he likes to tell the world to keep your ports closed. I was tasked with finding these CVEs so that Ziggy could alert the world to the CVE. This allows Ziggy to promote the CVE to the world while simultaneously showing how OpenZiti could solve the problem entirely, or at very least reduce the effect of the CVE to only trusted identities on your network. After all, someone on your zero trust overlay is far less likely to exploit the flaw. After discovering these CVEs, I then needed to be able to post the CVE to a channel on the [Mattermost](https://mattermost.com/) messaging server, alerting people of the CVE.\\n\\n## The Problem\\n\\nSo far, this all sounds pretty straightforward. The twist is that NetFoundry uses OpenZiti to protect its Mattermost server. That means I can\u2019t just hit a public webhook, the webhook isn\u2019t public at all. I\u2019d have to get a strong identity and get onto the overlay network in order to even access the webhook endpoint.\\n\\n## Background\\n\\n*If you know what a CVE is or what CVSS is or you don\u2019t want to learn, skip the next couple of paragraphs.*\\n\\n### What\u2019s a CVE\\n\\nAt this point, you might be asking yourself, what\u2019s a CVE? I didn\u2019t know either. A CVE is a vulnerability that has been discovered and cataloged. They are also called [\\"0-day\\"/\\"Oh-day\\"/\\"Zero-day\\"](https://en.wikipedia.org/wiki/Zero-day_(computing)), bugs, vulnerabilities, etc. Each CVE has an associated entry, including a description of the CVE and the [CVSS score](https://nvd.nist.gov/vuln-metrics/cvss). These scores, determined via criteria, categorize the severity of the CVE. Fortunately for us, I found that these CVEs are all collected and posted by NIST and are easily accessible using their [public API](https://nvd.nist.gov/vuln/data-feeds).\\n\\n### CVSS?\\n\\nThis might surprise you, I didn\u2019t know what CVSS was either. As I mentioned previously, CVSS is a way of scoring the CVE. CVSS stands for \u201cCommon Vulnerability Scoring System\u201d and the latest version, version 3.1, is the one we focused on. CVSS takes eight common properties of the vulnerability and somehow (I didn\u2019t research how) uses the results to calculate a score from 0.0 to 10.0, with 10.0 being a show-stopper, you really need to patch this vulnerability immediately! Anything over a 9 is really critical, but a 10.0 is earth-shattering. As an example, you almost certainly heard about \u201c[log4shell](https://en.wikipedia.org/wiki/Log4Shell)\u201d? Here\u2019s the [NIST CVE for log4shell](https://nvd.nist.gov/vuln/detail/CVE-2021-44228). As you can see, it was a 10.0, ooph.\\n\\n![image.png](/blogs/openziti/v1661374704921/4dfRMttjq.png)\\n\\nAs mentioned, the CVSS is calculated using eight different fields. The two fields I focused on were the \u201cAttack Vector\u201d and the \u201cPrivileges Required\u201d fields. You can see from the log4shell CVE that when the attack vector is network, and the privileges required are none, you already have a particularly sensitive CVE to mitigate. These sorts of CVEs are exploited routinely by attackers as it often permits them to \u201cland and expand\u201d. If you\u2019re interested in playing around with CVSS, there are at least two really good calculators, one [from NIST itself](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator), and the other from [first.org](https://www.first.org/cvss/), try it out.\\n\\n## Back to the Assignment\\n\\nOk, now I knew what a CVE is and what the CVSS score is, and what types of vulnerabilities I needed to look for. I also knew that NIST provides a list of these CVEs via their API which also provides decent filtering capabilities. Now I knew where I could find these CVEs but I still had to set up a recurring job to notify the Mattermost channel. I rolled up my sleeves and started at it.\\n\\nI wrote the initial script using Python in VScode. I already had it in my head that the final goal would be automating it to run every 15 minutes using [AWS Lambda](https://aws.amazon.com/lambda/). The script itself was pretty simple. I would make a REST API call to the NIST CVE database with a few filters in the API URL (no permissions required, attack vector of network). I also added a filter to narrow the date range and search for specific categories of CVEs. I tested everything and it seemed to work to gather the information we need. I tweaked the code to send a nicely formatted message so that it looked nice - a vital feature of the solution. Now I need to send a webhook message to our private Mattermost chat server.\\n\\n## Calling a \u201cDark\u201d Webhook\\n\\nAwesome, now I had a script that can gather the necessary information from the database. I also figured out how to format each CVE into an easily readable message and figured out how to send that message to a webhook in Mattermost to a specific channel when the Mattermost server was not dark, meaning it was actively listening on a port and my script could send a message directly to the server. Getting that done was easy, but in order to keep this implementation NetFoundry would need to open a port for the firewall for an incoming webhook and that would have defeated the purpose of having the Mattermost server protected by OpenZiti. We didn\u2019t want to have an open port in the firewall, so this solution really wasn\u2019t an option.\\n\\nLuckily, when I finished the script\'s first revision, the OpenZiti project had just released its [Python SDK](https://github.com/openziti/ziti-sdk-py). I decided I would inject my script with some embedded zero trust superpowers. This was exactly what I needed to grant my AWS Lambda the superpower of invoking a dark webhook.\\n\\n## Adding Zero Trust to the Lambda\\n\\n![](/blogs/openziti/v1661429495524/R5PsrBJou.png)\\n\\nThe process to \'[zitify](./zitification.md)\' the script (i.e., put an OpenZiti SDK inside) is very straightforward and was so simple even an intern could do it! First, I received an OpenZiti strong identity which was authorized to hook into the Mattermost server. I enrolled it using the OpenZiti [Command Line Interface (CLI)](https://openziti.github.io/ziti/identities/enrolling.html) using one command. From that, I received a JSON file containing the enrolled, strong identity. I stored this JSON document using AWS secrets manager which is easily accessed from AWS Lambda. In my Lambda script, I created an environment variable named \\"ZITI\\\\_IDENTITIES\\", which stores the path to a file containing the JSON from the enrolled identity. Note that the name of this variable is specific and must be used when zitifying a python script using the SDK. Initially, this file did not exist, so when running the script, I had it create the file, pull the identity JSON from AWS Secrets Manager, and populate the new file. After that, I imported the OpenZiti SDK, which validates the identity provided.\\n\\n#### The Code:\\n\\n![image.png](/blogs/openziti/v1661374430916/EE4XTdpby.png)\\n\\nCheck out the actual code over on github at https://github.com/openziti-test-kitchen/ziggy-fodder/blob/main/cve-alert-zitified.py\\n\\nOnce I had OpenZiti imported, it was as simple as using the openziti.monkeypatch() method and using the requests package to use the webhook as I did before.\\n\\n*When OpenZiti is imported, it attempts to validate the identity pointed to by the ZITI\\\\_IDENTITIES env variable. Remember that this file is initially empty with my script, so I had to break convention and import OpenZiti later in my script. This could be easily avoided by not using Secrets Manager to store the identity or by having an initialization script that loads the environment variable.*\\n\\n## Solution Overview\\n\\nWith my Lambda zitified, now the communication looks like this. No holes in the private data center are needed and the Lambda can send webhook payloads every 15 minutes successfully. The solution looks like this:\\n\\n![](/blogs/openziti/v1661374132819/pMR9FS30j.png)\\n\\n## Reflections on the Process\\n\\nOverall the process was easy and smooth and though my script was straightforward, the process would be the same for a more complicated program. The bulk of the work came from storing the identity and placing it where the OpenZiti package would be able to find it. After that, I could take advantage of the benefits provided by OpenZiti with little work.\\n\\n## The Payoff\\n\\n![image.png](/blogs/openziti/v1661374025216/lNxwSTAja.png)\\n\\nAnd there it is. Now, with our new zitified CVE finding script, [Ziggy](https://twitter.com/OpenZiggy) has a constantly growing feed of CVEs he can comment on. This image shows the Mattermost channel where all the CVEs appear and shows you what the messages look like when formatted. Each number hyperlinks to the page with more details - see [an example](https://nvd.nist.gov/vuln/detail/CVE-2022-36272). Overall this was an enjoyable project and a great introduction to AWS Lambda and using OpenZiti.\\n\\nIf you made it to the end and thought the OpenZiti project sounds neat - [give them a star over on GitHub](https://github.com/openziti/ziti/stargazers) and help spread the word about this awesome project. :)"},{"id":"extrovert-wednesday","metadata":{"permalink":"/docs/openziti/blog/extrovert-wednesday","source":"@site/blog/extrovert-wednesday.md","title":"Extrovert Wednesday","description":"Extrovert Wednesday","date":"2022-08-24T12:00:00.000Z","tags":[],"readingTime":4.74,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"title":"Extrovert Wednesday","date":"2022-08-24T12:00:00.000Z","slug":"extrovert-wednesday","authors":["CurtTudor"]},"unlisted":false,"prevItem":{"title":"My Intern Assignment - Call a Dark Webhook from AWS Lambda","permalink":"/docs/openziti/blog/my-intern-assignment-call-a-dark-webhook-from-aws-lambda"},"nextItem":{"title":"Securing Web APIs With OpenZiti \u2014 Zero Trust For Web APIs","permalink":"/docs/openziti/blog/securing-web-apis-with-openziti"}},"content":"## Extrovert Wednesday\\n\\nThe title of this post may not have the same ring as *Taco Tuesday*, so let me explain.\\n\\nThe OpenZiti team I am a part of loves creating things.  Art.  Music.  Certainly innovative software. But *making* something is not as simple as it sounds.  Regardless of the experience level anyone has, putting a creation \\"out there\\" might involve vulnerability, self doubt, and indecision.\\n\\nFor most creatives, the process of making something is enjoyable. The flip-side is that showing it to others, especially at web scale, can be a painful process where we (and our project) are laid bare, open to criticism.\\n\\nThis phenomenon could be among the reasons preventing, or slowing, us all from writing and sharing technical articles.\\n\\nPerhaps you are dealing with this issue as well, and are holding yourself back, not writing about your work.  \\n\\nIf so, here are some thoughts concerning how I have managed to overcome my fear, and have transitioned into actually enjoying producing technical blog content, as a vehicle to share and collaborate on the software I build.\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n# Overthink\\n\\nThe fact is most of us think other people care far more about what we do and how we do it than they actually do.  Social science folks refer to this as the *spotlight effect*.\\n\\nThe spotlight effect is a cognitive bias that skews our perception of ourselves and the world around us in a way that is often out of sync with reality and how others view us. \\n\\nYes, it\'s natural to inwardly focus on our flaws, inadequacies and shortcomings, but it\'s also important to understand that it\'s highly likely other people won\'t ever notice them at all.\\n\\nSure, try to recognize the thoughts that might stop you from sharing your work.  Just don\'t let them block you.\\n\\n---\\n\\n# WIP\\n\\nWhen you build or create something new, it\'s easy to focus on the finish line; the moment when you throw your hands in the air and shout \\"It\'s finished!\\".\\n\\nReality check: that moment rarely (if ever) happens.  Things are always a **W**ork **I**n **P**rogress.\\n\\nAccepting that your projects are a constant, never-ending work in progress, that you revisit and develop, will allow you to be less critical of the flaws that you find because once you\'ve found them, you can fix them, one at a time.\\n\\nShare the Process, not just Product.\\n\\nIf you agree that a project is never really, truly complete, then it\'s much easier to share your work along the way because it\'ll always have some flaws (no matter how minor), but they won\'t bother you quite so much because you just haven\'t fixed them yet.\\n\\nIf we remember that the process is more important than the end product, then why wouldn\'t we show the project as it develops?\\n\\n---\\n\\n# Criticism\\n\\nOnce you start shipping (publishing) articles, you\'re bound to receive both criticism and critique, but it\'s important to recognize the difference.\\n\\nCriticism is judgmental and typically is focused on finding fault. \\n\\nMeanwhile, critique is balanced and justified by explanation. \\n\\nIt\'s easy to think the two are the same, but critique is constructive and helps you to improve your work, criticism often doesn\'t.\\n\\nIn my experience, the vast majority of people in creative communities motivate others around them, not criticize them.  Most will look for the positives in your work, or offer ways to help you improve it.\\n\\nThe benefits you\'ll get from receiving constructive feedback will always outweigh the small amount of negativity that might come your way because you decided to share in public.\\n\\n---\\n\\n# Begin\\n\\nOh, this article\'s subject line.  What\'s that about, you ask?\\n\\nIn addition to the notions discussed above, another reason we Zitizen\'s haven\'t published as much interesting tech content as we\'d prefer is that we have been spending 110% of our cycles heads down solving software engineering problems related to zero trust networking, distributed systems, DevX, and many other things related to the OpenZiti mission.\\n\\nTo solve that \\"*too busy to write*\\" problem, with the blessing of our CTO, our new team commitment is that we will spend Wednesdays devoted to producing enhanced documentation and more tech articles related to the OpenZiti journey.  \\n\\nWe affectionately refer to this initiative as *Extrovert Wednesday*, a tongue-in-cheek nudge to get over any introverted tendencies we might have, and get out there!\\n\\nWe will share our journey (*and our work*), every step of the way.  Our community will definitely reap the benefits.  We hope you hop on for the ride (*use our \'newsletter subscribe\' widget, and you\'ll never miss any upcoming articles*).\\n\\nI wrote this post on our team\'s first Extrovert Wednesday, and it could be considered my way of re-telling myself not to be so shy, or just to take my quill out of moth balls and create a post to start exercising my writing muscles.\\n\\nWriting and sharing your work isn\'t easy, but the more you do it, the easier it gets.\\n\\nMoving forward, you can expect me to deliver on tech topics that include:\\n* WebAssembly and how it\'s used in OpenZiti\\n* How to make web servers invisible to malicious actors, without VPNs\\n* Self-hosting real-world CMS, analytics, and other types applications in the cloud, with no open ports, while still making the apps accessible to authorized users\\n* How to embed zero trust networking directly in your apps via OpenZiti SDKs\\n* much more\\n\\nI hope you come back here often to see what we\'re cookin\' up for you here in the OpenZiti kitchen.\\n![image.png](/blogs/openziti/v1661373062401/ZlzNy_oxv.png)\\n\\n---\\n\\n# Closing thought\\n\\nShow me someone who has never made a mistake, and I\'ll show you someone who has never ***made anything***.\\n\\nFear not. \\n\\nShip it."},{"id":"securing-web-apis-with-openziti","metadata":{"permalink":"/docs/openziti/blog/securing-web-apis-with-openziti","source":"@site/blog/securing-web-apis-with-openziti.md","title":"Securing Web APIs With OpenZiti \u2014 Zero Trust For Web APIs","description":"In the late 2000s, I was a software engineer in the telecom industry, working on large data pipelines that would","date":"2022-08-16T00:00:00.000Z","tags":[{"inline":false,"label":"APIs","permalink":"/docs/openziti/blog/tags/apis","description":"API development"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"},{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":5.63,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"slug":"securing-web-apis-with-openziti","title":"Securing Web APIs With OpenZiti \u2014 Zero Trust For Web APIs","authors":["AndrewMartinez"],"date":"2022-08-16T00:00:00.000Z","tags":["apis","zerotrust","security","openziti"]},"unlisted":false,"prevItem":{"title":"Extrovert Wednesday","permalink":"/docs/openziti/blog/extrovert-wednesday"},"nextItem":{"title":"Tunneling VoIP over OpenZiti","permalink":"/docs/openziti/blog/tunneling-voip-over-openziti"}},"content":"In the late 2000s, I was a software engineer in the telecom industry, working on large data pipelines that would \\naggregate billing data from any carrier. The older the carrier, the more likely we would write a web scrapper to \\nautomate data retrieval. The new carriers had Web APIs. It was exciting and abundantly clear that these servers were \\nexposed publicly on the internet.\\n\\n\x3c!-- truncate --\x3e\\n\\nThese Web APIs weren\'t servicing commercial or residential applications for consumer billing. These were data pipelines to detailed call records and other private data. A treasure trove of information for partners and data subscribers. Needless to say, it was amusing that this attack surface was exposed so cavalierly. The only reason it was exposed on the public internet was that it was convenient.\\n\\nThe carrier did secure the Web API. It was one of the first times I had ever seen a Web API require a client certificate in the wild. Over time I saw more and more APIs deployed, some publicly and some inside of private networks. The ones inside private networks required weeks to months of lead time to deploy as they generally required security reviews from the carriers, restricted internal network access, and other good ideas that made software development slow but security and compliance happy.\\n\\nThere simply was not a fast way to provide developer-focused access to Web APIs inside of a secure private networking space. So we made do with a process that took months to set up and took days to resolve issues when something went wrong. Tickets would ping-pong between the carrier support desk, our internal IT support desk, and me, the software engineer.\\n\\n\\n# A Brighter Future\\n\\nIf you had shown OpenZiti to me when I was working with dozens of telecom Web APIs - I would have marveled at it. OpenZiti would have given me an SDK in the language of my choice to access a private network. It would have cut out the entire IT department, and I could swap production and test network and credentials according to my CI/CD needs. Additionally, planning and estimating my work would have become known units of work after one deployment. Said more plainly, it would have eliminated my dependencies on outside departments for secure network access, thus improving the accuracy of my estimates. \\n\\nDoing a POC would have been reduced from weeks of inter-team/company coordination to \\"here are your credentials, put them into this SDK, and you are connected.\\" That is powerful.\\n\\nWhen OpenZiti is deployed to protect a Web API, the security model inherits all of Open  Ziti\'s Super Powers:\\n\\n- SDK or Tunneler Access - access private networks directly in software or through clients\\n- Private Service Address - \\"private DNS\\", custom top-level-domains, etc.\\n- Dark Services - service attack surfaces are reduced by adding a new layer of security\\n- Protocol/Data Masking - the traffic no longer appears to be web traffic to a compromised network observer\\n- End-To-End Encryption - traffic is only readable by the client and server no matter what in the middle is compromised\\n- Strong Identities - both parties know exactly who/what they are interacting with\\n- Role-Based Access Control & Posture Checks - restrict based on static and dynamic access policies\\n\\n...and more. There are many videos about \\"what OpenZiti is\\" and I suggest you check them out at the [OpenZiti Website](https://openziti.io) or the [OpenZiti YouTube Channel](https://www.youtube.com/c/OpenZiti).\\n\\n# Layers of Security & Attack Surfaces\\n\\nOpenZiti provides an additional layer of security by allowing your service attack surfaces to be reduced to zero. At the minimum, the controller and one router must be addressable over traditional networking for the Open OpenZiti network to initialize. \\n\\nCompromising OpenZiti does not compromise your Web API. If the controller is compromised, it would expose them as if they were deployed without OpenZiti.  Compromising routers in the system provides no insight into the traffic\'s contents as the data sent between clients and hosts is end-to-end encrypted.\\n\\n# Authentication Integration\\n\\nOn the OpenZiti project, we are also working a set of features that would allow external Web APIs to use OpenZiti identity credentials in your own API. This includes using JWTs and x509 client certificates minted by an OpenZiti network that can verify a client seamlessly without additional authentication.\\n\\n# Deployment Models\\n\\nBelow are some example deployments of OpenZiti with API clients and API hosts. The fastest startup time for API consumers is SDK-only deployment in their consumption software. If the software cannot be modified, Tunnelers must be introduced, which require deployment.\\n\\nA basic understanding of OpenZiti components is required:\\n\\n- SDK - An OpenZiti SDK is a software library used to connect to an OpenZiti Network\\n- Tunneler - A provided or custom OpenZiti client that uses a Ziti SDK to provide host-level access to an OpenZiti Network\\n- Controller - A OpenZiti Controller is used to synchronize and manage an OpenZiti Network\\n- Edge Router - A Ziti Edge Router is a process that is deployed in an OpenZiti Network to create a mesh network and enables ingress and egress from the network\\n\\nAdditionally, the following components are used in the following diagrams:\\n\\n- Private Network \\\\<#\\\\> - A network managed by a private entity\\n- Host - A virtual machine, physical machine, container, etc.\\n- API Host Software - Some software that provides a Web API\\n- API Client Software - Some software that consumes a Web API\\n\\n*Note: The following diagrams show SDK to SDK or Tunneler to Tunneler diagrams. It is possible to mix and match SDK host/client and Tunneller host/client models.*\\n\\n## SDK Host & Client Public Router\\n\\n![SDK-SDK-Public Router@4x.png](/blogs/openziti/v1660143492122/A-IxGQkAi.png)\\n\\n- Uses SDKs for both the host and client, which associates processes to identities in OpenZiti for the highest level of security\\n- Uses a public router deployed by the API provider\\n- Fast startup for API consumers\\n\\n\\n## SDK Host & Client Private Router\\n\\n![SDK-SDK-Private Routers@4x.png](/blogs/openziti/v1660143484083/TG8M_jfa1.png)\\n\\n- Uses SDKs for both the host and client, which associates processes to identities in OpenZiti for the highest level of security\\n- Uses a private router that requires a client to deploy the router (dial-out is required)\\n- API Consumer is required to deploy a Router\\n\\n## Tunneler Host & Client Public Router\\n\\n\\n![TUN-TUN-Public Router@4x.png](/blogs/openziti/v1660143502983/20FsHrueq.png)\\n\\n- Uses Tunellers for both the host and client, which associates hosts to identities in OpenZiti\\n- Uses a public router deployed by the API provider\\n- Tunnellers must be deployed\\n\\n## Tunneler Host & Client Private Router\\n\\n![TUN-TUN-Private Router@4x.png](/blogs/openziti/v1660143496703/cVbNoLM2t.png)\\n\\n- Uses Tunellers for both the host and client, which associates hosts to identities in OpenZiti\\n- Uses a private router that requires a client to deploy the router (dial-out is required)\\n- Tunnellers must be deployed\\n- API Consumer is required to deploy a Router"},{"id":"tunneling-voip-over-openziti","metadata":{"permalink":"/docs/openziti/blog/tunneling-voip-over-openziti","source":"@site/blog/tunneling-voip-over-openziti.md","title":"Tunneling VoIP over OpenZiti","description":"In this article we will look at what is VoIP (voice over IP), why it is inherently vulnerable to network based attacks,","date":"2022-08-05T15:43:13.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"VoIP","permalink":"/docs/openziti/blog/tags/voip","description":"VoIP and communications"}],"readingTime":14.38,"hasTruncateMarker":true,"authors":[{"name":"Shawn Carey","title":"Author","url":"https://github.com/scareything","imageURL":"https://avatars.githubusercontent.com/scareything","key":"ShawnCarey","page":null}],"frontMatter":{"title":"Tunneling VoIP over OpenZiti","date":"2022-08-05T15:43:13.000Z","cuid":"cl6gmz8i302jtxvnv7bxk7c79","slug":"tunneling-voip-over-openziti","authors":["ShawnCarey"],"image":"@site/blogs/openziti//EAmibi9_df.jpeg","imageDark":"@site/blogs/openziti//EAmibi9_df.jpeg","tags":["security","networking","voip"]},"unlisted":false,"prevItem":{"title":"Securing Web APIs With OpenZiti \u2014 Zero Trust For Web APIs","permalink":"/docs/openziti/blog/securing-web-apis-with-openziti"},"nextItem":{"title":"Bootstrapping Trust Part 5","permalink":"/docs/openziti/blog/bootstrapping-trust-part-5-bootstrapping-trust"}},"content":"In this article we will look at what is VoIP (voice over IP), why it is inherently vulnerable to network based attacks, \\nand how we can stop these attacks by closing inbound ports using open-source OpenZiti.\\n\\nThis will include a how-to guide on standing up an OpenZiti network and using OpenZiti tunnelers to connect IP phones \\nfrom anywhere in the world using a Asterisk PBX server.\\n\\n\x3c!-- truncate --\x3e\\n\\n# VoIP Introduction\\n\\n\\"VoIP\\" is an acronym for \\"voice over IP\\". It refers to a collection of protocols for coordinating calls between multiple phones and transferring the call data (e.g. voice, video, screen share, etc) - including making calls directly from data-driven devices (a [VoIP phone](https://explore.zoom.us/en/what-is-voip-phone/), your computer, etc.)\\n\\n## My VoIP is working perfectly right now\u2026 what\u2019s the problem?\\n\\n![voip-vulnerability-architecture.png](/blogs/openziti/v1660750218633/HCbn-iFaF.png)\\n\\nVoIP inherently relies on a strong and stable internet connection with low latency. Any disruption can impact performance and service availability. VoIP systems have critical components which need to be open to networks to operate \u2013 including SIP servers, SBCs, IP-PBX, proxies and TURN servers. By being exposed to the network (and internet) these systems are vulnerable to external attack, including DoS/DDoS. In 2021 we saw an [upsurge in the number of damaging DoS, DDoS and ransomware type cyberattacks](https://www.techradar.com/news/ddos-attack-takes-yet-another-voip-provider-offline) against VoIP systems.\\n\\nWhile not a problem for all VoIP users, some have stringent availability requirements \u2013 e.g., a critical services call \u2013 where any disruption causes business downtime. We have mitigation techniques which help, but they are inherently limited \u2013 e.g., attacks against VoIP providers in 2021, [mitigation techniques](https://netfoundry.io/why-ddos-and-dos-targets-voip-and-how-zero-trust-can-mitigate-the-threat/) only provided limited and temporary respite. What if we could deploy our VoIP systems and not have them exposed to the network\u2026 particularly the approximately 4.3 billion IPs on the public internet?\\n\\n## Invisible VoIP\\n\\nWe created OpenZiti to provide the next generation of secure, open-source networking for any application. It allows you to easily apply zero-trust principles, and high-performance mesh networking on any Internet connection, without VPNs.\\n\\n![secure-voip-architecture.png](/blogs/openziti/v1660750445519/vwC0Tlg8z.png)\\n\\nBoth sides of the application, VoIP in this case, use strong identity (X.509 certificate; bi-directionally authenticated and authorized) to build outbound-only overlays \u2013 we call this [dark or invisible networks](https://www.youtube.com/watch?v=ygHTixbra6A&list=PLMUj_5fklasKF1oisSSuLwSzLVxuL9JbC&index=5&t=3s&ab_channel=OpenZiti). As a result, our critical components do not need to be exposed to the internet - closed inbound ports or deny all inbound on the firewall.  \\nAn application using a Ziti Network configured with a truly zero-trust mindset will be IMMUNE to the \\"expand/multiply\\" phases of classic ransomware attacks.\\n\\nWe must remember though that VoIP is sensitive to having a stable and performant network. Luckily we built in features such as high throughput and smart routing into the mesh overlay which allows VoIP to operate without the traditional limitations associated with VPNs.\\n\\nIn this article we\u2019ll show you how to use OpenZiti tunnelers to connect IP phones from anywhere in the world to an Asterisk server that doesn\'t expose any ports to the Internet. The protocols that we\'ll set up ziti services for today are SIP ([session initiation protocol](https://en.wikipedia.org/wiki/Session_Initiation_Protocol)) for call coordination, and RTP ([real time transport protocol](https://en.wikipedia.org/wiki/Real-time_Transport_Protocol)) for voice audio streams.\\n\\nWe would like to get your feedback on our solution and experience. A great place for questions and conversation is in our [discourse community](https://openziti.discourse.group/).\\n\\n# OpenZiti Setup\\n\\nThe Ziti network that is shown in this article consists of a Ziti controller and a single Ziti edge router. Check out one of the [Ziti Quickstarts](https://openziti.github.io/ziti/quickstarts/quickstart-overview.html) for some guides on setting up a Ziti network of your own.\\n\\nIn addition to the Ziti network, we also need [Ziti Tunnelers](https://openziti.github.io/ziti/clients/tunneler.html) installed on the Asterisk and soft phone hosts to proxy SIP and RTP packets to/from the Ziti network.\\n\\n\\\\--------------------- --------------------- --------------------- | Linphone | | Asterisk | | Linphone | | \\\\_\\\\_\\\\_\\\\_\\\\_ | | ,\\\\_\\\\_ | | \\\\_\\\\_\\\\_\\\\_\\\\_ | | (.---.)-.*.-. | | ( \\\\* ) | | (.---.)-.*.-. | | /:::\\\\\\\\ \\\\_.---\' | | \\\\`\\\\`\' | | /:::\\\\\\\\ \\\\_.---\' | | \'-----\' | | | | \'-----\' | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | /\\\\\\\\ | | /\\\\\\\\ | | /\\\\\\\\ | | //\\\\\\\\ | | //\\\\\\\\ | | //\\\\\\\\ | | \\\\\\\\// | | \\\\\\\\// | | \\\\\\\\// | | / | | / | | / | | | | | | | | Ziti Desktop Edge | | ziti-edge-tunnel | | Ziti Desktop Edge | | for macOS | | for Linux | | for Windows | --------------------- --------------------- ---------------------\\n\\n\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_ / \\\\_\\\\_\\\\_ /  \\n| | \\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_/\\n\\n\\\\------------------- ------------------- | /\\\\\\\\ | | /\\\\\\\\ | | //\\\\\\\\ | | //\\\\\\\\ | | \\\\\\\\// | | \\\\\\\\// | | / | | / | | | | | | ziti-controller | | ziti-router | ------------------- -------------------\\n\\nOnce the Ziti controller is up and running we can create the Ziti service along with identities and policies.\\n\\n## Identities\\n\\nZiti identities are the basis for authentication to a Ziti network. You can think of Ziti identities as user accounts. See [the Ziti docs](https://openziti.io/docs/learn/core-concepts/identities/overview) for more information on identities.\\n\\nWe\'ll create three identities for our VoIP system: one to represent the Asterisk server and two more to represent connected IP phones:\\n\\n$ ziti edge create identity device asterisk --role-attributes \'asterisk-voip-server\' -o asterisk.jwt $ ziti edge create identity device ext6001 --role-attributes \'asterisk-voip-client\' -o ext6001.jwt $ ziti edge create identity device ext6002 --role-attributes \'asterisk-voip-client\' -o ext6002.jwt\\n\\nKeep track of the JWT files that are created here. They\'ll be used to enroll the identities with the network when the tunnelers are installed. The role attributes will be used when we define the service policies.\\n\\n## Service Configuration\\n\\nThe asterisk server will handle SIP messages as well as proxy RTP packets between phones. SIP is accessed at port 5060 and the RTP port range is defined in the Asterisk configuration (rtp.conf). The Ziti service configuration shown here assumes the default RTP port range of 10000-20000.\\n\\n```\\n$ ziti edge create config asterisk-voip.intercept.v1 intercept.v1 \'{ \\"protocols\\": \\\\[ \\"udp\\" \\\\], \\"addresses\\": \\\\[ \\"192.168.8.1\\" \\\\], \\"portRanges\\": \\\\[ { \\"low\\": 5060, \\"high\\": 5060 }, { \\"low\\": 10000, \\"high\\": 20000 } \\\\] }\'\\n\\n$ ziti edge create config asterisk-voip.host.v1 host.v1 \'{ \\"protocol\\": \\"udp\\", \\"address\\": \\"127.0.0.1\\", \\"forwardPort\\": true, \\"allowedPortRanges\\": \\\\[ { \\"low\\": 5060, \\"high\\": 5060 }, { \\"low\\": 10000, \\"high\\": 20000 } \\\\] }\'\\n\\n$ ziti edge create service asterisk-voip -c asterisk-voip.intercept.v1,asterisk-voip.host.v1\\n```\\n\\n## Policies\\n\\nZiti policies determine which identities can access which Ziti services.\\n\\nIdentities with the \\"asterisk-voip-server\\" identity role will be able to host the services, and those with the \\"asterisk-voip-client\\" role will be able to dial the service:\\n\\n$ ziti edge create service-policy asterisk-voip-client Dial  \\n\\\\--identity-roles \'#asterisk-voip-client\'  \\n\\\\--service-roles \'@asterisk-voip\'\\n\\n$ ziti edge create service-policy asterisk-voip-server Bind  \\n\\\\--identity-roles \'#asterisk-voip-server\'  \\n\\\\--service-roles \'@asterisk-voip\'\\n\\n## Tunneler Installation\\n\\nInstall the Ziti tunnelers on any hosts that will participate in your VoIP network. This article uses macOS, Windows, and Linux tunnelers. See https://openziti.github.io/ziti/clients/tunneler.html for more info on tunnelers and how to install them.\\n\\nOnce installed, you\'ll use the tunnelers \\"Add Identity\\" (on \\"enroll\\") function to register the identity JWT file that was created above.\\n\\n# Asterisk Setup\\n\\nI installed Asterisk on Fedora with the following command:\\n\\n$ sudo dnf install -y asterisk asterisk-pjsip asterisk-sounds-core-en-wav\\n\\nThese packages installed some sample configuration files in /etc/asterisk. For this article, I moved the pjsip and extensions example configuration files out of the way before creating my own.\\n\\n$ sudo mv /etc/asterisk/pjsip.conf /etc/asterisk/pjsip.conf.orig $ sudo mv /etc/asterisk/externsions.conf /etc/asterisk/extensions.conf.orig\\n\\nThe complete pjsip.conf and extensions.conf that I used for the setup in this article are attached below for reference. Here I\'ll point out a few details that are relevant to tunneling SIP and RTP.\\n\\n## Darkness\\n\\nOne benefit of connecting applications with Ziti is that all application components, including servers that accept incoming connections from clients, can be hidden behind a completely closed firewall. We\'ll configure Asterisk to listen for connections on the loopback interface. This is possible because the tunneler that connects Asterisk to our Ziti network is running on the same host as Asterisk. So not only is our Asterisk server inaccessible from the Internet; it\'s also inaccessible from the LAN.\\n\\nHere\'s the bit from pjsip.conf that sets the bind address:\\n\\n;===============TRANSPORT \\\\[transport-udp\\\\] type=transport protocol=udp bind=127.0.0.1\\n\\nNotice that the `host.v1` service configuration above must agree with the Asterisk listen address that\'s specified here. Specifically, the `bind` address in */etc/asterisk/pjsip.conf* must match the `host.v1` \\"address\\" field, and the `rtpstart` and `rtpend` ports in */etc/asterisk/rtp.conf* must be included in the `inttercept.v1` \\"portRanges\\" and `host.v1` \\"allowedPortRanges\\" fields.\\n\\n## Address Translation\\n\\nWe need to take special care in the Asterisk configuration so that it works correctly and reliably with Ziti tunnelers. The main issues that we need to deal with stem from the fact that the phones cannot connect to each other directly, and Asterisk cannot initiate connections to phones.\\n\\n1. Asterisk provides IP phones with addresses that the phones will use to connect to Asterisk. We need to make sure that Asterisk always provides the address in the `intercept.v1` Ziti service configuration, so connections are made to Asterisk instead of other phones. Note that we are working on a feature that makes it possible for IP phones to connect each other\'s media streams directly - avoiding the extra hop through Asterisk. Take a look at https://github.com/openziti/ziti-tunnel-sdk-c/issues/443 for more details, and please do let me know in the comments (here or on the github issue) if direct media connections are something that is important to you.\\n    \\n2. Asterisk cannot initiate connections to the IP phones, so we need to make sure that the inbound connections from IP phones stay open to serve as a return path to the phones.\\n    \\n\\n### SIP\\n\\nSIP is a http-like protocol that is used for phone registration and setting up calls between phones. SIP agents (including IP phones and Asterisk) add a `Via` header to outbound SIP messages. Each agent that initiates or proxies a SIP message adds its own `Via` with an address (protocol:ip:port) that the recipient should use when sending SIP responses.\\n\\nBy default, Asterisk populates `Via` with the destination IP address of the inbound connection from the client This makes sense sometimes, particularly if there is no address translation (NAT) between the clients and the Asterisk server. But in our case we\'ve chosen to lock down the Asterisk transport, so all inbound connections to Asterisk are going to 127.0.0.1. This means that phones will try to send SIP responses to themselves (127.0.0.1) unless we do something to change that! Fortunately the pjsip module supports the `external_signaling_address` configuration setting so that we can force the intercept address for our SIP service into the `Via` header of SIP messages that Asterisk sends to phones.\\n\\n; provide ziti intercepted IP to clients external\\\\_signaling\\\\_address=192.168.8.1 ;; use when populating SDP fields\\n\\nAsterisk also needs to be able to send unsolicited SIP messages to phones, for example a SIP `INVITE` is sent to the receiving phone when another phone initiates a call. Asterisk sends SIP messages to phones at the source IP:port from the phone\'s most recent inbound SIP message by default. This behavior will work for us if we can ensure that UDP connections (for SIP) between the hosting tunneler and the Asterisk server stay alive to serve as a return path to the phone.\\n\\nTo keep the SIP/UDP connections alive at the hosting tunneler we need to defeat logic in the client tunneler\'s that kills intercepted UDP connections when they\'ve been idle for 30 seconds. We can use the `qualify_frequency` configuration setting in *pjsip.conf* to make sure that bytes move frequently enough to prevent the client\'s connection (and by extension the Ziti connection and the UDP connection at the hosting tunneler) from going idle:\\n\\n; prevent client tunnelers from closing SIP/UDP connections due to 30s idle timeout. qualify\\\\_frequency=20\\n\\n### RTP\\n\\nSIP is used for setting up calls between phones, RTP carries the \\"media\\" (e.g. voice data) of VoIP calls. Each IP phone that participates in a call provides the address that other phones can connect to for the outbound media stream. Typically, the media stream consists of RTP packets. The important point is that each phone\'s media stream is carried on a discrete connection, and the phone provides the address for that media connection in the SIP `INVITE` and `OK` messages that were exchange when the call was set up.\\n\\nOf course, unless two phones are on the same network then it is unlikely that the phones will be able to produce an address that is routable from the other phones. This is why we are using Asterisk to proxy RTP connections (for now, at least). There are a few configuration options in *pjsip.conf* that we can use to ensure phones receive routable addresses for connecting to other phones:\\n\\n| Configuration Item | Description |\\n| --- | --- |\\n| `external_media_address` | Address to use when populating SDP payloads. This will match the Ziti intercept address. |\\n| `direct_media=no` | Always use `external_media_address` in SDP content of outbound SIP messages. |\\n| `rtp_symmetric=yes` | Asterisk returns RTP packets to the source IP:port of incoming RTP messages. |\\n\\n### SIP/SDP Conversation\\n\\nHere\'s an example of a SIP/SDP INVITE conversation between a calling phone, Asterisk, and the receiving phone when everything is set up correctly:\\n\\next 6001 Asterisk ext 6002 \\\\_\\\\_\\\\_\\\\_\\\\_ \\\\_\\\\_\\\\_\\\\_\\\\_ \\\\_\\\\_\\\\_\\\\_\\\\_ (.---.)-.*.-. |=====| (.---.)-.*.-. /:::\\\\\\\\ \\\\_.---\' |^\\\\* | /:::\\\\\\\\ \\\\_.---\' \'-----\' |:::: | \'-----\' \\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_ |:::: | \\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_\\\\_ | INVITE sip:6001@192.168.8.1 SIP/2.0 \\\\\\\\ ---&gt; |:::: | ---&gt; | INVITE sip:6001@192.168.8.1 SIP/2.0  \\n| Via: SIP/2.0/UDP 100.64.0.1:52047 | | | | Via: SIP/2.0/UDP 192.168.8.1:5060 | (1) | c=IN IP4 100.64.0.1 | ------- | c=IN IP4 192.168.8.1 | (2) | m=audio 7078 RTP/AVP 96 97 98 0 ... | | m=audio 16382 RTP/AVP 0 101 | (3) --------------------------------------- ---------------------------------------\\n\\n1. The `Via` address in the message that Asterisk sends to the receiving phone is the `external_signaling_address`\\n    \\n2. The \\"c=\\" media address in the SDP `INVITE` message is the `external_media_address`\\n    \\n3. The \\"m=\\" audio connection port is not the phone\'s audio port, but one from the configured rtp port range because `direct_media` is disabled\\n    \\n\\n# Linphone Configuration\\n\\nSetting up Linphone is pretty straightforward; you just need to create a SIP account that connects to the intercepted address that\'s specified in the Ziti service:\\n\\n![linphone-macos-setup.png](/blogs/openziti/v1659554018888/Xr1ffyp4Z.png)\\n\\nThe service will show a green checkmark if everything is working ok:\\n\\n![linphone-macos-connected.png](/blogs/openziti/v1659554272258/aGNgDcXKZ.png)\\n\\nIf Linphone isn\'t connecting for some reason, a quick look in the tunneler logs might be helpful.\\n\\nOn macOS the logs are available from the Ziti menu bar icon:\\n\\n![ziti-macos-logs.png](/blogs/openziti/v1659554458239/ID_-s3cND.png)\\n\\nYou\'ll probably want to start with the \\"Packet Tunnel\\" logs.\\n\\nOn Windows you\'ll want to look at the \\"Service\\" logs under \\"Main Menu\\" -&gt; \\"Advanced Settings\\"\\n\\n![ziti-windows-menu.png](/blogs/openziti/v1659555106171/kw4XEmo1A.png)\\n\\nOn Linux the tunneler logs are visible from the console that was used to launch `ziti-edge-tunnel`, or in `journalctl` if the tunneler was started as a systemd service.\\n\\nIf the tunneler\'s log level is DEBUG or higher you\'ll see something like this in the client tunneler logs when SIP connections are working:\\n\\n```\\n\\\\[2022-08-03T19:09:16.081Z\\\\] DEBUG tunnel-sdk:tunnel\\\\_udp.c:251 recv\\\\_udp() intercepted address\\\\[udp:192.168.8.1:5060\\\\] client\\\\[udp:100.64.0.1:51446\\\\] service\\\\[asterisk-voip\\\\] \\\\[2022-08-03T19:09:16.081Z\\\\] DEBUG tunnel-cbs:ziti\\\\_tunnel\\\\_cbs.c:364 ziti\\\\_sdk\\\\_c\\\\_dial() service\\\\[asterisk-voip\\\\] app\\\\_data\\\\_json\\\\[141\\\\]=\'{\\"connType\\":null,\\"dst\\\\_protocol\\":\\"udp\\",\\"dst\\\\_ip\\":\\"192.168.8.1\\",\\"dst\\\\_port\\":\\"5060\\",\\"src\\\\_protocol\\":\\"udp\\",\\"src\\\\_ip\\":\\"100.64.0.1\\",\\"src\\\\_port\\":\\"51446\\"}\'\\n```\\n\\nThe hosting tunneler logs will look like this:\\n\\n```\\n\\\\[ 2.434\\\\] DEBUG tunnel-cbs:ziti\\\\_hosting.c:559 on\\\\_hosted\\\\_client\\\\_connect() hosted\\\\_service\\\\[asterisk-voip\\\\], client\\\\[ext6001\\\\]: received app\\\\_data\\\\_json=\'{\\"connType\\":null,\\"dst\\\\_protocol\\":\\"udp\\",\\"dst\\\\_ip\\":\\"192.168.8.1\\",\\"dst\\\\_port\\":\\"5060\\",\\"src\\\\_protocol\\":\\"udp\\",\\"src\\\\_ip\\":\\"100.64.0.1\\",\\"src\\\\_port\\":\\"51446\\"}\' \\\\[ 2.434\\\\] INFO tunnel-cbs:ziti\\\\_hosting.c:610 on\\\\_hosted\\\\_client\\\\_connect() hosted\\\\_service\\\\[asterisk-voip\\\\], client\\\\[ext6001\\\\] dst\\\\_addr\\\\[udp:192.168.8.1:5060\\\\]: incoming connection \\\\[ 2.434\\\\] DEBUG ziti-sdk:channel.c:211 ziti\\\\_channel\\\\_add\\\\_receiver() ch\\\\[0\\\\] added receiver\\\\[2\\\\] \\\\[ 2.463\\\\] DEBUG tunnel-cbs:ziti\\\\_hosting.c:338 on\\\\_hosted\\\\_client\\\\_connect\\\\_complete() hosted\\\\_service\\\\[asterisk-voip\\\\] client\\\\[ext6001\\\\] server\\\\[udp:127.0.0.1:5060\\\\] connected\\n```\\n\\nFeel free to reach out on the OpenZiti discourse at https://openziti.discourse.group if Linphone is not connecting and the tunneler logs aren\'t helping you.\\n\\n# Asterisk Configuration Files\\n\\n## pjsip.conf\\n\\n```plaintext\\n;===============TRANSPORT\\n\\n[transport-udp]\\ntype=transport\\nprotocol=udp\\nbind=127.0.0.1\\n\\n; provide ziti intercepted IP to clients\\nexternal_media_address=192.168.8.1\\nexternal_signaling_address=192.168.8.1\\n\\n;===============ENDPOINT TEMPLATES\\n\\n[endpoint-basic](!)\\ntype=endpoint\\ncontext=default\\ndisallow=all\\nallow=ulaw\\n\\n; asterisk puts this in the \\"host\\" section of outgoing From: headers.\\n; without this, the source IP of the message will be used (e.g. the host\'s lan ip).\\nfrom_domain=192.168.8.1\\n; don\'t attempt to connect phones directly with each other.\\ndirect_media=no\\n; return rtp packets to the hosting tunneler\'s punched hole instead of the SDP c= address.\\nrtp_symmetric=yes\\n\\n[auth-userpass](!)\\ntype=auth\\nauth_type=userpass\\n\\n[aor-single-reg](!)\\ntype=aor\\nmax_contacts=1\\nremove_existing=yes\\n; prevent client tunnelers from closing SIP connections due to 30s idle timeout.\\nqualify_frequency=25\\n\\n;===============EXTENSION 6001\\n\\n[6001](endpoint-basic)\\nauth=auth6001\\naors=6001\\n\\n[auth6001](auth-userpass)\\npassword=6001\\nusername=6001\\n\\n[6001](aor-single-reg)\\n\\n;===============EXTENSION 6002\\n\\n[6002](endpoint-basic)\\nauth=auth6002\\naors=6002\\n\\n[auth6002](auth-userpass)\\npassword=6002\\nusername=6002\\n\\n[6002](aor-single-reg)\\n\\n;===============EXTENSION 6003\\n\\n[6003](endpoint-basic)\\nauth=auth6003\\naors=6003\\n\\n[auth6003](auth-userpass)\\npassword=6003\\nusername=6003\\n\\n[6003](aor-single-reg)\\n```\\n\\n## rtp.conf\\n\\n```plaintext\\n;\\n; RTP Configuration\\n;\\n[general]\\n;\\n; RTP start and RTP end configure start and end addresses\\n;\\n; Defaults are rtpstart=5000 and rtpend=31000\\n;\\nrtpstart=10000\\nrtpend=20000\\n```\\n\\n## extensions.conf\\n\\n```plaintext\\n[from-internal]\\nexten = 100,1,Answer()\\nsame = n,Wait(1)\\nsame = n,Playback(hello-world)\\nsame = n,Hangup()\\n\\n[default]\\nexten=>6001,1,Dial(PJSIP/6001,20)\\nexten=>6002,1,Dial(PJSIP/6002,20)\\nexten=>6003,1,Dial(PJSIP/6003,20)\\n```"},{"id":"bootstrapping-trust-part-5-bootstrapping-trust","metadata":{"permalink":"/docs/openziti/blog/bootstrapping-trust-part-5-bootstrapping-trust","source":"@site/blog/bootstrapping-trust-part-5.md","title":"Bootstrapping Trust Part 5","description":"If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series:","date":"2022-06-03T14:02:35.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":5.79,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"title":"Bootstrapping Trust Part 5","date":"Fri Jun 03 2022 14:02:35 GMT+0000 (Coordinated Universal Time)","cuid":"cl3yin5gw009jodnv0lv08r2r","slug":"bootstrapping-trust-part-5-bootstrapping-trust","authors":["AndrewMartinez"],"image":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","imageDark":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","tags":["security"]},"unlisted":false,"prevItem":{"title":"Tunneling VoIP over OpenZiti","permalink":"/docs/openziti/blog/tunneling-voip-over-openziti"},"nextItem":{"title":"Bootstrapping Trust Part 4","permalink":"/docs/openziti/blog/bootstrapping-trust-part-4-certificate-authorities-chains-of-trust"}},"content":"If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series:\\n\\n\x3c!-- truncate --\x3e\\n\\n* [Part 1: Encryption Everywhere](./bootstrapping-trust-part-1.md)\\n* [Part 2: A Primer On Public-Key Cryptography](./bootstrapping-trust-part-2.md)\\n* [Part 3: Certificates](./bootstrapping-trust-part-3.md)\\n* [Part 4: Certificate Authorities & Chains Of Trust](./bootstrapping-trust-part-4.md)\\n* [Part 5: Bootstrapping Trust](./bootstrapping-trust-part-5.md)\\n\\n### Ziti\\n\\nIn this series of articles, we are exploring bootstrapping trust, what that means, and how it enables Zero Trust security methodologies. Ziti provides a method to bootstrap trust via its enrollment process. For Ziti, the enrollment process is bootstrapping trust. This trust must be in place as all connections in Ziti require verification. All identities in Ziti have a key pair that identifies that individual. The enrollment process abstracts the steps of setting up keys, certificates, CSRs, CAs, and deploying them to the proper locations. In addition, the Ziti SDKs can be embedded within any application and enroll with a Ziti network in the exact same fashion to bootstrap trust as part of Ziti\'s Zero Trust model.\\n\\nZiti has a concept called the \\"Edge.\\" The Edge is a set of software features that sit on top of the \\"Fabric.\\" The Fabric is the core of each Ziti component, and it provides long haul mesh routing while the Edge focuses on enrolling Ziti components, managing access via policies, and maintaining the trust necessary to provide the foundation of a Zero Trust network without the hassle of setting it up yourself. Together they are a powerful combo of optimized long halt routing and trust management.\\n\\n![](/blogs/openziti/v1654257650307/yK04Reo05.png)\\n\\nA small scale example Ziti system appears as follows:\\n\\n![](/blogs/openziti/v1654257651564/s2sDvUeqe.png)\\n\\nZiti Edge has the concepts of identities for endpoint SDKs and routers. Both require certificates signed by a trusted CA. Ziti can generate the PKI necessary to manage that trust. The PKI and its CAs will form the backbone of the trust system that Ziti will deploy for you. In the system diagram above, the Ziti Controller will manage an intermediate CA and a secure enrollment process that will bootstrap trust for each router and SDK. After bootstrapping trust, the controller will maintain data to manage the entire life cycle of the certificates it generates. This life cycle encompasses all the concerns from part one of this series, including bootstrapping, revoking, renewing, and rotating keys.\\n\\nSo let us review the components a Ziti Controller must have to function:\\n\\n1. A CA (intermediate preferred)\\n    \\n2. A server certificate generated for the Controller\'s IP/hostname/etc. Signed by the CA or a public CA\\n    \\n3. A Ziti Controller configured and ready to run\\n    \\n\\nThis article series has touched on items one and two, but not three. For information on how to configure a Ziti Controller refer to the Ziti documentation repository on Github. You will also find details on how to use the Ziti CLI to generate the PKI necessary to start a Ziti network. However, here is a simple command that will help get the controller started.\\n\\nziti pki create ca test1 ziti pki create server --dns myserver.com\\n\\n## Enrollment\\n\\nOnce a Ziti Controller is up and running, it is possible to create a new identity and enroll it. Behind the scenes, many things happen, but for now, let us focus on what an administrator would have to perform.\\n\\n1. Authenticate via the Ziti CLI, Ziti Admin Console (ZAC), or Edge REST API\\n    \\n2. Issue a request to create a new identity for an SDK or router\\n    \\n3. Receive an enrollment JWT Use the JWT on the enrolling device/server to enroll\\n    \\n\\nIn those steps, we have performed many complex interactions.\\n\\n* The enrolling identity:\\n    \\n* validated the enrollment JWT cryptographically\\n    \\n* validated the Ziti Controller as a suitable trust anchor cryptographically\\n    \\n* bootstrapped its trust pool of CAs as additional trust anchors over a secure connection\\n    \\n* generated a key pair\\n    \\n* generated a CSR\\n    \\n* The controller has:\\n    \\n* asserted its identity cryptographically\\n    \\n* asserted the validity of the enrolling identity\\n    \\n* provided a CA store of trust anchors\\n    \\n* fulfilled the CSR request for the identity\\n    \\n\\nAll of these items are performed making no assumptions and securely verifying each step. This process does not suffer from man-in-the-middle attacks. It provides many benefits! Below is a detailed image of each step of the enrollment process.\\n\\n![](/blogs/openziti/v1654257653691/DBRXUelWS.png)\\n\\nLet\'s break those steps down:\\n\\n1. Via the Ziti CLI, ZAC, or Edge REST API the admin authenticates and requests to create an identity\\n    \\n2. The admin receives a JWT that is signed by the controller and is cryptographically verifiable. The JWT contains all the information for the enrolling device/server to contact the controller and verify its identity. It also includes a secret enrollment token.\\n    \\n3. The JWT is given to the enrolling device\\n    \\n4. The device parses the JWT, verifies all the information is present to enroll\\n    \\n5. The device retrieves the public certificate from the controller at the address specified in the JWT\\n    \\n6. The device confirms that the server is, in fact, the owner of the private key for that certificate\\n    \\n7. The device uses the retrieved certificate to verify the signature on the JWT\\n    \\n8. Verifies content has not changed\\n    \\n9. Verifies the issuing server is the server it is communicating with\\n    \\n10. Makes a secure connection to the server and requests the CAs to trust\\n    \\n11. The enrolling identity generates a key pair, if necessary, and a CSR. The CSR is submitted in a request with the JWT\'s enrollment token.\\n    \\n12. The controller verifies the CSR, verifies the enrollment token, verifies the client connection, and then returns the necessary signed certificates.\\n    \\n\\nAt the end of the process, which took four simple human steps, but numerous cryptographically secure software steps, the controller now has a record of the certificates issued to a specific identity. That identity now has certificates that can be used to make connections to other enrolled Ziti components. All components in the system can verify the identity of any other Ziti component. At every step, every link is verified. No individual piece of software blindly trusts any other for inbound or outbound connections. Trust has been successfully bootstrapped! Now we enter a maintenance window where trust has to be verified continuously and maintained. The enrolled identity can now interact with the Ziti Controller to either function as a Ziti Router or as Zero Trust network client.\\n\\n# Conclusion\\n\\nThank you for reading this far! If you completed the entire series, I hope it has been helpful. Zero Trust is a complicated topic, and it requires a serious foundation in bootstrapping trust to get right. Hopefully, this series starts you on your way. If you have time, please checkout [Ziti](https://github.com/openziti)! It is the Zero Trust network overlay solution that I have personally worked on and was the inspiration for this series."},{"id":"bootstrapping-trust-part-4-certificate-authorities-chains-of-trust","metadata":{"permalink":"/docs/openziti/blog/bootstrapping-trust-part-4-certificate-authorities-chains-of-trust","source":"@site/blog/bootstrapping-trust-part-4.md","title":"Bootstrapping Trust Part 4","description":"If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series:","date":"2022-06-03T13:57:36.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":7.88,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"title":"Bootstrapping Trust Part 4","date":"2022-06-03T13:57:36.000Z","cuid":"cl3yigq5d008xodnvbyiwfve3","slug":"bootstrapping-trust-part-4-certificate-authorities-chains-of-trust","authors":["AndrewMartinez"],"image":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","imageDark":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","tags":["security"]},"unlisted":false,"prevItem":{"title":"Bootstrapping Trust Part 5","permalink":"/docs/openziti/blog/bootstrapping-trust-part-5-bootstrapping-trust"},"nextItem":{"title":"Bootstrapping Trust Part 3 - Certificates","permalink":"/docs/openziti/blog/bootstrapping-trust-part-3-certificates"}},"content":"If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series:\\n\\n* [Part 1: Encryption Everywhere](./bootstrapping-trust-part-1.md)\\n* [Part 2: A Primer On Public-Key Cryptography](./bootstrapping-trust-part-2.md)\\n* [Part 3: Certificates](./bootstrapping-trust-part-3.md)\\n* [Part 4: Certificate Authorities & Chains Of Trust](./bootstrapping-trust-part-4.md)\\n* [Part 5: Bootstrapping Trust](./bootstrapping-trust-part-5.md)\\n    \\n\\nThis article makes implicit heavy use of [part 2](./bootstrapping-trust-part-2.md) and [part 3](./bootstrapping-trust-part-3.md) of this series.\\n\\n\x3c!-- truncate --\x3e\\n\\n### Root & Intermediate Certificate Authorities (CAs)\\n\\nNot all certificates are the same! Certificates have different capabilities depending on their usage attributes and extensions. The previous article in this series mentioned a few of those attributes and extensions. Two of those were `clientAuth`, for client certificates, and `serverAuth`, for server certificates, which play an essential role in how a certificate is used during network authentication negotiations. These roles are crucial, as they are a contract for what attributes and extensions should be included in the certificate to make it useful. For example, a server certificate usually finds it useful to include Subject Alternate Names (SANs). A SAN can be used to tie a certificate to a specific domain name (like ziti.dev). However, a client certificate will not have use for those same fields.\\n\\nThe roles of certificates and the attributes/extensions they have are not always strictly followed. Some systems, such as web browsers, require SANs on a server certificate. That wasn\'t always the case. Before that, the Common Name field in the subject information contained the domain name. Some systems still rely on that convention.\\n\\nAnother type of certificate is a Certificate Authority (CA) certificate. A CA is a key pair with a certificate that has a unique purpose: to sign other certificates. CA certificates have a special CA flag set to \\"true.\\" This flag alone does not grant the CA certificate any power, but if a system trusts that CA, it then allows that system to trust any certificate that CA has signed. As mentioned in previous parts of this series, trusting a CA is a software or operating system configuration process. This process can be done in multiple ways depending on the system: adding it to a store, a specific folder, or adding lines to a configuration file.\\n\\nYour operating system, right now, has its own set of trusted CAs. Most operating systems come with a default list installed and maintained by your OS developer. Over time this list is added to and removed from as trust is granted or withdrawn. Some pieces of software come with a list of CAs that are used instead of or in addition to the OS\'s CAs. The power of a CA comes not by its creation but by it being trusted.\\n\\nCAs come in two flavors: Root CAs and Intermediate CAs. Root CAs are the egg or the chicken (depending on your viewpoint) of the CA trust chicken-and-egg problem. Trust for CAs has to start somewhere. With CAs, it is the Root CA. A Root CA can sign certificates that are themselves CAs as well. Those certificates represent Intermediate CAs. Layers of CAs starting with a root and adding intermediates along the way allows the private key for the Root CAs to be kept in a highly secure environment, which is not convenient to use for signing. This security means that the Root CA has a far less likely chance of having its private key compromised. Intermediate CAs are put into less secure environments and, if compromised, can be revoked. Trust is usually put into the Root CA, and since it was not compromised can remain trusted. Compromised intermediate CAs can be blacklisted.\\n\\nRunning a public CA is serious business if you wish to be publicly trusted. The organizations running a CA have to have strict protocols that verify the security and safe handling of the CAs private keys. If the private key is compromised, it can be used to sign other certificates for malicious intents. Any system that trusted the compromised CA will now trust any maliciously signed certificates. This will compromise all certificates signed by that CA.\\n\\nPublic CAs are maintained by organizations such as DigiCert, Let\'s Encrypt, and others. Anyone can create private CAs. The only difference is that the number of systems that trust a private CA is much smaller than that of a public one. CAs are a cornerstone of bootstrapping trust. Trusting the proper CAs can grant trust to a large number of systems.\\n\\n### Chains of Trust & PKIs\\n\\n[Part three](./bootstrapping-trust-part-3.md) of this series introduced that certificates self-sign or sign another certificate. Certificates are usually signed via Certificate Signing Requests (CSRs). A certificate signing itself is called a \\"self-signed certificate\\" and is an indicator of it being a root CA if the CA flag is also set to true. A root CA can sign other certificates that also have the CA flag set to true. Those types of certificates are intermediate CAs. Any CA, root or intermediate, that fulfills a CSR and signs the enclosed certificate will generate a non-CA certificate as long as the CA flag is false. These certificates are \\"leaf certificates.\\"\\n\\nThe term Public Key Infrastructure (PKI) is used to describe all of the outputs that are generated when a CA is created. That includes the root, intermediates, and leaf certificates. It also optionally includes all of the systems, processes, procedures, and data used to manage them. For the purpose of this article, and simplicity, let us stick to the certificates only.\\n\\nConsider the following PKI setup:\\n\\n* Two root CAs:\\n    \\n* Root A\\n    \\n* Root B\\n    \\n* The root CAs each sign an intermediate CA via CSR:\\n    \\n* Intermediate A\\n    \\n* Intermediate B\\n    \\n* A server wishes to have a certificate to have Root A\'s trust extended to it.\\n    \\n* A key pair is generated\\n    \\n* A CSR is created and submitted to Intermediate A to sign\\n    \\n* The CSR is fulfilled.\\n    \\n* Server Cert A is created and signed by Intermediate A\\n    \\n\\nVisually this would appear as follows:\\n\\n![](/blogs/openziti/v1654257659271/JAGd2gVAS.png)\\n\\nThis PKI has two chains of trust: Chain A and Chain B. They are called chains because the signatures link the certificates together. Root A has signed Intermediate A\'s certificate and Intermediate A has signed Server A\'s certificate. Programmatically we can traverse these signatures and verify them using the public certificates of each signatory. Trusting Root A will trust Server A.\\n\\nThe second chain, Chain B, does not sign any of the certificates on Chain A. As expected, Trusting either of the CAs from Chain B does not grant any trust to the certificates on Chain A. Chain B highlights the fact that any system may have multiple chains of trust that do not interact in any fashion.\\n\\nReturning to Chain A, trusting Intermediate A designates it as a \\"trust anchor.\\" Any certificate can be a trust anchor. The certificate used as a trust anchor determines which certificates will additionally be trusted. A leaf certificate as a trust anchor only trusts that one certificate. Trusting a CA trusts all certificates that it has signed itself or any of its intermediates. In the diagram above, trust only flow downward.\\n\\n* Trusting Server Cert A will only trust that one server certificate\\n    \\n* Trusting Intermediate A will trust Server Cert A and any other certificate it signs\\n    \\n* Trust Root A will trust Intermediate A and Server Cert A and any other certificate Root A signs (intermediate CA or not) and in turn, any of the certificates they sign\\n    \\n\\nTrusting a CA that has signed many certificates allows public certificate trust to scale. This is how trust scales for web traffic. Companies like DigiCert, IdenTrust, GoDaddy, etc. have their root CA or one of their large intermediate CAs trusted. Those CAs sign certificates for websites. All of our devices trust those website certificates because the CA has signed them.\\n\\n### Distributed Systems & CAs\\n\\nThe goal for any private distributed system should be to have certificates verified on both sides: clients verify servers and vice versa. This behavior is a tenant of Zero Trust - do not trust, verify. Verification should be done on every connection before any data exchange. Over TLS, which secures HTTPS, this would be \\"mutual TLS\\" or \\"mTLS.\\" Most public websites do not require mTLS. Instead, they use TLS with the client validating the server. For public web traffic, the server wishes to be trusted widely. The reverse is not necessary. If it is, websites use an additional form of authentications, like usernames and passwords, to verify the client\'s identity. Public key cryptography is a stronger authentication mechanism, but it is also difficult for the general public to set up, manage, and maintain.\\n\\nThe same is true for distributed systems. Most don\'t secure anything at all or only verify servers. It is inherently insecure and can cause issues depending on the setup of the system. Ziti is a distributed system that abstracts away this security setup for both its internal routers and client SDKs. This setup allows application-specific networking with strong identity verification, powerful policy management, flexible mesh routing, and more. The goal of this series is to focus on bootstrapping trust. So in the [last article](./bootstrapping-trust-part-5.md) we will come full circle and see how all of this relates to bootstrapping trust for Zero Trust networks."},{"id":"bootstrapping-trust-part-3-certificates","metadata":{"permalink":"/docs/openziti/blog/bootstrapping-trust-part-3-certificates","source":"@site/blog/bootstrapping-trust-part-3.md","title":"Bootstrapping Trust Part 3 - Certificates","description":"Bootstrapping Trust Part 3","date":"2022-06-03T12:50:35.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":5.99,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"title":"Bootstrapping Trust Part 3 - Certificates","date":"2022-06-03T12:50:35.000Z","slug":"bootstrapping-trust-part-3-certificates","authors":["AndrewMartinez"],"image":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","imageDark":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","tags":["security"]},"unlisted":false,"prevItem":{"title":"Bootstrapping Trust Part 4","permalink":"/docs/openziti/blog/bootstrapping-trust-part-4-certificate-authorities-chains-of-trust"},"nextItem":{"title":"Bootstrapping Trust Part 2 - PKI","permalink":"/docs/openziti/blog/bootstrapping-trust-part-2-a-primer-on-public-key-cryptography"}},"content":"## Bootstrapping Trust Part 3\\n\\nIf you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series:\\n\\n* [Part 1: Encryption Everywhere](./bootstrapping-trust-part-1.md)\\n* [Part 2: A Primer On Public-Key Cryptography](./bootstrapping-trust-part-2.md)\\n* [Part 3: Certificates](./bootstrapping-trust-part-3.md)\\n* [Part 4: Certificate Authorities & Chains Of Trust](./bootstrapping-trust-part-4.md)\\n* [Part 5: Bootstrapping Trust](./bootstrapping-trust-part-5.md)\\n\\nIn the series, we have covered public-key cryptography, where we learned about public keys, private keys, and their uses for encryption and signing. Using keys to sign data will play an essential role in this article. It is vital that the reader understand that signatures verify both the content of the data and its source. For a refresher, see [part two](./bootstrapping-trust-part-2.md) of this series.\\n\\n\x3c!-- truncate --\x3e\\n\\nThis article covers how certificates and certificate authorities (CAs) work as \\"trust anchors.\\" When a CA is a trust anchor, it means that a system can trust the CA to sign certificates that it can, in turn, trust. Throughout this entire article, \\"trusting certificates\\" is mentioned. Trusting a certificate (CA or otherwise) is a software or operating system configuration process. This configuration tells the system that the specified certificates are trustworthy in the eyes of the operator.\\n\\n### Certificates\\n\\nPart two of this series covered keys, both public and private, but did not mention certificates. It is common to hear \\"certificate\\" used interchangeably with \\"public key\\" and, sometimes, \\"private key.\\" A certificate must have the public key inside of it. Some storage formats allow certificates to be stored along with the matching private key. One example of this is PFX files. PFX files, which are PKCS#12 archives, are also sometimes generically referred to as \\"certificates\\". In this article \\"certificate\\" will always mean an x509 certificate that contains\\\\\\nonly the public key.\\n\\nCertificates are a simple concept, but years of expansions and extensions have added to them and can be daunting uninitiated when you get into the nitty-gritty details. This article will strive to sit above that detail. If you venture into the realm of generating certificates, using OpenSSL and its configuration files, it can be a cumbersome experience to wade through. There are many great articles and tutorials available to get you started.\\n\\nFor this article, the word \\"certificate\\" will mean an \\"x509 Certificate\\". x509 is a public standard and is the de-facto standard for software systems dealing with public-key cryptography. There are other formats, but they are usually environment-specific, such as Card Verifiable Certificates. x509 good enough for general purpose use on most systems.\\n\\nSo, what is a certificate? It is yet another blob of data that is specially formatted. It can be stored anywhere data can be stored but is usually a file. For this conversation, we will focus on the following subset of information that a certificate contains:\\n\\n*   Subject information\\n*   A public key\\n*   Distinguished Name\\n*   Issuer Information\\n*   Validity Period\\n*   Usage/Extensions\\n*   Signatures\\n\\n#### Subject Information\\n\\nCertificates contain more than keys. The Distinguished Name (DN) are text fields. They are useful mainly to humans to know what/who owns a certificate. It is sometimes used by software as display information or for comparison checks. Since humans provide the DN values or configure software with values, it is not always distinguishing. DN values have an alternate name: relatively distinguished names.\\n\\nRelated to the Subject DN is the Issuer Information. The Issuer Information is the subject of the certificate that issued the certificate. Because of this, both the issuer information has similar values to the subject DN. Both can include the following information:\\n\\n*   CN - common name - a name\\n*   SN - surname\\n*   SERIALNUMBER - a number that is usually unique per certificate issuer, but not always\\n*   C - country\\n*   L - locality name\\n*   ST or S - state or province\\n*   STREET - street address\\n*   O - organization name\\n*   OU - organizational unit\\n*   T - title\\n*   G or GN - given name\\n*   E - email address\\n*   UID - user id\\n*   DC - domain component\\n\\nDo not worry about memorizing that list. Simply knowing they exist and that they may or may not matter is good enough for now. If the reader is wondering when they might matter, well, that is generally when the system you are using complains about them.\\n\\n#### Validity Period\\n\\nThe Validity Period specifies two points in time from when the certificate is valid. Before and after this window of time, the certificate is invalid and should not be trusted. Validity periods should be as small as possible to fit their use case. Shorter periods reduce the window of time that compromised private key can remain useful for an attack. The cost of this is overhead reissuing certificates as they reach the end of their validity period.\\n\\n#### Usage/Extensions\\n\\nUsage/Extension Data is interesting because it can limit what roles a certificate fulfills. Depending on the system, this may be adhered to or not. Some examples of usage that are common to see:\\n\\n*   key usage: client authentication, server authentication, signatures, etc.\\n*   Subject Alternate Names (SANs)\\n*   Limits what IP address, email address, domain name, etc. the certificate can be associated with\\n*   Certificate Authority (CA) flag\\n*   and more\\n\\nThis series will not dive into the details of these usages. However, it is essential to be aware of them and that they can affect the roles a certificate can fulfill.\\n\\n#### Signatures\\n\\nThe signature section of a certificate is a list of signatures from other entities that trust this certificate. A certificate that signs itself is a \\"self-signed certificate.\\" Self-signed certificates must be individually trusted as no other certificate has expressed trust in it by signing it. Self-signed certificates are sometimes used for testing purposes as they are easy to create. They are also used as Root Certificate Authorities (root CAs).\\n\\nEach signature on a certificate is the result of taking the contents of the certificate (without signatures), one-way hashing it, and then encrypting the hash with the signator\'s private key. The result is appended to the end of the signature list. During this process, the public certificate moves between systems to be signed.\\n\\nThe movement of the public certificate between systems is facilitated by Certificate Signing Requests (CSRs). CSRs can be transmitted electronically as files or as a data stream to the signer. CSRs contain only the public information of a certificate and a signature from the certificate\'s private key. Since CSRs only contain public information, they are not considered sensitive. The signature in a CSR allows the signer to verify that the CSR is from the subject specified in the CSR. If the signature is valid, the signator processes the CSR, and the result is a newly minted certificate with an additional signature.\\n\\n### Conclusion\\n\\nCertificates are keys, usually public ones, with additional metadata that adds conventions and restrictions around certificate usages. They provide a place for signatures to resides and, through CSRs, provide a vehicle to request additional signatures. Certificates are useful because they package all of these concerns into a neat single file. In [part four](./bootstrapping-trust-part-4.md), we will explore how to create a formidable chain of trust by linking multiple certificates together."},{"id":"bootstrapping-trust-part-2-a-primer-on-public-key-cryptography","metadata":{"permalink":"/docs/openziti/blog/bootstrapping-trust-part-2-a-primer-on-public-key-cryptography","source":"@site/blog/bootstrapping-trust-part-2.md","title":"Bootstrapping Trust Part 2 - PKI","description":"If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series:","date":"2022-06-03T12:42:37.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":7.76,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"title":"Bootstrapping Trust Part 2 - PKI","date":"2022-06-03T12:42:37.000Z","cuid":"cl3yfsb8900joemnv4jk46g98","slug":"bootstrapping-trust-part-2-a-primer-on-public-key-cryptography","authors":["AndrewMartinez"],"image":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","imageDark":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","tags":["security"]},"unlisted":false,"prevItem":{"title":"Bootstrapping Trust Part 3 - Certificates","permalink":"/docs/openziti/blog/bootstrapping-trust-part-3-certificates"},"nextItem":{"title":"Bootstrapping Trust Part 1 - Encryption Everywhere","permalink":"/docs/openziti/blog/bootstrapping-trust-part-1-encryption-everywhere"}},"content":"If you have read through the entire series up to here, welcome! If you have not, please consider reading the whole series:\\n\\n* [Part 1: Encryption Everywhere](./bootstrapping-trust-part-1.md)\\n* [Part 2: A Primer On Public-Key Cryptography](./bootstrapping-trust-part-2.md)\\n* [Part 3: Certificates](./bootstrapping-trust-part-3.md)\\n* [Part 4: Certificate Authorities & Chains Of Trust](./bootstrapping-trust-part-4.md)\\n* [Part 5: Bootstrapping Trust](./bootstrapping-trust-part-5.md)\\n    \\n\\nIt isn\'t easy to talk about bootstrapping trust without covering the basics of public-key cryptography. The reader may skip this article if the concepts of encryption, signing, and public/private keys are familiar. However, if not, I implore that you bear the brunt of this article as later parts will heavily rely on it.\\n\\n\x3c!-- truncate --\x3e\\n\\nIf you wish, you can dive into the mathematics behind it to prove it to yourself, but I promise, no math here. When necessary, I will wave my hands at it, point into the distance, and let the reader journey out.\\n\\n### Keys\\n\\nKeys are blobs of data containing rather large numbers. They can be stored anywhere data can be stored, but are commonly stored as files. A set of public and private keys is referred to as a \\"key set\\" or \\"key pair.\\"\\n\\nWithin a key pair, there is only one private key and one public key. The two keys are mathematically entangled, given a particular function and its parameters. Today, those functions and parameters are generally elliptical curves and are the basis of a \\"trapdoor function.\\" Trapdoor functions are attractive to the cryptographically inclined for two main reasons:\\n\\n1. they make it easy to encrypt with one key of a key pair and decrypt with the other.\\n    \\n2. one key cannot be derived from the other\\n    \\n\\nOf the two keys, the private key is the most important. It must be kept tucked away from prying eyes and attackers. Some secure environments store the private key in hardware such as [Hardware Security Modules (HSMs)](https://en.wikipedia.org/wiki/Hardware_security_module) or [Trusted Platform Modules (TPMs)](https://en.wikipedia.org/wiki/Trusted_Platform_Module). Mobile devices, such as laptops and smartphones, use hardware technology similar to TPMs. Apple has its Secure Enclave, and Android has its Keymaster Hardware Abstraction Layer. The goal of all of these pieces of hardware is to keep sensitive secrets (e.g., private keys) safe. The fact that an entire industry of embedded hardware has been developed to keep private keys safe should tip the reader off to how important they are.\\n\\nAs stated above, these two keys have some impressive capabilities. It is not possible to derive one from the other. This allows the public key to be handed out freely without compromising the private key. Also, both keys can generate encrypted data that only the other key can decrypt. More clearly:\\n\\n1. Anyone with the public key can encrypt data only the private key holder can decrypt\\n    \\n2. Anyone with the public key can decrypt data from the private key holder\\n    \\n\\nNumber one can succinctly be called \\"Public Key Encryption\\" and number two \\"Private Key Encryption.\\" This article explores the merits of both.\\n\\n#### Public Key Encryption\\n\\nFrom the list above, number one is what most people think of as \\"encryption.\\" It is \\"secure\\" as it allows anyone with the widely available public key to send messages only the private key holder can read. This property ensures that communication from the public key holder to the private key holder is being read exclusively by the intended target.\\n\\nThere is quite a bit of pressure to keep the private key extremely safe. Whoever holds the private key, has a guaranteed identity that is tied to and verifiable by the public key. It is verifiable because if one can use the public key to encrypt data, only the private key holder can decrypt it. This fact means that data can be encrypted and sent that coordinates on an additional secret. Since only the private key holder can decrypt the data to see this second level secret, future communication can use the new secret to encrypted and verify traffic in both directions. This additional exchange is roughly how part of the TLS negotiation works for HTTPs. TLS, and by proxy HTTPS, use other technologies and strategies to provide an incredible security proposition.\\n\\n#### Private Key Encryption\\n\\nFor private key encryption, the same principles apply as with public key encryption with the roles reversed. The private key encrypts data only the public key can decrypt. On the surface, this seems absurd. When the server encrypts data with its private key, the public key can decrypt it. The public key is not protected and expected to be widely available. It seems as if private key encryption is nearly useless as everyone can read it!\\n\\nExcept it isn\'t. Private key encryption verifies the identity of the private key holder. The public key cannot interact with anyone else. Additionally, this property allows us to generate encrypted data that could only have come from the private key holder. If that data happens to be small and describe another document, we call that a \\"digital signature\\" or \\"signature\\" for short.\\n\\n### Digital Signatures\\n\\nDigital signatures are similar to handwritten ones used to sign legal documents and checkbooks, but with a significant advantage. They validate that a document has not been altered since it was signed. With today\'s computer\'s graphical abilities, the nefarious can forge images and handwritten signatures. That puts handwritten signatures at a significant disadvantage. So how does this work?\\n\\nThe data that will be signed can be anything. What it represents is not important. It can be text, JSON, an image, a PDF, or anything at all! That data is processed by a one-way [cryptographic hashing algorithm](https://en.wikipedia.org/wiki/Cryptographic_hash_function), such as SHA-256. This process is idempotent, meaning running it repeatedly on the same data, parameters, and hashing algorithm gives the same result. The output of this process is a hash, a string of characters that uniquely identifies the input data. With sufficiently large input data, the hash is much shorter than the input data as the hash size is usually fixed length.\\n\\nFor example, here is the Ziti logo:\\n\\n![](/blogs/openziti/v1654257666736/kPJ_N4wis.png)\\n\\nThis logo\'s file can be hashed using SHA-256 via the `sha256sum` command commonly found on Linux.\\n\\n`c3a6681cc81f9c0fa44b3e2921495882c55f0a86c54cd60ee0fdc7d200ad26db=`\\n\\nThat long string \\"c3a....6db\\" is the hash of that file! The string is 64 characters long and is comprised of hex characters (a base 16 numbering system of 0-9 and a-f). Each character takes four bits to represent (4^2 = 16). Since there are 64 characters at 4 bits each we have: 64 x 4 = 256. This is where SHA-256 gets its name. SHA-256 is a fixed-length cryptographic hashing algorithm who\'s output is 256 bits in length.\\n\\nThe hash itself is not encryption. It is \\"hashing.\\" Hashing of this nature is not reversible while encryption is. For cryptographic hashing, it is impracticable to have two similar sets of data that have the same function that produces the same hash. In essence, the hash uniquely represents the data: all of it! Changing even a single character would generate a different hash.\\n\\nAfter hashing a data or document, the private key holder can encrypt the hash to generate a signature. This process provides the following truths when working with the signature:\\n\\n* the private key is the only key capable of producing its signature of the data\'s hash\\n    \\n* the public key can validate the signature given the data and hashing algorithm used\\n    \\n\\nVerifying a signature a straightforward process:\\n\\n* Use the public key to decrypt the signature to reveal the original hash\\n    \\n* Use the hashing algorithm that was used initially on the data, recreate the hash independently\\n    \\n* Compare the two hashes, and if they are the same the signature is valid\\n    \\n\\nSigning data is incredibly powerful. It allows a private key holder to state that data was approved by them and not altered. It is also publicly verifiable to anyone with the document, signature, and public key. This allows many decentralized approaches to sharing data that can have its source and content verified.\\n\\nBearer tokens are an example of the power of signatures. Bearer tokens are a document that is signed by a trusted authentication system and contain data that provides information about the client presenting the token. Signing the token ensures that the content of the token has not been changed and has been endorsed by a trusted system. An example of a bearer token is a [JSON Web Token (JWT)](https://en.wikipedia.org/wiki/JSON_Web_Token)\\n\\nA JWT specifies the format of the bearer token as a header, payload, and signature using JSON. A client can then present a JWT to any system which can then verify that the contents are valid and from a trusted identity. As long as the signature is valid, the JWT can grant access to the client presenting it based on whatever information is inside the JWT.\\n\\n# Closing\\n\\nThis article should have shed light on public-key cryptography by explaining the roles of the public and private keys. It should have also provided a glimpse at the power of encryption and digital signatures. In [part three](./bootstrapping-trust-part-3.md) we will see how key pairs can be combined with certificates!"},{"id":"bootstrapping-trust-part-1-encryption-everywhere","metadata":{"permalink":"/docs/openziti/blog/bootstrapping-trust-part-1-encryption-everywhere","source":"@site/blog/bootstrapping-trust-part-1.md","title":"Bootstrapping Trust Part 1 - Encryption Everywhere","description":"Whether you are an encryption expert or a newcomer, welcome! This series is for you! It assumes you know nothing and takes you from soup to nuts on how to bootstrap trust with the intent to power a Zero Trust security model. The process and thinking described in this series are the direct output of developing the same system for the Ziti open source project. Ziti can be found on the GitHub project page for OpenZiti. The series starts with the basics and dovetails into Ziti\'s Enrollment system.","date":"2022-06-03T12:20:35.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":14.79,"hasTruncateMarker":true,"authors":[{"name":"Andrew Martinez","title":"Author","url":"https://github.com/andrewpmartinez","imageURL":"https://avatars.githubusercontent.com/andrewpmartinez","key":"AndrewMartinez","page":null}],"frontMatter":{"title":"Bootstrapping Trust Part 1 - Encryption Everywhere","date":"2022-06-03T12:20:35.000Z","cuid":"cl3yezz5h0071jenv50mr48ia","slug":"bootstrapping-trust-part-1-encryption-everywhere","authors":["AndrewMartinez"],"image":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","imageDark":"@site/blogs/openziti/v1654265273968/JSUhAzpL_.jpeg","tags":["security"]},"unlisted":false,"prevItem":{"title":"Bootstrapping Trust Part 2 - PKI","permalink":"/docs/openziti/blog/bootstrapping-trust-part-2-a-primer-on-public-key-cryptography"},"nextItem":{"title":"Configuring OpenZiti to Enable Prometheus","permalink":"/docs/openziti/blog/configuring-openziti-to-enable-prometheus"}},"content":"Whether you are an encryption expert or a newcomer, welcome! This series is for you! It assumes you know nothing and takes you from soup to nuts on how to bootstrap trust with the intent to power a Zero Trust security model. The process and thinking described in this series are the direct output of developing the same system for the Ziti open source project. Ziti can be found on the GitHub project page for [OpenZiti](https://github.com/openziti). The series starts with the basics and dovetails into Ziti\'s Enrollment system.\\n\\nThe parts are as follows.\\n\\n* [Part 1: Encryption Everywhere](./bootstrapping-trust-part-1.md)\\n* [Part 2: A Primer On Public-Key Cryptography](./bootstrapping-trust-part-2.md)\\n* [Part 3: Certificates](./bootstrapping-trust-part-3.md)\\n* [Part 4: Certificate Authorities & Chains Of Trust](./bootstrapping-trust-part-4.md)\\n* [Part 5: Bootstrapping Trust](./bootstrapping-trust-part-5.md)\\n\\n\x3c!-- truncate --\x3e\\n    \\n\\n### Zero Trust\\n\\nThis entire series assumes some familiarity with Zero Trust. If you do not have a strong background in it, that is fine. This section should give the reader enough context to make use of the entire series. If a more in-depth understanding is desired, please consider reading *Zero Trust Networks: Building Secure Systems in Untrusted Networks* by Evan Gilman.\\n\\nZero Trust is a security model that requires strict identity authentication and access verification on every connection at all times. It sets the tone for a system\'s security to say, \\"this system shall never assume the identity or access of any connection.\\" Before the Zero Trust security models, IT infrastructures were set up as a series of security perimeters. Think of as a castle with walls and moats. The castle would have a set number of entry points with guards. Once past the guards and inside the castle, any visitors were trusted and had access to the castle. In the real world, passing the guards is analogous to authenticating with a machine or, at worst, connect the office network via WiFi or ethernet cable.\\n\\nZero Trust does away with the concept of having a central castle that assumes anyone inside is trusted. It assumes that the castle has already been breached. That is to say, we expect attackers to already be inside the network and for it to be a hostile environment. Any resources inside the network should be treated as being publicly available on the internet and must be defended. To accomplish this defense, a series of Zero Trust pillars are defined:\\n\\n* Never Trust, Verify - the virtue of a connection should not grant access\\n    \\n* Authenticate Before Connect - authentication should happen before resources are connected to\\n    \\n* Least Privileged Access - access should only grant connectivity to the minimum number of resources\\n    \\n\\nImplementing those pillars is not a simple tweak to existing infrastructure. The first point alone will have much of this series dedicated to it.\\n\\n### Ziti & Zero Trust\\n\\nIn a Zero Trust model, there needs to exist mechanisms to verify identities such that trust can be granted. Zero Trust does not mean there is no trust. Zero Trust means that trust is given only after verification. Even then, that trust is limited to accessing the minimum network resources necessary. To accomplish this, we need a network that can force all connections through the following process.\\n\\n1. Authenticate\\n    \\n2. Request Access To A Resource\\n    \\n3. Connect To The Requested Resource\\n    \\n\\nThis process is not the typical connection order on a network. Most connections on a network are made in the reverse order. At first, this may seem counter-intuitive. To help make Zero Trust and bootstrapping trust a bit clearer, it helps to have a concrete system to use an example. It just so happens that the Ziti software system makes a great example!\\n\\n![Ziti System Diagram](/blogs/openziti/v1654257671096/sxd8XxGHc.png)\\n\\nIn Ziti, all of the above steps require interacting with a Ziti Controller. The Ziti Controller manages the Ziti overlay network by maintaining a list of known network services, SDK clients, routers, enrollments, policies, and much more! All of these pieces working together to create a Ziti Network. A Ziti Network is an overlay network - meaning it creates a virtual network on top of a concrete network. The concrete network may be the internet, a university network, or your own home network. Whatever it is, it is referred to as the underlay network.\\n\\nIn the Ziti Network, all network resources are modeled as services in the Ziti Controller. All services on a Ziti Network should only be accessible via the Ziti Network for maximum effect. Network services can be made available via a Ziti Network in a variety of manners. The preferred method is embedding the Ziti SDK inside of applications and servers as it provides the highest degree of Zero Trust security. However, it is also possible to configure various overlay-to-underlay connections to existing network services via \\"router termination\\" or a particular type of application with the Ziti SDK embedded in it that specifically deals with underlay-to-overlay translations (i.e., Ziti Desktop Edge/Mobile Edge).\\n\\nThe Ziti Controller also knows about one or more Ziti Routers that form a mesh network that can create dynamic circuits amongst themselves. Routers use circuits to move data across the Ziti Network. Routers can be configured to allow data to enter and exit the mesh. The most common entry/exit points are Ziti SDKs acting as clients or servers.\\n\\nNetwork clients wishing to attach to the network use the Ziti SDK to first authenticate with the Ziti Controller. During authentication, the Ziti SDK client and Ziti Controller will verify each other. Upon successful authentication, the Ziti Controller can provide a list of available services to dial (connect) or to bind (host) for the authenticated SDK Client. The client can then request to dial or bind a service. If fulfilled, a session is associated with the client and service. This new session is propagated to the necessary Ziti Routers, and the required circuits are created. The client is returned a list of Ziti Routers, which can be connected to in order to complete the last mile of communication between the Ziti overlay network and the SDK client.\\n\\nThis set of steps covers the pillars of the Zero Trust model! The Ziti Controller and SDK Clients verify each other. The client cannot connect to network resources or services until it authenticates. After authentication, a client is given the least privilege access allowed by only being told about and only being able to dial/bind the authenticated identity\'s assigned services. It is a Zero Trust overlay network!\\n\\nHow did this system come into existence? How do the Ziti SDK client and Ziti Controller verify each other? How do the routers and controller know to validate each other? How is this managed at scale with hundreds of Ziti Routers and thousands of Ziti SDK clients? It seems that this is a recursive problem. To terminate the recursion, we have to start our system with a well-defined and carefully controlled seed of trust.\\n\\n# Trust\\n\\nIn software systems that require network connectivity, there are at least two parties in the system. Generally, there are more, and in the case of a Ziti network, there could be thousands. Between two parties, each time a connection is made, a trust decision is made. Should this connection be allowed? Mechanisms must be put into place to verify the identity of the connecting party if that question is to be answered.\\n\\nOne mechanism that might jump out at the reader is a password or secret. In Ziti, it would be possible to configure the Controller, Routers, and SDK Clients with a secret. Software is easy to deploy with a secret. Throw it into a configuration file, point the software at, and off you go!\\n\\nIt is also fundamentally weak as there is only one secret in the system necessary to compromise the entire system. In Ziti, this would mean giving the secret to network clients that may or may not be owned by the network operator. Also, shared secrets do not individually identify each component, nor do they define how secrets will power other security concerns, like encryption.\\n\\nThe solution can be improved. Secrets could be generated per software component. The controller, each router, and each SDK client could have a unique secret. This secret would then individually identity each component! It is a significant improvement, but how does each component verify connections? Do they challenge for the incoming connections secret and compare it to a list? That means that a pair of systems that need to connect must have each other\'s secrets. Secret sharing will not do! We can not be copying secrets between every machine. One machine that is compromised would mean that many secrets are revealed!\\n\\nThis solution can be evolved and improved, but we do not have to do that hard work! If we did, we would end up recreating an existing technology. That technology is (public-key cryptography)\\\\[[https://en.wikipedia.org/wiki/Public-key\\\\\\\\\\\\\\\\\\\\\\\\\\\\_cryptography\\\\\\\\\\\\\\\\\\\\]](https://en.wikipedia.org/wiki/Public-key%5C%5C%5C_cryptography%5C%5C%5D), and it provides everything we need.\\n\\nPublic-key cryptography allows each device to have a unique, secret, private key that proves its unique identity. That private key is mathematically tied to a public key. The public key can be used to encrypt messages that only the private key holder can decrypt. Also, the public key cannot be used to derive the original private key. This functionality fits perfectly with what our distributed system needs! Alas, public-key cryptography introduces complex behaviors, setup, and management. In the next article, we will dive a little deeper into this topic. For now, let us take it on faith that it will serve our needs well.\\n\\n#### Setting It Up\\n\\nSo we have decided that public-key cryptography is the answer. What does that mean? What do I have to do? Let us explore what would need to be done by a human or a piece of software automating this process. Don\'t worry if you don\'t get all of this; the gist is all you need for now. Later articles will expand upon this terminology. In fact, after reading the later articles, consider revisiting this part.\\n\\nConsider the following diagram of a \\"mesh\\" distributed system. This mesh could be any type of system such as a mesh of Ziti Routers, or maybe it is a system of sensors on an airplane. What they do does not matter. What matters is that this system has multiple pieces of software connecting amongst themselves. Consider what it means to accomplish this using public-key cryptography.\\n\\n![](/blogs/openziti/v1654257672325/FSrRyzXGm.png)\\n\\nIn the diagram above, each system needs:\\n\\n* a key pair for client and server connections\\n    \\n* to have the public keys of each system it is connecting to\\n    \\n\\nSo what do we need to do? Drop into a CLI and start generating keys on each machine. Do that by using these commands:\\n\\nopenssl ecparam -name secp256k1-genkey -param\\\\_enc explicit -out private-key.pem\\n\\nopenssl req -new -x509 -key private-key.pem -out server.pem -days 360\\n\\nVoila - you now have a self-signed certificate! What is a self-signed certificate? For now, let us understand it means that no other system has expressed trust in your public certificate. In [Part 4: Certificate Authorities & Chains Of Trust](./bootstrapping-trust-part-4.md) we will cover them in more detail.\\n\\nYou can repeat the above process for every piece of software in your mesh network. Preferably, you log into each machine and generate the private key there. Moving private keys on and off devices is a security risk and frowned upon. For maximum security, hardware, such as [Hardware Security Modules (HSMs)](https://en.wikipedia.org/wiki/Hardware_security_module) and [Trusted Platform Modules (TPMs)](https://en.wikipedia.org/wiki/Trusted_Platform_Module), can be used to store the private keys in a manner that does not make them directly accessible.\\n\\nThen you will need to copy each public certificate to every other machine and configure your software so that it trusts that certificate. The system will need to repeat this process any time the system adds a piece of software. If a machine is compromised, the analogous public certificate will need to be untrusted on every node in the mesh. Adding or removing trust in a public certificate involves configuring software or operating systems. There are many ways it can be implemented, including configuration files, files stored in specific directories, and even via configuration tools such as Windows Certificate Manager snap-in.\\n\\nThis is a log of careful work to get a simple system running. Consider what this means when adding or removing many nodes? Visiting each machine and reconfiguring them each time is quite a bit of overhead. There is a solution to these woes. While it is elegant on its own, it does add complexity. Let us see how Certificate Authorities (CAs) can help! In the next section, we will hit the highlights of CAs. For more detail, look forward to [Part 4: Certificate Authorities & Chains Of Trust](./bootstrapping-trust-part-4.md).\\n\\n#### CAs & Adding Complexity\\n\\nA CA enables trust deferral from multiple individual certificates to a single certificate, which means that instead of trusting each certificate, each piece of software will trust the CA. The CA will be used to sign every public certificate our software pieces need to use. How does \\"signing\\" work? We will cover that in [part three](./bootstrapping-trust-part-3.md) and why it matters part in [four](./bootstrapping-trust-part-4.md). For now, the basics will be provided.\\n\\nHere are the high-level steps of using a CA:\\n\\n1. create a CA configuration via OpenSSL CNF files\\n    \\n2. create the CA\\n    \\n3. use the CA\'s public key to sign all of the public certificates\\n    \\n4. distribute the CA\'s certificate to every machine\\n    \\n5. configure the machines certificate store or configure the software\\n    \\n\\nFor items one and two, the process can be a bit mystical. There is a multitude of options involved in managing a CA. To perform number three, you will need to go through the processing of creating certificate signing requests (CSRs, see [parts three](./bootstrapping-trust-part-3.md) for more detail) on behalf of the piece of software, and someone or something will have to play the role of the CA and resolve the CSRs. The last two steps will depend on the operating system and software being used.\\n\\nAll of these actions can be done via a CLI or programmatically. You will have to spend time and energy, making sure the options are correctly set and learning about all the different capabilities and extensions. Mistakes will inevitably occur. It is time-consuming to debug why a specific public certificate is not working as intended. The tools and systems that use the certificates are purposely vague in error messages as not to reveal too much information to attackers.\\n\\nThe payoff for using CAs is having the ability to create chains of trust. Chains of trust allow distributed systems to scale without having to reconfigure each node every time the system grows or shrinks. With a little more upfront cost and bookkeeping to run a CA, the system will greatly decrease the amount of configuration required on each device.\\n\\n#### Further Concerns\\n\\nOnce configured, there are still other concerns that need to be taken into account. Consider the following list of events that may happen to a CA, and it\'s certificates:\\n\\n* What happens when a certificate expires?\\n    \\n* How does a system know not to trust a certificate anymore?\\n    \\n* What happens when private keys need to regenerate?\\n    \\n\\nCAs do not automatically handle the propagation of these types of events. CAs are files on a storage device or HSM. Issuing or revoking certificates does not generate any kind of event without additional software. There is also the issue of certificates expiring. That \\"-days 360\\", used in the example above, puts a lifetime on each certificate. The lifetime can be extended far into the future, but this is a bad practice. Limiting the life span of a certificate reduces attack windows and can be used as a trigger to adopt strong encryption.\\n\\nEven if we ignore all of those concerns, who did we trust to get this system setup? What was the seed of trust used to bootstrap trust? So far, you could have imagined that a human was doing all of this work. In that case, a human operator is trusted to properly configure all of the systems - trusting them with access to all of the private keys. The seed of trust is in that human. If this is a software system performing these actions, that means that the system has to be trusted and most likely have access to every other system coming online. That is workable, but what happens when your system can have external systems request to be added to the network? How can that be handled? How do you trust that system in the first place? Using a secret password creates a single, exploitable, weak point. Public-key cryptography could be put in place, but then we are in a chicken-and-egg scenario. We are putting public-key cryptography in place to automate public-key cryptography.\\n\\nThere are many caveats to bootstrapping trust. In a dynamic distributed system where pieces of software can come and go at the whim of network operators, the issues become a mountain of concerns. Thankfully in Ziti, a mechanism is provided that abstracts all of these issues. To understand how Ziti accomplishes this, we have a few more topics to discuss. In [part two](./bootstrapping-trust-part-2.md), we will chip away at those topics by covering public-key cryptography in more detail to understand its powers and applications."},{"id":"configuring-openziti-to-enable-prometheus","metadata":{"permalink":"/docs/openziti/blog/configuring-openziti-to-enable-prometheus","source":"@site/blog/configuring-openziti-to-enable-prometheus.md","title":"Configuring OpenZiti to Enable Prometheus","description":"This is part two of a three-part article. This article provides the technical deep dive into the steps necessary to implement the vision outlined in part one. This article will be heavy on OpenZiti CLI commands, explaining what we are doing to configure the overlay network, and why. In the final article, we will explore what we have just created and understand what was just created","date":"2022-04-23T04:00:00.000Z","tags":[{"inline":false,"label":"Kubernetes","permalink":"/docs/openziti/blog/tags/kubernetes","description":"Kubernetes content"},{"inline":false,"label":"Prometheus","permalink":"/docs/openziti/blog/tags/prometheus","description":"Prometheus monitoring"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":20.43,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Configuring OpenZiti to Enable Prometheus","date":"2022-04-23T04:00:00.000Z","cuid":"cluvhwqbp001108kyehhib9hb","slug":"configuring-openziti-to-enable-prometheus","authors":["ClintDovholuk"],"tags":["kubernetes","prometheus","zerotrust"]},"unlisted":false,"prevItem":{"title":"Bootstrapping Trust Part 1 - Encryption Everywhere","permalink":"/docs/openziti/blog/bootstrapping-trust-part-1-encryption-everywhere"},"nextItem":{"title":"Prometheus - Scrape Anything from Anywhere","permalink":"/docs/openziti/blog/prometheus-scrape-anything-from-anywhere"}},"content":"*This is part two of a three-part article. This article provides the technical deep dive into the steps necessary to implement the vision outlined in* [*part one.*](./prometheus-scrape-anything-from-anywhere.md) *This article will be heavy on OpenZiti CLI commands, explaining what we are doing to configure the overlay network, and why. In* [*the final article*](./scraping-anything-anywhere-in-action.md)*, we will explore what we have just created and understand what was just created*\\n\\n---\\n\\n## Goals\\n\\n* Incredibly easy to deploy Prometheus servers\\n    \\n* No ports exposed to the internet\\n    \\n* Prometheus servers can be deployed listening on the overlay, not on the underlay\\n    \\n* Private Kubernetes API\\n\\n\x3c!-- truncate --\x3e\\n    \\n\\n## Zitified Prometheus\\n\\nAs described in [the previous article](./prometheus-scrape-anything-from-anywhere.md), Prometheus really prefers to be able to gather metrics from the targets it is monitoring. When the target is behind a firewall, you will be left with two choices.\\n\\n![](/blogs/openziti/v1712853892186/74523233-0c1a-4a09-bb26-9eb1d5cd92c4.png)\\n\\nYou can choose to open a hole in the firewall granting access (a generally bad idea), or you can use a PushGateway. Even if you choose to use the PushGateway, Prometheus will still need to be able to access and pull from the PushGateway so you\'ll still need some port open and listening for Prometheus to collect data.\\n\\nWhat we really want is to enable Prometheus to scrape data from targets without needing to expose any ports to the internet. It would be \\\\*\\\\* even better\\\\*\\\\* if we didn\'t have to expose any ports at all, even to the local \\"trusted\\" network. This capability is something that is unique to an OpenZiti-enabled application. You can take an OpenZiti SDK and embed it into your application, and give your app zero trust superpowers! If we take an OpenZiti SDK and embed it into Prometheus, we can give Prometheus the superpower of invisibility and addressability. Embedding an OpenZiti SDK produces a zitified version of Prometheus. With an OpenZiti-powered Prometheus, no ports need to be open.\\n\\nThe OpenZiti project has done the work to produce an OpenZiti-enabled version of Prometheus. It\'s also entirely open source. Check it out from the OpenZiti Test Kitchen hosted on GitHub https://github.com/openziti-test-kitchen/prometheus.\\n\\n## Solution Overview\\n\\nAs you\'ll recall from [part1](./prometheus-scrape-anything-from-anywhere.md), we are trying to use Prometheus to monitor workloads in two different Kubernetes clusters. We are going to deploy one cluster which will represent a first step of an OpenZiti solution. It will use a Prometheus server that is OpenZiti-enabled, but it will still listen on the underlay network and be available to local devices on an ip:port. This Prometheus server will use OpenZiti to scrape targets which are available anywhere on the OpenZiti overlay network and we\'ll refer to this as \\"ClusterA\\".\\n\\nWe\'ll also deploy a second OpenZiti-enabled Prometheus server, in a totally separate Kubernetes cluster. This Prometheus server will **not** listen on an ip:port. Instead, it will listen exclusively on the OpenZiti overlay. This Prometheus server will have no ports available to attack and will only be accessible via a properly authorized and authenticated OpenZiti client. This will be our \\"ClusterB\\"\\n\\nFinally, we\'ll stand up a third Prometheus server and use it to federate metrics back to a \\"central\\" Prometheus server. This emulates what one might do to provide a central location for humans to go to in order to visualize data or use the Prometheus server. We won\'t care where this is deployed, we\'ll actually deploy it in locally and then move it to a private server in AWS just to show how easy it that is.\\n\\nThis is what the solution we\'ll build looks like:\\n\\n![after](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubernetes-prometheus-after.svg)\\n\\n## Digging In\\n\\nLet\'s get to work and build this solution. We\'ll need some legwork done first.\\n\\n> It\'s going to get deep in this article with CLI commands. You\'ll see what the OpenZiti objects are that get created and learn why. You might not want to replicate the solution on your own and instead are looking for \\"the big reveal\\". If that describes you, just skim this article lightly and get on to [part3](./scraping-anything-anywhere-in-action.md). In part 3 we\'ll explore the deployed solution and see what makes it so interesting and cool.\\n\\n### Prerequisites\\n\\n* ![](/blogs/openziti/v1712854086884/8b08379c-00c2-4e12-a2fb-cb9f0a3bc975.png)\\n    \\n    You have an OpenZiti overlay network available. If not, for this scenario you will want to use [\\"host your own\\"](@openzitidocs/learn/quickstarts/network/hosted). You\'ll also want to have the ziti cli tool on your path\\n    \\n* Two Kubernetes clusters provisioned\\n    \\n* Necessary tooling installed and available on the path\\n    \\n    * kubectl\\n        \\n    * helm\\n        \\n* bash/zsh shell - tested in bash and some commands will use variables. If you use another shell, change accordingly\\n    \\n* a machine with [docker installed](https://docs.docker.com/get-docker/) to run the final Prometheus sever on (your local machine is fine)\\n    \\n* Ziti Desktop Edge installed on the development machine. I use [Ziti Desktop Edge for Windows](https://openziti.io/docs/reference/tunnelers/windows).\\n    \\n* A temporary folder exists to house files as we need them: /tmp/prometheus\\n    \\n\\n---\\n\\n## ClusterA - Using `ziti-host`\\n\\n![clusterA](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/clusterA.svg)\\n\\nWe start with an empty OpenZiti network, and two empty Kubernetes clusters. Let\'s start by populating ClusterA. We will deploy three pods into this Kubernetes cluster. When done, the Kubernetes cluster will look similar to the image to the right.\\n\\n* Pod 1. **ziti-host**. This pod will provide what is effectively the equivalent of a Kubernetes ingress controller. We\'ll install this using helm from a NetFoundry provided chart\\n    \\n* Pod 2. **prometheuz**. This pod will be our Prometheus server with OpenZiti embedded in it. We won\'t use OpenZiti to listen on the overlay network. Instead, we will follow a more traditional model of listening on the underlay at a known ip:port combination. We\'ll install this pod using a chart from the OpenZiti charts repository.\\n    \\n* Pod 3. **reflectz**. This pod represents the workload which we want to monitor. This is another chart provided by the OpenZiti chart repository and will also be installed with helm. If you are interested in viewing the source code for this project you can find it on [GitHub here](https://github.com/nf-npieros/sdk-golang/tree/feature/reflect-prometheus)\\n    \\n\\n> Running the ziti cli commands shown below as shown will expect you to have the ziti binary on your path. Also it is expected that all the commands run will run from the same \\"development\\" machine with the expected tools available. Reach out on discourse if you get stuck.\\n\\n### Pod 1 - `ziti-host`\\n\\nWe will start off deploying Pod 1, ziti-host, to provide access to Kubernetes ClusterA. The ziti-host pod will require a single identity to be provisioned. We will use a shortened name for the cluster and we\'ll embed that name into the identity to make it easier for us to understand what identity we provisioned and why, should we ever need to reference these identities later. We\'ll refer to ClusterA as simply \\"kubeA\\". Let\'s make the identity now. Notice we are also passing the \\"-a\\" attribute during creation to add a role attribute to the identity of `kubeA.services`. This will be used later when setting up policies.\\n\\n#### Create the Identity\\n\\n```text\\nziti edge create identity device kubeA.ziti.id -o /tmp/prometheus/kubeA.ziti.id.jwt -a \\"kubeA.services\\"\\n```\\n\\nYou should see confirmation output such as:\\n\\n```text\\nNew identity kubeA.ziti.id created with id: BeyyFUZFDR\\nEnrollment expires at 2022-04-22T01:18:53.402Z\\n```\\n\\n#### Deploy `ziti-host` into ClusterA\\n\\nOnce created, we can use helm to install the `ziti-host` pod. The jwt is a one-use token and will be useless after being consumed by `ziti-host`. As this is probably your first time running this helm chart, you will need to install it. The command is idempotent to running it over and over is of no concern. Run the following:\\n\\n```text\\nhelm repo add netfoundry https://netfoundry.github.io/charts/\\nhelm repo update\\nhelm install ziti-host netfoundry/ziti-host --set-file enrollmentToken=\\"/tmp/prometheus/kubeA.ziti.id.jwt\\"\\n```\\n\\nYou will see the confirmation output from helm. Now when you look at your Kubernetes cluster with `kubectl`, you will see a pod deployed:\\n\\n```text\\nkubectl get pods\\nNAME                        READY   STATUS    RESTARTS   AGE\\nziti-host-db55b5c4b-rpc7f   1/1     Running   0          2m40s\\n```\\n\\nAwesome, we have our first deployed pod. It\'s useless at the moment as we have defined no services, nor authorized any services. Right now there\'s nothing to connect to, so we can simply move on and install the next pod, `reflectz`.\\n\\n### Pod 2 - `reflectz`\\n\\nThe first pod we want to have access to is the `reflectz` pod. It is a workload we will deploy that will do two things. First, it will listen on the OpenZiti overlay network for connections. When a connection is made, and when bytes are sent, the workload sill simply return back to the caller whatever was sent to it adding \\"you sent me: \\" to the payload. It\'s not much, but it\'s a demo after all. The second service provided is a scrape target for Prometheus. There is one metric exposed by `reflectz` we will care about, the total number of connections established to this workload. This pod also needs an identity provisioned, and this time around we will also provision some services. We will also use the `ziti` cli to enroll this identity. This helm chart wants you to provide an enrolled identity as part of the helm command. Let\'s do all this now.\\n\\n#### Create and Enroll the Identity\\n\\n```text\\nziti edge create identity user kubeA.reflect.id -o /tmp/prometheus/kubeA.reflect.id.jwt\\nziti edge enroll /tmp/prometheus/kubeA.reflect.id.jwt -o /tmp/prometheus/kubeA.reflect.id.json\\n```\\n\\n#### Create Configs and Services (including Tunneling-based Access)\\n\\nThe `reflectz` chart also needs two services to be declared and specified at the time of the helm chart installation. We will want to be able to test the service to ensure they work. To enable testing the services, we will create two configs of type `intercept.v1`. This will allow identities using tunneling apps to be able to access the services, this is how we\'ll verify the services work. Make the configs and services now.\\n\\n```text\\n# create intercept configs for the two services\\nziti edge create config kubeA.reflect.svc-intercept.v1 intercept.v1 \\\\\\n  \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"kubeA.reflect.svc.ziti\\"],\\"portRanges\\":[{\\"low\\":80, \\"high\\":80}]}\'\\nziti edge create config \\"kubeA.reflect.svc-intercept.v1.scrape\\" intercept.v1 \\\\\\n  \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"kubeA.reflect.scrape.svc.ziti\\"], \\"portRanges\\":[{\\"low\\":80, \\"high\\":80}], \\"dialOptions\\":{\\"identity\\":\\"kubeA.reflect.id\\"}}\'\\n\\n# create the two services\\nziti edge create service \\"kubeA.reflect.svc\\" --configs \\"kubeA.reflect.svc-intercept.v1\\" -a \\"kubeA.reflect.svc.services\\"\\nziti edge create service \\"kubeA.reflect.scrape.svc\\" --configs \\"kubeA.reflect.svc-intercept.v1.scrape\\"\\n```\\n\\n#### Authorize the Workload and Clients\\n\\nServices are not valuable if there are no identities which can use the services. The identity used in the helm installation will also need to be authorized to bind these services. Tunneling apps will need to be authorized to dial these services but also remember Prometheus servers will need to be able to dial these services too. We will now create `service-policies` to authorize the tunneling clients, Prometheus scrapes, and the `reflectz` server to bind the service.\\n\\n```text\\n# create the bind service policies and authorize the reflect id to bind these services\\nziti edge create service-policy \\"kubeA.reflect.svc.bind\\" Bind \\\\\\n  --service-roles \\"@kubeA.reflect.svc\\" --identity-roles \\"@kubeA.reflect.id\\"\\nziti edge create service-policy \\"kubeA.reflect.scrape.svc.bind\\" Bind \\\\\\n  --service-roles \\"@kubeA.reflect.scrape.svc\\" --identity-roles \\"@kubeA.reflect.id\\"\\n\\n# create the dial service policies and authorize the reflect id to bind these services\\nziti edge create service-policy \\"kubeA.reflect.svc.dial\\" Dial \\\\\\n  --service-roles \\"@kubeA.reflect.svc\\" --identity-roles \\"#reflectz-clients\\"\\nziti edge create service-policy \\"kubeA.reflect.svc.dial.scrape\\" Dial \\\\\\n  --service-roles \\"@kubeA.reflect.scrape.svc\\" --identity-roles \\"#reflectz-clients\\"\\n```\\n\\n#### Deploy `reflectz`\\n\\nWith the identity enrolled, we can now install the helm chart from openziti, and install our demonstration workload: `reflectz`. Notice that to deploy `reflectz` we need to supply an identity to the workload using `--set-file reflectIdentity`. This identity will be used to \'Bind\' the services the workload exposes. We also need to define what the service names are we want to allow that identity to bind. We do this using the `--set serviceName` and `--set prometheusServiceName` flags.\\n\\n```text\\nhelm repo add openziti-test-kitchen https://openziti-test-kitchen.github.io/helm-charts/\\nhelm repo update\\nhelm install reflectz openziti-test-kitchen/reflect \\\\\\n  --set-file reflectIdentity=\\"/tmp/prometheus/kubeA.reflect.id.json\\" \\\\\\n  --set serviceName=\\"kubeA.reflect.svc\\" \\\\\\n  --set prometheusServiceName=\\"kubeA.reflect.scrape.svc\\"\\n```\\n\\nAfter running helm, pod 2 should be up and running. Let\'s take a look using `kubectl`\\n\\n```text\\nkubectl get pods\\nNAME                        READY   STATUS    RESTARTS   AGE\\nreflectz-775bd45d86-4sjwh   1/1     Running   0          7s\\nziti-host-db55b5c4b-rpc7f   1/1     Running   0          4m\\n```\\n\\n### Pod 3 - `Prometheuz`\\n\\n#### Overlay Work - Setting Up OpenZiti\\n\\nNow we have access to the cluster and a workload to monitor. Now we want to deploy Prometheus and monitor this workload. Remember that the workload only exposes a scrape target over the OpenZiti overlay. For Prometheus to be able to scrape the workload, even when resident inside the Kubernetes cluster (!), Prometheus will need to be OpenZiti-enabled. That will require a few things. We\'ll need a new identity for Prometheus, we\'ll need to authorize Prometheus to access the workload\'s target, and we\'ll need to configure Prometheus to scrape that workload. When we create this identity we\'ll assign two attributes. The `reflectz-clients` attribute gives this identity the ability to dial the two services defined above. The `prometheus-clients` attribute is currently unused. We\'ll put that to use later, but we can define it now.\\n\\n#### Create and Enroll the Identity\\n\\n```text\\n# create and enroll the identity.\\nziti edge create identity user kubeA.prometheus.id -o /tmp/prometheus/kubeA.prometheus.id.jwt -a \\"reflectz-clients\\",\\"prometheus-clients\\"\\nziti edge enroll /tmp/prometheus/kubeA.prometheus.id.jwt -o /tmp/prometheus/kubeA.prometheus.id.json\\n```\\n\\n#### Create Configs and Services (including Tunneling-based Access)\\n\\n```text\\n# create the config and service for the kubeA prometheus server\\nziti edge create config \\"kubeA.prometheus.svc-intercept.v1\\" intercept.v1 \\\\\\n  \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"kubeA.prometheus.svc\\"],\\"portRanges\\":[{\\"low\\":80, \\"high\\":80}]}\'\\nziti edge create config \\"kubeA.prometheus.svc-host.v1\\" host.v1 \\\\\\n  \'{\\"protocol\\":\\"tcp\\", \\"address\\":\\"prometheuz-prometheus-server\\",\\"port\\":80}\'\\nziti edge create service \\"kubeA.prometheus.svc\\" \\\\\\n  --configs \\"kubeA.prometheus.svc-intercept.v1\\",\\"kubeA.prometheus.svc-host.v1\\"\\n```\\n\\n#### Authorize the Workload and Clients\\n\\n```text\\n# grant the prometheus clients the ability to dial the service and the kubeA.prometheus.id the ability to bind\\nziti edge create service-policy \\"kubeA.prometheus.svc.dial\\" Dial \\\\\\n  --service-roles \\"@kubeA.prometheus.svc\\" \\\\\\n  --identity-roles \\"#prometheus-clients\\"\\nziti edge create service-policy \\"kubeA.prometheus.svc.bind\\" Bind \\\\\\n  --service-roles \\"@kubeA.prometheus.svc\\" \\\\\\n  --identity-roles \\"@kubeA.ziti.id\\"\\n```\\n\\n#### Deploying `Prometheuz` {#deploying-prometheuz-1}\\n\\nWith our services, configs and service-policies in place we are now ready to start our Prometheus server. Remember this server will not listen on a the OpenZiti overlay. It\'s going to listen exclusively on the underlay. We are still exploring OpenZiti, and we are not yet comfortable deploying our Prometheus server dark. We\'ll change this soon, don\'t worry. For now, we\'ll imagine that we\'re still evaluating the tech and chose to deploy it on the underlay, not on the overlay.\\n\\nAlthough Prometheus is listening on the underlay, we **have** deployed our workload listening on the overlay network. It won\'t be available on the underlay at all. The workload has **no listening ports**. This means that we\'ll still need an OpenZiti-enabled Prometheus to access and scrape that workload. To do this we\'ll use helm, and use a chart provided by the OpenZiti charts repo.\\n\\nSome interesting things to notice below in the `helm install` command. Notice that we are passing helm two `--set` parameters. These parameters are informing the helm chart that the Prometheus server is not \\"zitified\\", meaning it will be accessible via the underlay network. We\'re also passing one `--set-file` parameter to tell Prometheus what identity we want to be stored in the pod (as a secret). This secret will be used when we configure Prometheus to scrape the workload. Go ahead and run this command now and run `kubectl get pods` until all the containers are running.\\n\\n```text\\nhelm repo add openziti-test-kitchen https://openziti-test-kitchen.github.io/helm-charts/\\nhelm repo update\\nhelm install prometheuz openziti-test-kitchen/prometheus \\\\\\n  --set server.ziti.enabled=\\"false\\" \\\\\\n  --set-file server.scrape.id.contents=\\"/tmp/prometheus/kubeA.prometheus.id.json\\"\\n```\\n\\n---\\n\\n## ClusterB - Fully Dark\\n\\n![clusterB](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/clusterB.svg)\\n\\nNow that we have deployed our first Kubernetes cluster, it\'s now time to deploy the second Kubernetes cluster. This time, we are going to keep our entire deployment **fully dark**! There will be no listening ports, not even local to the Kubernetes cluster itself. To get any traffic to this Prometheus server, you will need a strong identity and need to be authorized on the OpenZiti overlay. When complete, ClusterB will look like the image to the right.\\n\\nThis time, \\"Pod1\\" will be the `reflectz` workload. Since this is a **fully dark** deployment, listening entirely on the OpenZiti overlay, we won\'t need a `ziti-host` pod. Remember, in ClusterA `ziti-host` is used to provide internal access to the Kubernetes cluster via the OpenZiti overlay. It\'s similar in role to an ingress controller, but doesn\'t require you to expose your workloads to the internet. While that\'s pretty good we want to go fully dark this time. We\'ll have no `ziti-host`. We\'ll only need to deploy two pods: `reflectz` and `prometheuz`.\\n\\nThe good news is that the same commands you\'ve run for ClusterA, will mostly be used for ClusterB. You will want to beware that where you used \\"kubeA\\" before, make sure you change those to \\"kubeB\\". There will be small other changes we\'ll make along the way too, we\'ll see those changes and explain them below.\\n\\n### Pod1 - `reflectz`\\n\\nThe `relectz` workload we\'ll deploy for ClusterB will be nearly identical to the ClusterA workload. We will create a service for the actual \'reflect\' service. We will make a service for Prometheus to scrape the workload. We\'ll also need another identity, so we\'ll create that identity, authorize it to bind the services, and authorize clients to access the workload. Since this process is very similar to what we did for ClusterA, there\'s not much to explain. Setup ClusterB\'s `reflectz` now.\\n\\n#### Create the Identity\\n\\n```text\\nziti edge create identity user kubeB.reflect.id -o /tmp/prometheus/kubeB.reflect.id.jwt\\nziti edge enroll /tmp/prometheus/kubeB.reflect.id.jwt -o /tmp/prometheus/kubeB.reflect.id.json\\n```\\n\\n#### Create Configs and Services (including Tunneling-based Access)\\n\\n```text\\n# create intercept configs for the two services\\nziti edge create config kubeB.reflect.svc-intercept.v1 intercept.v1 \\\\\\n  \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"kubeB.reflect.svc.ziti\\"],\\"portRanges\\":[{\\"low\\":80, \\"high\\":80}]}\'\\nziti edge create config \\"kubeB.reflect.svc-intercept.v1.scrape\\" intercept.v1 \\\\\\n  \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"kubeB.reflect.scrape.svc.ziti\\"], \\"portRanges\\":[{\\"low\\":80, \\"high\\":80}], \\"dialOptions\\":{\\"identity\\":\\"kubeB.reflect.id\\"}}\'\\n\\n# create the two services\\nziti edge create service \\"kubeB.reflect.svc\\" --configs \\"kubeB.reflect.svc-intercept.v1\\" -a \\"kubeB.reflect.svc.services\\"\\nziti edge create service \\"kubeB.reflect.scrape.svc\\" --configs \\"kubeB.reflect.svc-intercept.v1.scrape\\"\\n```\\n\\n#### Authorize the Workload to Bind the Services\\n\\n```text\\n# create the bind service policies and authorize the reflect id to bind these services\\nziti edge create service-policy \\"kubeB.reflect.svc.bind\\" Bind \\\\\\n  --service-roles \\"@kubeB.reflect.svc\\" --identity-roles \\"@kubeB.reflect.id\\"\\nziti edge create service-policy \\"kubeB.reflect.scrape.svc.bind\\" Bind \\\\\\n  --service-roles \\"@kubeB.reflect.scrape.svc\\" --identity-roles \\"@kubeB.reflect.id\\"\\n```\\n\\n#### Authorize Clients to Access the Services\\n\\n```text\\n# create the dial service policies and authorize the reflect id to bind these services\\nziti edge create service-policy \\"kubeB.reflect.svc.dial\\" Dial \\\\\\n  --service-roles \\"@kubeB.reflect.svc\\" --identity-roles \\"#reflectz-clients\\"\\nziti edge create service-policy \\"kubeB.reflect.svc.dial.scrape\\" Dial \\\\\\n  --service-roles \\"@kubeB.reflect.scrape.svc\\" --identity-roles \\"#reflectz-clients\\"\\n```\\n\\n#### Deploy `reflectz` {#deploy-reflectz-1}\\n\\n```text\\nhelm repo add openziti-test-kitchen https://openziti-test-kitchen.github.io/helm-charts/\\nhelm repo update\\nhelm install reflectz openziti-test-kitchen/reflect \\\\\\n  --set-file reflectIdentity=\\"/tmp/prometheus/kubeB.reflect.id.json\\" \\\\\\n  --set serviceName=\\"kubeB.reflect.svc\\" \\\\\\n  --set prometheusServiceName=\\"kubeB.reflect.scrape.svc\\"\\n```\\n\\n### Pod 2 - `Prometheuz`\\n\\nFor ClusterB we want `Prometheuz` to be **totally dark**. It will exclusively listen on the OpenZiti overlay and there will be no listening ports on the underlay. We will need another identity, of course, and most of the configuration and commands appear the same on the surface with very subtle differences. We\'ll explore these differences as we go. In this section we\'ll be making an identity, **one config** (a difference from the ClusterA install), a service, and two service-policies. Let\'s get to it.\\n\\n#### Create the Identity\\n\\n```text\\nziti edge create identity user kubeB.prometheus.id -o /tmp/prometheus/kubeB.prometheus.id.jwt -a \\"reflectz-clients\\",\\"prometheus-clients\\"\\nziti edge enroll /tmp/prometheus/kubeB.prometheus.id.jwt -o /tmp/prometheus/kubeB.prometheus.id.json\\n```\\n\\n#### Create **One** Config and Service\\n\\nHere\'s a difference from ClusterA. Since we are going to listen on the OpenZiti overlay, we are not installing `ziti-host`. That means we don\'t need to create a `host.v1` config. A `host.v1` config is necessary for services which have a \'Bind\' configuration and are being bound by a tunneling application. We\'re not doing that, here Prometheus will \'Bind\' this service, thus we don\'t need that `host.v1` config.\\n\\n```text\\n# create the config and service for the kubeB prometheus server\\nziti edge create config \\"kubeB.prometheus.svc-intercept.v1\\" intercept.v1 \\\\\\n  \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"kubeB.prometheus.svc\\"],\\"portRanges\\":[{\\"low\\":80, \\"high\\":80}], \\"dialOptions\\": {\\"identity\\":\\"kubeB.prometheus.id\\"}}\'\\n# no need for the host.v1 config\\nziti edge create service \\"kubeB.prometheus.svc\\" \\\\\\n  --configs \\"kubeB.prometheus.svc-intercept.v1\\"\\n```\\n\\n#### Authorize Clients and Prometheus to Bind the Service\\n\\nAt first, these commands appear identical. You need to look very closely to notice the difference between these command and the ones we ran for ClusterA, other than the obvious changes from \\"kubeA\\" to \\"kubeB\\". Pay close attention to the supplied `--identity-roles` for the bind policy specified below. With ClusterA, we did not have Prometheus listen on the overlay and we allowed Prometheus to listen on the underlay. That meant we needed to deploy `ziti-host` into that cluster to provide access to the service, and that means the service had to be bound by the `ziti-host` identity.\\n\\nHere we are flipping that script. We are allowing Prometheus to bind this service! That means we\'ll need to authorize the `kubeB.prometheus.id` to be able to bind the service.\\n\\n```text\\n# grant the prometheus clients the ability to dial the service and the kubeB.prometheus.id the ability to bind\\nziti edge create service-policy \\"kubeB.prometheus.svc.dial\\" Dial \\\\\\n  --service-roles \\"@kubeB.prometheus.svc\\" \\\\\\n  --identity-roles \\"#prometheus-clients\\"\\nziti edge create service-policy \\"kubeB.prometheus.svc.bind\\" Bind \\\\\\n  --service-roles \\"@kubeB.prometheus.svc\\" \\\\\\n  --identity-roles \\"@kubeB.prometheus.id\\"\\n```\\n\\n#### Deploying `Prometheuz`\\n\\nAt this point we have the OpenZiti overlay all configured. What\'s left, is to deploy Prometheus into ClusterB. This command is substantially different from what we ran while deploying Prometheus into ClusterA. You\'ll see that we need to supply two other identities for this installation. Remember, Prometheus will be entirely dark once deployed into ClusterB, listening only on the OpenZiti overlay. The container in the pod which monitors configmap changes won\'t be able to trigger a webhook using the underlay! This `configmap-reloadz` is a second \\"zitification\\" we didn\'t realize we were deploying in ClusterA, because we did not need it. We need it for ClusterB.\\n\\nYou\'ll see for configmapReload we need to supply the identity which the container will use to hit the Prometheus webhook. We do that by passing `--set-file configmapReload.ziti.id.contents=\\"/tmp/prometheus/kubeB.prometheus.id.json\\"`. Then we\'ll supply the service which `configmap-reloadz` will dial, and we\'ll also specify what identity we expect to be hosting the service.\\n\\nNext you\'ll see we need to supply the identity to the Prometheus server we want to allow to listen on the OpenZiti overlay ( `-set-file server.ziti.id.contents`). Similar to `configmap-reloadz` we will also specify the service and identity name to bind.\\n\\nFinally, to allow the server to scrape targets we need to supply a final identity which will be used when scraping targets with `--set-file server.scrape.id.contents`.\\n\\nYou\'ll notice for simplicities sake, we are using the same identity for all three needs which is perfectly fine. If you wanted to use a different identity, you could. That choice is up to you. To keep it simple we just authorized this identity for all these purposes.\\n\\n```text\\n# install prometheus\\nhelm repo add openziti-test-kitchen https://openziti-test-kitchen.github.io/helm-charts/\\nhelm repo update\\nhelm install prometheuz openziti-test-kitchen/prometheus \\\\\\n  --set-file configmapReload.ziti.id.contents=\\"/tmp/prometheus/kubeB.prometheus.id.json\\" \\\\\\n       --set configmapReload.ziti.targetService=\\"kubeB.prometheus.svc\\" \\\\\\n       --set configmapReload.ziti.targetIdentity=\\"kubeB.prometheus.id\\" \\\\\\n  --set-file server.ziti.id.contents=\\"/tmp/prometheus/kubeB.prometheus.id.json\\" \\\\\\n       --set server.ziti.service=\\"kubeB.prometheus.svc\\" \\\\\\n       --set server.ziti.identity=\\"kubeB.prometheus.id\\" \\\\\\n  --set-file server.scrape.id.contents=\\"/tmp/prometheus/kubeB.prometheus.id.json\\"\\n```\\n\\n## What\'s Next\\n\\nIn this article we\'ve done a lot of OpenZiti CLI work, run some `kubectl` and `helm` commands but we still haven\'t explored what it is we are building and why it\'s so cool. We\'ll do that in the [last, and final](./scraping-anything-anywhere-in-action.md) article. Hopefully, the payoff for you will be as rewarding as it was for me while building this article series.\\n\\n---\\n\\n#### Addendum - a Quicker Start\\n\\nAll the commands above are also available in github as `.sh` scripts. If you would prefer, you can clone the [ziti-doc repository](https://github.com/openziti/ziti-doc) and access the scripts from the path mentioned below. \\"Cleanup\\" scripts are provided if desired.\\n\\n```text\\n${checkout_root}/docusaurus/blog/zitification/prometheus/scripts\\n```"},{"id":"prometheus-scrape-anything-from-anywhere","metadata":{"permalink":"/docs/openziti/blog/prometheus-scrape-anything-from-anywhere","source":"@site/blog/prometheus-scrape-anything-from-anywhere.md","title":"Prometheus - Scrape Anything from Anywhere","description":"This is part one of a three-part article. This article provides the necessary background and rationale for the series. The next article will be a detailed explanation of the actual steps necessary to implement the solution. In the final article, we will explore what we have just created and understand what was just created","date":"2022-04-23T04:00:00.000Z","tags":[{"inline":false,"label":"Kubernetes","permalink":"/docs/openziti/blog/tags/kubernetes","description":"Kubernetes content"},{"inline":false,"label":"Prometheus","permalink":"/docs/openziti/blog/tags/prometheus","description":"Prometheus monitoring"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":12.86,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Prometheus - Scrape Anything from Anywhere","date":"2022-04-23T04:00:00.000Z","cuid":"cluvhg6tz000808l37bo69r4k","slug":"prometheus-scrape-anything-from-anywhere","authors":["ClintDovholuk"],"tags":["kubernetes","prometheus","zerotrust"]},"unlisted":false,"prevItem":{"title":"Configuring OpenZiti to Enable Prometheus","permalink":"/docs/openziti/blog/configuring-openziti-to-enable-prometheus"},"nextItem":{"title":"Scraping Anything, Anywhere in Action","permalink":"/docs/openziti/blog/scraping-anything-anywhere-in-action"}},"content":"*This is part one of a three-part article. This article provides the necessary background and rationale for the series.* [*The next article*](./configuring-openziti-to-enable-prometheus.md) *will be a detailed explanation of the actual steps necessary to implement the solution. In* [*the final article*](./scraping-anything-anywhere-in-action.md)*, we will explore what we have just created and understand what was just created*\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## The Problem With Pulling\\n\\nPrometheus is a server which wants to reach out and pull data from \\"scrape targets\\". It will generally do this using http requests. One problem with this design is that these targets are often inaccessible, hidden from Prometheus behind a firewall.\\n\\nIf not hidden, it means some port was exposed on some network, thereby giving Prometheus the ability to pull the data it needs. Exposing that port on a \\"trusted\\" network is a possible attack vector for bad actors. Exposing that port on the open internet (as is often the case) is an open invitation for attack. It\'s much better to keep these servers totally dark to all networks.\\n\\nOpenZiti solves this problem of reach elegantly and natively while also keeping your service dark to all networks. This gives an OpenZiti-enabled Prometheus the ability to literally scrape any target, anywhere. As long as the target is participates on an OpenZiti overlay network, and as long as the proper polices are in place allowing the traffic to flow, Prometheus will be able to reach out and pull the data it needs from anything, anywhere.\\n\\nIt doesn\'t matter if the target is in some private cloud data center, some private data center protected by a corporate firewall, or heck even running inside my local docker environment! As long as the target participates on that OpenZiti Prometheus can scrape it! That sort of reach is impossible with classic networks.\\n\\n## Prometheus\\n\\n[Prometheus](https://prometheus.io/) is an incredibly popular [CNCF](https://www.cncf.io/projects/prometheus/) project, which has graduated the gauntlet of progressions to emerge as a \\"graduated\\" CNCF project. If you\'re familiar with Prometheus, there are probably a couple of reasons people mainly choose to deploy it: metrics collection, visualization and alerting.\\n\\nPrometheus is also tremendously flexible. It has numerous available plugins and supports integrating with a wide number of systems. According to [this CNCF survey](https://www.cncf.io/blog/2022/03/08/cloud-native-observability-microsurvey-prometheus-leads-the-way-but-hurdles-remain-to-understanding-the-health-of-systems/), Prometheus leads the pack when it comes to the project people go to for observability. Its popularity is probably because Prometheus is a CNCF project and is often considered the \\"default\\" solution to deploy on another wildly popular CNCF project called [Kubernetes](https://kubernetes.io). One interesting aspect of Prometheus is that it generally favors a poll-based approach to metrics collection instead of a push-based model.\\n\\n### Poll-based?\\n\\nI don\'t know about you, but historically, when I\'ve thought about a metrics collection agent, I tend to think of an agent that reads a log file or some library that pushes rows into a giant data lake in the cloud. I don\'t generally think about a solution that implements poll-based metrics. This is often because the target of a poll-based collecting agent will probably be behind a firewall.\\n\\n![FW](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/fw.png)\\n\\nAs you would expect, firewalls make it exceptionally difficult to implement a poll-based solution as firewalls have been known to make a habit of preventing external actors from accessing random http servers behind it! After all, that is their primary function!\\n\\nThe Prometheus project makes [strong arguments](https://prometheus.io/docs/practices/pushing/) explaining the benefits of a poll-based solution. They also realize that firewalls are important in creating a safe network and understand the challenges firewalls create for such a solution. To deal with these situations, the project also provides a [PushGateway](https://prometheus.io/docs/instrumenting/pushing/). This allows solutions to push their data to a location outbound of the firewall. Pushing data out of the firewall allows metrics and alerting to function without the worry (and maintenance heartache) of an open, inbound firewall hole.\\n\\n### Acceptable Risk\\n\\nPrometheus is often deployed into Kubernetes clusters, but it can be deployed anywhere. Taking the operational differences out of the equation, there is little difference between deploying Prometheus in a Kubernetes cluster and deploying it in one\'s data center. Once deployed, the needs will be the same. Prometheus will need to be authorized to reach out and scrape the targets it needs to scrape. All too often, this is done with relatively open network permissions. Even though we all know it\'s not the most secure way of authorizing Prometheus, this is often considered \\"safe enough\\" because we deployed Prometheus into a zone considered \\"safe\\". Managing firewall rules to all the computers Prometheus needs access to, feels like an impossible feat. There are just too many.\\n\\nTo add to our acceptable risk, we will need to be able to access the Prometheus server in some way. We\'ll want to get at the UI, see the charts and graphs and data it provides and use the server to its fullest. For that, we\'ll **of course** need a hole in our firewall, or in the case of Kubernetes we will probably deploy some form of [Kubernetes Ingress Controller](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/) to provide users access the service.\\n\\nWhat we need are better and richer controls over our network. We need a better way of authorizing Prometheus without the hassle of maintaining firewall rules on individual machines. We also need a way to do this across multiple clouds, multiple Kubernetes clusters and multiple data centers. Let\'s see how OpenZiti can solve this problem while also enhancing our overall security.\\n\\n---\\n\\n## OpenZiti\\n\\nThe [OpenZiti](https://openziti.github.io) project allows us to solve all the problems outlined above. It is a fully-featured, zero trust overlay network and enables [zero trust networking principles](https://en.wikipedia.org/wiki/Zero_trust_security_model) to be applied anywhere. This includes bringing those zero trust principles directly into your application through one of the many SDKs provided by the project. Let\'s look at an example and see what a setup might look like before and after applying OpenZiti.\\n\\n### Overview\\n\\nLet\'s imagine that we have already deployed a solution using two Kubernetes clusters, ClusterA and ClusterB. It doesn\'t matter where the clusters are deployed. We are trying to illustrate a real-world situation where we have two separate Kubernetes clusters that we want to manage. The clusters could be deployed in the same cloud provider, in a private data center, in different cloud providers, it really does not matter. What is important, is that these clusters are available over the network. To enable access to the workloads inside the clusters, some form of Kubernetes ingress controller will be required on both clusters. In our example, we will have a workload deployed which exposes a prometheus scrape target we want Prometheus to monitor.\\n\\n#### Figure 1 - Before OpenZiti\\n\\n![Before OpenZiti](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubernetes-prometheus-before.svg)\\n\\n### Taking a Closer Look\\n\\nLooking at the diagram above with a discerning eye towards security, there are some immediate observations one can make.\\n\\n#### Listening Ports\\n\\nOne observation we have already accepted from the overview, is that these clusters must be exposed via the internet. At first that doesn\'t seem like a big deal, we expose workloads like this to the internet all the time. This is a perfectly normal action, it\'s likely done every day somewhere in the world. It\'s so common, we almost don\'t even think about it until the time comes when we **need** to think about it. This ends up in an exposed port, listening somewhere in the world. There might be a firewall with complex rules to protect this port, but it\'s just as likely that this isn\'t the case. People might need to access the resources inside these clusters from anywhere.\\n\\n#### Kubernetes API Exposed\\n\\nAnother observation is that the Kubernetes API is fully exposed to the internet. This API is a very high-value target and should be secured as strongly as possible. That probably means yet another complex firewall rule to maintain.\\n\\n#### \\"Trusted\\" Intra-cluster Traffic\\n\\nThe final point to note is that the traffic within the cluster is considered safe. As mentioned above, the Prometheus server needs to be able to scrape the target workloads. That traffic is necessary to be considered safe. Also, notice that the pod for Prometheus contains a container named \\"configmap-reload\\" which is used to trigger a webhook on the Prometheus server when the [Kubernetes config map](https://kubernetes.io/docs/concepts/configuration/configmap/) changes. This is necessary when changing the Prometheus config, adding new scrape configs etc.\\n\\n### Applying Zero Trust Networking Principles Using OpenZiti\\n\\nNow that we understand the basic setup and understand some possible problems, let\'s see if OpenZiti can address one or more of these issues. When applying OpenZiti, the goal will be to strengthen our security posture for each of the above items.\\n\\n#### Figure 2 - After OpenZiti\\n\\n![after](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubernetes-prometheus-after.svg)\\n\\n### Taking a Closer Look After OpenZiti\\n\\n#### No External Listening Ports\\n\\nWith a classic deployment as shown in the initial design, we know there will be ports exposed to the open internet. In an ideal scenario, there would be absolutely no ports exposed on the open internet **nor** in the \\"trusted networking zone\\". It\'s immediately obvious after applying a solution using OpenZiti that those listening ports exposed by the Kubernetes ingress controller are no longer deployed and thus are no longer exposed to the internet. That\'s one attack vector eliminated. OpenZiti will initiate outbound mTLS connections among all the constituent pieces of the overlay network. This means connections will begin inside the trusted network zone and only create outbound links. Once established, those connections can be used to safely transfer data between any participating edge node.\\n\\nThis capability really can\'t be emphasized enough. With OpenZiti and with applications that use an OpenZiti SDK, such as the ones shown, there are no open ports to attack. This network is nearly impervious to the classical \\"land and expand\\" technique so many bad actors look to exploit.\\n\\n#### Kubernetes API no Longer Exposed\\n\\nAnother significant benefit provided by OpenZiti is starting to come into focus. By having access to our clusters provided through OpenZiti, we can **stop exposing** the Kubernetes APIs for both clusters to the open internet. Prometheus will still be able to monitor each Kubernetes cluster through the private Kubernetes network. Accessing Prometheus will be provided via OpenZiti, instead of using a Kubernetes ingress controller. Later, we can ues the built-in capability Prometheus already provides to federate information from the clusters to a centralized, [zitified](/zitification.md) Prometheus server.\\n\\nOnce no longer exposed to the open internet, to maintain our Kubernetes cluster we could then turn to \\\\[zitified\\\\] (/zitification.md) tools. The OpenZiti project provides zitified versions of `kubectl` - [kubeztl](https://github.com/openziti-test-kitchen/kubectl) and `helm` - [helmz](https://github.com/openziti-test-kitchen/helm). Each of these tools have an OpenZiti SDK embedded inside them. This allows both tools to connect to the private Kubernetes API over the OpenZiti overlay network. To use them, you will need a strong, OpenZiti identity as well as be authorized to access the service. Also note that we\'re also not replacing the existing security constraints the Kubernetes ecosystem already provides. You can (and should) still secure your Kubernetes clusters using namespaces, roles, etc.\\n\\nWe\'ll explore `kubeztl` and `helmz` in future articles.\\n\\n#### \\"Trusted\\" Intra-cluster Traffic\\n\\nLastly, let\'s turn our eyes toward the traffic running inside the Kubernetes cluster. Pay attention to the lines in orange and the lines in dark blue. Orange lines represent \\"private\\" traffic, traffic that needs to traverse the private network space.\\n\\nAt this point we cannot send traffic to the Kubernetes API via the overlay network. The Kubernetes API doesn\'t have an OpenZiti SDK embedded within it. That means when we deploy Prometheus into ClusterA and ClusterB to monitor the cluster, Prometheus will be forced to connect to a port exposed on the cluster\'s underlay network. Still, while not ideal, we have greatly improved the overall security posture of the cluster. We\'re no longer able to access the Kubernetes API without first gaining access to the zero trust overlay network. Accessing the Kubernetes API will also require the identity to be properly authorized to access the service attaching to the Kubernetes API.\\n\\nLet\'s now focus on ClusterA. It contains a Prometheus server that decided against listening on the OpenZiti overlay. This means it will need to expose ports to the Kubernetes underlay network. The container inside the Prometheus pod will watch for configmap changes. To trigger the webhook, it will be forced to send unauthenticated webhook traffic to the Prometheus server on the underlay network in order to trigger the config to reload.\\n\\nStill, accessing this cluster and the listening Prometheus server will require being on the OpenZiti overlay. Also, this Prometheus server does have an OpenZiti SDK built into it. We also deployed the \\"reflectz\\" workload with an OpenZiti SDK built into it as well. That means the Prometheus server must scrape the \\"reflectz\\" workload exclusively over the OpenZiti overlay. **Only** authorized identities can access that scrape data.\\n\\nContrast ClusterA with ClusterB. ClusterB deployed a Prometheus server with an embedded OpenZiti SDK and chose to provide its services exclusively on the OpenZiti overlay. We\'ve also deployed a zitified \\"reflectz\\" workload here. Notice how little traffic traverses the Kubernetes cluster underlay network. The only traffic which needs to traverse the cluster\'s underlay network in ClusterB is the traffic which monitors the Kubernetes API. All other traffic in the cluster is now secured by the OpenZiti overlay network. You will need a strong identity, and you will need to be authorized on the overlay before even being allowed to connect to the target service.\\n\\n## OpenZiti-Enabled Prometheus\\n\\nWe are now coming to the final piece of the puzzle. We have protected both Kubernetes clusters using OpenZiti. Now we want to bring all this data back to a centralized Prometheus server to make it easier on our user base. To do this, we\'ll again deploy an OpenZiti-enabled Prometheus server. This time we don\'t care where it is deployed except that we know we are not deploying it into either of the Kubernetes clusters we are already using. Since the Prometheus servers are all now accessible via the overlay network, we can literally deploy our server anywhere in the world. It could be on development server, it could be deployed in some other cloud, it could be deployed in our private data center. Because it\'s part of the overlay network, it no longer matters where we deploy the server. Wherever deployed, all it will need is outbound internet access, a strong identity, and access and authorization to services defined in the OpenZiti overlay network. Once that\'s done, OpenZiti will take care of the rest.\\n\\nIf you have made it this far, you might want to try all this for yourself. The [next article](./configuring-openziti-to-enable-prometheus.md) will go into the details necessary to implement this solution. When complete you\'ll be able to deploy a zitified version of Prometheus and give Prometheus the power to scrape anything from anywhere using OpenZiti."},{"id":"scraping-anything-anywhere-in-action","metadata":{"permalink":"/docs/openziti/blog/scraping-anything-anywhere-in-action","source":"@site/blog/scraping-anything-anywhere-in-action.md","title":"Scraping Anything, Anywhere in Action","description":"This is part three of a three-part article. This article builds on the previous two articles. Here we will take a look at what we built and use it to explore the power of a zitified Prometheus. See part one for the necessary background about the series. See part two for detailed instructions covering how to setup the environment you\'re about to explore","date":"2022-04-23T04:00:00.000Z","tags":[{"inline":false,"label":"Kubernetes","permalink":"/docs/openziti/blog/tags/kubernetes","description":"Kubernetes content"},{"inline":false,"label":"Prometheus","permalink":"/docs/openziti/blog/tags/prometheus","description":"Prometheus monitoring"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zerotrust","description":"Zero Trust Networking"}],"readingTime":13.29,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Scraping Anything, Anywhere in Action","date":"2022-04-23T04:00:00.000Z","cuid":"cluvi4mc6000h08l53eca5d01","slug":"scraping-anything-anywhere-in-action","authors":["ClintDovholuk"],"tags":["kubernetes","prometheus","zerotrust"]},"unlisted":false,"prevItem":{"title":"Prometheus - Scrape Anything from Anywhere","permalink":"/docs/openziti/blog/prometheus-scrape-anything-from-anywhere"},"nextItem":{"title":"Tunneling Ingress to Kubernetes Workloads","permalink":"/docs/openziti/blog/kubernetes"}},"content":"*This is part three of a three-part article. This article builds on the previous two articles. Here we will take a look at what we built and use it to explore the power of a zitified Prometheus. See* [*part one*](./prometheus-scrape-anything-from-anywhere.md) *for the necessary background about the series. See* [*part two*](./configuring-openziti-to-enable-prometheus.md) *for detailed instructions covering how to setup the environment you\'re about to explore*\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Payoff\\n\\nOk. Here it is. We are at the end of the series and here is where we\'ll put it all together and really start to understand the sort of innovations you can create when you zitify an application. As a reminder, we are working with [Prometheus](https://prometheus.io/), a CNCF project that we will use to monitor a workload deployed in two separate [Kubernetes](https://kubernetes.io) clusters. To save you from flipping back to a previous article, here is what that solution looks like.\\n\\n![overview](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubernetes-prometheus-after.svg)\\n\\nNow we are ready to start using our Prometheus servers. We\'ll use our OpenZiti overlay network to connect to a workload which will generate a metric we want to display in Prometheus. We\'ll then configure Prometheus to scrape the workload and put it on a graph to prove it works. Once that\'s complete, we\'ll play around with the setup and see if we really can scrape anything, anywhere. Let\'s begin.\\n\\n## Developer Access\\n\\nIn the [previous article](./configuring-openziti-to-enable-prometheus.md), we established our entire solution using the OpenZiti overlay, `kubectl` and `helm`. We saw everything get installed and it all \\"seems to work\\". But how do we **know** it works? Let\'s provision an identity for yourself now and let\'s enroll it in your local tunneling app and find out. Go out and get [a tunneling client](https://openziti.io/docs/reference/tunnelers/) running locally. Once you have that installed, provision an identity and enroll it with your tunneling client.\\n\\n```text\\nziti edge create identity user dev.client -a \\"prometheus-clients\\",\\"reflectz-clients\\"\\n```\\n\\nYou should have access to six total services when this identity is enrolled:\\n\\n```text\\nService Name: kubeA.prometheus.svc\\n   Intercept: kubeA.prometheus.svc:80\\nService Name: kubeA.reflect.svc\\n   Intercept: kubeA.reflect.svc.ziti:80\\nService Name: kubeA.reflect.scrape.svc\\n   Intercept: kubeA.reflect.scrape.svc.ziti:80\\n\\nService Name: kubeB.prometheus.svc\\n   Intercept: kubeB.prometheus.svc:80\\nService Name: kubeB.reflect.svc\\n   Intercept: kubeB.reflect.svc.ziti:80\\nService Name: kubeB.reflect.scrape.svc\\n   Intercept: kubeB.reflect.scrape.svc.ziti:80\\n```\\n\\n## ClusterA\\n\\nWith your developer access you should be able to navigate your browser to http://kubea.prometheus.svc/targets.\\n\\n> We won\'t dwell on this for long in this article but notice that this is showing off another superpower of OpenZiti, private DNS. Notice that you were able to browse to a totally fictitious domain name: kubea.prometheus.svc. \\".svc\\" is **not** a legitimate top level domain. [Look at the full list of top level domains starting with S](https://en.wikipedia.org/wiki/List_of_Internet_top-level_domains#S). You won\'t find \\".svc\\" on that list at this time\\n\\n![kubea.prom.init](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubea.prom.init.png)\\n\\nYou should see the following. You might have noticed that the chart deployed has a few other containers we have not discussed yet. We\'ll not go into those containers in this article. What\'s important is that this Prometheus server has a few targets already for us to access. Neat, but this isn\'t what we want to actually monitor.\\n\\nWhat we really want to monitor is the workload we deployed: `reflectz`. We can do this by editing the Prometheus configmap using `kubectl`. Let\'s go ahead and do this now:\\n\\n```text\\nkubectl edit cm prometheuz-prometheus-server\\n```\\n\\nThis will open an editor in your terminal and allow you to update the config map for the pod. Once the editor is open, find the section labeled \\"scrape\\\\_config\\" and add the following entry:\\n\\n```text\\n    - job_name: \'kubeA.reflectz\'\\n      scrape_interval: 5s\\n      honor_labels: true\\n      scheme: \'ziti\'\\n      params:\\n        \'match[]\':\\n          - \'{job!=\\"\\"}\'\\n        \'ziti-config\':\\n          - \'/etc/prometheus/scrape.json\'\\n      static_configs:\\n        - targets:\\n          - \'kubeA.reflect.scrape.svc-kubeA.reflect.id\'\\n```\\n\\nThis is yaml and yaml is sensitive to spaces. The block above is properly indented for the config that the helm chart installs. You should be able to simply copy it and add it under the scrape\\\\_config. Remember, there is a `configmap-reload` container in the pod which monitors the configmap. On successful edit, this container will notice and will issue a web hook to the `prometheus-server` container. The trigger is not immediate, don\'t worry if it takes a while. It can take around a minute for the trigger to fire.\\n\\nWhile we wait for the trigger, let\'s explain what this is doing. This is informing the Prometheus server to monitor a workload which can be found at the provided target of `kubeA.reflect.scrape.svc-kubeA.reflect.id`. Notice that no port is included in this target, and also notice that this is a very strange looking FQDN. That\'s because this is a zitified version of Prometheus. We have extended Prometheus to understand a \\"scheme\\" of `ziti`. When we configure this job with a scheme of ziti, we can then supply targets to the job which represent an OpenZiti service. We need to supply the `ziti-config` node with the path to the identity we want Prometheus to use to issue the scrape. This will always be `/etc/prometheus/scrape.json` at this time. Should the community desire it, we can look into changing the location of the identity.\\n\\nIf you would like to tail the `configmap-reloadz` container, you can issue this one liner. This will instruct `kubectl` to tail the logs from `configmap-reloadz`.\\n\\n```text\\npod=$(kubectl get pods | grep server | cut -d \\" \\" -f1); echo POD: $pod; kubectl logs -f \\"$pod\\" prometheus-server-configmap-reload\\n```\\n\\nWhen the trigger happens for ClusterA you will see a message like the one below. Notice that `configmap-reloadz` is using the underlay network: `http://127.0.0.1:9090/-/reload`\\n\\n```text\\n2022/04/23 20:01:23 config map updated\\n2022/04/23 20:01:23 performing webhook request (1/1/http://127.0.0.1:9090/-/reload)\\n2022/04/23 20:01:23 successfully triggered reload\\n```\\n\\n### Config Reloaded\\n\\nOnce you\'ve correctly updated the configmap, and `configmap-reloadz` detected the change and told Prometheus to reload. You\'ll see a new target has been reported by Prometheus at http://kubea.prometheus.svc/targets. You should now see \\"kubeA.reflectz (1/1 up)\\" showing. Congratulations! You have just successfully scraped a target from zitified Prometheus! Remember this workload does not listen on the Kubernetes underlay network. It\'s only accessible from the OpenZiti overlay.\\n\\n![kubea.target1.png](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubea.target1.png)\\n\\n### Let\'s Graph It!\\n\\nCool, we have a target. The target can be scraped by Prometheus over the OpenZiti overlay. We\'re also able to securely access the Prometheus UI over the same OpenZiti overlay. Let\'s use the Prometheus UI to graph the data point we want to see, the `reflect_total_connections` metric.\\n\\n1. Navigate to http://kubea.prometheus.svc/graph\\n    \\n2. enter `reflect_total_connections`\\n    \\n3. click Graph (notice I changed my time to \'10s\', located just under Graph)\\n    \\n4. click Execute\\n    \\n5. Notice there are no connections (0)\\n    \\n\\n![grpah it](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubea.graph.png)\\n\\n### Generate Some Data\\n\\nNow let\'s change that graph of `reflect_total_connections` from 0 to 1 (or more). One of the services you will have access to will intercept `kubeA.reflect.svc.ziti:80`.\\n\\n> If you are using Windows and Windows Subsystem for Linux (WSL) as I am, you **might** need to understand how get WSL to use your Ziti Desktop Edge for Windows as your DNS resolver when inside WSL. Generally speaking this is as easy as editing /etc/resolv.conf and adding the IP as the first nameserver: `nameserver 100.64.0.1` (or whatever the DNS IP is). Try it first, depending on how you setup WSL it might \'just work\' for you. You can also just use cygwin or any other netcat tool from Windows (not WSL) too.\\n\\nNow we can use netcat to open a connection through this intercept a few times. The metric tracks the total number of connections to the reflect service. Connect, send some text, the use ctrl-c to disconnect. Do that a few times then click \'execute\' again on the graph page. You can see I did this over a minute and moved my total count on kubeA to 8, shown below.\\n\\n```text\\n/tmp/prometheus$ nc kubeA.reflect.svc.ziti 80\\nkubeA reflect test\\nyou sent me: kubeA reflect test\\n^C\\n/tmp/prometheus$ nc kubeA.reflect.svc.ziti 80\\nanother reflect test\\nyou sent me: another reflect test\\n^C\\n/tmp/prometheus$ nc kubeA.reflect.svc.ziti 80\\nanother reflect test\\nyou sent me: another reflect test\\n^C\\n```\\n\\n![kubea.more.total.conn.png](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubea.more.total.conn.png)\\n\\n### Scrape Something Else\\n\\nHopefully you agree with me that this is pretty neat. Well what if we take it to the next level? What if we tried to scrape the workload we deployed to ClusterB? Could we get that to work? Recall from above how we enabled the job named \'kubeA.reflectz\'. What if we simply copied/pasted that into the configmap changing kubeA --&gt; kubeB. Would it work? Let\'s see.\\n\\n```text\\n# edit the configmap on ClusterA:\\nkubectl edit cm prometheuz-prometheus-server\\n\\n#add the job - and wait for the configmap to reload\\n\\n    - job_name: \'kubeB.reflectz\'\\n      scrape_interval: 5s\\n      honor_labels: true\\n      scheme: \'ziti\'\\n      params:\\n        \'match[]\':\\n          - \'{job!=\\"\\"}\'\\n        \'ziti-config\':\\n          - \'/etc/prometheus/scrape.json\'\\n      static_configs:\\n        - targets:\\n          - \'kubeB.reflect.scrape.svc-kubeB.reflect.id\'\\n```\\n\\nAfter watching the logs from `configmap-reloadz` on ClusterA and seeing the webhook trigger. Just go back to the Prometheus server in the browser. You should be at the \'graph\' url but if not navigate back and execute another graph for `reflect_total_connections`. When we do that it probably doesn\'t look much different but... Wait a second? In the legend? Can it be? That\'s right. From Kubernetes ClusterA, we have just scraped a workload from Kubernetes ClusterB, entirely over the OpenZiti overlay.\\n\\n![kubeA-and-kubeB.png](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubeA-and-kubeB.png)\\n\\nGenerate some data like you did before by running a few netcat connection/disconnects and click \'Execute\' again. Don\'t forget to send the connection request to kubeB though!\\n\\n```text\\nnc kubeB.reflect.svc.ziti 80\\nthis is kubeb\\nyou sent me: this is kubeb\\n^C\\nnc kubeB.reflect.svc.ziti 80\\nanother to kube b\\nyou sent me: another to kube b\\n^C\\nnc kubeB.reflect.svc.ziti 80\\none more for fun and profit\\nyou sent me: one more for fun and profit\\n^C\\n```\\n\\n![kubeB from kubeA](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/kubeB-from-kubeA.png)\\n\\n## Scraping All the Things!\\n\\nBy now, you are probably starting to get the idea just how powerful this is for Prometheus. A zitified Prometheus can scrape things easily and natively by just deploying a `Prometheuz` instance into the location you want to scrape. Or, you can just enable a scrape target using a tunneling app, or in Kubernetes using the `ziti-host` helm chart. Let\'s complete our vision now and stand up a Prometheus server on our local workstation using Docker.\\n\\nWhen we run `Prometheuz` locally using docker we\'ll need a config file to give to docker using a volume mount. We also provide the identity used to connect to the OpenZiti overlay in the same fashion. Let\'s start up a docker container locally and see if we can grab data from our two Prometheus instances using a locally deployed `Prometheuz` via docker.\\n\\n*EDIT 2024 link removed:*<s>GitHub has a sample Prometheus </s> [<s>file you can download</s>](https://raw.githubusercontent.com/openziti/ziti-doc/main/docusaurus/blog/zitification/prometheus/scripts/local.prometheus.yml)<s>.</s> Below, I used curl to download it and put it into the expected location.\\n\\n```text\\ncurl -s https://raw.githubusercontent.com/openziti/ziti-doc/main/docusaurus/blog/zitification/prometheus/scripts/local.prometheus.yml > /tmp/prometheus/prometheus.config.yml\\n\\nziti edge create identity user local.prometheus.id -o /tmp/prometheus/local.prometheus.id.jwt -a \\"reflectz-clients\\",\\"prometheus-clients\\"\\nziti edge enroll /tmp/prometheus/local.prometheus.id.jwt -o /tmp/prometheus/local.prometheus.id.json\\n\\ndocker run \\\\\\n  -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.id.json \\\\\\n  -v /tmp/prometheus/prometheus.config.yml:/etc/prometheus/prometheus.yml \\\\\\n  -p 9090:9090 \\\\\\n  openziti/prometheuz\\n```\\n\\n![local-docker-targets.png](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/local-docker-targets.png)\\n\\nLook at what we\'ve just done. We have started a Prometheus instance locally, and used it to connect to four Prometheus targets via scrape configurations when all four targets are hidden entirely from my local computer (and any computer) unless the computer has an OpenZiti identity. I personally think that is incredibly cool!\\n\\n## Taking it to 11\\n\\nBut wait, I\'m not done. That docker instance is listening on an underlay network. It\'s exposed to attack by anything on my local network. I want to fix that too. Let\'s start this docker container up listening only on the OpenZiti overlay. Just like in [part 2](./configuring-openziti-to-enable-prometheus.md) we will make a config, a service and two policies to enable identities on the OpenZiti overlay.\\n\\n```text\\ncurl -s https://raw.githubusercontent.com/openziti/ziti-doc/main/docusaurus/blog/zitification/prometheus/scripts/local.prometheus.yml > /tmp/prometheus/prometheus.config.yml\\n\\n# create the config and service for the local prometheus server\\nziti edge create config \\"local.prometheus.svc-intercept.v1\\" intercept.v1 \\\\\\n  \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"local.prometheus.svc\\"],\\"portRanges\\":[{\\"low\\":80, \\"high\\":80}], \\"dialOptions\\": {\\"identity\\":\\"local.prometheus.id\\"}}\'\\n\\nziti edge create service \\"local.prometheus.svc\\" \\\\\\n  --configs \\"local.prometheus.svc-intercept.v1\\"\\n\\n# grant the prometheus clients the ability to dial the service and the local.prometheus.id the ability to bind\\nziti edge create service-policy \\"local.prometheus.svc.dial\\" Dial \\\\\\n  --service-roles \\"@local.prometheus.svc\\" \\\\\\n  --identity-roles \\"#prometheus-clients\\"\\nziti edge create service-policy \\"local.prometheus.svc.bind\\" Bind \\\\\\n  --service-roles \\"@local.prometheus.svc\\" \\\\\\n  --identity-roles \\"@local.prometheus.id\\"\\n```\\n\\nOnce that\'s done - let\'s see if we can start the docker container. The helm charts are configured to translate the `--set` flags provided into \\"container friendly\\" settings like environment variables, volumes and mounts etc. In docker we need to provide those. If you\'re familiar with docker these will probably all make sense. The most important part of the command below is the **lack** of a `-p` flag. The `-p` flag is used to expose a port from inside docker, outside docker. Look at the previous docker sample and you\'ll find we were mapping local underlay port 9090 to port 9090 in the docker container. In this example, **we will do no such thing**! :)\\n\\n```text\\ndocker run \\\\\\n    -e ZITI_LISTENER_SERVICE_NAME=local.prometheus.svc \\\\\\n    -e ZITI_LISTENER_IDENTITY_FILE=/etc/prometheus/ziti.server.json \\\\\\n    -e ZITI_LISTENER_IDENTITY_NAME=local.prometheus.id \\\\\\n    -v /tmp/prometheus/prometheus.config.yml:/etc/prometheus/prometheus.yml \\\\\\n    -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.id.json \\\\\\n    -v /tmp/prometheus/local.prometheus.id.json:/etc/prometheus/ziti.server.json \\\\\\n    openziti/prometheuz\\n```\\n\\n### But - Does It Work?\\n\\nAfter configuring the OpenZiti overlay, we just need to open a browser and navigate to http://local.prometheus.svc/targets. SUCCESS!\\n\\n![local-docker-targets-no-listener.png](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/local-docker-targets-no-listener.png)\\n\\n### SUCCESS!\\n\\n![local-docker-graph-no-listener.png](https://github.com/dovholuknf/ziti-doc/raw/main/docusaurus/blog/zitification/prometheus/local-docker-graph-no-listener.png)\\n\\n## Wrap Up\\n\\nThis was quite the journey and a lot of fun. We have taken a wildly popular open source project and brought OpenZiti to it with really not much code at all. Then using OpenZiti we were able to give Prometheus superpowers and enable it to scrape any target regardless of where that target is or what network it is on.\\n\\nThink of the possibilities here. Are you a cloud provider looking to monitor your client\'s services which are deployed on-prem? That\'s so easy with OpenZiti and without sacrificing security **at all**. In fact, using OpenZiti like this provides amazing reach while **strengthening** the security posture of the solution because you\'re now using the concepts of [zero trust networking principles](https://en.wikipedia.org/wiki/Zero_trust_security_model) and applying them to your alerting and monitoring solution.\\n\\nWhat do you think? Was this series interesting? Do you think OpenZiti is cool and you are looking to try it out? What are you going to zitify? Tell us on [X <s>twitter</s>](https://twitter.com/openziti) or on [discourse](https://openziti.discourse.group/)! Both links are included in this page. Let us know what you think! Go star the [openziti/ziti](http://github.com/openziti/ziti) repo and help us spread the word of OpenZiti to the world!"},{"id":"kubernetes","metadata":{"permalink":"/docs/openziti/blog/kubernetes","source":"@site/blog/tunneling-ingress-to-kubernetes-workloads.md","title":"Tunneling Ingress to Kubernetes Workloads","description":"The previous post showed how to use a zero trust overlay like Ziti for transferring files by","date":"2021-10-21T00:49:30.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Kubernetes","permalink":"/docs/openziti/blog/tags/kubernetes","description":"Kubernetes content"},{"inline":false,"label":"Uncategorized","permalink":"/docs/openziti/blog/tags/uncategorized","description":"Uncategorized posts"}],"readingTime":13.21,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Tunneling Ingress to Kubernetes Workloads","date":"2021-10-21T00:49:30.000Z","cuid":"cl4758oa9030tiunvbtg82umz","slug":"kubernetes","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1653224137964/I7QcSkiM3.jpeg","imageDark":"@site/blogs/openziti/v1653224137964/I7QcSkiM3.jpeg","tags":["security","kubernetes","uncategorized"]},"unlisted":false,"prevItem":{"title":"Scraping Anything, Anywhere in Action","permalink":"/docs/openziti/blog/scraping-anything-anywhere-in-action"},"nextItem":{"title":"Zitifying SCP","permalink":"/docs/openziti/blog/zitifying-scp"}},"content":"The [previous post](./zitifying-scp.md) showed how to use a zero trust overlay like Ziti for transferring files by \\nzitifying `scp`. Next up in the list of zitifications is `kubectl`. [Kubernetes](https://Kubernetes.io/) is a \\ncontainer orchestration system. Its purpose is to deploy, scale, and manage the deployment containers. Containers \\nare self-contained, pre-built images of software generally with a singular purpose. \\n[Developers often like using containers for various reasons](https://appfleet.com/blog/10-reasons-why-developers-love-docker/). \\nOne major reason developers like containers is because it simplifies the deployment of the solutions \\nthey are developing. This is where Kubernetes starts to come into focus.\\n\\n\x3c!-- truncate --\x3e\\n\\nIn this article we\'ll use a cloud provider to create a Kubernetes cluster to use. I\'m using Oracle OKE in this article but there are [numerous Kubernetes providers](https://www.google.com/search?q=kubernetes+cloud+providers&oq=kubernetes+cloud+providers) and any of them will work but clearly the commands I\'m running here are Oracle specific. Once created we will then access the cluster three ways:\\n\\n1. Via the public Kubernetes API secured via mTLS. This is the default, out-of-the-box mechanism provided by Kubernetes.\\n    \\n2. Via a tunneling app. I run Windows, so I\'ll use the Ziti Desktop Edge for Windows.\\n    \\n3. Via a zitified `kubectl`.\\n    \\n\\nHere\'s where we\'ll get to see the power of a truly zitified application. We\'ll be able to access our cluster extremely securely using the Ziti overlay network without installing an additional agent. Once access to the cluster comes entirely from the [Ziti Network](https://openziti.github.io/ziti/overview.html#overview-of-a-ziti-network), we will be able to turn public access to the Kubernetes management API **off** entirely!\\n\\n---\\n\\n## About Kubernetes\\n\\nIf you aren\'t already familiar with Kubernetes then it\'s probably best for you to stop reading and learn a little about it first. Though this article only expects you to understand the most rudimentary of commands, it won\'t teach you enough about Kubernetes to understand the what\'s and why\'s. Lots of documentation on this topic already exist and are just a search away in your search engine of choice.\\n\\nKubernetes itself is not a container engine, it\'s an orchestrator. This means that Kubernetes knows how to interface with container engines to perform deployments and management of workloads on the behalf of operators. This provides people with a common abstraction to use when doing this management and deployment. Interacting with the Kubernetes API is made easy by using the command-line tool: `kubectl`.\\n\\n[kubectl](https://Kubernetes.io/docs/reference/kubectl/overview/) provides numerous commands and utilities to interact with your Kubernetes cluster. It does this by creating REST requests to a well-known endpoint. This endpoint is a highly-valuable target as it is the entry-point to the cluster. Plenty of blogs exist already on the internet addressing how to secure this endpoint but in this post we\'ll take it one step further than ever before by removing the Kubernetes control plane from the internet entirely. Following that we will even go one step further by replacing the existing `kubectl` command with a zero-trust implementation leveraging the ziti golang sdk.\\n\\nIf you\'d prefer to watch a video that goes over the same content contained in the rest of this article you can go ahead and click here to watch.\\n\\n%[https://youtu.be/CRoansolpR0] \\n\\n---\\n\\n## Setup\\n\\nBelow is an overview of the [Ziti Network](https://openziti.github.io/ziti/overview.html#overview-of-a-ziti-network) I created for this article. On the left you can see that the client, my computer, runs Windows 10. Inside Windows 10 I run linux and bash using Ubuntu via [Windows Subsystem For Linux (WSL)](https://docs.microsoft.com/en-us/windows/wsl/install). If you run Windows and don\'t have WSL installed I would encourage you to install and learn it! In my bash shell I have downloaded the linux version of `kubectl` created by combining the Ziti Golang SDK into it. You can grab it from [this link](https://github.com/openziti-incubator/kubectl/releases/latest/download/kubectl-linux-amd64) if you like or go check out [the code on GitHub](https://github.com/openziti-incubator/kubectl) and build it yourself!\\n\\n![\ud83d\ude42](/blogs/openziti/v1653224133689/DoisPrjcH.png)\\n\\n### Solution Overview\\n\\n![image.png](/blogs/openziti/v1654786613938/D7i8n0NOP.png)\\n\\n### Basic Ziti Setup\\n\\nTo accomplish our stated goals, we will need not only an existing [Ziti Network](https://openziti.github.io/ziti/overview.html#overview-of-a-ziti-network) but we\'ll also have to configure that network accordingly. Here\'s a list of the components necessary to deliver Kubernetes with our zero-trust network:\\n\\n1. A configuration for the `Bind` side of the service. This informs the identity within Kubernetes where to send traffic and how.\\n    \\n2. A configuration for the `Dial` side of the service. This is strictly **only** necessary for tunneling apps. In this example, for the Ziti Desktop Edge for Windows and specifies what host and port will be intercepted on the machine running the stock `kubectl`. for Windows.\\n    \\n3. The service itself which ties our polices mentioned above together.\\n    \\n4. A `Bind` service-policy which specifies which identities are allowed to act as a \\"host\\" for the service (meaning an identity to send traffic to which knows where and how to offload that traffic). In our example this will be the `ziti-edge-tunnel` running in a Kubernetes pod.\\n    \\n5. A `Dial` service-policy which specifies the identities allowed to access the service. This will be the identity using  \\n    `kubectl`.\\n    \\n6. Create two identities - one for the `Bind` side of the service (deployed within the Kubernetes cluster) and one for the `Dial` or client side.\\n    \\n\\nHere are some example commands using the [ziti cli](https://github.com/openziti/ziti/releases/latest) which illustrate how to create these services. Some things of note worth mentioning. I\'m setting a variable to make my configuration easier. I reuse these code blocks a lot and by extracting some variables it makes it easy for me to delete/recreate services. First I set the `service_name`  \\nvariable. I use this variable in all the names of the Ziti objects I create just to make it more clear and obvious if I have to look back at my configuration again.\\n\\nSince I\'m going to be accessing my Kubernetes API which I\'ve deployed using the Oracle cloud I chose to use `k8s.oci`  \\nas my service name. When deployed by a cloud provider, the Kubernetes API is generated or updated with numerous SANS and IP address I can choose from to represent the `Dial` side which will be intercepted by the Ziti Desktop Edge for Windows. The Oracle cloud console informs me that the private IP of `10.0.0.6` was assigned to my cluster when I click on the \'Access Cluster\' button which is why I chose to use that value below. I could have choosen to use any of the DNS names provided by OKE. There are at least five I could choose from, all visible as SANS on the cert that the server returns: `kubernetes`, `kubernetes.default`, `kubernetes.default.svc`, `kubernetes.default.svc.cluster`  \\n, `kubernetes.default.svc.cluster.local`. I chose the IP since it\'s pretty obvious that it\'s an internal IP, not on my local network. Also worth pointing out is that I\'m mapping the port as well, changing it from the port that the server provides, 6443, to the common HTTPS port of 443 for the local intercept. With zitified `kubectl` we don\'t even need these intercepts, but we\'ll keep it here so that we can use the unmodified `kubectl` as well. Finally, these commands are all executed inside a bash shell since I\'m using WSL.\\n\\n#### Example Ziti CLI commands\\n\\n```bash\\n# the name of the service\\nservice_name=k8s.oci\\n\\n# the name of the identity you\'d like to see on the kubectl client\\nthe_user_identity=\\"${service_name}.client\\"\\n\\n# the name of the identity deployed into the kubernetes cluster\\nthe_kubernetes_identity=\\"${service_name}.private\\"\\n\\nziti edge create config \\"${service_name}-host.v1\\" host.v1 \\\\\\n    \'{\\"protocol\\":\\"tcp\\", \\"address\\":\\"10.0.0.6\\",\\"port\\":6443 }\'\\n\\nziti edge create config \\"${service_name}-client-config\\" intercept.v1 \\\\\\n    \'{\\"protocols\\":[\\"tcp\\"],\\"addresses\\":[\\"10.0.0.6\\",\\"kubernetes\\"], \\"portRanges\\":[{\\"low\\":443, \\"high\\":443}]}\'\\n\\nziti edge create service \\\\\\n    \\"${service_name}\\" \\\\\\n    --configs \\"${service_name}-client-config,${service_name}-host.v1\\"\\n\\nziti edge create service-policy \\"${service_name}-binding\\" Bind \\\\\\n    --service-roles \\"@${service_name}\\" \\\\\\n    --identity-roles \\"#${service_name}ServerEndpoints\\"\\n\\nziti edge create service-policy \\"${service_name}-dialing\\" Dial \\\\\\n    --service-roles \\"@${service_name}\\" \\\\\\n    --identity-roles \\"#${service_name}ClientEndpoints\\"\\n\\nziti edge create identity device \\"${the_kubernetes_identity}\\" \\\\\\n    -a \\"${service_name}ServerEndpoints\\" \\\\\\n    -o \\"${the_kubernetes_identity}.jwt\\"\\n\\nziti edge create identity device \\"${the_user_identity}\\" \\\\\\n    -a \\"${service_name}ClientEndpoints\\" \\\\\\n    -o \\"${the_user_identity}.jwt\\"\\n```\\n\\n## Kubernetes Config Files\\n\\nOnce we have established the pieces of the [Ziti Network](https://openziti.github.io/ziti/overview.html#overview-of-a-ziti-network), we\'ll want to get the Kubernetes config files from OKE so that we can test access, make sure the cluster works etc. Oracle provides a CLI command which makes it pretty easy to get those config files called `oci`. As of this writing - the guide from [Oracle is here](https://docs.oracle.com/en-us/iaas/Content/API/SDKDocs/cliinstall.htm). Once `oci` is installed and configured the Oracle cloud gives you very easy commands to run which will generate two files. One file will be for accessing the Kubernetes API through the public endpoint. The other will get you the file for private access. We\'re going to want both since we\'re on a journey here from \\"public API endpoint\\" to tunneling-app-based access, to the final stage of app-embedded zero-trust directly into `kubeztl`.\\n\\n### Getting the Kubernetes Config Files\\n\\nNotice that we are changing the file location output by these commands and they are being output as two separate Kubernetes config files. If you prefer to merge them all into one big config file and change contexts - feel free. I left them as separate files here because it provides a very clear separation as to which config is being used or modified.\\n\\n```bash\\n# Get this value directly from Oracle\\noci_cluster_id=\\"put-your-cluster-id-here\\"\\n\\noci ce cluster create-kubeconfig \\\\\\n    --cluster-id ${oci_cluster_id} \\\\\\n    --file /tmp/oci/config.oci.public \\\\\\n    --region us-ashburn-1 \\\\\\n    --token-version 2.0.0 \\\\\\n    --kube-endpoint PUBLIC_ENDPOINT\\nchmod 600 /tmp/oci/config.oci.public\\n\\noci ce cluster create-kubeconfig \\\\\\n    --cluster-id ${oci_cluster_id} \\\\\\n    --file /tmp/oci/config.oci.private \\\\\\n    --region us-ashburn-1 \\\\\\n    --token-version 2.0.0 \\\\\\n    --kube-endpoint PRIVATE_ENDPOINT\\nchmod 600 /tmp/oci/config.oci.private\\n```\\n\\n## Connecting the Pieces\\n\\nAt this point we should have all the pieces in place so that we can start putting them together to test the overall solution. In this section we\'ll access our public Kubernetes api to make sure it works. Then we\'ll install Ziti into the Kubernetes cluster and verify private access works. Finally we\'ll disable public access **entirely** and use the zitified `kubeztl` command to access the cluster with true, app-embedded zero-trust binary.\\n\\n### Testing the Public API\\n\\nThis step is very straight-forward for anyone who\'s used Kubernetes before. Issue the following commands, making sure the path is correct for your public Kubernetes config file, and verify Kubernetes works as expected.\\n\\n```bash\\nexport KUBECONFIG=/tmp/oci/config.oci.public\\nkubectl get pods -v6 --request-timeout=5s\\nI1019 13:57:31.910962    3211 loader.go:372] Config loaded from file:  /tmp/oci/config.oci.public\\nI1019 13:57:33.676047    3211 round_trippers.go:454] GET https://150.230.150.0:6443/api/v1/namespaces/default/pods?limit=500&timeout=5s 200 OK in 1752 milliseconds\\nNAME                                        READY   STATUS    RESTARTS   AGE\\n```\\n\\nIf your output looks something similar to the above (with or without the pods you expect to see) then great! That means your Kubernetes cluster is indeed up and running. Let\'s move on!\\n\\n#### Deploying Ziti to Kubernetes\\n\\n1. install the `helm` CLI tool [using this guide](https://helm.sh/docs/intro/install/)\\n    \\n2. add the OpenZiti Helm repo:\\n    \\n    ```bash\\n    helm repo add openziti https://openziti.github.io/helm-charts/\\n    ```\\n    \\n3. locate the jwt file for the Kubernetes identity. If you followed the steps above the file will be named: `\\"${the_kubernetes_identity}\\".jwt` (make sure you replace the variable with the correct value)\\n    \\n4. enroll the Kubernetes identity. This exchanges the temporary JWT for a permanent identity JSON file. Several Ziti CLIs have an `enroll` command for this purpose. Here\'s one way to obtain the identity that doesn\'t require you to download a CLI if you already have Docker:\\n    \\n    ```bash\\n    # start with JWT file on Docker host in \\n    #  /tmp/${the_kubernetes_identity}.jwt\\n    docker run --rm --volume /tmp:/mnt \\\\\\n        openziti/quickstart /openziti/ziti-bin/ziti edge enroll \\\\\\n        \\"/mnt/${the_kubernetes_identity}.jwt\\"\\n    # now you will have a new file \\n    # /tmp/${the_kubernetes_identity}.json\\n    ```\\n    \\n5. use the Kubernetes identity JSON file when you install the Helm chart:\\n    \\n    ```bash\\n    helm install ziti-host openziti/ziti-host \\\\\\n        --set-file zitiIdentity=\\"/tmp/${the_kubernetes_identity}.json\\"\\n    ```\\n    \\n\\nAgain, make sure you replace the variable name\\n\\n#### Add/Enroll the Client Identity\\n\\nNow consume the one time token (the jwt file) to enroll and create a client-side identity using the Ziti Desktop Edge for Windows (or MacOS or via the `ziti-edge-tunnel` if you prefer). Once you can see the identity in your tunneling app, you should be able to use the private kubernetes config file to access the same exact cluster. Remember though, we have mapped the port on the client side to use 443. That means you\'ll need to update your config file and change 6443 --&gt; 443. Now when you run `get pods` you\'ll see the ziti-host pod deployed:\\n\\n```bash\\n$ export KUBECONFIG=/tmp/oci/config.oci.private\\n$ kubectl get pods\\nNAME                        READY   STATUS    RESTARTS   AGE\\nziti-host-976b84c66-kr4bc   1/1     Running   0          90m\\n```\\n\\n## The Big Finale - Zitified kubectl\\n\\nIf you have made it this far, you\'ve seen us access the Kubernetes API via the public IP. We\'ve even accessed it via the private IP (which btw - is pretty cool in my opinion!). Now we\'re going to download the zitified kubectl command, turn off the public IP and even turn off the locally running tunneling app and still access the API!\\n\\n1. Disable the cluster\'s public IP address in OKE (go to the cluster in Oracle Cloud, click Edit and remove the public IP and click save)\\n    \\n2. Turn off the Ziti Desktop Edge for Windows\\n    \\n3. Download `kubeztl` (you don\'t need to call the executable `kubeztl` - you can keep it named `kubectl` if you want)\\n    \\n    ```bash\\n    curl -L -o kubeztl https://github.com/openziti-incubator/kubectl/releases/download/v0.0.4/kubectl-linux-amd64\\n    ```\\n    \\n4. Use `kubeztl` to get pods!\\n    \\n    ```bash\\n    ./kubeztl get pods -c id.json -S k8s.oci\\n    NAME                        READY   STATUS    RESTARTS   AGE\\n    ziti-host-976b84c66-kr4bc   1/1     Running   0          101m\\n    ```\\n    \\n    ### Modifying KUBECONFIG\\n    \\n\\nThe `kubeztl` command has also been modified to allow you to add the service name and config file directly into the file itself. This is convenient since you will not need to supply the ziti identity file, nor will you need to specify which service to use. Modifying the file is straight-forward. Open the config file, find the context listed under the contexts root and add two rows as shown here.\\n\\n```yaml\\ncontexts\\n- context:\\n    cluster: cluster-cjw4arxuolq\\n    user: user-cjw4arxuolq\\n    zConfig: /tmp/oci/k8s.id.json\\n    service: k8s.oci\\n```\\n\\nOnce done - you can now simply use the context the same way you have always - `kubeztl get pods`!!!\\n\\n```bash\\n./kubeztl get pods\\nNAME                        READY   STATUS    RESTARTS   AGE\\nziti-host-976b84c66-kr4bc   1/1     Running   0          114m\\n```\\n\\n## Conclusion\\n\\nWe\'ve seen in this post how you can not only secure your Kubernetes API with the normal Kubernetes mechanisms. You can also take your Kubernetes API off the internet **ENTIRELY**. No need to deploy and maintain a special bastion node. Now by having a secure, zero-trust overlay in place you can safely and securely access your Kubernetes API without the fear of that public, high-value API getting attacked.\\n\\n![](/blogs/openziti/v1653224136599/XaHdVbzL4.jpeg)\\n\\nOnce you\'ve deployed Ziti into the Kubernetes cluster you\'re not done there. Now you can also use Ziti to span cloud networks. You can use it to easily link private data centers or other private Kubernetes clusters all into one secure, zero-trust overlay network! Use Ziti to expose workloads that are **TRULY** private! In future articles we might explore how we can bring Ziti to bear on these topics, stay tuned!\\n\\n---"},{"id":"zitifying-scp","metadata":{"permalink":"/docs/openziti/blog/zitifying-scp","source":"@site/blog/zitifying-scp.md","title":"Zitifying SCP","description":"In the previous post we talked about how we could take a well-known","date":"2021-08-12T14:45:18.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"}],"readingTime":5.7,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Zitifying SCP","date":"2021-08-12T14:45:18.000Z","cuid":"cl475237g030diunv9eu78yn8","slug":"zitifying-scp","authors":["ClintDovholuk"],"image":"@site/blogs/openziti//5dcfe6cb113284b378817a8ad5878f98.jpeg","imageDark":"@site/blogs/openziti//5dcfe6cb113284b378817a8ad5878f98.jpeg","tags":["security","zero-trust"]},"unlisted":false,"prevItem":{"title":"Tunneling Ingress to Kubernetes Workloads","permalink":"/docs/openziti/blog/kubernetes"},"nextItem":{"title":"Zitifying SSH","permalink":"/docs/openziti/blog/zitifying-ssh"}},"content":"In the [previous post](./zitifying-ssh.md) we talked about how we could take a well-known \\napplication and improve its security by zitifying it, producing `zssh`. The logical next step after zitifying `ssh` \\nwould be to extend the functionality of `zssh` to cover moving files securely as well, enter `zscp`. A zitified `scp` \\neffectively creates a more secure command line tool for sending and receiving files between ziti-empowered devices. \\nOnce zitified, we can use `zscp` using ziti identity names just like we did in \\n[zitifying ssh](./zitifying-ssh.md). I recommend reading the \\n[previous article](./zitifying-ssh.md) if you haven\'t to learn more about the benefits of \\nzitifying tools like `ssh` and `scp`.\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## First Things First\\n\\n`zscp` functions with the same prerequisites as `zssh`:\\n\\n* Establish a [Ziti Network](https://openziti.io/docs/learn/quickstarts/network/hosted)\\n    \\n* Create and enroll two Ziti Endpoints (one for our `ssh` server, one for the client)\\n    \\n    * the `sshd` server will run `ziti-tunnel` for this demonstration. Conveniently it will run on the same machine I used to setup the [Ziti Network](https://openziti.io/docs).\\n        \\n    * the client, in this case, is my local machine, and I\'ll `zscp` files both to and from the remote machine.\\n        \\n* Create the [Ziti Service](https://openziti.io/docs/learn/core-concepts/services/overview) we\'ll use and authorize the two endpoints to use this service\\n    \\n* Use the `zscp` binary from the client side and the `ziti-tunnel` binary from the serving side to connect\\n    \\n* Harden `sshd` further by removing port 22 from any internet-based firewall configuration (for example, from within the security-groups wizard in AWS) or by forcing `sshd` to only listen on `localhost/127.0.0.1`\\n    \\n\\nAfter ensuring these steps are complete, you can copy files across your Ziti Network. The traffic will be even more secure since now a Ziti Network is required for the connection, requiring that strong identity before even being able to access the `sshd` server. And of course, now `sshd` is \'dark\' - it no longer needs the typical port 22 to be exposed to any network.\\n\\nGiven all the prerequisites are satisfied, we can put `zscp` to use. Simply download the binary for your platform:\\n\\n* [linux amd64](https://github.com/openziti-incubator/zssh/releases/latest/download/zscp-linux-amd64)\\n    \\n* [windows amd64](https://github.com/openziti-incubator/zssh/releases/latest/download/zscp-windows-amd64.exe)\\n    \\n* [macOs amd64](https://github.com/openziti-incubator/zssh/releases/latest/download/zscp-macos-amd64)\\n    \\n* [other](https://github.com/openziti-test-kitchen/zssh/releases/latest)\\n    \\n\\n---\\n\\n## Sending and Receiving Files with Zscp\\n\\nOnce you have the executable downloaded, make sure it is named `zscp` and for simplicity\'s sake we\'ll assume it\'s on the path. Just like `zssh` to `ssh`, `zscp` provides the same basic functionality as `scp`. As with most tooling, executing the binary with no arguments will display the expected usage.\\n\\nThere are two main functions of `zscp`. Just like `scp` you can send and receive from the remote host.\\n\\nTo send files we use this basic syntax:\\n\\n`./zscp LOCAL_FILEPATHS... <REMOTE_USERNAME>@TARGET_IDENTITY:REMOTE_FILEPATH`\\n\\nThen, to retrieve remote files we use a similar syntax:\\n\\n`./zscp <REMOTE_USERNAME>@TARGET_IDENTITY:REMOTE_FILEPATH LOCAL_FILEPATH`\\n\\nBelow is a working example of using `zscp` to send a file to a remote machine. In this case the remote username is not the same as my local username. Just like with `scp`, I\'ll need to supply the username in my command and it will use the same syntax that regular `scp` uses. Here I am `zscp`\'ing as username `ubuntu` to the remote computer that is joined to the Ziti Network using the identity named `ziti-tunnel-aws`.\\n\\n./zscp local/1.txt ubuntu@ziti-tunnel-aws:remote INFO connection to edge router using token 6c2e8b79-ce8e-483e-a9f8-a930530e706a INFO sent file: /Users/name/local/1.txt ==&gt; /home/ubuntu/remote/1.txt\\n\\nThis is only a basic example on how we can use `zscp` to send a singular file to a remote computer. In the next section, we will go over how to use `zscp` flags for extended functionality.\\n\\n---\\n\\n## Zscp Flags\\n\\nJust like `zssh`, `zscp` has the same flags to pass in: ssh key, ziti configuration file, service name, and one to toggle debug logging. All the defaults are the same as with `zssh`, thus both `zscp` and `zssh` will work without the `-i` and `-c` flag providing the files exist at the default locations. Refer to \\\\[zitifying-ssh\\\\]\\\\[2\\\\] for instructions on how to use the flags below.\\n\\n\\\\-i, --SshKeyPath string Path to ssh key. default: $HOME/.ssh/id\\\\_rsa -c, --ZConfig string Path to ziti config file. default: $HOME/.ziti/zssh.json -d, --debug pass to enable additional debug information -s, --service string service name. (default \\"zssh\\")\\n\\nIn addition to the flags above, `zscp` has a flag to enable recursive copying:\\n\\n\\\\-r, --recursive pass to enable recursive file transfer\\n\\nTo use the recursive flag, you must input a directory into the `LOCAL_FILEPATH` argument. Just like `scp`, `zscp` will copy all file contents under the provided directory. You can see below how we can use the `-r` flag to send all contents of `big_directory`.\\n\\nContents of `big_directory` on local computer:\\n\\ntree local local \u2514\u2500\u2500 big\\\\_directory \u251c\u2500\u2500 1.txt \u251c\u2500\u2500 2.txt \u251c\u2500\u2500 3.txt \u251c\u2500\u2500 small\\\\_directory1 \u2502 \u2514\u2500\u2500 4.txt \u251c\u2500\u2500 small\\\\_directory2 \u2502 \u2514\u2500\u2500 5.txt \u2514\u2500\u2500 small\\\\_directory3 \u2514\u2500\u2500 6.txt\\n\\nHere is the command and output:\\n\\n$ zscp -r big\\\\_directory ubuntu@ziti-tunnel-aws:remote INFO connection to edge router using token d6c268ee-e4f5-4836-bd38-2fc1558257aa INFO sent file: /Users/name/local/big\\\\_directory/1.txt ==&gt; /home/ubuntu/remote/big\\\\_directory/1.txt INFO sent file: /Users/name/local/big\\\\_directory/2.txt ==&gt; /home/ubuntu/remote/big\\\\_directory/2.txt INFO sent file: /Users/name/local/big\\\\_directory/3.txt ==&gt; /home/ubuntu/remote/big\\\\_directory/3.txt INFO sent file: /Users/name/local/big\\\\_directory/small\\\\_directory1/4.txt ==&gt; /home/ubuntu/remote/big\\\\_directory/small\\\\_directory1/4.txt INFO sent file: /Users/name/local/big\\\\_directory/small\\\\_directory2/5.txt ==&gt; /home/ubuntu/remote/big\\\\_directory/small\\\\_directory2/5.txt INFO sent file: /Users/name/local/big\\\\_directory/small\\\\_directory3/6.txt ==&gt; /home/ubuntu/remote/big\\\\_directory/small\\\\_directory3/6.txt\\n\\nAfter `zssh\'ing` to the remote machine, we can prove that all files have been transferred to remote device:\\n\\nubuntu@IP:~$ tree remote/ remote/ \u2514\u2500\u2500 big\\\\_directory \u251c\u2500\u2500 1.txt \u251c\u2500\u2500 2.txt \u251c\u2500\u2500 3.txt \u251c\u2500\u2500 small\\\\_directory1 \u2502 \u2514\u2500\u2500 4.txt \u251c\u2500\u2500 small\\\\_directory2 \u2502 \u2514\u2500\u2500 5.txt \u2514\u2500\u2500 small\\\\_directory3 \u2514\u2500\u2500 6.txt\\n\\nRecursive copying also works to retrieve all contents of a directory on the remote machine.\\n\\n---\\n\\nI hope this post has helped you get familiar with another ziti-empowered developer\'s tool and hopefully it\'s becoming more clear why zitifying your application will make it more resilient to attack and make the act of connecting to remote services trivial.\\n\\nHave a look at the code over at [GitHub](https://github.com/openziti-test-kitchen/zssh/blob/main/zssh/zscp/main.go) or continue reading on to the next zitification - [kubectl](./kubernetes)!"},{"id":"zitifying-ssh","metadata":{"permalink":"/docs/openziti/blog/zitifying-ssh","source":"@site/blog/zitifying-ssh.md","title":"Zitifying SSH","description":"As we learned in the opening post, \\"zitifying\\" an application means to embed a","date":"2021-07-19T17:01:13.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":8.44,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Zitifying SSH","date":"2021-07-19T17:01:13.000Z","cuid":"cl474zpmo02wf82nvgfg5ay8i","slug":"zitifying-ssh","image":"@site/blogs/openziti/v1702472610269/e0723aac-2386-4a55-b6cb-9aad978e36c1.png","imageDark":"@site/blogs/openziti/v1702472610269/e0723aac-2386-4a55-b6cb-9aad978e36c1.png","tags":["security"]},"unlisted":false,"prevItem":{"title":"Zitifying SCP","permalink":"/docs/openziti/blog/zitifying-scp"},"nextItem":{"title":"Zitification","permalink":"/docs/openziti/blog/zitification"}},"content":"As we learned in the [opening post](./zitification.md), \\"zitifying\\" an application means to embed a \\nZiti SDK into an application and leverage the power of a [Ziti Network](https://openziti.io/docs) to provide secure, \\ntruly zero-trust access to your application no matter where in the world that application goes. In this post, we will \\nsee how we have zitified `ssh` and why. Future posts will expand on this even further by showing how NetFoundry \\nuses `zssh` to support our customers.\\n\\n%[https://youtu.be/WyZ8GRvtgGs]\\n\\n\x3c!-- truncate --\x3e\\n\\n---\\n\\n## Why SSH?\\n\\nAs I sit here typing these words, I can tell you\'re skeptical. I can tell you\'re wondering why in the world we would even attempt to mess with `ssh` at all. After all, `ssh` has been a foundation of the administration of not only home networks but also corporate networks and the internet itself. Surely if millions (billions?) of computers can interact every day safely and securely using `ssh` there is \\"no need\\" for us to be spending time zitifying `ssh` right? (Spoiler alert: wrong)\\n\\nI\'m sure you\'ve guessed that this is not the case whatsoever. After all, attackers don\'t leave `ssh` alone just because it\'s not worth it to try! Put a machine on the open internet, expose `ssh` on port 22 and watch for yourself all the attempts to access `ssh` using known default/weak/bad passwords flood in. Attacks don\'t only come from the internet either! Attacks from a single compromised machine on your network very well could behave in the same way as an outside attacker. This is particularly true for ransomware-style attacks as the compromised machine attempts to expand/multiply. The problems don\'t just stop here either. DoS attacks, other zero-day type bugs and more are all waiting for any service sitting on the open internet.\\n\\nA zitified `ssh` client is superior since the port used by `ssh` can be eliminated from the internet-based firewall preventing any connections whatsoever from any network client. In this configuration the `ssh` process is effectively \\"  \\ndark\\". The only way to `ssh` to a machine configured in this way is to have an identity authorized for that [Ziti Network](https://openziti.github.io/ziti/overview.html#overview-of-a-ziti-network).\\n\\nIt doesn\'t stop there though. A Ziti Network mandates the use of a strong identity. You cannot access any services defined in a [Ziti Network](https://openziti.io/docs) without having gone through the enrollment process to create a strong identity used for bidirectional authentication and authorization. With Ziti, you can\'t even connect to SSH without first being authorized to connect to the remote SSH server.\\n\\nContrast that to SSH. With SSH you need access the sshd port before starting the authentication process. This requires the port to be exposed to the network, exposing it to attack. With SSH you are also usually allowed to authenticate without providing a strong identity using a username and password. Even if you are choosing to use the more secure pub/private key authentication for SSH, the remote machine still needed the public key added to the authorized\\\\_keys file before allowing connections to it via SSH. This is all-too-often a step which a human will do, making the process of authorizing a user or revoking access relatively cumbersome. Ziti provides a secure, centralized location to manage authorization of users to services. Ziti makes it trivial to grant or revoke access to a given set of services to users immediately.\\n\\nLastly, Ziti provides support for continual authorization through the use of policy checks. These policy checks run continuously. If a user suddenly fails to meet a particular policy, access to the services provided via the [Ziti Network](https://openziti.io/docs) are revoked immediately.\\n\\nCool right? Let\'s see how we did it and how you can do the same thing using a [Ziti Network](https://openziti.io/docs).\\n\\n#### Overview of SSH - notice how port 22 is open to inbound connections:\\n\\n![](/blogs/openziti/v1715775317970/ef9d66ab-193b-4768-81e1-f6bd1915cbcc.png)\\n\\n---\\n\\n## How It\'s Done\\n\\nThere are a few steps necessary before being able to use `zssh`:\\n\\n* Establish a [Ziti Network](https://openziti.io/docs/learn/quickstarts/network/hosted)\\n    \\n* Create and enroll two Ziti Endpoints (one for our `ssh` server, one for the client)\\n    \\n    * the `sshd` server will run `ziti-tunnel` for this demonstration. Conveniently it will run on the same machine I used to setup the [Ziti Network](https://openziti.io/docs).\\n        \\n    * the client will run `zssh` from my local machine, and I\'ll `zssh` to the other endpoint\\n        \\n* Create the [Ziti Service](https://openziti.io/docs/learn/core-concepts/services/overview) we\'ll use and authorize the two endpoints to use this service\\n    \\n* Use the `zssh` binary from the client side and the `ziti-tunnel` binary from the serving side to connect\\n    \\n* Harden `sshd` further by removing port 22 from any internet-based firewall configuration (for example, from within the security-groups wizard in AWS) or by forcing `sshd` to only listen on `localhost/127.0.0.1`\\n    \\n\\n#### Overview of ZSSH - notice port 22 is no longer open to inbound connections:\\n\\n![](/blogs/openziti/v1715775306181/b102647e-44cb-4dc1-841f-50ec7ca14d2b.png)\\n\\nAfter performing these steps you\'ll have an `sshd` server that is dark to the internet. Accessing the server via `ssh`  \\nmust now occur using the Ziti Network. Since the service is no longer accessible directly through a network, it is no longer susceptible to the attacks mentioned previously!\\n\\n---\\n\\n## Zssh in Action\\n\\nOnce the prerequisites are satisfied, we can see `zssh` in action. Download the binary for your platform:\\n\\n* [Linux](https://github.com/openziti-incubator/zssh/releases/latest/download/zssh-linux-amd64)\\n    \\n* [Windows](https://github.com/openziti-incubator/zssh/releases/latest/download/zssh-windows-amd64.exe)\\n    \\n* [MacOs](https://github.com/openziti-incubator/zssh/releases/latest/download/zssh-macos-amd64)\\n    \\n\\nOnce you have the executable download, make sure it is named `zssh` and for simplicity\'s sake we\'ll assume it\'s on the path. A goal for `zssh` is to make the usage of the command very similar to the usage of `ssh`. Anyone familiar with `ssh` should be able to pick up `zssh` easily. As with most tooling, executing the binary with no arguments will display the expected usage. The general format when using `zssh` will be similar to that of `ssh`: `zssh <remoteUsername>@<targetIdentity>`\\n\\nBelow you can see me `zssh` from my local machine to the AWS machine secured by `ziti-tunnel`:\\n\\n./zssh ubuntu@ziti-tunnel-aws INFO\\\\[0000\\\\] connection to edge router using token 95c45123-9415-49d6-930a-275ada9ae06f connected. ubuntu@ip-172-31-27-154:~$\\n\\nIt really was that simple! Now let\'s break down the current flags for `zssh` and exactly how this worked.\\n\\n---\\n\\n## Zssh Flags\\n\\nWe know that `zssh` requires access to a [Ziti Network](https://openziti.io/docs) but it is not clear from the example above is where `zssh`  \\nfound the credentials required to access the network. `zssh` supports three basic flags:\\n\\n\\\\-i, --SshKeyPath string Path to ssh key. default: $HOME/.ssh/id\\\\_rsa -c, --ZConfig string Path to ziti config file. default: $HOME/.ziti/zssh.json -d, --debug pass to enable additional debug information -h, --help help for this command -s, --service string service name. default: zssh (default \\"zssh\\")\\n\\nWhat you see above is exactly the output `zssh` provides should you pass the `-h/--help` flag or execute `zssh` without any parameters. The `-i/--SshKeyPath` flag is congruent to the `-i` flag for `ssh`. You would use it to supply your key to the `ssh` client. Under the hood of `zssh` is a full-fledged `ssh` client that works similarly to how `ssh` does. If your `~/.ssh/id_rsa` file is in the `authorized_keys` of the remote machine, then you won\'t need to specify the `-i/`  \\nflag (as I didn\'t in my example). Using `zssh` requires the use of a public/private key in order for the `zssh` client to connect to the remote machine.\\n\\nThe `-c/--ZConfig` flag controls access to the network. A configuration file must be supplied to use `zssh` but does not need to be supplied as part of the command. By default, `zssh` will look at your home directory in a folder named `.ziti` for a file named `zssh.json`. In bash this is would be the equivalent of `$HOME`. In Windows this is the equivalent the environment variable named `USERPROFILE`. You do not need to supply this flag if a file exists at the default location. You can specify this flag to use `zssh` with other networks.\\n\\nThe `-s/--service` flag is for passing in a different service name other than \\"zssh\\". By defualt, the service name will be \\"zssh\\", but if you would like to access a different service use the `-s` flag followed by the service name.\\n\\nThe `-d/--debug` flag outputs additional information to assist you with debugging. For example:\\n\\n$ ./zssh ubuntu@ziti-tunnel-aws -d INFO\\\\[0000\\\\] sshKeyPath set to: /home/myUser/.ssh/id\\\\_rsa INFO\\\\[0000\\\\] ZConfig set to: /home/myUser/.ziti/zssh.json INFO\\\\[0000\\\\] username set to: ubuntu INFO\\\\[0000\\\\] targetIdentity set to: ziti-tunnel-aws INFO\\\\[0000\\\\] connection to edge router using token 95c45123-a234-412e-8997-96139fbd1938 connected. ubuntu@ip-172-31-27-154:~$\\n\\nShown above is also one additional piece of information, the remote username. Shown in the example above I have `zssh`ed to an ubuntu image in AWS. When it was provisioned AWS used the username `ubuntu`. In order to `zssh` to this machine I need to tell the remote `sshd` server that I wish to attach as the `ubuntu` user. If your username is the same for your local environment as the remote machine you do not need to specify the username. For example, my local username is `cd` (my initials). When I `zssh` to my dev machine I can simply use `zssh ClintLinux`:\\n\\n$ ./zssh ClintLinux INFO\\\\[0000\\\\] connection to edge router using token 909dfb4f-fa83-4f73-af8e-ed251bcd30be connected. cd@clint-linux-vm ~\\n\\nHopefully this post has been helpful and insightful. Zitifying an application is *POWERFUL*!!!!\\n\\nThe next post in this series will cover how we extended the same code we used for `zssh` and [zitified scp](./zitifying-scp).\\n\\nHave a look at the code over at [GitHub](https://github.com/openziti-test-kitchen/zssh/blob/main/zssh/zssh/main.go)"},{"id":"zitification","metadata":{"permalink":"/docs/openziti/blog/zitification","source":"@site/blog/zitification.md","title":"Zitification","description":"\\"Zitification\\" or \\"zitifying\\" is the act of taking an application and incorporating a Ziti SDK into that application. Once an","date":"2021-07-19T15:01:35.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"}],"readingTime":1.24,"hasTruncateMarker":true,"authors":[{"name":"Clint Dovholuk","title":"Author","url":"https://github.com/dovholuknf","imageURL":"https://avatars.githubusercontent.com/dovholuknf","key":"ClintDovholuk","page":null}],"frontMatter":{"title":"Zitification","date":"2021-07-19T15:01:35.000Z","cuid":"cl474tt6y02vs82nvanu32thu","slug":"zitification","authors":["ClintDovholuk"],"image":"@site/blogs/openziti/v1654785931484/SGu2ETR_s.jpeg","imageDark":"@site/blogs/openziti/v1654785931484/SGu2ETR_s.jpeg","tags":["security"]},"unlisted":false,"prevItem":{"title":"Zitifying SSH","permalink":"/docs/openziti/blog/zitifying-ssh"},"nextItem":{"title":"Mobile Point of Sale (mPOS) app \u2013 embed zero trust networking","permalink":"/docs/openziti/blog/mobile-point-of-sale-mpos-app-ziti-android-java-sdk-integration"}},"content":"\\"Zitification\\" or \\"zitifying\\" is the act of taking an application and incorporating a Ziti SDK into that application. Once an  \\napplication has a Ziti SDK incorporated into it, that application can now access network resources securely from anywhere in  \\nthe world provided that the computer has internet access: NO VPN NEEDED, NO ADDITIONAL SOFTWARE NEEDED.\\n\\n\x3c!-- truncate --\x3e\\n\\nIntegrating a Ziti SDK into your application and enrolling the application itself into a Ziti Network provides you with_  \\ntremendous_ additional security. An application using a [Ziti Network](https://openziti.github.io/docs/introduction/intro/) configured with a truly zero-trust mindset will be  \\n**IMMUNE** to the \\"expand/multiply\\" phases of classic [ransomware attacks](https://netfoundry.io/ztna-ransomware/). As recent events have shown, it\'s probably not  \\na case of if your application will be attacked, but when.\\n\\nIn these posts we\'re going to explore how common applications can be \\"zitified\\". The first application we are going to focus  \\non will be `ssh` and it\'s corollary `scp`. At first, you might think, \\"why even bother\\" zitifying (of all things) `ssh`  \\nand `scp`? These applications are vital to system administration, and we have been using `ssh` and  \\n`scp` \\"safely\\" on the internet for years. Hopefully you\'re now interested enough to find out in the first post:  \\n[zitifying ssh](./zitifying-ssh.md)\\n\\nIf you\'d prefer to read about other zitifications, a running list of zitified apps will be updated below:\\n\\n*   [ssh->zssh](./zitifying-ssh.md)\\n*   [scp->zscp](./zitifying-scp.md)\\n*   [Kubernetes cluster manager - kubectl](./tunneling-ingress-to-kubernetes-workloads.md)"},{"id":"mobile-point-of-sale-mpos-app-ziti-android-java-sdk-integration","metadata":{"permalink":"/docs/openziti/blog/mobile-point-of-sale-mpos-app-ziti-android-java-sdk-integration","source":"@site/blog/mobile-point-of-sale-mpos-app-ziti-android-java-sdk-integration.md","title":"Mobile Point of Sale (mPOS) app \u2013 embed zero trust networking","description":"Mobile Point of Sale (mPOS) app \u2013 embed zero trust networking","date":"2020-03-19T00:00:00.000Z","tags":[{"inline":false,"label":"Mobile","permalink":"/docs/openziti/blog/tags/mobile","description":"Mobile application development and usage"},{"inline":false,"label":"Zero Trust","permalink":"/docs/openziti/blog/tags/zero-trust","description":"Zero Trust Security"},{"inline":false,"label":"Android","permalink":"/docs/openziti/blog/tags/android","description":"Android development and integrations"},{"inline":false,"label":"Java","permalink":"/docs/openziti/blog/tags/java","description":"Java content"},{"inline":false,"label":"SDK","permalink":"/docs/openziti/blog/tags/sdk","description":"Software Development Kits"}],"readingTime":4.04,"hasTruncateMarker":true,"authors":[{"name":"Curt Tudor","title":"Author","url":"https://github.com/rentallect","imageURL":"https://avatars.githubusercontent.com/rentallect","key":"CurtTudor","page":null}],"frontMatter":{"slug":"mobile-point-of-sale-mpos-app-ziti-android-java-sdk-integration","title":"Mobile Point of Sale (mPOS) app \u2013 embed zero trust networking","authors":["CurtTudor"],"date":"2020-03-19T00:00:00.000Z","tags":["mobile","zero-trust","android","java","sdk"]},"unlisted":false,"prevItem":{"title":"Zitification","permalink":"/docs/openziti/blog/zitification"}},"content":"## Mobile Point of Sale (mPOS) app \u2013 embed zero trust networking\\n\\n_Written with Sagarkumar S of Enlume Technologies_\\n\\nPoint of sale application developers and solution providers need to provide secure, reliable applications to retailers.\xa0 However, retailers need to create duplicate networks with extra hardware and configuration to separate their point of sale (POS) data for PCI compliance.\xa0 **Now, there is a better way.\xa0 Use the simple Ziti SDKs to embed zero trust networking, inside the POS app, so that the POS app is secure on any network - micro-segmented and zero trust.**\\n\\n\x3c!-- truncate --\x3e\\n\\nThis blog summarizes use of the Ziti SDK in a mobile point of sale application (mPOS) that is based on Java and built specifically for Android tablets and phones.\xa0 Ziti SDKs can also be used for Apple iOS, Mac, Windows and Linux environments.\\n\\nThis is a relatively simple mPOS application with the front-end mobile application written in Java.\xa0 The backend application features a mongo DB cluster that is used as a repository of merchant transactions. The application server side can also use the Ziti zero trust, cloud native networking for simple, secure integrations with banking providers (not in scope for this post).\\n\\n![](/blogs/openziti/v1653224174107/oS2wUTgbT.png)\\n\\nThe basic use of the mPOS solution:\\n\\n1\\\\. Merchant initiates a sale transaction (pull mode) with customer phone number to send an OTP.\\n\\n2.Customer receives the OTP number and enters in mPOS app to complete the transaction.\\n\\n3.The transaction summary is updated in the mPOS app\\n\\n4.Dashboard on application server records the transaction into mongo DB\\n\\nTechnologies used:\\n\\n*   Mobile Apps Front end (mPOS for Merchant)\\n*   Java SDKs and Android app\\n*   Server side for Mobile\\n*   Node JS\\n*   MongoDB\\n*   Dashboard on Transactions\\n*   Angular 6\\n*   Ziti SDK\\n\\n_Prerequisite_ : Read the [Quickstart guide](https://netfoundry.github.io/ziti-doc/ziti/quickstarts/quickstart-overview.html) and have access to the Ziti virtual gateway deployed in your cloud environment (pre-built versions in GCP, AWS and Azure marketplaces, with images available for other platforms).\\n\\n### Configuring Ziti zero trust networking for mPOS\\n\\n#### Configure a zero trust service in minutes\\n\\nIn simple terms, this is how you tell Ziti where your backend server is located\\n\\nName - _Name of your Service_\\n\\nZiti Router - _the last Ziti Router traffic will be sent to select default_\\n\\nIntercepting Host and Port - what DNS name or IP you wish to use Ziti to optimize Eg : **backend-server**\\n\\nEndpoint Service -\xa0\\n\\n*   Protocol : If you are consuming rest API, select TCP\\n*   Host : Provide your backend server IP address\xa0\\n*   Port : Provide the port on which your server is running\\n\\nCluster - select the default\\n\\nIdentity - Leave as it is\\n\\nSample reference configuration:\\n\\n![](/blogs/openziti/v1653224176290/BCbr4KcjC.png)\\n\\n### Create Identity\\n\\nThis is for secure authentication between your Ziti network and your mPOS or other application.\xa0\\n\\n*   Create a new identity from Ziti admin console (web)\\n    *   Name - Name of identity Eg ;\xa0 Device1\\n    *   Identity Type - Device\\n*   Leave the rest of the fields as it is\\n*   Download the token from the list of identities. This is a JWT token which we will use later to securely enroll with our Ziti network.\\n\\n### Configure AppWANs\\n\\nThis is policy based management of authorization between your seucre identities and your Ziti Services - determines which devices or users you want to authorize to use which services, in a least privileged access architecture.\\n\\n*   Create a new AppWAN from Ziti web console\\n*   Link the identity and service configured earlier\\n\\n### Integrate SDK in Android App\\n\\nBuildscript \u2192 repositories\\n```\\nmavenCentral()\\n\\nmaven \\\\{ url =\xa0**\\"https://netfoundry.jfrog.io/netfoundry/ziti-maven\\"**\xa0\xa0\\\\}\\n```\\n\\n### Add Ziti Dependency\\n\\nIn your Android studio,\xa0 project-level build.gradle file add ziti repositories as follows :\\n\\n```\\nBuildscript \u2192 repositories\\nmavenCentral()\\nmaven { url = \\"https://netfoundry.jfrog.io/netfoundry/ziti-maven\\"  }\\n\\nAllprojects  \u2192 repositories\\nmavenCentral()\\nmaven { url = \\"https://netfoundry.jfrog.io/netfoundry/ziti-maven\\"  }\\n```\\n\\nAdd dependency in module level build.gradle file as follows :\\n\\n    dependencies\\n    implementation \\"io.netfoundry.ziti:ziti:0.+\\"\\n\\n### Initialize Ziti\\n\\nZiti should be initialized when you launch your app so place the following code appropriate to your project.\\n\\n```\\n    private KeyStore ks;\\n    \\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n       ks = KeyStore.getInstance(\\"AndroidKeyStore\\");\\n       ks.load(null);\\n       // Initialize Ziti\\n       Ziti.init(ks, true);\\n\\n```\\n\\nZiti Init returns List `<ZitiContext>` \xa0Object\xa0 so if the list is empty it means that device is not enrolled to Ziti network.\\n\\n### Enroll Identity\\n\\nTo enroll application you need to call the following method :\\n\\nZiti._enroll_(**ks**, jwt, name);\\n\\n*   Ks is the keystore.\xa0\\n*   Jwt is the token we obtained from the downloaded file from identity\xa0\\n*   name is the name of the android device.\\n\\nReferring to the Service in the mobile app:\xa0\\n\\nNow that the device is enrolled and Ziti initialized, you can refer to the application service via Ziti service name using the service host name configured earlier - [**http://backend-server/api**](http://backend-server/api)\\n\\n**That\'s it! We have successfully embedded zero trust networking inside our point of sale app.\xa0 Now it will be secure on any device and any network.**\\n\\nGithub source code repo: [https://github.com/netfoundry/ziti-demos-mpos](https://github.com/netfoundry/ziti-demos-mpos)"}]}}')}}]);