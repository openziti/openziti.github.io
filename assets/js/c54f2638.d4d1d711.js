"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[12392],{60107:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var i=n(41152),s=n(74848),r=n(28453);const o={title:"zrok with the Power of Caddy",date:new Date("2023-09-08T15:24:23.000Z"),cuid:"clmaqzvmg000808l2b8ij7yw8",slug:"zrok-with-the-power-of-caddy",authors:["MichaelQuigley"],image:"@site/blogs/openziti/v1694020472308/0ab25cb6-f4ef-4227-b487-5bc6a0b5c621.png",imageDark:"@site/blogs/openziti/v1694020472308/0ab25cb6-f4ef-4227-b487-5bc6a0b5c621.png",tags:["security","networking","peer-to-peer","openziti","zrok"]},a="The Open-ended Caddyfile",d={authorsImageUrls:[void 0]},c=[{value:"Multiple Upstream Backends",id:"multiple-upstream-backends",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{LiteYouTubeEmbed:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteYouTubeEmbed",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["It's that time again... we've just dropped a new ",(0,s.jsx)(t.code,{children:"zrok"})," release! This time the marquee features are based on\nCaddy (",(0,s.jsx)(t.a,{href:"https://caddyserver.com/",children:"https://caddyserver.com/"}),"). Caddy is a powerful Swiss Army Knife for serving and proxying HTTP resources,\nand we've integrated that power into the ",(0,s.jsx)(t.code,{children:"zrok"})," ecosystem."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"zrok"})," provides a new ",(0,s.jsx)(t.code,{children:"caddy"})," backend mode, which allows you to utilize the full capabilities of Caddy in the ",(0,s.jsx)(t.code,{children:"zrok"})," environment. This power is exposed through a Caddy feature called a ",(0,s.jsx)(t.code,{children:"Caddyfile"}),". A ",(0,s.jsx)(t.code,{children:"Caddyfile"})," is an expressive, powerful mechanism for configuring the different features available in Caddy."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's look at an example of a ",(0,s.jsx)(t.code,{children:"Caddyfile"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-apache",children:"http:// {\n\tbind {{ .ZrokBindAddress }}\n\treverse_proxy 127.0.0.1:3000\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This example ",(0,s.jsx)(t.code,{children:"Caddyfile"})," provides a simple reverse proxy implementation that works very much like the ",(0,s.jsx)(t.code,{children:"proxy"})," backend mode. ",(0,s.jsx)(t.code,{children:"zrok"})," will automatically rewrite the ",(0,s.jsx)(t.code,{children:"{{ .ZrokBindAddress }}"})," token in the ",(0,s.jsx)(t.code,{children:"bind"})," statement with the correct address for your share. This happens automatically when ",(0,s.jsx)(t.code,{children:"zrok"})," loads the ",(0,s.jsx)(t.code,{children:"Caddyfile"})," you specify as the target for the ",(0,s.jsx)(t.code,{children:"caddy"})," backend mode."]}),"\n",(0,s.jsxs)(t.p,{children:["This example ",(0,s.jsx)(t.code,{children:"Caddyfile"})," is located at ",(0,s.jsx)(t.code,{children:"etc/caddy/simple_reverse_proxy.Caddyfile"})," in the ",(0,s.jsx)(t.code,{children:"zrok"})," repository on GitHub (",(0,s.jsx)(t.a,{href:"https://github.com/openziti/zrok",children:"https://github.com/openziti/zrok"}),"). We can run this example from an enabled ",(0,s.jsx)(t.code,{children:"zrok"})," environment like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-plaintext",children:'\n$ zrok share public --backend-mode caddy etc/caddy/simple_reverse_proxy.Caddyfile \n[   0.069]    INFO main.(*sharePublicCommand).run: access your zrok share at the following endpoints:\n https://3s9fddkilbi6.share.zrok.io\n2023/09/06 18:12:43.582\tINFO\tadmin\tadmin endpoint started\t{"address": "localhost:2019", "enforce_origin": false, "origins": ["//localhost:2019", "//[::1]:2019", "//127.0.0.1:2019"]}\n2023/09/06 18:12:43.583\tWARN\thttp.auto_https\tserver is listening only on the HTTP port, so no automatic HTTPS will be applied to this server\t{"server_name": "srv0", "http_port": 80}\n2023/09/06 18:12:43.583\tINFO\ttls.cache.maintenance\tstarted background certificate maintenance\t{"cache": "0xc000166c00"}\n2023/09/06 18:12:43.584\tINFO\ttls\tcleaning storage unit\t{"description": "FileStorage:/home/michael/.local/share/caddy"}\n2023/09/06 18:12:43.584\tINFO\ttls\tfinished cleaning storage units\n2023/09/06 18:12:43.636\tINFO\thttp.log\tserver running\t{"name": "srv0", "protocols": ["h1", "h2", "h3"]}\n2023/09/06 18:12:43.636\tINFO\tautosaved config (load with --resume flag)\t{"file": "/home/michael/.config/caddy/autosave.json"}\n[   0.127]    INFO sdk-golang/ziti.(*listenerManager).createSessionWithBackoff: {session token=[2a9ca2d1-21c2-4516-8b03-ffdd789283e6]} new service session\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Notice that we've used ",(0,s.jsx)(t.code,{children:"--backend-mode caddy"})," and the target of our share is the path to our ",(0,s.jsx)(t.code,{children:"Caddyfile"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"zrok"})," logs the ephemeral share URL: ",(0,s.jsx)(t.code,{children:"https://3s9fddkilbi6.share.zrok.io"})]}),"\n",(0,s.jsxs)(t.p,{children:["If we access the URL with ",(0,s.jsx)(t.code,{children:"curl"}),", we get the following result:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"$ curl https://3s9fddkilbi6.share.zrok.io\nInvalid Host header\n"})}),"\n",(0,s.jsxs)(t.p,{children:['In my environment, the "upstream" target specified in the ',(0,s.jsx)(t.code,{children:"Caddyfile"})," is ",(0,s.jsx)(t.code,{children:"127.0.0.1:3000"}),", which corresponds to my local ",(0,s.jsx)(t.code,{children:"npm"})," development server. Evidently this ",(0,s.jsx)(t.code,{children:"npm"})," development server does not like to have a reverse proxy in front of it. If we rewrite the ",(0,s.jsx)(t.code,{children:"Host"})," header hiding the fact that it's being proxied, we might get a different result."]}),"\n",(0,s.jsxs)(t.p,{children:["Caddy supports a ",(0,s.jsx)(t.code,{children:"header_up"})," directive nested within the ",(0,s.jsx)(t.code,{children:"reverse_proxy"}),' statement, which allows for "upstream" (traffic on its way to the proxied "backend") header rewriting. Let\'s try setting the ',(0,s.jsx)(t.code,{children:"Host"})," header to make it look like the server is being accessed from ",(0,s.jsx)(t.code,{children:"localhost:3000"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-apache",children:"http:// {\n\tbind {{ .ZrokBindAddress }}\n\treverse_proxy 127.0.0.1:3000 {\n\t    header_up Host localhost:3000\n\t}\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If we restart our share and ",(0,s.jsx)(t.code,{children:"curl"})," the new URL, we get:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-plaintext",children:'$ curl http://e52lx23k7qgq.share.zrok.io\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <meta name="theme-color" content="#000000" />\n    <meta name="description" content="zrok ui"/>\n...\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This works! Now the ",(0,s.jsx)(t.code,{children:"npm"})," development server thinks it's being accessed from ",(0,s.jsx)(t.code,{children:"localhost:3000"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Header rewriting is the first Caddy capability we've added that goes beyond the built-in ",(0,s.jsx)(t.code,{children:"--backend-mode proxy"})," in ",(0,s.jsx)(t.code,{children:"zrok"}),". But there are tons and tons of other things we can do with the ",(0,s.jsx)(t.code,{children:"caddy"})," backend mode."]}),"\n",(0,s.jsx)(t.p,{children:"Let's look at a more complex example..."}),"\n",(0,s.jsx)(t.h2,{id:"multiple-upstream-backends",children:"Multiple Upstream Backends"}),"\n",(0,s.jsxs)(t.p,{children:["There are many reasons why you might want to utilize multiple upstream backends with a ",(0,s.jsx)(t.code,{children:"zrok"})," share. You might want:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"to distribute load across multiple backends, horizontally scaling the workload between multiple systems"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"to aggregate multiple microservice backends into a single combined API"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"to enforce additional security or performance constraints on the shared resources"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"to provide fault tolerance, allowing one or more backends to fail before the shared service becomes unavailable"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Let's take a look at a simple example using the ",(0,s.jsx)(t.code,{children:"caddy"})," backend mode to route traffic to two different backends:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-apache",children:"http:// {\n    # Bind to the zrok share\n\tbind {{ .ZrokBindAddress }}\n\n    # Handle paths starting with `/zrok/*`\n    # This will also strip the `/zrok/` from the path before sending to the backend\n\thandle_path /zrok/* {\n\t    reverse_proxy https://zrok.io {\n\t        header_up Host zrok.io\n\t    }\n\t}\n\n\t# All other traffic goes to localhost:3000\n\treverse_proxy /* 127.0.0.1:3000 {\n\t\theader_up Host localhost:3000\n\t}\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Just like the first example, we bind our configuration to ",(0,s.jsx)(t.code,{children:"{{ .ZrokBindAddress }}"}),". But in this case, we've added a second ",(0,s.jsx)(t.code,{children:"reverse_proxy"})," statement. The new ",(0,s.jsx)(t.code,{children:"reverse_proxy"})," statement is wrapped in a ",(0,s.jsx)(t.code,{children:"handle_path"})," block. Wrapping the ",(0,s.jsx)(t.code,{children:"reverse_proxy"})," statement with the ",(0,s.jsx)(t.code,{children:"handle_path"})," causes Caddy to strip the ",(0,s.jsx)(t.code,{children:"/zrok"})," path prefix before sending the request upstream to the backend. And like before, we're replacing the ",(0,s.jsx)(t.code,{children:"Host"})," header to direct the traffic to the correct website instance (",(0,s.jsx)(t.code,{children:"zrok.io"}),")."]}),"\n",(0,s.jsxs)(t.p,{children:["We've qualified the existing ",(0,s.jsx)(t.code,{children:"reverse_proxy"})," statement with ",(0,s.jsx)(t.code,{children:"/*"})," to direct all other traffic to the backend at ",(0,s.jsx)(t.code,{children:"localhost:3000"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's see what happens when we send some traffic to this new Caddyfile. We'll share it using ",(0,s.jsx)(t.code,{children:"zrok share"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-plaintext",children:'$ zrok share public --backend-mode caddy etc/caddy/multiple_upstream.Caddyfile \n[   0.296] WARNING zrok/endpoints/proxy.NewCaddyfileBackend: etc/caddy/multiple_upstream.Caddyfile [4] (): Caddyfile input is not formatted; run \'caddy fmt --overwrite\' to fix inconsistencies\n[   0.296]    INFO main.(*sharePublicCommand).run: access your zrok share at the following endpoints:\n https://u7cncngzhohb.share.zrok.io\n2023/09/07 18:10:20.324\tINFO\tadmin\tadmin endpoint started\t{"address": "localhost:2019", "enforce_origin": false, "origins": ["//localhost:2019", "//[::1]:2019", "//127.0.0.1:2019"]}\n2023/09/07 18:10:20.324\tWARN\thttp.auto_https\tserver is listening only on the HTTP port, so no automatic HTTPS will be applied to this server\t{"server_name": "srv0", "http_port": 80}\n2023/09/07 18:10:20.325\tINFO\ttls.cache.maintenance\tstarted background certificate maintenance\t{"cache": "0xc0005ff880"}\n2023/09/07 18:10:20.325\tINFO\ttls\tcleaning storage unit\t{"description": "FileStorage:/home/michael/.local/share/caddy"}\n2023/09/07 18:10:20.325\tINFO\ttls\tfinished cleaning storage units\n2023/09/07 18:10:20.549\tINFO\thttp.log\tserver running\t{"name": "srv0", "protocols": ["h1", "h2", "h3"]}\n2023/09/07 18:10:20.550\tINFO\tautosaved config (load with --resume flag)\t{"file": "/home/michael/.config/caddy/autosave.json"}\n[   0.549]    INFO sdk-golang/ziti.(*listenerManager).createSessionWithBackoff: {session token=[c16288b6-401e-4e0c-bacf-1661c5badd59]} new service session\n'})}),"\n",(0,s.jsxs)(t.p,{children:["If we curl our new share URL, ",(0,s.jsx)(t.code,{children:"https://u7cncngzhohb.share.zrok.io"}),", we get this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-plaintext",children:'$ curl https://u7cncngzhohb.share.zrok.io\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <meta name="theme-color" content="#000000" />\n    <meta name="description" content="zrok ui"/>\n    \x3c!--\n      manifest.json provides metadata used when your web app is installed on a\n      user\'s mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n    --\x3e\n...\n'})}),"\n",(0,s.jsxs)(t.p,{children:["And we can see that this is a response from our development ",(0,s.jsx)(t.code,{children:"npm"})," server running on ",(0,s.jsx)(t.code,{children:"localhost:3000"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If we access a path starting with ",(0,s.jsx)(t.code,{children:"/zrok"}),", we get this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-plaintext",children:'$ curl https://u7cncngzhohb.share.zrok.io/zrok/\n<!DOCTYPE html>\n<html lang="en-US">\n<head>\n    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">\n    <meta id="siteViewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">\n    <link rel="profile" href="https://gmpg.org/xfn/11">\n    <meta name=\'robots\' content=\'index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1\' />\n\n\t\x3c!-- This site is optimized with the Yoast SEO plugin v20.12 - https://yoast.com/wordpress/plugins/seo/ --\x3e\n\t<title>Home - zrok</title>\n...\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This is the HTML from the ",(0,s.jsx)(t.code,{children:"zrok.io"})," website."]}),"\n",(0,s.jsxs)(t.p,{children:["Be sure to check out the Caddy ",(0,s.jsx)(t.a,{href:"https://caddyserver.com/docs/caddyfile",children:"reference documentation"})," for even more possibilities for the ",(0,s.jsx)(t.code,{children:"caddy"})," backend mode!"]}),"\n",(0,s.jsx)(t.h1,{id:"improved-web-and-file-sharing",children:"Improved Web and File Sharing"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"zrok"})," provides a ",(0,s.jsx)(t.code,{children:"web"})," backend mode for sharing files. In this mode, ",(0,s.jsx)(t.code,{children:"zrok"})," behaves as if it is a traditional web server hosting static content on a filesystem. You can use this mode to share arbitrary files like documents, or code, or binaries. When sharing a tree of files like this, ",(0,s.jsx)(t.code,{children:"zrok"})," provides a handy user interface to navigate the tree and download files."]}),"\n",(0,s.jsxs)(t.p,{children:["Alternatively, if the tree of files contains ",(0,s.jsx)(t.code,{children:"index.html"})," in any of the folders, the built-in file browser is suppressed, and the ",(0,s.jsx)(t.code,{children:"index.html"})," is returned instead. This mimics the behavior of a traditional web server like Apache or nginx. This means you can use ",(0,s.jsx)(t.code,{children:"--backend-mode web"})," to serve arbitrary directories containing files, and you can also use it to host static websites."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"I"}),"n the new ",(0,s.jsx)(t.code,{children:"v0.4.6"})," release of ",(0,s.jsx)(t.code,{children:"zrok"}),", the ",(0,s.jsx)(t.code,{children:"--backend-mode web"})," sharing mode has been improved to utilize Caddy for this function."]}),"\n",(0,s.jsx)(t.p,{children:"Here's what it looks like:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(90974).A+"",width:"1508",height:"1260"})}),"\n",(0,s.jsxs)(t.p,{children:["Caddy gives ",(0,s.jsx)(t.code,{children:"zrok"})," a much nicer-looking file server experience. Built-in searching. Better MIME types. All together this makes for a much smoother and nicer experience."]}),"\n",(0,s.jsxs)(t.p,{children:['There\'s a longer format "office hours" video dedicated to this new integration with Caddy. Check it out for a more leisurely stroll through these features, along with a little ',(0,s.jsx)(t.code,{children:"zrok"})," debugging:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(i,{id:"zgP9wLSESl4",title:"YouTube video"})}),"\n",(0,s.jsx)(t.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(t.p,{children:["Bringing Caddy into ",(0,s.jsx)(t.code,{children:"zrok"})," is a powerful new capability enabling lots of new sharing features. The new ",(0,s.jsx)(t.code,{children:"web"})," backend mode implementation is just the first of many user experience and quality-of-life improvements we have planned for ",(0,s.jsx)(t.code,{children:"zrok"})," users."]}),"\n",(0,s.jsxs)(t.p,{children:["Before we're done with the Caddy integration, we plan on enhancing the ",(0,s.jsx)(t.code,{children:"zrok access"})," functionality to allow you to use the powerful HTTPS certificate management and request routing capabilities on the frontend side of ",(0,s.jsx)(t.code,{children:"zrok"}),". Imagine aggregating multiple ",(0,s.jsx)(t.code,{children:"zrok"})," shares into a single ",(0,s.jsx)(t.code,{children:"zrok access"})," command with fault-tolerance and failover capabilities!"]}),"\n",(0,s.jsxs)(t.p,{children:['And stay tuned for the new "',(0,s.jsx)(t.code,{children:"zrok"})," Drives\" features. We're pretty excited about the doors that are going to open when it's released!"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},90974:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/b31243c9-c793-4873-9319-506aec9e312b-2edcaf046f424978bfff1fbc7384cc8a.gif"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(96540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}},41152:e=>{e.exports=JSON.parse('{"permalink":"/docs/openziti/blog/zrok-with-the-power-of-caddy","source":"@site/blog/zrok-with-the-power-of-caddy.md","title":"zrok with the Power of Caddy","description":"It\'s that time again... we\'ve just dropped a new zrok release! This time the marquee features are based on","date":"2023-09-08T15:24:23.000Z","tags":[{"inline":false,"label":"Security","permalink":"/docs/openziti/blog/tags/security","description":"Security-related posts"},{"inline":false,"label":"Networking","permalink":"/docs/openziti/blog/tags/networking","description":"Networking related posts"},{"inline":false,"label":"Peer-to-Peer","permalink":"/docs/openziti/blog/tags/peer-to-peer","description":"Peer-to-peer networking"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"zrok","permalink":"/docs/openziti/blog/tags/zrok","description":"zrok related content"}],"readingTime":8.23,"hasTruncateMarker":true,"authors":[{"name":"Michael Quigley","title":"Author","url":"https://github.com/michaelquigley","imageURL":"https://avatars.githubusercontent.com/michaelquigley","key":"MichaelQuigley","page":null}],"frontMatter":{"title":"zrok with the Power of Caddy","date":"2023-09-08T15:24:23.000Z","cuid":"clmaqzvmg000808l2b8ij7yw8","slug":"zrok-with-the-power-of-caddy","authors":["MichaelQuigley"],"image":"@site/blogs/openziti/v1694020472308/0ab25cb6-f4ef-4227-b487-5bc6a0b5c621.png","imageDark":"@site/blogs/openziti/v1694020472308/0ab25cb6-f4ef-4227-b487-5bc6a0b5c621.png","tags":["security","networking","peer-to-peer","openziti","zrok"]},"unlisted":false,"prevItem":{"title":"OpenZiti Zero Trust IoT Wi-Fi Gateway","permalink":"/docs/openziti/blog/openziti-zero-trust-iot-wi-fi-gateway"},"nextItem":{"title":"The zrok SDK","permalink":"/docs/openziti/blog/the-zrok-sdk"}}')}}]);