"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[52152],{83054:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var i=n(90894),o=n(74848),a=n(28453);const s={title:"Using eBPF-TC to securely mangle packets in the kernel, and pass them to my secure networking application",seoDescription:"This article described how I leveraged eBPF-TC to build a Plugin TPROXY IFW to steer traffic to my target application.",date:new Date("2022-11-09T22:10:42.000Z"),cuid:"claa73b5k000509l012jsa3ic",slug:"using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application",authors:["RobertCaamano"],image:"@site/blogs/openziti/v1668008121762/C4XmMYoVT.jpg",imageDark:"@site/blogs/openziti/v1668008121762/C4XmMYoVT.jpg",tags:["opensource","firewall","openziti","ebpf","tc","tproxy"]},r=void 0,p={authorsImageUrls:[void 0]},l=[{value:"Introduction",id:"introduction",level:2},{value:"Project context \u2013 passing packets to OpenZiti endpoints",id:"project-context--passing-packets-to-openziti-endpoints",level:2},{value:"TC-eBPF IFW \u2013 tproxy target entries",id:"tc-ebpf-ifw--tproxy-target-entries",level:2},{value:"TC-eBPF IFW \u2013 insertion and mapping",id:"tc-ebpf-ifw--insertion-and-mapping",level:2},{value:"TC-eBPF \u2013 Stateful Firewall",id:"tc-ebpf--stateful-firewall",level:2},{value:"TC-eBPF IFW \u2013 SSH inbound",id:"tc-ebpf-ifw--ssh-inbound",level:2},{value:"eBPF User Space Integration",id:"ebpf-user-space-integration",level:2},{value:"TC-eBPF IFW \u2013 process and packet flow diagrams",id:"tc-ebpf-ifw--process-and-packet-flow-diagrams",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(t.p,{children:"eBPF enables you to safely run sandboxed programs for functions like security and networking in the OS kernel, without\nchanging kernel source code or loading kernel modules. eBPF-TC specifically has robust packet mangling capability, and\nenables ingress and egress operations, with high performance."}),"\n",(0,o.jsxs)(t.p,{children:["This is how I used TC-eBPF to build a Plugin TPROXY Interception Firewall (IFW) to intercept and deliver packets to my target application - OpenZiti Edge Routers. You can use a similar eBPF-TC implementation to intercept packets to send to your specific observability, security or networking application. The code is here: ",(0,o.jsx)(t.a,{href:"https://github.com/netfoundry/zfw",children:"https://github.com/netfoundry/zfw"}),". Process flow and packet flow diagrams are at the end of this article."]}),"\n",(0,o.jsx)(t.h2,{id:"project-context--passing-packets-to-openziti-endpoints",children:"Project context \u2013 passing packets to OpenZiti endpoints"}),"\n",(0,o.jsx)(t.p,{children:"OpenZiti (open source zero trust networking platform) enables private connections across full mesh Internet overlay networks. Ziti endpoints are embedded in applications as code (via Ziti SDKs), and deployed as OS agents, daemons, containers or VMs. You can spin up any number of Ziti routers in your private mesh - it looks like this if you deploy two routers:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"OpenZiti End to End Encryption Terminating at the Routers",src:n(77693).A+"",width:"2395",height:"453"})}),"\n",(0,o.jsxs)(t.p,{children:["Ziti Edge Routers are often used on Linux and default to iptables to map incoming interesting traffic toward service listening ports using ",(0,o.jsx)(t.a,{href:"https://docs.kernel.org/networking/tproxy.html",children:"IP Table Tproxy Target"}),". This works great if for example you are running Ubuntu and FWD. However, there are many Linux distros with key variances. I therefore used TC-eBPF to build a more universal option for Linux distros which support eBPF, enabling those distros to intercept traffic of interest. The eBPF feature set also enabled additional packet filtering and manipulation not natively supported in iptables/nftables."]}),"\n",(0,o.jsx)(t.h2,{id:"tc-ebpf-ifw--tproxy-target-entries",children:"TC-eBPF IFW \u2013 tproxy target entries"}),"\n",(0,o.jsx)(t.p,{children:"So before diving into building the eBPF IFW I needed to reverse engineer how OpenZiti edge-routers natively translate services into iptables rules - which TPROXY target statements need to be added/deleted based on services the router learned from the OpenZiti Controller. The following is the information used to create the tproxy target entries via iptables."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-plaintext",children:"IP Destination Prefix: Dotted Decimal IP/mask bit-length\nTCP/UDP port range in the format Decimal Low_Port:High_Port\nProtocol: TCP/UDP\nTPROXY Listening port: Decimal port\n"})}),"\n",(0,o.jsx)(t.h2,{id:"tc-ebpf-ifw--insertion-and-mapping",children:"TC-eBPF IFW \u2013 insertion and mapping"}),"\n",(0,o.jsx)(t.p,{children:"So now with this information I could start thinking about the eBPF map types and structures that I would use to communicate between a user space mapping tool and the IFW to dynamically update rules."}),"\n",(0,o.jsx)(t.p,{children:"Since I wanted my program to act function similarly to ufw/iptables I chose TC-eBPF as my insertion point due to the combination of its attachment at the interface level (ability to drop packets before forwarding to the Linux IP stack), and the currently available sk helpers for socket lookup/splicing."}),"\n",(0,o.jsx)(t.p,{children:"In order to check if an incoming packet matches an intercept policy created by a Ziti network administrator (Ziti intercepts specifically defined flows \u2013 doesn\u2019t default to intercepting all flows), I needed a pinned map that supported a struct key type. A a eBPF hash map which allows for struct as a key gave me the flexibility to customize the lookup and add or delete criteria as use cases evolve. Using pinned maps allows multiple copies of the ebpf program to run (One on each inbound interface) and share the map updated by the mapping tool/Ziti."}),"\n",(0,o.jsx)(t.p,{children:"Depicted below is the initial map definition I chose:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-plaintext",children:'struct {\n    __uint(type, BPF_MAP_TYPE_ARRAY);\n    __uint(id, BPF_MAP_ID_IFINDEX_IP);\n    __uint(key_size, sizeof(uint32_t));\n    __uint(value_size, sizeof(struct ifindex_ip4));\n    __uint(max_entries, 50);\n    __uint(pinning, LIBBPF_PIN_BY_NAME);\n} ifindex_ip_map SEC(".maps");\nThe initial key I chose a struct of the following form:\nstruct tproxy_key {\n    __u32 dst_ip;\n    __u16 prefix_len;\n    __u16 protocol;\n} \nThese data structures allow for a lookup based on destination ip prefix, cidr length, and ip protocol(tcp/udp) which can all be decerned from the incoming packet. \nFor value I used a struct of the following format:\nstruct tproxy_tuple {\n   __u16 index_len; /*tracks the number of entries in the index_table*/\n   __u16 index_table[MAX_INDEX_ENTRIES];/* Array used as index table which points to    \nStruct *tproxy_port_mapping in the     \nport_maping array with each poulated\nindex representing a udp or tcp tproxy     \nmapping in the port_mapping\n                                         */\nstruct tproxy_port_mapping port_mapping[MAX_TABLE_SIZE];/* Array to store unique   \ntproxy mappings\nwith each index match   \nthe low_port of the\nstruct  tproxy_port_mapping{\n__u16 low_port;\n__u16 high_port;\n__u16 tproxy_port;\n__u32 tproxy_ip;\n}*/\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"Since OpenZiti IP based service policies can be defined at any level of granularity, including network CIDR blocks, I did not want to have to generate hash entries for every host address in contained in a block. I therefore implemented a longest match lookup algorithm that successively widens the mask checking to see if an incoming IP tuple either directly matches a host address or falls within a CIDR block range that matches the ip_dest / prefix_len fields in the tproxy_key along with matching IP transport protocol (TCP or UDP)."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"struct tproxy_tuple *tproxy\n__u32 exponent=24;  /* unsugend integer used to calulate prefix matches */\n__u32 mask = 0xffffffff;  /* starting mask value used in prefix match calculation */\n__u16 maxlen = 32; /* max number ip ipv4 prefixes */\n \nfor (__u16 count = 0;count <= maxlen; count++){\n    struct tproxy_key key = {(tuple->ipv4.daddr & mask), maxlen-count,protocol}\n    if ((tproxy = get_tproxy(key))){\n            { Redacted for brevity}\n           \n    /*algorithm used to calucate mask while traversing each octet.*/\n    if(mask == 0x00ffffff){\n       exponent=16;\n    }\n    if(mask == 0x0000ffff){\n       exponent=8;\n    }\n    if(mask == 0x000000ff){\n       exponent=0;\n    }\n    if(mask == 0x00000080){\n       return TC_ACT_SHOT;\n    }\n    if((mask >= 0x80ffffff) && (exponent >= 24)){\n       mask = mask - (1 << exponent);\n    }else if((mask >= 0x0080ffff) && (exponent >= 16)){\n       mask = mask - (1 << exponent);\n    }else if((mask >= 0x000080ff) && (exponent >= 8)){\n       mask = mask - (1 << exponent);\n    }else if((mask >= 0x00000080) && (exponent >= 0)){\n       mask = mask - (1 << exponent);\n            }\n    exponent++;\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"Further, since a Ziti end user can associate any number of port ranges to a destination on a per protocol basis, in this first pass I did not want to create an entry in the hash map for every port given the potential for large port ranges i.e 1-65535. Instead, I created an index table in which each entry points to a populated array index in the port_mapping table where the index is the low_port value of the mapped rule. This limits the search for a port match to only populated port range entries vs sequential index searches directly in the port mapping table. I plan to test the performance and resource limitation of creating hash map entries for every member port vs indexed lookup of range start. Below is a code snippet of the lookup used to find a match based on the incoming tuple->ipv4.dport"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"for (int index = 0; index < max_entries; index++) {\n    /* set port_key equal to the port value stored at current Index */\n    int port_key = tproxy->index_table[index];\n    /*\ncheck if tuple destination port is greater than low port and lower than high    \nport at mapping[port_key]\nif matched get associated tproxy port and attempt to find listening socket\nif successfull jump to assign:\n   */\n     if ((bpf_ntohs(tuple->ipv4.dport) >= bpf_ntohs(tproxy->port_mapping[port_key].low_port))\n          && (bpf_ntohs(tuple->ipv4.dport) <=bpf_ntohs(tproxy>port_mapping[port_key].high_port))){               \n          If(local){ /* if tuple->daddr == router\u2019s ip then forward to stack */\n              return TC_ACT_OK;\n         }\n         /* construct tuple to used to lookup TPROXY sk */\n         sockcheck.ipv4.daddr = tproxy->port_mapping[port_key].tproxy_ip;\n         sockcheck.ipv4.dport = tproxy->port_mapping[port_key].tproxy_port;\n         /* look up sk based on protocol in map key */\n         if(protocol == 6){\n              sk = bpf_skc_lookup_tcp(skb, &sockcheck, sizeof(sockcheck.ipv4),\n                 BPF_F_CURRENT_NETNS, 0);\n         }else{\n             sk = bpf_sk_lookup_udp(skb, &sockcheck,  sizeof(sockcheck.ipv4),\n                 BPF_F_CURRENT_NETNS, 0);\n         }  \n         if(!sk){\n             return TC_ACT_SHOT;\n         }  \n         if((protocol == IPPROTO_TCP) && (sk->state != BPF_TCP_LISTEN)){\n             bpf_sk_release(sk);\n             return TC_ACT_SHOT;\n         }\n         goto assign;\n     }\n}\nassign:\n    /*attempt to splice the skb to the tproxy or local socket*/\n    ret = bpf_sk_assign(skb, sk, 0);\n    /*release sk*/\n    if(ret == 0){\n       //if succedded forward to the stack\n       return TC_ACT_OK;\n    }   \n    /*else drop packet if not running on loopback*/\n    if(skb->ingress_ifindex == 1){\n        return TC_ACT_OK;\n    }else{\n        return TC_ACT_SHOT;\n    }\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"tc-ebpf--stateful-firewall",children:"TC-eBPF \u2013 Stateful Firewall"}),"\n",(0,o.jsx)(t.p,{children:"Since I wanted eBPF to perform the functionality of a stateful firewall (At least to the extent that there must be an active outbound session to a host for acknowledged packets to be accepted from that host), I needed to consider how to allow the program to manage session states for both UDP and TCP. I initially thought that this might be complicated. However, while working with the ebpf helpers used to splice sockets together, I realized that the same helpers could be used to check to see if an outgoing sockets had been initiated. In the case that an incoming packet tuple matched an existing outgoing session, splice the incoming skb to the existing sk while performing the same lookup that the program was already performing for the OpenAiti service tproxy sk(s). The following code excerpts shows the basic state inspection code I used for TCP:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"/* if tcp based tuple implement statefull inspection to see if they were\ninitiated by the local OS if not pass on to tproxy logic to determin if the OpenZiti router has tproxy \nintercepts defined for the flow\n */\nsk = bpf_skc_lookup_tcp(skb, tuple, tuple_len,BPF_F_CURRENT_NETNS, 0);\nif(sk){\n  if (sk->state != BPF_TCP_LISTEN){\n     goto assign;\n  }\n  bpf_sk_release(sk);\n}\n\nassign:\n    /*attempt to splice the skb to the tproxy or local socket*/\n    ret = bpf_sk_assign(skb, sk, 0);\n    /*release sk*/\n    if(ret == 0){\n       //if succeeded forward to the stack\n       return TC_ACT_OK;\n    }   \n/*else drop packet if not running on loopback*/\n    if(skb->ingress_ifindex == 1){\n        return TC_ACT_OK;\n    }else{\n        return TC_ACT_SHOT;\n    }\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"tc-ebpf-ifw--ssh-inbound",children:"TC-eBPF IFW \u2013 SSH inbound"}),"\n",(0,o.jsx)(t.p,{children:"Taking things, a step further I wanted to allow ssh inbound by default, but wanted to restrict ssh to only the IP address of the external interface which the eBPF program was attached. However, when running eBPF at the TC level you do not have access to the interface\u2019s IP address. Having this functionality is essential to support ssh services over Ziti when using the standard port since the services would also have a destination port of TCP/22. So, without being able to discern the router\u2019s IP, the program would not know whether to forward to the Linux stack or to Ziti Tproxy service ports. To solve this, I initially allow ssh to pass to any address, and then let my user space zfw app inform eBPF what its attached IP is via a bpf hash map. I did this by having the user space app use the ifindex as the hash map key and then then store the IP address in a struct with the IP Address array as one of its fields. Specifically, the map and structs I created are as follows:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-plaintext",children:'/* hash Map */\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(key_size, sizeof(uint32_t));\n    __uint(value_size, sizeof(struct ifindex_ip4));\n    __uint(max_entries, MAX_IF_ENTRIES);\n    __uint(pinning, LIBBPF_PIN_BY_NAME);\n    __uint(map_flags, BPF_F_NO_PREALLOC);\n} ifindex_ip_map SEC(".maps");\n \n/*value to ifindex_ip_map*/\nstruct ifindex_ip4 {\n    uint32_t ipaddr[MAX_ADDRESSES];\n    char ifname[IFNAMSIZ];\n    uint8_t count;\n};\n \nstatic inline struct ifindex_ip4 *get_local_ip4(__u32 key){\n    struct ifindex_ip4 *ifip4;\n    ifip4 = bpf_map_lookup_elem(&ifindex_ip_map, &key);\n\treturn ifip4;\n}\n \n/*look up attached interface IP address*/\nstruct ifindex_ip4 *local_ip4 = get_local_ip4(skb->ingress_ifindex);\n\n/* if ip of attached interface found in map only allow ssh to that IP */\nif(tcp && (bpf_ntohs(tuple->ipv4.dport) == 22)){\n        if((!local_ip4 || !local_ip4->count)){\n            return TC_ACT_OK;\n        }else{\n            uint8_t addresses = 0; \n            if(local_ip4->count < MAX_ADDRESSES){\n                addresses = local_ip4->count;\n            }else{\n                addresses = MAX_ADDRESSES;\n            }\n            for(int x = 0; x < addresses; x++){\n                if((tuple->ipv4.daddr == local_ip4->ipaddr[x]) && !local_diag->ssh_disable){\n                    if(local_diag->verbose && ((event.tstamp % 2) == 0)){\n                        event.proto = IPPROTO_TCP;\n                        send_event(&event);\n                    }\n                    return TC_ACT_OK;\n                }\n            }\n        }\n  }\n'})}),"\n",(0,o.jsx)(t.p,{children:"UDP follows the same basic premise, but I needed to make an exception specifically for DHCP since it operates in a way that makes state inspection difficult (other stateful FWs like UFW also make the same inbound exception)"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"/* forward DHCP messages to local system */\n    if(udp && (bpf_ntohs(tuple->ipv4.sport) == 67) && (bpf_ntohs(tuple->ipv4.dport) == 68)){\n       return TC_ACT_OK;\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"ebpf-user-space-integration",children:"eBPF User Space Integration"}),"\n",(0,o.jsx)(t.p,{children:"I created a user space app zfw.c which updates the pinned maps described earlier. The zfw populates the ip address / name of the interface with the attached eBPF program and inserts/deletes rules into/ffrom the nf_tproxy_map with the usage following patterns:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"Usage: sudo zfw -I -c <ip dest address or prefix> -m <dst prefix len> -o <ip src address or prefix> -n <src prefix len>  -p tcp -l <dst low port> -h <dst high port> -t <tproxy port> -p <ip protocol>\n\n sudo zfw -I -c 172.16.240.1 -m 32 -o 10.1.1.1 -n 32  -p tcp -l 22 -h 22 -t 0\n \nUsage: sudo zfw -D -c <ip dest address or prefix> -m <dst prefix len> -o <ip src address or prefix> -n <src prefix len>  -p tcp -l <dst low port> -h <dst high port> -t <tproxy port> -p <ip protocol>\n \n sudo zfw -D -c 172.16.240.1 -m 32 -o 10.1.1.1 -n 32  -p tcp -l 22\n"})}),"\n",(0,o.jsx)(t.p,{children:"If you run an OpenZiti Router in diverter mode it will dynamically update the pinned BPF zt_tproxy_map used by the IFW to make forwarding decisions. The system calls are made dynamically whenever changes are made to any service either to add or delete them when running an OpenZiti edge-router in diverter mode."}),"\n",(0,o.jsx)(t.p,{children:"The following shows the logging output from the edge-router running in diverter mode when initially learning services from the Ziti controller. You can see that it makes system calls to the zfw user space program to add the learned services as hash map entries into the bpf map."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'Feb 24 20:21:32 ebpf-router ziti-router[30284]: {"command":"/opt/openziti/bin/zfw -I -c 100.72.0.4 -m 32 -p tcp -l 5985 -h 5985 -t 43321","file":"/home/ziggy/gitnfnew/ziti/tunnel/intercept/tproxy/tproxy_linux.go:546","func":"github.com/openziti/ziti/tunnel/intercept/tproxy.(*tProxy).addInterceptAddr","level":"info","msg":"diverter command succeeded. output: Adding TCP mapping\\n","time":"2024-02-24T20:21:32.420Z"}\nFeb 24 20:21:32 ebpf-router ziti-router[30284]: {"command":"/opt/openziti/bin/zfw -I -c 100.72.0.4 -m 32 -p tcp -l 22 -h 22 -t 43321","file":"/home/ziggy/gitnfnew/ziti/tunnel/intercept/tproxy/tproxy_linux.go:546","func":"github.com/openziti/ziti/tunnel/intercept/tproxy.(*tProxy).addInterceptAddr","level":"info","msg":"diverter command succeeded. output: Adding TCP mapping\\nlookup success\\n","time":"2024-02-24T20:21:32.426Z"}\n'})}),"\n",(0,o.jsx)(t.h2,{id:"tc-ebpf-ifw--process-and-packet-flow-diagrams",children:"TC-eBPF IFW \u2013 process and packet flow diagrams"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"TC-eBPF IFW \u2013 process diagram",src:n(33528).A+"",width:"2198",height:"1950"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"TC-eBPF IFW \u2013 packet flow diagram",src:n(870).A+"",width:"2328",height:"1754"})}),"\n",(0,o.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(t.p,{children:"This article described how I leveraged eBPF-TC to build a Plugin TPROXY IFW to steer traffic to my target application. Hopefully you found the experience that I shared useful. Would love to hear how other eBPF developers are making use of this robust functionality."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},33528:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/6LzUjyxVe-4baeb5ce3e80d68b32c2712bc00cd3e4.jpg"},870:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/DlMW3rsU9-2890255b7ae2425e6f53163307329079.jpg"},77693:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/qJTZ9uPxE-7b244682c8554ae608cf648ab6b87cb1.png"},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},90894:e=>{e.exports=JSON.parse('{"permalink":"/docs/openziti/blog/using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application","source":"@site/blog/using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application.md","title":"Using eBPF-TC to securely mangle packets in the kernel, and pass them to my secure networking application","description":"Introduction","date":"2022-11-09T22:10:42.000Z","tags":[{"inline":false,"label":"Open Source","permalink":"/docs/openziti/blog/tags/opensource","description":"Open Source content"},{"inline":false,"label":"Firewall","permalink":"/docs/openziti/blog/tags/firewall","description":"Firewall technologies"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"eBPF","permalink":"/docs/openziti/blog/tags/ebpf","description":"eBPF tech"},{"inline":false,"label":"tc","permalink":"/docs/openziti/blog/tags/tc","description":"Linux tc"},{"inline":false,"label":"TProxy","permalink":"/docs/openziti/blog/tags/tproxy","description":"Transparent proxy"}],"readingTime":12.09,"hasTruncateMarker":true,"authors":[{"name":"Robert Caamano","title":"Author","url":"https://github.com/r-caamano","imageURL":"https://avatars.githubusercontent.com/r-caamano","key":"RobertCaamano","page":null}],"frontMatter":{"title":"Using eBPF-TC to securely mangle packets in the kernel, and pass them to my secure networking application","seoDescription":"This article described how I leveraged eBPF-TC to build a Plugin TPROXY IFW to steer traffic to my target application.","date":"2022-11-09T22:10:42.000Z","cuid":"claa73b5k000509l012jsa3ic","slug":"using-ebpf-tc-to-securely-mangle-packets-in-the-kernel-and-pass-them-to-my-secure-networking-application","authors":["RobertCaamano"],"image":"@site/blogs/openziti/v1668008121762/C4XmMYoVT.jpg","imageDark":"@site/blogs/openziti/v1668008121762/C4XmMYoVT.jpg","tags":["opensource","firewall","openziti","ebpf","tc","tproxy"]},"unlisted":false,"prevItem":{"title":"NGINX & ZeroTrust API Security","permalink":"/docs/openziti/blog/nginx-zerotrust-api-security"},"nextItem":{"title":"OpenZiti BrowZer Gateway","permalink":"/docs/openziti/blog/browzer-gateway-fqdn-certs"}}')}}]);