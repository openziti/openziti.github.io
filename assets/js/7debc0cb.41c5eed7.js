"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[8121],{93588:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var r=t(75589),i=t(74848),o=t(28453);const a={title:"Golang Aha! Moments: Generics",date:new Date("2022-10-06T17:46:21.000Z"),cuid:"cl8xcodj6000c09mi9gbne8el",slug:"golang-aha-moments-generics",authors:["PaulLorenz"],image:"@site/blogs/openziti/v1663771708776/OXjhFrMmZ.jpg",imageDark:"@site/blogs/openziti/v1663771708776/OXjhFrMmZ.jpg",tags:["golang","developer","generics","openziti","golang-aha"]},s=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Introduction",id:"introduction",level:2},{value:"Generics Overview",id:"generics-overview",level:2},{value:"Copy/Paste Reduction",id:"copypaste-reduction",level:3},{value:"Container Types",id:"container-types",level:3},{value:"Generics Learnings",id:"generics-learnings",level:2},{value:"No Generic Methods",id:"no-generic-methods",level:3},{value:"New Instances of Generic Types",id:"new-instances-of-generic-types",level:3},{value:"Case Study: Command Decoding",id:"case-study-command-decoding",level:3},{value:"Supporting Types Reference",id:"supporting-types-reference",level:4},{value:"Decoder: No Generics",id:"decoder-no-generics",level:4},{value:"Decoder: Generics + Reflection",id:"decoder-generics--reflection",level:4},{value:"Decoder: Pure Generics",id:"decoder-pure-generics",level:4},{value:"Performance",id:"performance",level:5},{value:"Complexity",id:"complexity",level:5},{value:"Generic parameters vs args",id:"generic-parameters-vs-args",level:5},{value:"Case Study: Entity Managers",id:"case-study-entity-managers",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Further Reading/Viewing",id:"further-readingviewing",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{LiteYouTubeEmbed:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteYouTubeEmbed",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["I work with Golang every day as a developer on the ",(0,i.jsx)(n.a,{href:"http://openziti.io",children:"OpenZiti project"}),". In learning Go,\nI've hit various stumbling blocks, settled on some best practices and hopefully gotten better at writing Go code.\nThis series exists to share some of the 'Aha!' moments I've had overcoming obstacles and finding solutions that\nsparked joy."]}),"\n",(0,i.jsxs)(n.p,{children:["This ",(0,i.jsx)(n.a,{href:"./tags/golang-aha",children:"series"})," is targeted both at new team members and for anyone in the Go community who might be interested. I'm very happy to hear from others about their own 'aha'\nmoments and also how the solutions presented strike your sensibilities. Suggested improvements, corrections and constructive criticism are welcome."]}),"\n",(0,i.jsx)(n.p,{children:"This second installment will cover various topics related to Go generics."}),"\n",(0,i.jsx)(n.h2,{id:"generics-overview",children:"Generics Overview"}),"\n",(0,i.jsx)(n.p,{children:"Generics were introduced into the Go language in version 1.18 after years of debate and discussion."}),"\n",(0,i.jsxs)(n.p,{children:["This article assumes you are already familiar with generics from other languages and is not focused on the basics of using generics. Other than a brief overview, it it is focused on shortcomings, workarounds and considerations more specific to Go. For some links to more introductory works, please see the ",(0,i.jsx)(n.a,{href:"./golang-aha-moments-generics#further-readingviewing",children:"further reading"})," section at the end."]}),"\n",(0,i.jsx)(n.p,{children:"The initial release of Go generics seems focused on two things."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Reducing copy/paste code"}),"\n",(0,i.jsx)(n.li,{children:"Better type safety and removing casts for container types"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If you're already familiar with these, feel free to skip ahead to the ",(0,i.jsx)(n.a,{href:"/docs/openziti/blog/golang-aha-moments-generics#generics-learnings",children:"learnings section"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"copypaste-reduction",children:"Copy/Paste Reduction"}),"\n",(0,i.jsxs)(n.p,{children:["For an example of copy/paste reduction, take the classic ",(0,i.jsx)(n.code,{children:"math.Min"})," function. The standard library (as of Go 1.19) only has ",(0,i.jsx)(n.code,{children:"math.Min(x, y float64) float64"}),". If you want to find the minimum of any other types you either need to do some casting or write your own.\nThis is admittedly trivial code to write, but there are likely many implementations scattered across many code bases at this point. With generics you can write the following code"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:'import "golang.org/x/exp/constraints"\n\nfunc Min[T constraints.Ordered](x, y T) T {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["While this code isn't in the standard library yet (and neither is the useful constraints package) it likely will be in a future release. At a minimum, developers now only need to write a single ",(0,i.jsx)(n.code,{children:"Min"})," function now, instead of writing one each time a new type needs to compared."]}),"\n",(0,i.jsx)(n.h3,{id:"container-types",children:"Container Types"}),"\n",(0,i.jsxs)(n.p,{children:["Before generics if you wanted a custom container, such as a b-tree implementation, copy-on-write data structures or some concurrency friendly map, it would generally be implemented in terms of ",(0,i.jsx)(n.code,{children:"interface{}"}),", requiring values to be cast when extracted. An API that looked like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type MyMap interface {\n\tPut(key, value interface{})\n\tGet(key interface{}) (interface{}, bool)\n\tDelete(key interface{}) bool\n\tEach(func (key, value interface{}))\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"can now instead look like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type MyGenericMap[K comparable, V any] interface {\n\tPut(key K, value V)\n\tGet(key K) (V, bool)\n\tDelete(key K) bool\n\tEach(func (key K, value V))\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["OpenZiti has some data structures using generics ",(0,i.jsx)(n.a,{href:"https://github.com/openziti/foundation/blob/main/concurrenz/",children:"in the foundation library"}),", including:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["CopyOnWriteMap - ",(0,i.jsx)(n.a,{href:"https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/copy_on_write_map.go",children:"https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/copy_on_write_map.go"})]}),"\n",(0,i.jsxs)(n.li,{children:["CopyOnWriteSlice - ",(0,i.jsx)(n.a,{href:"https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/copy_on_write_slice.go",children:"https://github.com/openziti/foundation/blob/v2.0.4/concurrenz/copy_on_write_slice.go"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Over time I expect more of these types to be in the standard library."}),"\n",(0,i.jsx)(n.h2,{id:"generics-learnings",children:"Generics Learnings"}),"\n",(0,i.jsx)(n.h3,{id:"no-generic-methods",children:"No Generic Methods"}),"\n",(0,i.jsx)(n.p,{children:"As of Go 1.19, generic functions are supported, but not generic methods (funcs defined on a type)."}),"\n",(0,i.jsx)(n.p,{children:"So for a Tree type, with the given partial implementation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type node[E any] struct {\n\tvalue E\n\tchildren []*node[E]\n}\n\nfunc (self *node[E]) Add(elem E) {\n\tself.children = append(self.children, &node[E]{\n\t\tvalue: elem,\n\t})\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you wanted to define a ",(0,i.jsx)(n.code,{children:"Map"})," method to map a Tree of values from one type to another, you couldn't define a generic method with the following signature:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"// not allowed\nfunc (self *node[E]) Map[T any](f func(E) T) *node[T] { ... }\n"})}),"\n",(0,i.jsx)(n.p,{children:"The workaround is to convert the method into a func. For example, the above method could be rewritten as func:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"// legal version\nfunc Map[E any, T any](self *node[E], f func(E) T) *node[T] { ... }\n"})}),"\n",(0,i.jsx)(n.p,{children:"If you had a tree and wanted map it, you'd have to write:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"var tree *node[string]\nvar result *node[int] := Map(tree, func(s string) { return len(s) })\n\n// instead of \nvar result *node[int] := tree.Map(func(s string) { return len(s) })\n"})}),"\n",(0,i.jsx)(n.p,{children:"While not ideal, it means that this functionality is within reach, even if the syntax is not what I would have preferred."}),"\n",(0,i.jsx)(n.h3,{id:"new-instances-of-generic-types",children:"New Instances of Generic Types"}),"\n",(0,i.jsx)(n.p,{children:"A common need is to be able to return a valid instance of a generic type. In the simplest case you might just need to return some default value to satisfy the method contract. Let's start with the generic Tree implementation we were using above."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type node[E any] struct {\n\tvalue E\n\tchildren []*node[E]\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's add a method to find the first value in the tree matching a given predicate. The basic implementation is straightforward."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"func (self *node[E]) GetFirstMatch(f func(E) bool) (E, bool) {\n\tif f(self.value) {\n\t\treturn self.value, true\n\t}\n\n\tfor _, child := range self.children {\n\t\tif val, found := child.GetFirstMatch(f); found {\n\t\t\treturn val, found\n\t\t}\n\t}\n    // what to return here? \n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["What do we return at the end, if nothing is found? We can't return nil, since E maybe a primitive or non-pointer struct. Fortunately we can just declare a ",(0,i.jsx)(n.code,{children:"var"})," of type ",(0,i.jsx)(n.code,{children:"E"})," and it will be assigned the default value for that type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"func (self *node[E]) GetFirstMatch(f func(E) bool) (E, bool) {\n\tif f(self.value) {\n\t\treturn self.value, true\n\t}\n\n\tfor _, child := range self.children {\n\t\tif val, found := child.GetFirstMatch(f); found {\n\t\t\treturn val, found\n\t\t}\n\t}\n\tvar defaultValue E\n\treturn defaultValue, false\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"There are also some cases where we want to create new instances of structs. This gets a little complicated. Let's use a type factory as an example. This example is not necessarily realistic, but it is concise."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type Example interface {\n\tInit(config map[string]interface{})\n}\n\ntype ExampleFactory[T Example] struct {\n\tconfig map[string]interface{}\n}\n\nfunc (self *ExampleFactory[T]) Get() T {\n\tresult := new(T)\n\tresult.Init(self.config)\n\treturn result\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"When we compile this, we see:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"./scratch_2.go:14:9: result.Init undefined (type *T is pointer to type parameter, not type parameter)\n./scratch_2.go:15:9: cannot use result (variable of type *T) as type T in return statement\n"})}),"\n",(0,i.jsx)(n.p,{children:"In order to resolve this we need two type parameters. One for the underlying type and one for the pointer type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type Example[T any] interface {\n   *T // indicates that Example must be a pointer type\n   Init(config map[string]interface{})\n}\n\ntype ExampleFactory[T any, P Example[T]] struct {\n   config map[string]interface{}\n}\n\nfunc (self *ExampleFactory[T,P]) Get() P {\n   var result P = new(T) // result := new(T) won't work\n   result.Init(self.config)\n   return result\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Example"})," interface now has a type parameter. That type parameter is used to indicate that the interface must be implemented by a pointer type. We also need to include both types on the factory. Otherwise, when we call ",(0,i.jsx)(n.code,{children:"new"}),", we don't have the correct type to call it with."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, ",(0,i.jsx)(n.code,{children:"result := new(T)"})," doesn't work due to apparent limitations in the type inferencing, the explicit type must be provided."]}),"\n",(0,i.jsx)(n.h3,{id:"case-study-command-decoding",children:"Case Study: Command Decoding"}),"\n",(0,i.jsx)(n.p,{children:"To pull some of these threads together, I thought it would be useful to look at a place where we introduced generics, in an attempt to reduce boilerplate."}),"\n",(0,i.jsxs)(n.p,{children:["Our software has two main server side components: controllers and routers. While you can run any number of routers to form a network mesh, up till now you've only been able to run a single controller. We're working on allowing the controller to be run in a cluster for better availability and performance. Part of that work has been moving most of our model into Raft (using the excellent ",(0,i.jsx)(n.a,{href:"https://github.com/hashicorp/raft/",children:"Raft library"})," from Hashicorp). We had to move the create/update/delete logic into commands, which get applied as entries to the Raft log. We need to be able to marshal/unmarshal these commands to and from binary, both so we can ship them to the leader and so the Raft library can propagate them."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TL;DR"}),": We need to be able to decode binary encoded commands. Can we reduce the boilerplate for doing that?"]}),"\n",(0,i.jsx)(n.p,{children:"We're going to take a look at a simplified version of the code. We're using protobufs for the binary format."}),"\n",(0,i.jsx)(n.h4,{id:"supporting-types-reference",children:"Supporting Types Reference"}),"\n",(0,i.jsx)(n.p,{children:"Here are some of the primary interfaces, which you can reference when looking at the decoder implementations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TypedMessage"})," - message interface which is just a protobuf message which knows its command type"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Command"})," - types we're marshalling/unmarshalling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DeleteEntityCommand"})," - example command for deleting entities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Decoder"})," -  func for decoding a binary messages back into a Command"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DecoderRegistry"})," - place to lookup the Decoder for a give message"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This implementation has some interfaces for types messages, which extend the protobuf message"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"// TypedMessage instances are protobuf messages which know their command type\ntype TypedMessage interface {\n\tproto.Message\n\tGetCommandType() int32\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Next we've got the Command interface and the delete entity command, which covers all model types."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type Command interface {\n\tApply() error\n\tEncode() ([]byte, error)\n}\n\ntype DeleteEntityCommand struct {\n\tId         string\n\tEntityType string\n}\n\nfunc (self *DeleteEntityCommand) Apply() error {\n\t// implemention elided for brevity \n}\n\nfunc (self *DeleteEntityCommand) Encode() ([]byte, error) {\n    // EncodeProtobuf marshalls the msg to bytes and prefixes the command type\n\treturn cmd_pb.EncodeProtobuf(&cmd_pb.DeleteEntityCommand{\n\t\tEntityId:   self.Id,\n\t\tEntityType: self.EntityType,\n\t})\n}\n\nfunc (self *DeleteEntityCommand) Decode(msg *cmd_pb.DeleteEntityCommand) error {\n\tself.Id = msg.EntityId\n\tself.EntityType = msg.EntityType\n\treturn nil\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So encoding is straightforward, we can just create the appropriate protobuf type and serialize them. Decoding is a little more complicated because we're starting with the raw bytes and need a way to rebuild our types. We're going to need a ",(0,i.jsx)(n.code,{children:"Registry"})," of things that can decode our various commands for us. To  keep things simple, let's just use ",(0,i.jsx)(n.code,{children:"funcs"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type Decoder func(data []byte) (Command, error)\n\ntype DecoderRegistry interface {\n\tAddDecoder(commandType int32, decoder Decoder)\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"decoder-no-generics",children:"Decoder: No Generics"}),"\n",(0,i.jsxs)(n.p,{children:["Now we can create a decoder for our ",(0,i.jsx)(n.code,{children:"DeleteEntityCommand"})," and register it."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"func decodeDeleteEntityCommand(data []byte) (Command, error) {\n    // Unmarshal to a protobuf message type\n\tmsg := &cmd_pb.DeleteEntityCommand{}\n\tif err := proto.Unmarshal(data, msg); err != nil {\n\t\treturn nil, err\n\t}\n\n    // Populate the command using the protobuf message\n\tcmd := &DeleteEntityCommand{}\n\tif err := cmd.Decode(msg); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cmd, nil\n}\n\nfunc registerDecodeDeleteCommand(registry DecoderRegistry) {\n\tregistry.AddDecoder(int32(cmd_pb.CommandType_DeleteEntityType), decodeDeleteEntityCommand)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, there's not much special going on here. This function will be essentially the same for every command. It needs to create an instance of the protobuf command, Unmarshal it, and then pass that off to a new instance of the model Command."}),"\n",(0,i.jsx)(n.h4,{id:"decoder-generics--reflection",children:"Decoder: Generics + Reflection"}),"\n",(0,i.jsx)(n.p,{children:"Here's a first pass at using generics to take care of this boilerplate."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"func RegisterCommand[M TypedMessage, C decodableCommand[M]](registry DecoderRegistry, cmdType C, msgType M) {\n\tdecoder := func(data []byte) (Command, error) {\n\t\tmsg := proto.MessageV1(proto.MessageV2(msgType).ProtoReflect().New()).(M)\n\t\tif err := proto.Unmarshal(data, msg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcmd := reflect.New(reflect.TypeOf(cmdType).Elem()).Interface().(C)\n\t\tif err := cmd.Decode(msg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn cmd, nil\n\t}\n\tregistry.AddDecoder(msgType.GetCommandType(), decoder)\n}\n\nfunc registerDecodeDeleteCommand(registry DecoderRegistry) {\n\tRegisterCommand(registry, &DeleteEntityCommand{}, &cmd_pb.DeleteEntityCommand{})\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This works for removing the boilerplate. We have a single line where we register the decoder, with the two types it needs to know about."}),"\n",(0,i.jsx)(n.p,{children:"Unfortunately, the implementation is ugly and employs both some sketchy protobuf library reflection and regular reflection. This is both hard to read and not terribly efficient."}),"\n",(0,i.jsx)(n.h4,{id:"decoder-pure-generics",children:"Decoder: Pure Generics"}),"\n",(0,i.jsx)(n.p,{children:"We can do better using what we learned about instantiating generic types above."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type commandMsg[T any] interface {\n\tTypedMessage\n\t*T\n}\n\ntype decodableCommand[T any, M any] interface {\n\tCommand\n\tDecode(msg M) error\n\t*T\n}\n\nfunc RegisterCommand[MT any, CT any, M commandMsg[MT], C decodableCommand[CT, M]](registry DecoderRegistry, _ C, msg M) {\n\tdecoder := func(data []byte) (Command, error) {\n\t\tvar msg M = new(MT)\n\t\tif err := proto.Unmarshal(data, msg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcmd := C(new(CT))\n\t\tif err := cmd.Decode(msg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn cmd, nil\n\t}\n\n\tregistry.AddDecoder(msg.GetCommandType(), decoder)\n}\n\nfunc registerDecodeDeleteCommand(registry DecoderRegistry) {\n\tRegisterCommand(registry, &DeleteEntityCommand{}, &cmd_pb.DeleteEntityCommand{})\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"performance",children:"Performance"}),"\n",(0,i.jsx)(n.p,{children:"This is better from an efficiency perspective, though admittedly not by much. The reflection based code results:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"BenchmarkRegisterCommand-16         1013774          1259 ns/op\nBenchmarkRegisterCommand-16         1012059          1267 ns/op\n"})}),"\n",(0,i.jsx)(n.p,{children:"vs the generics based code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"BenchmarkRegisterCommand-16         1165557          1144 ns/op\nBenchmarkRegisterCommand-16         1143402          1134 ns/op\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, the code is less fragile, as it's not relying on protobuf tricks, and is likely to get faster over time as generics support improves."}),"\n",(0,i.jsx)(n.h5,{id:"complexity",children:"Complexity"}),"\n",(0,i.jsx)(n.p,{children:"It is still hard code to read. However, that ugliness is balanced by a relatively clean API and reduced code externally. Personally I'll trade some encapsulated ugliness for reduced code and complexity elsewhere. This is an area where reasonable people can disagree, though."}),"\n",(0,i.jsx)(n.h5,{id:"generic-parameters-vs-args",children:"Generic parameters vs args"}),"\n",(0,i.jsx)(n.p,{children:"This method could also be written with a different type signature:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"func RegisterCommand[MT any, CT any, M commandMsg[MT], C decodableCommand[CT, M]](registry DecoderRegistry) { ... }\n\nfunc registerDecodeDeleteCommand(registry DecoderRegistry) {\n\tRegisterCommand[cmd_pb.DeleteEntityCommand, DeleteEntityCommand](registry)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"So we've replaced the arguments, which weren't strictly necessary and are explicitly providing the generic types instead. This is another matter of taste. As someone calling the library, I found it easier to provide function parameters than generic types, since it was easier to figure out what was required. Others might reach different conclusions."}),"\n",(0,i.jsx)(n.p,{children:"To look at the actual implementation in OpenZiti, here are some starting points:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/openziti/fabric/tree/v0.21.0/controller/command",children:"https://github.com/openziti/fabric/tree/v0.21.0/controller/command"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/openziti/fabric/blob/v0.21.0/controller/network/command.go",children:"https://github.com/openziti/fabric/blob/v0.21.0/controller/network/command.go"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"case-study-entity-managers",children:"Case Study: Entity Managers"}),"\n",(0,i.jsxs)(n.p,{children:["There are also places where the the complexity tradeoff goes the other way. Let's look at an entity manager type. We've got an interface for Entities which know how to load themselves from a data store. Our model is persisted in ",(0,i.jsx)(n.a,{href:"https://github.com/etcd-io/bbolt",children:"bbolt"}),", but the pattern should be broadly applicable."]}),"\n",(0,i.jsx)(n.p,{children:"We want our base entity manager type to be able to load entities. For that, it must be able to create new instances of the entity type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type Entity interface {\n\tGetId() string\n\tLoad(store DataStore, entityData *Bucket)\n}\n\ntype baseEntityManager[E Entity] struct {\n\tstore DataStore\n}\n\nfunc (mgr *baseEntityManager[E]) Load(id string) (E, error) {\n\tvar entity E // need to get new instance of E somehow\n\t// load entity, if it exists, otherwise return an error\n\treturn entity, nil\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"If our base manager type can create new instances of the Entity type, it can load them in a generic fashion. We could use the same pattern from above to allow new instances of the entity type to be created using generics. That would look something like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type EntityP[T any] interface {\n\tEntity\n\t*T\n}\n\ntype baseEntityManager[E any, PE EntityP[E]] struct {\n\tstore DataStore\n}\n\nfunc (mgr *baseEntityManager[E, PE]) Load(id string) (PE, error) {\n\tvar entity PE = new(E) // init using generics\n\t// load entity, if it exists, otherwise return an error\n\treturn entity, nil\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"So this works,but it also requires a more complex generics parameters and those more complex parameters have to be on every method we define on the type. So by making the one method slightly simpler, we have incurred a complexity penalty in many places. This will also spread to anywhere were the type is used."}),"\n",(0,i.jsxs)(n.p,{children:["Given this we decided to go for a simpler solution: providing a ",(0,i.jsx)(n.code,{children:"func"})," which can create new entity instances."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-golang",children:"type baseEntityManager[E Entity] struct {\n\tstore DataStore\n\tnewEntity func() E\n}\n\nfunc (mgr *baseEntityManager[E]) Load(id string) (E, error) {\n\tvar entity E = mgr.newEntity() // init using a constructor function\n\t// load entity, if it exists, otherwise return an error\n\treturn entity, nil\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"While this requires us to provide logic at construction time, it keeps the rest of the code cleaner."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"While not perfect, generics in Go have let us remove a lot of boilerplate from the OpenZiti project. We've also found and fixed some bugs when we switched to type safe collections."}),"\n",(0,i.jsx)(n.p,{children:"We're generally still trying to be somewhat conservative with where we use generics. When we add it, as with the examples above, we want to be sure that we're getting good value for the extra complexity."}),"\n",(0,i.jsx)(n.p,{children:"It will be interesting to see where generics make their way into the standard libraries and what best practices emerge around Go generics."}),"\n",(0,i.jsx)(n.p,{children:"If you've got any feedback, maybe better ways to accomplish the things outlined above, let me know!"}),"\n",(0,i.jsx)(n.h2,{id:"further-readingviewing",children:"Further Reading/Viewing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://go.dev/blog/intro-generics",children:"https://go.dev/blog/intro-generics"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://go.dev/doc/tutorial/generics",children:"https://go.dev/doc/tutorial/generics"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://gobyexample.com/generics",children:"https://gobyexample.com/generics"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's a video some of my coworkers did around the time of the initial generics release on our weekly video stream:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(t,{id:"4JFA31O2UaE",title:"YouTube video"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(96540);const i={},o=r.createContext(i);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:n},e.children)}},75589:e=>{e.exports=JSON.parse('{"permalink":"/docs/openziti/blog/golang-aha-moments-generics","source":"@site/blog/golang-aha-moments-generics.md","title":"Golang Aha! Moments: Generics","description":"Introduction","date":"2022-10-06T17:46:21.000Z","tags":[{"inline":false,"label":"golang","permalink":"/docs/openziti/blog/tags/golang","description":"Go/Golang content"},{"inline":false,"label":"Developer","permalink":"/docs/openziti/blog/tags/developer","description":"Developer topics"},{"inline":false,"label":"Generics","permalink":"/docs/openziti/blog/tags/generics","description":"Programming generics"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"},{"inline":false,"label":"golang-aha","permalink":"/docs/openziti/blog/tags/golang-aha","description":"Golang Ahas!"}],"readingTime":13.79,"hasTruncateMarker":true,"authors":[{"name":"Paul Lorenz","title":"Author","url":"https://github.com/plorenz","imageURL":"https://avatars.githubusercontent.com/plorenz","key":"PaulLorenz","page":null}],"frontMatter":{"title":"Golang Aha! Moments: Generics","date":"2022-10-06T17:46:21.000Z","cuid":"cl8xcodj6000c09mi9gbne8el","slug":"golang-aha-moments-generics","authors":["PaulLorenz"],"image":"@site/blogs/openziti/v1663771708776/OXjhFrMmZ.jpg","imageDark":"@site/blogs/openziti/v1663771708776/OXjhFrMmZ.jpg","tags":["golang","developer","generics","openziti","golang-aha"]},"unlisted":false,"prevItem":{"title":"Integrating Ziti is Easy! How we got our app tested with go-httpbin","permalink":"/docs/openziti/blog/integrating-ziti-is-easy"},"nextItem":{"title":"Securing NodeJS Applications \u2014 An Introduction to the OpenZiti SDK for NodeJS","permalink":"/docs/openziti/blog/securing-nodejs-applications"}}')}}]);