"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[9089],{26254:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"reference/ha/data-model","title":"Controller HA Data Model","description":"This document is likely most interesting for developers working on OpenZiti,","source":"@site/docs/reference/ha/data-model.md","sourceDirName":"reference/ha","slug":"/reference/ha/data-model","permalink":"/docs/reference/ha/data-model","draft":false,"unlisted":false,"editUrl":"https://github.com/openziti/ziti-doc/tree/main/docusaurus/docs/reference/ha/data-model.md","tags":[],"version":"current","lastUpdatedAt":1743428643000,"sidebarPosition":80,"frontMatter":{"sidebar_label":"Data Model","sidebar_position":80},"sidebar":"docsSidebar","previous":{"title":"Topology","permalink":"/docs/reference/ha/topology"},"next":{"title":"Migrating","permalink":"/docs/reference/ha/migrating"}}');var r=i(74848),s=i(28453);const a={sidebar_label:"Data Model",sidebar_position:80},o="Controller HA Data Model",l={},c=[{value:"Model Data",id:"model-data",level:2},{value:"Model Data Characteristics",id:"model-data-characteristics",level:3},{value:"Raft Resources",id:"raft-resources",level:3},{value:"Raft Characteristics",id:"raft-characteristics",level:3},{value:"Updates",id:"updates",level:3},{value:"Reads",id:"reads",level:3},{value:"Runtime Data",id:"runtime-data",level:2},{value:"Runtime Data Characteristics",id:"runtime-data-characteristics",level:3},{value:"Links",id:"links",level:3},{value:"Circuits",id:"circuits",level:3},{value:"Api Sessions, Sessions, Posture Data",id:"api-sessions-sessions-posture-data",level:3}];function d(e){const t={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"controller-ha-data-model",children:"Controller HA Data Model"})}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsx)(t.p,{children:"This document is likely most interesting for developers working on OpenZiti,\nthose curious about how distributed systems work in general, or curious\nabout how data is distributed in OpenZiti."})}),"\n",(0,r.jsx)(t.h2,{id:"model-data",children:"Model Data"}),"\n",(0,r.jsx)(t.h3,{id:"model-data-characteristics",children:"Model Data Characteristics"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"All data required on every controller"}),"\n",(0,r.jsxs)(t.li,{children:["Read characteristics","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Reads happen all the time, from every client and as well as admins"}),"\n",(0,r.jsx)(t.li,{children:"Speed is very important. They affect how every client perceives the system."}),"\n",(0,r.jsx)(t.li,{children:"Availability is very important. Without reading definitions, can\u2019t create new connections"}),"\n",(0,r.jsx)(t.li,{children:"Can be against stale data, if we get consistency within a reasonable timeframe (seconds to\nminutes)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Write characteristics","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Writes only happen from administrators"}),"\n",(0,r.jsx)(t.li,{children:"Speed needs to be reasonable, but doesn't need to be blazing fast"}),"\n",(0,r.jsx)(t.li,{children:"Write availability can be interrupted, since it primarily affects management operations"}),"\n",(0,r.jsx)(t.li,{children:"Must be consistent. Write validation can\u2019t happen with stale data. Don\u2019t want to have to deal\nwith reconciling concurrent, contradictory write operations."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"Generally involves controller to controller coordination"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Of the distribution mechanisms we looked at, Raft had the best fit."}),"\n",(0,r.jsx)(t.h3,{id:"raft-resources",children:"Raft Resources"}),"\n",(0,r.jsx)(t.p,{children:"For a more in-depth look at Raft, see"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://raft.github.io/",children:"https://raft.github.io/"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"http://thesecretlivesofdata.com/raft/",children:"http://thesecretlivesofdata.com/raft/"})}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"raft-characteristics",children:"Raft Characteristics"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Writes","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Consistency over availability"}),"\n",(0,r.jsx)(t.li,{children:"Good but not stellar performance"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Reads","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Every node has full state"}),"\n",(0,r.jsx)(t.li,{children:"Local state is always internally consistent, but maybe slightly behind the leader"}),"\n",(0,r.jsx)(t.li,{children:"No coordination required for reads"}),"\n",(0,r.jsx)(t.li,{children:"Fast reads"}),"\n",(0,r.jsx)(t.li,{children:"Reads work even when other nodes are unavailable"}),"\n",(0,r.jsx)(t.li,{children:"If latest data is desired, reads can be forwarded to the current leader"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["So, the OpenZiti controller uses Raft to distribute the data model. Specifically, it uses the\n",(0,r.jsx)(t.a,{href:"https://github.com/hashicorp/raft/",children:"HashiCorp Raft Library"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"updates",children:"Updates"}),"\n",(0,r.jsx)(t.p,{children:"The basic flow for model updates is as follows:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"A client requests a model update via the REST API."}),"\n",(0,r.jsx)(t.li,{children:"The controller checks if it is the Raft cluster leader. If it is not, it forwards the request to\nthe leader."}),"\n",(0,r.jsx)(t.li,{children:"Once the request is on the leader, it applies the model update to the Raft log. This involves\ngetting a quorum of the controllers to accept the update."}),"\n",(0,r.jsx)(t.li,{children:"One the update has been accepted, it will be executed on each node of the cluster. This will\ngenerate create one or more changes to the bolt database."}),"\n",(0,r.jsx)(t.li,{children:"The results of the operation (success or failure) are returned to the controller which received\nthe original REST request."}),"\n",(0,r.jsx)(t.li,{children:"The controller waits until the operation has been applied locally."}),"\n",(0,r.jsx)(t.li,{children:"The result is returned to the REST client."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"reads",children:"Reads"}),"\n",(0,r.jsx)(t.p,{children:"Reads are always done to the local bolt database for performance. The assumption is that if\nsomething like a policy change is delayed, it may temporarily allow a circuit to be created, but as\nsoon as the policy update is applied, it will make changes to circuits as necessary."}),"\n",(0,r.jsx)(t.h2,{id:"runtime-data",children:"Runtime Data"}),"\n",(0,r.jsx)(t.p,{children:"In addition to model data, the controller also manages some amount of runtime data. This data is for\nrunning OpenZiti's core functions, i.e. managing the flow of data across the mesh, along with\nrelated authentication data. So this includes things like:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Links"}),"\n",(0,r.jsx)(t.li,{children:"Circuits"}),"\n",(0,r.jsx)(t.li,{children:"API Sessions"}),"\n",(0,r.jsx)(t.li,{children:"Sessions"}),"\n",(0,r.jsx)(t.li,{children:"Posture Data"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"runtime-data-characteristics",children:"Runtime Data Characteristics"}),"\n",(0,r.jsx)(t.p,{children:"Runtime data has different characteristics than the model data does."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Not necessarily shared across controllers"}),"\n",(0,r.jsxs)(t.li,{children:["Reads ",(0,r.jsx)(t.strong,{children:"and"})," writes must be very fast"]}),"\n",(0,r.jsx)(t.li,{children:"Generally involves sdk to controller or controller to router coordination"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Because writes must also be fast, Raft is not a good candidate for storing this data. Good\nperformance is critical for these components, so they are each evaluated individually."}),"\n",(0,r.jsx)(t.h3,{id:"links",children:"Links"}),"\n",(0,r.jsx)(t.p,{children:"Each controller currently needs to know about links so that it can make routing decisions. However,\nlinks exist on routers. So, routers are the source of record for links. When a router connects to a\ncontroller, the router will tell the controller about any links that it already has. The controller\nwill ask to fill in any missing links and the controller will ensure that it doesn't create\nduplicate links if multiple controllers request the same link be created. If there are duplicates,\nthe router will inform the controller of the existing link."}),"\n",(0,r.jsx)(t.p,{children:"The allows the routers to properly handle link dials from multiple routers and keep controllers up\nto date with the current known links."}),"\n",(0,r.jsx)(t.h3,{id:"circuits",children:"Circuits"}),"\n",(0,r.jsx)(t.p,{children:"Circuits were and continue to be stored in memory for both standalone and HA mode\ncontrollers.Circuits are not distributed. Rather, each controller remains responsible for any\ncircuits that it created."}),"\n",(0,r.jsx)(t.p,{children:"When a router needs to initiate circuit creation it will pick the one with the lowest response time\nand send a circuit creation request to that router. The controller will establish a route. Route\ntables as well as the xgress endpoints now track which controller is responsible for the associated\ncircuit. This way when failures or other notifications need to be sent, the router knows which\ncontroller to talk to."}),"\n",(0,r.jsx)(t.p,{children:"This gets routing working with multiple controllers without a major refactor. Future work will\nlikely delegate more routing control to the routers, so routing should get more robust and\ndistributed over time."}),"\n",(0,r.jsx)(t.h3,{id:"api-sessions-sessions-posture-data",children:"Api Sessions, Sessions, Posture Data"}),"\n",(0,r.jsx)(t.p,{children:"API Sessions and Sessions are moving to bearer tokens. Posture Data is now handled in the routers."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(96540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);