"use strict";(self.webpackChunkdocusaurus_3=self.webpackChunkdocusaurus_3||[]).push([[81480],{8606:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var i=t(19398),s=t(74848),r=t(28453);const o={title:"OpenAPI Python Clients",date:new Date("2023-03-03T20:06:20.000Z"),cuid:"clesyuhca000009lcf8f79ub7",slug:"openapi-python-clients",authors:["StevenBroderick"],image:"@site/blogs/openziti/v1677866933476/6a4428fe-aa77-489d-b4f3-f8251969f8df.png",imageDark:"@site/blogs/openziti/v1677866933476/6a4428fe-aa77-489d-b4f3-f8251969f8df.png",tags:["python","openapi","openziti"]},a=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Generating an OpenAPI Python Client:",id:"generating-an-openapi-python-client",level:2},{value:"Understanding the Generated Files:",id:"understanding-the-generated-files",level:2},{value:"Let&#39;s Get Started:",id:"lets-get-started",level:2},{value:"Using the Generated API Client:",id:"using-the-generated-api-client",level:2},{value:"A closer look at the response:",id:"a-closer-look-at-the-response",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["At the ",(0,s.jsx)(n.a,{href:"https://github.com/openziti",children:"OpenZiti project"}),", we heavily rely on OpenAPI specifications to streamline our development process. The OpenAPI project provides ",(0,s.jsx)(n.a,{href:"https://openapi-generator.tech/docs/generators/",children:"code generators"})," that support a variety of programming languages. In this blog, we'll focus on a practical guide for using a generated OpenAPI Python client library. Using a generated client as a user of an API is not entirely a straightforward process. Investing some time upfront to understand the translation between the spec and the code will help you establish the right mental model and kickstart your development."]}),"\n",(0,s.jsxs)(n.p,{children:["We'll generate an OpenAPI Python client library from our ",(0,s.jsx)(n.a,{href:"https://github.com/openziti/edge-api/blob/main/client.yml",children:"OpenZiti Edge Client API spec"}),". This API allows OpenZiti clients to create OpenZiti ",(0,s.jsx)(n.a,{href:"https://netfoundry.io/docs/openziti/learn/introduction/components#openziti-controller",children:"controller"})," sessions to gather information needed for them to do work. We'll map what we define in the spec to the concepts expressed in the generated client. We'll step through a basic authentication and request/response example to help you understand what is going on."]}),"\n",(0,s.jsx)(n.h2,{id:"generating-an-openapi-python-client",children:"Generating an OpenAPI Python Client:"}),"\n",(0,s.jsxs)(n.p,{children:["Our ",(0,s.jsx)(n.a,{href:"https://github.com/openziti/edge-api",children:"edge-api"})," project uses ",(0,s.jsx)(n.a,{href:"https://github.com/go-swagger/go-swagger",children:"go-swagger"}),", which is strictly an OpenAPI 2.0 (a.k.a. Swagger 2.0/OAS2) implementation for Go. In our testing, the Python generator that best supported this spec version was the ",(0,s.jsx)(n.a,{href:"https://openapi-generator.tech/docs/generators/python/",children:"python-prior"})," generator. Below, we leverage the ",(0,s.jsx)(n.code,{children:"openapi-generator-cli"})," docker container to generate the Python client library for the OpenZiti Edge Client API from its specification. The generator reads in the spec and produces a Python library compatible with our API. The ",(0,s.jsx)(n.code,{children:"--package-name"})," option specifies the Python package name (directory structure under ",(0,s.jsx)(n.code,{children:"site-packages"})," that will contain our library's ",(0,s.jsx)(n.code,{children:"__init__.py"})," file)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"docker run \\\n    --rm \\\n    --volume \"$PWD\":/out \\\n    docker.io/openapitools/openapi-generator-cli generate \\\n        --generator-name python-prior \\\n        --input-spec 'https://raw.githubusercontent.com/openziti/edge-api/main/client.yml'\n        --output '/out' \\\n        --package-name 'openziti_edge_client'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Once generated, this library can be installed locally with ",(0,s.jsx)(n.code,{children:"pip"})," as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pip install .\n"})}),"\n",(0,s.jsx)(n.h2,{id:"understanding-the-generated-files",children:"Understanding the Generated Files:"}),"\n",(0,s.jsx)(n.p,{children:"You'll have a wealth of generated files in the output of the generator. Let's take a condensed look at the structure of what is generated."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-txt",children:"README.md\n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 openziti_edge_client\n\u2502\xa0\xa0 \u251c\u2500\u2500 api/\n\u2502\xa0\xa0 \u251c\u2500\u2500 api_client.py\n\u2502\xa0\xa0 \u251c\u2500\u2500 apis/\n\u2502\xa0\xa0 \u251c\u2500\u2500 configuration.py\n\u2502\xa0\xa0 \u251c\u2500\u2500 exceptions.py\n\u2502\xa0\xa0 \u251c\u2500\u2500 model/\n\u2502\xa0\xa0 \u251c\u2500\u2500 models/\n\u2502\xa0\xa0 \u2514\u2500\u2500 rest.py\n\u2514\u2500\u2500 test\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"docs"})," folder contains a bunch of markdown files that document usage for each API endpoint and model generated in the library. The ",(0,s.jsx)(n.code,{children:"README.md"})," file is essentially a ",(0,s.jsx)(n.code,{children:"TOC"})," which links to these files, and additionally provides a synopsis of using the library."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"models"})," and ",(0,s.jsx)(n.code,{children:"apis"})," packages are there for convenience. Importing either will import all ",(0,s.jsx)(n.code,{children:"api"})," or ",(0,s.jsx)(n.code,{children:"model"})," modules respectively."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import openziti_edge_client.apis   # all api modules\nimport openziti_edge_client.models # all model modules\n"})}),"\n",(0,s.jsxs)(n.p,{children:["By now, you may be wondering what we mean by ",(0,s.jsx)(n.code,{children:"api"})," and ",(0,s.jsx)(n.code,{children:"model"})," - they are the meat and potatoes of the translated spec."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"api"})," package contains Python modules that map the OpenAPI resource ",(0,s.jsx)(n.code,{children:"paths"})," into Python ",(0,s.jsx)(n.code,{children:"classes"}),". The generator creates a class ",(0,s.jsx)(n.code,{children:"method"})," for each HTTP request method associated with the OpenAPI spec for that ",(0,s.jsx)(n.code,{children:"path"}),". The spec's ",(0,s.jsx)(n.code,{children:"tags"})," field determines the generated set of ",(0,s.jsx)(n.code,{children:"classes"})," the Python generator creates. A path specifying multiple ",(0,s.jsx)(n.code,{children:"tags"})," in the spec results in the same ",(0,s.jsx)(n.code,{children:"path"})," being available in multiple ",(0,s.jsx)(n.code,{children:"api"})," modules."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"model"})," package contains modules for each of the OpenAPI ",(0,s.jsx)(n.code,{children:"definitions"}),". Each model module contains a Python ",(0,s.jsx)(n.code,{children:"class"})," which maps a ",(0,s.jsx)(n.code,{children:"definition"}),"'s ",(0,s.jsx)(n.code,{children:"properties"})," to the Python class attributes. Requests that contain a payload through an ",(0,s.jsx)(n.code,{children:"api"})," module take a ",(0,s.jsx)(n.code,{children:"model"})," instance pertaining to that ",(0,s.jsx)(n.code,{children:"api"})," request as defined in the spec. Responses through the ",(0,s.jsx)(n.code,{children:"api"})," modules return an instance of the module class pertaining to the defined response definitions in the spec. In other words, ",(0,s.jsx)(n.code,{children:"models"})," are the things exchanged through the ",(0,s.jsx)(n.code,{children:"api"})," modules. Because a model maps OpenAPI definition properties and instance attributes, accessing the response payload is a matter of accessing the resulting model's instance attributes."]}),"\n",(0,s.jsxs)(n.p,{children:["Finally, if requests made against an ",(0,s.jsx)(n.code,{children:"api"})," with the ",(0,s.jsx)(n.code,{children:"api_client.py"})," result in an error, the library throws one of the exceptions defined in the ",(0,s.jsx)(n.code,{children:"exceptions.py"})," module. The ",(0,s.jsx)(n.code,{children:"configuration.py"})," contains a ",(0,s.jsx)(n.code,{children:"Configuration"})," class to hold state regarding things like the ",(0,s.jsx)(n.code,{children:"api_client"})," credentials, or the ",(0,s.jsx)(n.code,{children:"logger"})," configuration. We'll show an example below that does this, and we take a closer look at the ",(0,s.jsx)(n.code,{children:"api"})," and ",(0,s.jsx)(n.code,{children:"model"})," modules."]}),"\n",(0,s.jsxs)(n.p,{children:["For now, let's grab the OpenZiti Edge Client spec so we can inspect a few ",(0,s.jsx)(n.code,{children:"paths"}),", ",(0,s.jsx)(n.code,{children:"definitions"}),", and ",(0,s.jsx)(n.code,{children:"securityDefinitions"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"curl -O https://raw.githubusercontent.com/openziti/edge-api/main/client.yml\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We'll use ",(0,s.jsx)(n.code,{children:"yq"})," to filter the spec YAML. I'll strip the ",(0,s.jsx)(n.code,{children:"examples"})," throughout here to keep the output a little more concise."]}),"\n",(0,s.jsx)(n.h2,{id:"lets-get-started",children:"Let's Get Started:"}),"\n",(0,s.jsx)(n.p,{children:"Let's look at a subset of the generated documentation and map it to back to the spec."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Class"}),(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"HTTP request"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.em,{children:"ServiceApi"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"list_services"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"GET"})," /services"]}),(0,s.jsx)(n.td,{children:"List services"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:["Here, we see we have a generated ",(0,s.jsx)(n.code,{children:"ServiceApi"})," class. That class has a ",(0,s.jsx)(n.code,{children:"list_services"})," method, which performs a ",(0,s.jsx)(n.code,{children:"GET"})," request against the ",(0,s.jsx)(n.code,{children:"/services"})," path in our API."]}),"\n",(0,s.jsx)(n.p,{children:"Let's briefly take a look at that path in our spec:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yq --yaml-output '.paths.\"/services\"' client.yml\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"get:\n  security:\n    - ztSession: []\n  description: 'Retrieves a list of config resources; supports filtering, sorting,\n    and pagination. Requires admin access.'\n  tags:\n    - Service\n  summary: List services\n  operationId: listServices\n  parameters:\n    - type: integer\n      name: limit\n      in: query\n    - type: integer\n      name: offset\n      in: query\n    - type: string\n      name: filter\n      in: query\n    - type: array\n      items:\n        type: string\n      collectionFormat: multi\n      name: roleFilter\n      in: query\n    - type: string\n      name: roleSemantic\n      in: query\n  responses:\n    '200':\n      description: A list of services\n      schema:\n        $ref: '#/definitions/listServicesEnvelope'\n    '400':\n      description: The supplied request contains invalid fields or could not be parsed\n        (json and non-json bodies). The error's code, message, and cause fields can\n        be inspected for further information\n      schema:\n        $ref: '#/definitions/apiErrorEnvelope'\n    '401':\n      description: The currently supplied session does not have the correct access\n        rights to request this resource\n      schema:\n        $ref: '#/definitions/apiErrorEnvelope'\n"})}),"\n",(0,s.jsx)(n.p,{children:"Notice a few of the keys in the spec and how they map to the generated documentation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tags"})," => defines the Python class the requests methods will be generated in => ",(0,s.jsx)(n.code,{children:"ServicesApi"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"path"})," => the endpoint the request will operate against => ",(0,s.jsx)(n.code,{children:"/services"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"get"})," -> defines the HTTP request method when executing the method => ",(0,s.jsx)(n.code,{children:"GET"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"operationId"})," -> defines the method name that will perform the request => ",(0,s.jsx)(n.code,{children:"list_services()"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"parameters"})," -> become the available function parameters in the generated method => ",(0,s.jsx)(n.code,{children:"list_services(limit=my_limit, offset=my_offset, ...)"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, the ",(0,s.jsx)(n.code,{children:"responses"})," describe a number of ",(0,s.jsx)(n.code,{children:"schemas"})," that shall be returned by the API for each of the possible HTTP status codes. These are ",(0,s.jsx)(n.code,{children:"models"})," in the generated Python library. When a request is made successfully (status code == ",(0,s.jsx)(n.code,{children:"200"}),"), the return value of the ",(0,s.jsx)(n.code,{children:"list_services()"})," method will be an instance of the ",(0,s.jsx)(n.code,{children:"ListServicesEnvelope"})," model class. For any other status code, implying an error has occurred, the method will instead return an instance of the ",(0,s.jsx)(n.code,{children:"ApiErrorEnvelope"})," model class."]}),"\n",(0,s.jsxs)(n.p,{children:["You'll also notice the ",(0,s.jsx)(n.code,{children:"security"})," section on this path. This endpoint requires the ",(0,s.jsx)(n.code,{children:"ztSession"})," security definition:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yq --yaml-output '.securityDefinitions' client.yml\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"ztSession:\n  description: An API Key that is provided post authentication\n  type: apiKey\n  name: zt-session\n  in: header\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, we see that requests to this endpoint must include a header named ",(0,s.jsx)(n.code,{children:"zt-session"})," containing an API key."]}),"\n",(0,s.jsx)(n.h2,{id:"using-the-generated-api-client",children:"Using the Generated API Client:"}),"\n",(0,s.jsxs)(n.p,{children:["OpenZiti Edge clients can authenticate using either the ",(0,s.jsx)(n.code,{children:"password"})," or ",(0,s.jsx)(n.code,{children:"cert"})," method. In practice, most OpenZiti clients will create a session with the controller by performing an mTLS handshake, reading a client ",(0,s.jsx)(n.code,{children:"credentials.json"})," file after JWT enrollment. We'll add these credentials to our ",(0,s.jsx)(n.code,{children:"api_client"}),"'s ",(0,s.jsx)(n.code,{children:"configuration"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Once we authenticate, we'll gather the ",(0,s.jsx)(n.code,{children:"zt-session"})," token out of the response and add it to our client ",(0,s.jsx)(n.code,{children:"configuration"})," so that it is used in subsequent requests. We can then finally make a request with our ",(0,s.jsx)(n.code,{children:"ServicesApi"})," class using the ",(0,s.jsx)(n.code,{children:"list_services()"})," method, which will return a ",(0,s.jsx)(n.code,{children:"ListServicesEnvelope"})," model to grant us access to our service information. OpenZiti ",(0,s.jsx)(n.a,{href:"https://netfoundry.io/docs/openziti/learn/core-concepts/services/overview",children:"services"})," are container types that encapsulate information needed by OpenZiti clients to operate on the network."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import json\nimport tempfile\n\nimport openziti_edge_client\nfrom openziti_edge_client.api import authentication_api, service_api\nfrom openziti_edge_client.model.authenticate import Authenticate\n\n# NOTE: we omit some error handling here, to keep things clear\n\nwith open(\"./credentials.json\", 'r', encoding='UTF-8') as id_f:\n    id_json = json.load(id_f)\n\n# The generated library expects the CA, client cert and key to be files\n# so we'll split our `credentials.json` file contents here\nca_fp = tempfile.NamedTemporaryFile(buffering=0)\ncert_fp = tempfile.NamedTemporaryFile(buffering=0)\nkey_fp = tempfile.NamedTemporaryFile(buffering=0)\n\nca_fp.write(id_json['id']['ca'].encode('UTF-8'))\ncert_fp.write(id_json['id']['cert'].encode('UTF-8'))\nkey_fp.write(id_json['id']['key'].encode('UTF-8'))\n\n# We instantiate a Configuration class to store the\n# Edge Client API endpoint and client certificates\nconfiguration = openziti_edge_client.Configuration(\n    host=id_json['ztAPI'] + \"/edge/client/v1\",\n    ssl_ca_cert=ca_fp.name\n)\n\nconfiguration.cert_file = cert_fp.name\nconfiguration.key_file = key_fp.name\n\n# We pass the configuration to the constructor of the `ApiClient`,\n# which will read the stored state of the configuration class\nwith openziti_edge_client.ApiClient(configuration) as api_client:\n    \n    # We'll use this api_client as a context manager to make requests\n    # against the Edge API and set the authentication method\n    api_auth = authentication_api.AuthenticationApi(api_client)\n    method = \"cert\"\n  \n    # The /authenticate endpoint requires an `Authenticate` model\n    auth = Authenticate()\n\n    # Session here will be an instance of the\n    # CurrentApiSessionDetailEnvelope  model class\n    session = api_auth.authenticate(method, auth=auth)\n\n    # We can descend down the nested definitions to get our\n    # final return value.\n    configuration.api_key['ztSession'] = session.data.token\n    \n    # Finally, we can make a request to GET /services\n    api_service = service_api.ServiceApi(api_client)\n    services = api_service.list_services()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["That's it! We authenticated to our API, gathered our ",(0,s.jsx)(n.code,{children:"zt-session"})," token, and ran our first request to ",(0,s.jsx)(n.code,{children:"ServiceApi.list_services()"}),". All other requests using the generated client follow a similar pattern. While not shown here, requests for HTTP resource types that contain a body (often a ",(0,s.jsx)(n.code,{children:"POST"}),", ",(0,s.jsx)(n.code,{children:"PUT"}),", etc.) will require you to create a model class instance with all required properties and attach it to your request via arguments to the relevant class methods."]}),"\n",(0,s.jsxs)(n.p,{children:["A noteworthy aspect of the resulting ",(0,s.jsx)(n.code,{children:"session"})," and ",(0,s.jsx)(n.code,{children:"services"})," objects above is they are OpenAPI models whose schemas reference other schemas in the spec. When we descend down the instance attributes like ",(0,s.jsx)(n.code,{children:"session.data.token"}),", we are actually traversing the attributes of 3 schema definitions. Similarly, the ",(0,s.jsx)(n.code,{children:"services"})," object is a ",(0,s.jsx)(n.code,{children:"ListServicesEnvelope"})," model class instance as prescribed in the spec, which is composed of other definitions. This relationship between the ",(0,s.jsx)(n.code,{children:"api"})," classes and the ",(0,s.jsx)(n.code,{children:"model"})," classes is key in the behavior of the Python client."]}),"\n",(0,s.jsx)(n.h2,{id:"a-closer-look-at-the-response",children:"A closer look at the response:"}),"\n",(0,s.jsxs)(n.p,{children:["Let's recursively show the definitions defined in the ",(0,s.jsx)(n.code,{children:"ListServicesEnvelope"}),", and see how we can access the list of services. Remember, each of these definitions becomes a model class in our generated client."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yq --yaml-output '.definitions.listServicesEnvelope' client.yml\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"type: object\nrequired:\n  - meta\n  - data\nproperties:\n  data:\n    $ref: '#/definitions/serviceList'\n  meta:\n    $ref: '#/definitions/meta'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, we see that the envelope itself is a JSON object with two properties: meta and data. The ",(0,s.jsx)(n.code,{children:"data"})," property is itself a ",(0,s.jsx)(n.code,{children:"serviceList"})," with an ",(0,s.jsx)(n.code,{children:"array"})," type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yq --yaml-output '.definitions.serviceList' client.yml\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"type: array\nitems:\n  $ref: '#/definitions/serviceDetail'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Each item in this array is a ",(0,s.jsx)(n.code,{children:"serviceDetail"}),". These are the actual ",(0,s.jsx)(n.code,{children:"service"})," objects stored in the OpenZiti database that the API client making this request has access to. If we want to inspect some properties of the services, we must do so through the ",(0,s.jsx)(n.code,{children:"ServiceDetail"})," model nested in the result."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yq --yaml-output '.definitions.serviceDetail' client.yml\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"type: object\nallOf:\n  - $ref: '#/definitions/baseEntity'\n  - type: object\n    required:\n      - name\n      - terminatorStrategy\n      - roleAttributes\n      - permissions\n      - configs\n      - config\n      - encryptionRequired\n      - postureQueries\n    properties:\n      config:\n        description: map of config data for this service keyed by the config type\n          name. Only configs of the types requested will be returned.\n        type: object\n        additionalProperties:\n          type: object\n          additionalProperties:\n            type: object\n      configs:\n        type: array\n        items:\n          type: string\n      encryptionRequired:\n        description: Describes whether connections must support end-to-end encryption\n          on both sides of the connection. Read-only property, set at create.\n        type: boolean\n      name:\n        type: string\n      permissions:\n        $ref: '#/definitions/dialBindArray'\n      postureQueries:\n        type: array\n        items:\n          $ref: '#/definitions/postureQueries'\n      roleAttributes:\n        $ref: '#/definitions/attributes'\n      terminatorStrategy:\n        type: string\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Continuing from our example above, we can traverse down to these services to inspect the properties described in the ",(0,s.jsx)(n.code,{children:"ServiceDetail"})," above for each service in our ",(0,s.jsx)(n.code,{children:"ServiceList"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'    # ... continued from above ...\n    services = api_service.list_services()\n    \n    # ListServicesEnvelope->ServiceList->ServiceDetail\n    for service in services.data.value:\n        print(f"Model: {type(service)}")\n        print(f"Service Name: {service.name}")\n        print(f"Service: {service}")\n      \n        # ServiceDetail->DialBindArray->DialBind\n        for permission in service.permissions.value:\n            print(f"Permissions: {permission}")\n'})}),"\n",(0,s.jsx)(n.p,{children:"Finally, we've arrived at our actual services and can access the response JSON through the model's instance attributes."}),"\n",(0,s.jsxs)(n.p,{children:["We hope this guide has helped you get started using OpenAPI-generated Python clients. Currently, we host generated Python clients for our Edge Management and Client APIs in the ",(0,s.jsx)(n.a,{href:"https://github.com/openziti-test-kitchen",children:"openziti-test-kitchen"})," GitHub project."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},19398:e=>{e.exports=JSON.parse('{"permalink":"/docs/openziti/blog/openapi-python-clients","source":"@site/blog/openapi-python-clients.md","title":"OpenAPI Python Clients","description":"At the OpenZiti project, we heavily rely on OpenAPI specifications to streamline our development process. The OpenAPI project provides code generators that support a variety of programming languages. In this blog, we\'ll focus on a practical guide for using a generated OpenAPI Python client library. Using a generated client as a user of an API is not entirely a straightforward process. Investing some time upfront to understand the translation between the spec and the code will help you establish the right mental model and kickstart your development.","date":"2023-03-03T20:06:20.000Z","tags":[{"inline":false,"label":"Python","permalink":"/docs/openziti/blog/tags/python","description":"Python content"},{"inline":false,"label":"OpenAPI","permalink":"/docs/openziti/blog/tags/openapi","description":"OpenAPI specification"},{"inline":false,"label":"OpenZiti","permalink":"/docs/openziti/blog/tags/openziti","description":"OpenZiti related content"}],"readingTime":10.53,"hasTruncateMarker":true,"authors":[{"name":"Steven A. Broderick","title":"Author","url":"https://github.com/sabedevops","imageURL":"https://avatars.githubusercontent.com/sabedevops","key":"StevenBroderick","page":null}],"frontMatter":{"title":"OpenAPI Python Clients","date":"2023-03-03T20:06:20.000Z","cuid":"clesyuhca000009lcf8f79ub7","slug":"openapi-python-clients","authors":["StevenBroderick"],"image":"@site/blogs/openziti/v1677866933476/6a4428fe-aa77-489d-b4f3-f8251969f8df.png","imageDark":"@site/blogs/openziti/v1677866933476/6a4428fe-aa77-489d-b4f3-f8251969f8df.png","tags":["python","openapi","openziti"]},"unlisted":false,"prevItem":{"title":"Websockets over zrok","permalink":"/docs/openziti/blog/websockets-over-zrok"},"nextItem":{"title":"Postman and the Management API","permalink":"/docs/openziti/blog/postman-mgmt"}}')}}]);